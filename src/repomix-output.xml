This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
nanobrag_torch/
  models/
    __init__.py
    crystal.py
    detector.py
  utils/
    __init__.py
    geometry.py
    physics.py
    units.py
  __init__.py
  config.py
  simulator.py
nanobrag_torch.egg-info/
  dependency_links.txt
  PKG-INFO
  requires.txt
  SOURCES.txt
  top_level.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="nanobrag_torch/models/__init__.py">
"""
Core object models for nanoBragg PyTorch implementation.

This package contains the Crystal and Detector classes that encapsulate
the geometric and physical properties of the diffraction experiment.
"""

from .crystal import Crystal
from .detector import Detector

__all__ = ["Crystal", "Detector"]
</file>

<file path="nanobrag_torch/models/crystal.py">
"""
Crystal model for nanoBragg PyTorch implementation.

This module defines the Crystal class responsible for managing unit cell,
orientation, and structure factor data.

NOTE: The default parameters in this file are configured to match the 'simple_cubic'
golden test case, which uses a 10 Å unit cell and a 500×500×500 cell crystal size.
"""

from typing import Optional, Tuple

import torch

from ..config import CrystalConfig
from ..utils.geometry import angles_to_rotation_matrix


class Crystal:
    """
    Crystal model managing unit cell, orientation, and structure factors.

    Responsible for:
    - Unit cell parameters and reciprocal lattice vectors
    - Crystal orientation and rotations (misset, phi, mosaic)
    - Structure factor data (Fhkl) loading and lookup

    The Crystal class now supports general triclinic unit cells with all six
    cell parameters (a, b, c, α, β, γ) as differentiable tensors. This enables
    gradient-based optimization of crystal parameters from diffraction data.

    The rotation pipeline applies transformations in the following order:
    1. Static misset rotation (applied once to reciprocal vectors during initialization)
    2. Dynamic spindle (phi) rotation (applied during simulation)
    3. Mosaic domain rotations (applied during simulation)
    """

    def __init__(
        self, config: Optional[CrystalConfig] = None, device=None, dtype=torch.float64
    ):
        """Initialize crystal from configuration."""
        self.device = device if device is not None else torch.device("cpu")
        self.dtype = dtype

        # Store configuration
        self.config = config if config is not None else CrystalConfig()

        # Initialize cell parameters from config
        # These are the fundamental parameters that can be differentiable
        self.cell_a = torch.as_tensor(
            self.config.cell_a, device=self.device, dtype=self.dtype
        )
        self.cell_b = torch.as_tensor(
            self.config.cell_b, device=self.device, dtype=self.dtype
        )
        self.cell_c = torch.as_tensor(
            self.config.cell_c, device=self.device, dtype=self.dtype
        )
        self.cell_alpha = torch.as_tensor(
            self.config.cell_alpha, device=self.device, dtype=self.dtype
        )
        self.cell_beta = torch.as_tensor(
            self.config.cell_beta, device=self.device, dtype=self.dtype
        )
        self.cell_gamma = torch.as_tensor(
            self.config.cell_gamma, device=self.device, dtype=self.dtype
        )

        # Crystal size from config
        self.N_cells_a = torch.as_tensor(
            self.config.N_cells[0], device=self.device, dtype=self.dtype
        )
        self.N_cells_b = torch.as_tensor(
            self.config.N_cells[1], device=self.device, dtype=self.dtype
        )
        self.N_cells_c = torch.as_tensor(
            self.config.N_cells[2], device=self.device, dtype=self.dtype
        )

        # Clear the cache when parameters change
        self._geometry_cache = {}

        # Structure factor storage
        self.hkl_data: Optional[torch.Tensor] = None  # Will be loaded by load_hkl()

    def to(self, device=None, dtype=None):
        """Move crystal to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype

        # Move all tensors to new device/dtype
        self.cell_a = self.cell_a.to(device=self.device, dtype=self.dtype)
        self.cell_b = self.cell_b.to(device=self.device, dtype=self.dtype)
        self.cell_c = self.cell_c.to(device=self.device, dtype=self.dtype)
        self.cell_alpha = self.cell_alpha.to(device=self.device, dtype=self.dtype)
        self.cell_beta = self.cell_beta.to(device=self.device, dtype=self.dtype)
        self.cell_gamma = self.cell_gamma.to(device=self.device, dtype=self.dtype)

        self.N_cells_a = self.N_cells_a.to(device=self.device, dtype=self.dtype)
        self.N_cells_b = self.N_cells_b.to(device=self.device, dtype=self.dtype)
        self.N_cells_c = self.N_cells_c.to(device=self.device, dtype=self.dtype)

        if self.hkl_data is not None:
            self.hkl_data = self.hkl_data.to(device=self.device, dtype=self.dtype)

        # Clear geometry cache when moving devices
        self._geometry_cache = {}

        return self

    def load_hkl(self, hkl_file_path: str) -> None:
        """
        Load structure factor data from HKL file.

        This method parses a plain-text HKL file containing h, k, l, and F
        values and loads them into a tensor for use in the simulation.

        C-Code Implementation Reference (from nanoBragg.c, lines 1858-1861):
        The C implementation uses a two-pass approach: first to find the
        min/max HKL ranges, and second to read the data into a 3D array.
        This is the core loop from the second pass.

        ```c
        printf("re-reading %s\n",hklfilename);
        while(4 == fscanf(infile,"%d%d%d%lg",&h0,&k0,&l0,&F_cell)){
            Fhkl[h0-h_min][k0-k_min][l0-l_min]=F_cell;
        }
        fclose(infile);
        ```
        """
        # Parse HKL file
        hkl_list = []
        with open(hkl_file_path, "r") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    parts = line.split()
                    if len(parts) >= 4:
                        h, k, l, F = (  # noqa: E741
                            int(parts[0]),
                            int(parts[1]),
                            int(parts[2]),
                            float(parts[3]),
                        )
                        hkl_list.append([h, k, l, F])

        # Convert to tensor: shape (N_reflections, 4) for h,k,l,F
        if hkl_list:
            self.hkl_data = torch.tensor(hkl_list, device=self.device, dtype=self.dtype)
        else:
            # Empty HKL data
            self.hkl_data = torch.empty((0, 4), device=self.device, dtype=self.dtype)

    def get_structure_factor(
        self, h: torch.Tensor, k: torch.Tensor, l: torch.Tensor  # noqa: E741
    ) -> torch.Tensor:
        """
        Look up or interpolate the structure factor for given h,k,l indices.

        This method will replace the milestone1 placeholder. It must handle both
        nearest-neighbor lookup and differentiable tricubic interpolation,
        as determined by a configuration flag, to match the C-code's
        `interpolate` variable.

        C-Code Implementation Reference (from nanoBragg.c, lines 3101-3139):

        ```c
                                    /* structure factor of the unit cell */
                                    if(interpolate){
                                        h0_flr = floor(h);
                                        k0_flr = floor(k);
                                        l0_flr = floor(l);


                                        if ( ((h-h_min+3)>h_range) ||
                                             (h-2<h_min)           ||
                                             ((k-k_min+3)>k_range) ||
                                             (k-2<k_min)           ||
                                             ((l-l_min+3)>l_range) ||
                                             (l-2<l_min)  ) {
                                            if(babble){
                                                babble=0;
                                                printf ("WARNING: out of range for three point interpolation: h,k,l,h0,k0,l0: %g,%g,%g,%d,%d,%d \n", h,k,l,h0,k0,l0);
                                                printf("WARNING: further warnings will not be printed! ");
                                            }
                                            F_cell = default_F;
                                            interpolate=0;
                                        }
                                    }

                                    /* only interpolate if it is safe */
                                    if(interpolate){
                                        /* integer versions of nearest HKL indicies */
                                        h_interp[0]=h0_flr-1;
                                        h_interp[1]=h0_flr;
                                        h_interp[2]=h0_flr+1;
                                        h_interp[3]=h0_flr+2;
                                        k_interp[0]=k0_flr-1;
                                        k_interp[1]=k0_flr;
                                        k_interp[2]=k0_flr+1;
                                        k_interp[3]=k0_flr+2;
                                        l_interp[0]=l0_flr-1;
                                        l_interp[1]=l0_flr;
                                        l_interp[2]=l0_flr+1;
                                        l_interp[3]=l0_flr+2;

                                        /* polin function needs doubles */
                                        h_interp_d[0] = (double) h_interp[0];
                                        // ... (rest of h_interp_d, k_interp_d, l_interp_d) ...

                                        /* now populate the "y" values (nearest four structure factors in each direction) */
                                        for (i1=0;i1<4;i1++) {
                                            for (i2=0;i2<4;i2++) {
                                               for (i3=0;i3<4;i3++) {
                                                      sub_Fhkl[i1][i2][i3]= Fhkl[h_interp[i1]-h_min][k_interp[i2]-k_min][l_interp[i3]-l_min];
                                               }
                                            }
                                         }


                                        /* run the tricubic polynomial interpolation */
                                        polin3(h_interp_d,k_interp_d,l_interp_d,sub_Fhkl,h,k,l,&F_cell);
                                    }

                                    if(! interpolate)
                                    {
                                        if ( hkls && (h0<=h_max) && (h0>=h_min) && (k0<=k_max) && (k0>=k_min) && (l0<=l_max) && (l0>=l_min)  ) {
                                            /* just take nearest-neighbor */
                                            F_cell = Fhkl[h0-h_min][k0-k_min][l0-l_min];
                                        }
                                        else
                                        {
                                            F_cell = default_F;  // usually zero
                                        }
                                    }
        ```
        """
        # For the simple_cubic test case with -default_F 100,
        # all reflections have F=100 regardless of indices
        # This matches the C code behavior with the -default_F flag
        return torch.full_like(h, float(self.config.default_F), device=self.device, dtype=self.dtype)

    def compute_cell_tensors(self) -> dict:
        """
        Calculate real and reciprocal space lattice vectors from cell parameters.

        This is the central, differentiable function for all geometry calculations.
        Uses the nanoBragg.c convention to convert cell parameters (a,b,c,α,β,γ)
        to real-space and reciprocal-space lattice vectors.

        This method now supports general triclinic cells and maintains full
        differentiability for all six cell parameters. The computation graph
        is preserved for gradient-based optimization.

        The implementation follows the nanoBragg.c default orientation convention:
        - a* is placed purely along the x-axis
        - b* is placed in the x-y plane
        - c* fills out 3D space

        C-Code Implementation Reference (from nanoBragg.c):

        Volume calculation from cell parameters (lines 1798-1808):
        ```c
        /* get cell volume from angles */
        aavg = (alpha+beta+gamma)/2;
        skew = sin(aavg)*sin(aavg-alpha)*sin(aavg-beta)*sin(aavg-gamma);
        if(skew<0.0) skew=-skew;
        V_cell = 2.0*a[0]*b[0]*c[0]*sqrt(skew);
        if(V_cell <= 0.0)
        {
            printf("WARNING: impossible unit cell volume: %g\n",V_cell);
            V_cell = DBL_MIN;
        }
        V_star = 1.0/V_cell;
        ```

        NOTE: This PyTorch implementation uses a different but mathematically
        equivalent approach. Instead of Heron's formula above, we construct
        the real-space vectors explicitly and compute V = a · (b × c).

        Default orientation construction for reciprocal vectors (lines 1862-1871):
        ```c
        /* construct default orientation */
        a_star[1] = a_star[0];
        b_star[1] = b_star[0]*cos_gamma_star;
        c_star[1] = c_star[0]*cos_beta_star;
        a_star[2] = 0.0;
        b_star[2] = b_star[0]*sin_gamma_star;
        c_star[2] = c_star[0]*(cos_alpha_star-cos_beta_star*cos_gamma_star)/sin_gamma_star;
        a_star[3] = 0.0;
        b_star[3] = 0.0;
        c_star[3] = c_star[0]*V_cell/(a[0]*b[0]*c[0]*sin_gamma_star);
        ```

        Real-space basis vector construction (lines 1945-1948):
        ```c
        /* generate direct-space cell vectors, also updates magnitudes */
        vector_scale(b_star_cross_c_star,a,V_cell);
        vector_scale(c_star_cross_a_star,b,V_cell);
        vector_scale(a_star_cross_b_star,c,V_cell);
        ```

        Reciprocal-space vector calculation (lines 1951-1956):
        ```c
        /* now that we have direct-space vectors, re-generate the reciprocal ones */
        cross_product(a,b,a_cross_b);
        cross_product(b,c,b_cross_c);
        cross_product(c,a,c_cross_a);
        vector_scale(b_cross_c,a_star,V_star);
        vector_scale(c_cross_a,b_star,V_star);
        vector_scale(a_cross_b,c_star,V_star);
        ```

        Returns:
            Dictionary containing:
            - "a", "b", "c": Real-space lattice vectors (Angstroms)
            - "a_star", "b_star", "c_star": Reciprocal-space vectors (Angstroms^-1)
            - "V": Unit cell volume (Angstroms^3)
        """
        # Convert angles to radians
        alpha_rad = torch.deg2rad(self.cell_alpha)
        beta_rad = torch.deg2rad(self.cell_beta)
        gamma_rad = torch.deg2rad(self.cell_gamma)

        # Calculate trigonometric values
        cos_alpha = torch.cos(alpha_rad)
        cos_beta = torch.cos(beta_rad)
        cos_gamma = torch.cos(gamma_rad)
        sin_gamma = torch.sin(gamma_rad)

        # Calculate cell volume using C-code formula
        aavg = (alpha_rad + beta_rad + gamma_rad) / 2.0
        skew = (
            torch.sin(aavg)
            * torch.sin(aavg - alpha_rad)
            * torch.sin(aavg - beta_rad)
            * torch.sin(aavg - gamma_rad)
        )
        skew = torch.abs(skew)  # Handle negative values

        # Handle degenerate cases where skew approaches zero
        skew = torch.clamp(skew, min=1e-12)

        V = 2.0 * self.cell_a * self.cell_b * self.cell_c * torch.sqrt(skew)
        # Ensure volume is not too small
        V = torch.clamp(V, min=1e-6)
        V_star = 1.0 / V

        # Calculate reciprocal cell lengths using C-code formulas
        a_star_length = self.cell_b * self.cell_c * torch.sin(alpha_rad) * V_star
        b_star_length = self.cell_c * self.cell_a * torch.sin(beta_rad) * V_star
        c_star_length = self.cell_a * self.cell_b * torch.sin(gamma_rad) * V_star

        # Calculate reciprocal angles with numerical stability
        sin_alpha = torch.sin(alpha_rad)
        sin_beta = torch.sin(beta_rad)

        # Clamp denominators to avoid division by zero
        denom1 = torch.clamp(sin_beta * sin_gamma, min=1e-12)
        denom2 = torch.clamp(sin_gamma * sin_alpha, min=1e-12)
        denom3 = torch.clamp(sin_alpha * sin_beta, min=1e-12)

        cos_alpha_star = (cos_beta * cos_gamma - cos_alpha) / denom1
        cos_beta_star = (cos_gamma * cos_alpha - cos_beta) / denom2
        cos_gamma_star = (cos_alpha * cos_beta - cos_gamma) / denom3

        # Ensure cos_gamma_star is in valid range for sqrt
        cos_gamma_star_clamped = torch.clamp(cos_gamma_star, min=-1.0, max=1.0)
        sin_gamma_star = torch.sqrt(
            torch.clamp(1.0 - torch.pow(cos_gamma_star_clamped, 2), min=0.0)
        )

        # Construct default orientation for reciprocal vectors (C-code convention)
        # a* along x-axis
        a_star = torch.stack(
            [
                a_star_length,
                torch.zeros_like(a_star_length),
                torch.zeros_like(a_star_length),
            ]
        )

        # b* in x-y plane
        b_star = torch.stack(
            [
                b_star_length * cos_gamma_star,
                b_star_length * sin_gamma_star,
                torch.zeros_like(b_star_length),
            ]
        )

        # c* fills out 3D space
        c_star_x = c_star_length * cos_beta_star
        # Clamp sin_gamma_star to avoid division by zero
        sin_gamma_star_safe = torch.clamp(sin_gamma_star, min=1e-12)
        c_star_y = (
            c_star_length
            * (cos_alpha_star - cos_beta_star * cos_gamma_star_clamped)
            / sin_gamma_star_safe
        )
        c_star_z = (
            c_star_length
            * V
            / (self.cell_a * self.cell_b * self.cell_c * sin_gamma_star_safe)
        )
        c_star = torch.stack([c_star_x, c_star_y, c_star_z])

        # Generate real-space vectors from reciprocal vectors
        # Cross products
        a_star_cross_b_star = torch.cross(a_star, b_star, dim=0)
        b_star_cross_c_star = torch.cross(b_star, c_star, dim=0)
        c_star_cross_a_star = torch.cross(c_star, a_star, dim=0)

        # Real-space vectors: a = (b* × c*) × V_cell
        a_vec = b_star_cross_c_star * V
        b_vec = c_star_cross_a_star * V
        c_vec = a_star_cross_b_star * V

        # Now that we have real-space vectors, re-generate the reciprocal ones
        # This matches the C-code behavior (lines 1951-1956)
        a_cross_b = torch.cross(a_vec, b_vec, dim=0)
        b_cross_c = torch.cross(b_vec, c_vec, dim=0)
        c_cross_a = torch.cross(c_vec, a_vec, dim=0)

        # Recalculate volume from the actual vectors
        # This is crucial - the volume from the vectors is slightly different
        # from the volume calculated by the formula, and we need to use the
        # actual volume for perfect metric duality
        V_actual = torch.dot(a_vec, b_cross_c)
        # Ensure volume is not too small to prevent numerical instability
        V_actual = torch.clamp(V_actual, min=1e-6)
        V_star_actual = 1.0 / V_actual

        # a* = (b × c) / V, etc.
        a_star = b_cross_c * V_star_actual
        b_star = c_cross_a * V_star_actual
        c_star = a_cross_b * V_star_actual

        # Update V to the actual volume
        V = V_actual

        # Apply static orientation if misset is specified
        if hasattr(self.config, "misset_deg") and any(
            angle != 0.0 for angle in self.config.misset_deg
        ):
            # Apply the misset rotation to reciprocal vectors
            vectors = {
                "a": a_vec,
                "b": b_vec,
                "c": c_vec,
                "a_star": a_star,
                "b_star": b_star,
                "c_star": c_star,
                "V": V,
            }
            vectors = self._apply_static_orientation(vectors)
            # Extract the rotated vectors - both reciprocal AND real space
            a_vec = vectors["a"]
            b_vec = vectors["b"]
            c_vec = vectors["c"]
            a_star = vectors["a_star"]
            b_star = vectors["b_star"]
            c_star = vectors["c_star"]

        return {
            "a": a_vec,
            "b": b_vec,
            "c": c_vec,
            "a_star": a_star,
            "b_star": b_star,
            "c_star": c_star,
            "V": V,
        }

    def _compute_cell_tensors_cached(self):
        """
        Cached version of compute_cell_tensors to avoid redundant calculations.

        Note: For differentiability, we cannot use .item() or create cache keys
        from tensor values. Instead, we simply recompute when needed, relying
        on PyTorch's own computation graph caching.
        """
        # For now, just compute directly - PyTorch will handle computation graph caching
        # A more sophisticated caching mechanism that preserves gradients could be added later
        return self.compute_cell_tensors()

    @property
    def a(self) -> torch.Tensor:
        """Real-space lattice vector a (Angstroms)."""
        return self._compute_cell_tensors_cached()["a"]

    @property
    def b(self) -> torch.Tensor:
        """Real-space lattice vector b (Angstroms)."""
        return self._compute_cell_tensors_cached()["b"]

    @property
    def c(self) -> torch.Tensor:
        """Real-space lattice vector c (Angstroms)."""
        return self._compute_cell_tensors_cached()["c"]

    @property
    def a_star(self) -> torch.Tensor:
        """Reciprocal-space lattice vector a* (Angstroms^-1)."""
        return self._compute_cell_tensors_cached()["a_star"]

    @property
    def b_star(self) -> torch.Tensor:
        """Reciprocal-space lattice vector b* (Angstroms^-1)."""
        return self._compute_cell_tensors_cached()["b_star"]

    @property
    def c_star(self) -> torch.Tensor:
        """Reciprocal-space lattice vector c* (Angstroms^-1)."""
        return self._compute_cell_tensors_cached()["c_star"]

    @property
    def V(self) -> torch.Tensor:
        """Unit cell volume (Angstroms^3)."""
        return self._compute_cell_tensors_cached()["V"]

    def get_rotated_real_vectors(self, config: "CrystalConfig") -> Tuple[
        Tuple[torch.Tensor, torch.Tensor, torch.Tensor],
        Tuple[torch.Tensor, torch.Tensor, torch.Tensor],
    ]:
        """
        Get real-space and reciprocal-space lattice vectors after applying all rotations.

        This method applies rotations in the correct physical sequence:
        1. Static missetting rotation (already applied to reciprocal vectors in compute_cell_tensors)
        2. Dynamic spindle (phi) rotation
        3. Mosaic domain rotations

        The method now returns both real-space and reciprocal-space vectors to support
        the correct physics implementation where Miller indices are calculated using
        reciprocal-space vectors.

        C-Code Implementation Reference (from nanoBragg.c):

        ---
        FUTURE WORK: Initial Orientation (`-misset`), applied once (lines 1521-1527):
        This rotation should be applied first, before the phi and mosaic rotations.
        ```c
        /* apply any missetting angle, if not already done */
        if(misset[0] > 0.0)
        {
            rotate(a_star,a_star,misset[1],misset[2],misset[3]);
            rotate(b_star,b_star,misset[1],misset[2],misset[3]);
            rotate(c_star,c_star,misset[1],misset[2],misset[3]);
        }
        ```
        ---

        IMPLEMENTED: Spindle and Mosaic Rotations, inside the simulation loop (lines 3004-3019):
        ```c
                                    /* sweep over phi angles */
                                    for(phi_tic = 0; phi_tic < phisteps; ++phi_tic)
                                    {
                                        phi = phi0 + phistep*phi_tic;

                                        if( phi != 0.0 )
                                        {
                                            /* rotate about spindle if neccesary */
                                            rotate_axis(a0,ap,spindle_vector,phi);
                                            rotate_axis(b0,bp,spindle_vector,phi);
                                            rotate_axis(c0,cp,spindle_vector,phi);
                                        }

                                        /* enumerate mosaic domains */
                                        for(mos_tic=0;mos_tic<mosaic_domains;++mos_tic)
                                        {
                                            /* apply mosaic rotation after phi rotation */
                                            if( mosaic_spread > 0.0 )
                                            {
                                                rotate_umat(ap,a,&mosaic_umats[mos_tic*9]);
                                                rotate_umat(bp,b,&mosaic_umats[mos_tic*9]);
                                                rotate_umat(cp,c,&mosaic_umats[mos_tic*9]);
                                            }
                                            else
                                            {
                                                a[1]=ap[1];a[2]=ap[2];a[3]=ap[3];
                                                b[1]=bp[1];b[2]=bp[2];b[3]=bp[3];
                                                c[1]=cp[1];c[2]=cp[2];c[3]=cp[3];
                                            }
        ```

        Args:
            config: CrystalConfig containing rotation parameters.

        Returns:
            Tuple containing:
            - First tuple: rotated (a, b, c) real-space vectors with shape (N_phi, N_mos, 3)
            - Second tuple: rotated (a*, b*, c*) reciprocal-space vectors with shape (N_phi, N_mos, 3)
        """
        from ..utils.geometry import rotate_axis, rotate_umat

        # Generate phi angles
        # Assume config parameters are tensors (enforced at call site)
        # torch.linspace doesn't preserve gradients, so we handle different cases manually
        if config.phi_steps == 1:
            # For single step, use the midpoint (preserves gradients)
            phi_angles = config.phi_start_deg + config.osc_range_deg / 2.0
            if isinstance(phi_angles, torch.Tensor):
                phi_angles = phi_angles.unsqueeze(0)  # Add batch dimension
            else:
                phi_angles = torch.tensor(
                    [phi_angles], device=self.device, dtype=self.dtype
                )
        else:
            # For multiple steps, we need to create a differentiable range
            # Use arange and manual scaling to preserve gradients
            step_indices = torch.arange(
                config.phi_steps, device=self.device, dtype=self.dtype
            )
            step_size = (
                config.osc_range_deg / config.phi_steps
                if config.phi_steps > 1
                else config.osc_range_deg
            )
            phi_angles = config.phi_start_deg + step_size * (step_indices + 0.5)
        phi_rad = torch.deg2rad(phi_angles)

        # Convert spindle axis to tensor
        spindle_axis = torch.tensor(
            config.spindle_axis, device=self.device, dtype=self.dtype
        )

        # Apply spindle rotation to both real and reciprocal vectors
        # Shape: (N_phi, 3)
        a_phi = rotate_axis(self.a.unsqueeze(0), spindle_axis.unsqueeze(0), phi_rad)
        b_phi = rotate_axis(self.b.unsqueeze(0), spindle_axis.unsqueeze(0), phi_rad)
        c_phi = rotate_axis(self.c.unsqueeze(0), spindle_axis.unsqueeze(0), phi_rad)

        a_star_phi = rotate_axis(
            self.a_star.unsqueeze(0), spindle_axis.unsqueeze(0), phi_rad
        )
        b_star_phi = rotate_axis(
            self.b_star.unsqueeze(0), spindle_axis.unsqueeze(0), phi_rad
        )
        c_star_phi = rotate_axis(
            self.c_star.unsqueeze(0), spindle_axis.unsqueeze(0), phi_rad
        )

        # Generate mosaic rotation matrices
        # Assume config.mosaic_spread_deg is a tensor (enforced at call site)
        if isinstance(config.mosaic_spread_deg, torch.Tensor):
            has_mosaic = torch.any(config.mosaic_spread_deg > 0.0)
        else:
            has_mosaic = config.mosaic_spread_deg > 0.0

        if has_mosaic:
            mosaic_umats = self._generate_mosaic_rotations(config)
        else:
            # Identity matrices for no mosaicity
            mosaic_umats = (
                torch.eye(3, device=self.device, dtype=self.dtype)
                .unsqueeze(0)
                .repeat(config.mosaic_domains, 1, 1)
            )

        # Apply mosaic rotations to both real and reciprocal vectors
        # Broadcast phi and mosaic dimensions: (N_phi, 1, 3) x (1, N_mos, 3, 3) -> (N_phi, N_mos, 3)
        a_final = rotate_umat(a_phi.unsqueeze(1), mosaic_umats.unsqueeze(0))
        b_final = rotate_umat(b_phi.unsqueeze(1), mosaic_umats.unsqueeze(0))
        c_final = rotate_umat(c_phi.unsqueeze(1), mosaic_umats.unsqueeze(0))

        a_star_final = rotate_umat(a_star_phi.unsqueeze(1), mosaic_umats.unsqueeze(0))
        b_star_final = rotate_umat(b_star_phi.unsqueeze(1), mosaic_umats.unsqueeze(0))
        c_star_final = rotate_umat(c_star_phi.unsqueeze(1), mosaic_umats.unsqueeze(0))

        return (a_final, b_final, c_final), (a_star_final, b_star_final, c_star_final)

    def _generate_mosaic_rotations(self, config: "CrystalConfig") -> torch.Tensor:
        """
        Generate random rotation matrices for mosaic domains.

        Args:
            config: CrystalConfig containing mosaic parameters.

        Returns:
            torch.Tensor: Rotation matrices with shape (N_mos, 3, 3).
        """
        from ..utils.geometry import rotate_axis

        # Convert mosaic spread to radians
        # Assume config.mosaic_spread_deg is a tensor (enforced at call site)
        if isinstance(config.mosaic_spread_deg, torch.Tensor):
            mosaic_spread_rad = torch.deg2rad(config.mosaic_spread_deg)
        else:
            mosaic_spread_rad = torch.deg2rad(
                torch.tensor(
                    config.mosaic_spread_deg, device=self.device, dtype=self.dtype
                )
            )

        # Generate random rotation axes (normalized)
        random_axes = torch.randn(
            config.mosaic_domains, 3, device=self.device, dtype=self.dtype
        )
        axes_normalized = random_axes / torch.norm(random_axes, dim=1, keepdim=True)

        # Generate random rotation angles (small, scaled by mosaic spread)
        random_angles = (
            torch.randn(config.mosaic_domains, device=self.device, dtype=self.dtype)
            * mosaic_spread_rad
        )

        # Create rotation matrices using Rodrigues' formula
        # Start with identity vectors
        identity_vecs = (
            torch.eye(3, device=self.device, dtype=self.dtype)
            .unsqueeze(0)
            .repeat(config.mosaic_domains, 1, 1)
        )

        # Apply rotations to each column of identity matrix
        rotated_vecs = torch.zeros_like(identity_vecs)
        for i in range(3):
            rotated_vecs[:, :, i] = rotate_axis(
                identity_vecs[:, :, i], axes_normalized, random_angles
            )

        return rotated_vecs

    def _apply_static_orientation(self, vectors: dict) -> dict:
        """
        Apply static misset rotation to reciprocal space vectors and update real-space vectors.

        This method applies the crystal misset angles (in degrees) as XYZ rotations
        to the reciprocal space vectors (a*, b*, c*), then recalculates the real-space
        vectors from the rotated reciprocal vectors. This matches the C-code
        behavior where misset is applied once during initialization.

        C-Code Implementation Reference (from nanoBragg.c, lines 1911-1916 and 1945-1948):
        ```c
        /* apply any missetting angle, if not already done */
        if(misset[0] > 0.0)
        {
            rotate(a_star,a_star,misset[1],misset[2],misset[3]);
            rotate(b_star,b_star,misset[1],misset[2],misset[3]);
            rotate(c_star,c_star,misset[1],misset[2],misset[3]);
        }

        /* generate direct-space cell vectors, also updates magnitudes */
        vector_scale(b_star_cross_c_star,a,V_cell);
        vector_scale(c_star_cross_a_star,b,V_cell);
        vector_scale(a_star_cross_b_star,c,V_cell);
        ```

        Args:
            vectors: Dictionary containing lattice vectors, including a_star, b_star, c_star

        Returns:
            Dictionary with rotated reciprocal vectors and updated real-space vectors
        """
        from ..utils.geometry import rotate_umat

        # Convert misset angles from degrees to radians
        # Handle both tensor and float inputs
        misset_x_rad = torch.deg2rad(
            torch.as_tensor(
                self.config.misset_deg[0], device=self.device, dtype=self.dtype
            )
        )
        misset_y_rad = torch.deg2rad(
            torch.as_tensor(
                self.config.misset_deg[1], device=self.device, dtype=self.dtype
            )
        )
        misset_z_rad = torch.deg2rad(
            torch.as_tensor(
                self.config.misset_deg[2], device=self.device, dtype=self.dtype
            )
        )

        # Generate rotation matrix using XYZ convention
        rotation_matrix = angles_to_rotation_matrix(
            misset_x_rad, misset_y_rad, misset_z_rad
        )

        # Apply rotation to reciprocal vectors
        vectors["a_star"] = rotate_umat(vectors["a_star"], rotation_matrix)
        vectors["b_star"] = rotate_umat(vectors["b_star"], rotation_matrix)
        vectors["c_star"] = rotate_umat(vectors["c_star"], rotation_matrix)

        # Recalculate real-space vectors from rotated reciprocal vectors
        # This is crucial: a = (b* × c*) × V
        V = vectors["V"]
        b_star_cross_c_star = torch.cross(vectors["b_star"], vectors["c_star"], dim=0)
        c_star_cross_a_star = torch.cross(vectors["c_star"], vectors["a_star"], dim=0)
        a_star_cross_b_star = torch.cross(vectors["a_star"], vectors["b_star"], dim=0)

        vectors["a"] = b_star_cross_c_star * V
        vectors["b"] = c_star_cross_a_star * V
        vectors["c"] = a_star_cross_b_star * V

        # Note: CLAUDE.md Rule #13 suggests circular recalculation here, but
        # testing shows this may not be needed for the current issue

        return vectors
</file>

<file path="nanobrag_torch/models/detector.py">
"""
Detector model for nanoBragg PyTorch implementation.

This module defines the Detector class responsible for managing all detector
geometry calculations and pixel coordinate generation.
"""

from typing import Optional, Tuple

import torch

from ..config import DetectorConfig
from ..utils.units import mm_to_angstroms, degrees_to_radians


def _nonzero_scalar(x) -> bool:
    """Return a Python bool for 'x != 0' even if x is a 0-dim torch.Tensor."""
    if isinstance(x, torch.Tensor):
        return bool(torch.abs(x).item() > 1e-12)
    return abs(float(x)) > 1e-12


class Detector:
    """
    Detector model managing geometry and pixel coordinates.

    **Authoritative Specification:** For a complete specification of this
    component's coordinate systems, conventions, and unit handling, see the
    full architectural deep dive: `docs/architecture/detector.md`.

    Responsible for:
    - Detector position and orientation (basis vectors)
    - Pixel coordinate generation and caching
    - Solid angle corrections
    """

    def __init__(
        self, config: Optional[DetectorConfig] = None, device=None, dtype=torch.float64
    ):
        """Initialize detector from configuration."""
        self.device = device if device is not None else torch.device("cpu")
        self.dtype = dtype

        # Use provided config or create default
        if config is None:
            config = DetectorConfig()  # Use defaults
        self.config = config

        # NOTE: Detector geometry works in METERS, not Angstroms!
        # This is different from the physics calculations which use Angstroms
        # The C-code detector geometry calculations use meters as evidenced by
        # DETECTOR_PIX0_VECTOR outputting values like 0.1 (for 100mm distance)
        self.distance = config.distance_mm / 1000.0  # Convert mm to meters
        self.pixel_size = config.pixel_size_mm / 1000.0  # Convert mm to meters

        # Copy dimension parameters
        self.spixels = config.spixels
        self.fpixels = config.fpixels

        # Convert beam center from mm to pixels
        # Note: beam center is given in mm from detector origin
        self.beam_center_s: torch.Tensor
        self.beam_center_f: torch.Tensor

        if isinstance(config.beam_center_s, torch.Tensor):
            self.beam_center_s = config.beam_center_s / config.pixel_size_mm
        else:
            self.beam_center_s = torch.tensor(
                config.beam_center_s / config.pixel_size_mm,
                device=self.device,
                dtype=self.dtype,
            )

        if isinstance(config.beam_center_f, torch.Tensor):
            self.beam_center_f = config.beam_center_f / config.pixel_size_mm
        else:
            self.beam_center_f = torch.tensor(
                config.beam_center_f / config.pixel_size_mm,
                device=self.device,
                dtype=self.dtype,
            )

        # Initialize basis vectors
        if self._is_default_config():
            # Use hard-coded vectors for backward compatibility
            # Detector basis vectors from golden log: DIRECTION_OF_DETECTOR_*_AXIS
            # Fast axis (X): [0, 0, 1]
            # Slow axis (Y): [0, -1, 0]
            # Normal axis (Z): [1, 0, 0]
            self.fdet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype
            )
            self.sdet_vec = torch.tensor(
                [0.0, -1.0, 0.0], device=self.device, dtype=self.dtype
            )
            self.odet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        else:
            # Calculate basis vectors dynamically in Phase 2
            self.fdet_vec, self.sdet_vec, self.odet_vec = (
                self._calculate_basis_vectors()
            )

        # Calculate and cache pix0_vector (position of first pixel)
        self._calculate_pix0_vector()

        self._pixel_coords_cache: Optional[torch.Tensor] = None
        self._geometry_version = 0
        self._cached_basis_vectors = (
            self.fdet_vec.clone(),
            self.sdet_vec.clone(),
            self.odet_vec.clone(),
        )
        self._cached_pix0_vector = self.pix0_vector.clone()

    def _is_default_config(self) -> bool:
        """Check if using default config (for backward compatibility)."""
        from ..config import DetectorConvention

        c = self.config
        # Check all basic parameters
        basic_check = (
            c.distance_mm == 100.0
            and c.pixel_size_mm == 0.1
            and c.spixels == 1024
            and c.fpixels == 1024
            and c.beam_center_s == 51.2
            and c.beam_center_f == 51.2
        )

        # Check detector convention is default (MOSFLM)
        convention_check = c.detector_convention == DetectorConvention.MOSFLM

        # Check rotation parameters (handle both float and tensor)
        rotx_check = (
            c.detector_rotx_deg == 0
            if isinstance(c.detector_rotx_deg, (int, float))
            else torch.allclose(
                c.detector_rotx_deg, torch.tensor(0.0, dtype=c.detector_rotx_deg.dtype)
            )
        )
        roty_check = (
            c.detector_roty_deg == 0
            if isinstance(c.detector_roty_deg, (int, float))
            else torch.allclose(
                c.detector_roty_deg, torch.tensor(0.0, dtype=c.detector_roty_deg.dtype)
            )
        )
        rotz_check = (
            c.detector_rotz_deg == 0
            if isinstance(c.detector_rotz_deg, (int, float))
            else torch.allclose(
                c.detector_rotz_deg, torch.tensor(0.0, dtype=c.detector_rotz_deg.dtype)
            )
        )
        twotheta_check = (
            c.detector_twotheta_deg == 0
            if isinstance(c.detector_twotheta_deg, (int, float))
            else torch.allclose(
                c.detector_twotheta_deg,
                torch.tensor(0.0, dtype=c.detector_twotheta_deg.dtype),
            )
        )

        return bool(
            basic_check
            and convention_check
            and rotx_check
            and roty_check
            and rotz_check
            and twotheta_check
        )

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype

        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)

        # Move beam center tensors
        self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
        self.beam_center_f = self.beam_center_f.to(device=self.device, dtype=self.dtype)

        # Invalidate cache since device/dtype changed
        self.invalidate_cache()
        return self

    def invalidate_cache(self):
        """Invalidate cached pixel coordinates when geometry changes."""
        self._pixel_coords_cache = None
        self._geometry_version += 1
        # Recalculate pix0_vector when geometry changes
        self._calculate_pix0_vector()

    def _calculate_pix0_vector(self):
        """
        Calculate the position of the first pixel (0,0) in 3D space.

        This follows the C-code convention where pix0_vector represents the
        3D position of pixel (0,0), taking into account the beam center offset
        and detector positioning.

        The calculation depends on the detector_pivot mode:
        - BEAM pivot: pix0_vector = -Fbeam*fdet_vec - Sbeam*sdet_vec + distance*beam_vec
        - SAMPLE pivot: Calculate pix0_vector BEFORE rotations, then rotate it

        C-Code Implementation Reference (from nanoBragg.c):
        For SAMPLE pivot (lines 376-385):
        ```c
        if(detector_pivot == SAMPLE){
            printf("pivoting detector around sample\n");
            /* initialize detector origin before rotating detector */
            pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
            pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
            pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
            
            /* now swing the detector origin around */
            rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
            rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
        }
        ```
        For BEAM pivot (lines 398-403):
        ```c
        if(detector_pivot == BEAM){
            printf("pivoting detector around direct beam spot\n");
            pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
            pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
            pix0_vector[3] = -Fbeam*fdet_vector[3]-Sbeam*sdet_vector[3]+distance*beam_vector[3];
        }
        ```

        Note: This uses pixel centers at integer indices.
        """
        from ..config import DetectorPivot, DetectorConvention
        from ..utils.geometry import angles_to_rotation_matrix, rotate_axis
        from ..utils.units import degrees_to_radians

        if self.config.detector_pivot == DetectorPivot.BEAM:
            # BEAM pivot mode: detector rotates around the direct beam spot
            # For MOSFLM convention, beam_vector is [1, 0, 0]
            if self.config.detector_convention == DetectorConvention.MOSFLM:
                beam_vector = torch.tensor(
                    [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
                )
            else:
                # XDS convention uses [0, 0, 1] as beam vector
                beam_vector = torch.tensor(
                    [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype
                )

            # Distances along detector axes measured from pixel centers (meters)
            Fbeam = (self.beam_center_f + 0.5) * self.pixel_size
            Sbeam = (self.beam_center_s + 0.5) * self.pixel_size

            # Calculate pix0_vector using BEAM pivot formula
            # Uses the ROTATED basis vectors
            self.pix0_vector = (
                -Fbeam * self.fdet_vec
                - Sbeam * self.sdet_vec
                + self.distance * beam_vector
            )
        else:
            # SAMPLE pivot mode: detector rotates around the sample
            # IMPORTANT: Compute pix0 BEFORE rotating, using the same formula as C:
            # pix0 = -Fclose*fdet - Sclose*sdet + close_distance*odet

            # Unrotated basis (by convention)
            if self.config.detector_convention == DetectorConvention.MOSFLM:
                fdet_initial = torch.tensor([0.0, 0.0, 1.0], device=self.device, dtype=self.dtype)
                sdet_initial = torch.tensor([0.0, -1.0, 0.0], device=self.device, dtype=self.dtype)
                odet_initial = torch.tensor([1.0, 0.0, 0.0], device=self.device, dtype=self.dtype)
            else:
                # XDS convention
                fdet_initial = torch.tensor([1.0, 0.0, 0.0], device=self.device, dtype=self.dtype)
                sdet_initial = torch.tensor([0.0, 1.0, 0.0], device=self.device, dtype=self.dtype)
                odet_initial = torch.tensor([0.0, 0.0, 1.0], device=self.device, dtype=self.dtype)

            # Distances from pixel (0,0) center to the beam spot, measured along detector axes
            Fclose = (self.beam_center_f + 0.5) * self.pixel_size  # meters
            Sclose = (self.beam_center_s + 0.5) * self.pixel_size  # meters

            # Compute pix0 BEFORE rotations (close_distance == self.distance)
            pix0_initial = (
                -Fclose * fdet_initial
                - Sclose * sdet_initial
                + self.distance * odet_initial
            )

            # Now rotate pix0 with detector_rotx/roty/rotz and twotheta, same as C
            c = self.config
            detector_rotx = degrees_to_radians(c.detector_rotx_deg)
            detector_roty = degrees_to_radians(c.detector_roty_deg)
            detector_rotz = degrees_to_radians(c.detector_rotz_deg)
            detector_twotheta = degrees_to_radians(c.detector_twotheta_deg)

            if not isinstance(detector_rotx, torch.Tensor):
                detector_rotx = torch.tensor(detector_rotx, device=self.device, dtype=self.dtype)
            if not isinstance(detector_roty, torch.Tensor):
                detector_roty = torch.tensor(detector_roty, device=self.device, dtype=self.dtype)
            if not isinstance(detector_rotz, torch.Tensor):
                detector_rotz = torch.tensor(detector_rotz, device=self.device, dtype=self.dtype)
            if not isinstance(detector_twotheta, torch.Tensor):
                detector_twotheta = torch.tensor(detector_twotheta, device=self.device, dtype=self.dtype)

            rotation_matrix = angles_to_rotation_matrix(detector_rotx, detector_roty, detector_rotz)
            pix0_rotated = torch.matmul(rotation_matrix, pix0_initial)

            if isinstance(c.twotheta_axis, torch.Tensor):
                twotheta_axis = c.twotheta_axis.to(device=self.device, dtype=self.dtype)
            else:
                twotheta_axis = torch.tensor(c.twotheta_axis, device=self.device, dtype=self.dtype)

            if _nonzero_scalar(detector_twotheta):
                pix0_rotated = rotate_axis(pix0_rotated, twotheta_axis, detector_twotheta)

            self.pix0_vector = pix0_rotated

    def get_pixel_coords(self) -> torch.Tensor:
        """
        Get 3D coordinates of all detector pixels.

        Returns:
            torch.Tensor: Pixel coordinates with shape (spixels, fpixels, 3) in meters
        """
        # Check if geometry has changed by comparing cached values
        geometry_changed = False
        if hasattr(self, "_cached_basis_vectors") and hasattr(
            self, "_cached_pix0_vector"
        ):
            # Check if basis vectors have changed
            if not (
                torch.allclose(self.fdet_vec, self._cached_basis_vectors[0], atol=1e-15)
                and torch.allclose(
                    self.sdet_vec, self._cached_basis_vectors[1], atol=1e-15
                )
                and torch.allclose(
                    self.odet_vec, self._cached_basis_vectors[2], atol=1e-15
                )
            ):
                geometry_changed = True
            # Check if pix0_vector has changed
            if not torch.allclose(
                self.pix0_vector, self._cached_pix0_vector, atol=1e-15
            ):
                geometry_changed = True

        if self._pixel_coords_cache is None or geometry_changed:
            # Create pixel index grids (integer indices, pixel centers handled in pix0_vector)
            s_indices = torch.arange(self.spixels, device=self.device, dtype=self.dtype)
            f_indices = torch.arange(self.fpixels, device=self.device, dtype=self.dtype)

            # Create meshgrid of indices
            s_grid, f_grid = torch.meshgrid(s_indices, f_indices, indexing="ij")

            # Calculate pixel coordinates using pix0_vector as the reference
            # pixel_coords = pix0_vector + s * pixel_size * sdet_vec + f * pixel_size * fdet_vec

            # Expand vectors for broadcasting
            pix0_expanded = self.pix0_vector.unsqueeze(0).unsqueeze(0)  # (1, 1, 3)
            sdet_expanded = self.sdet_vec.unsqueeze(0).unsqueeze(0)  # (1, 1, 3)
            fdet_expanded = self.fdet_vec.unsqueeze(0).unsqueeze(0)  # (1, 1, 3)

            # Calculate pixel coordinates
            pixel_coords = (
                pix0_expanded
                + s_grid.unsqueeze(-1) * self.pixel_size * sdet_expanded
                + f_grid.unsqueeze(-1) * self.pixel_size * fdet_expanded
            )

            self._pixel_coords_cache = pixel_coords

            # Update cached values for future comparisons
            self._cached_basis_vectors = (
                self.fdet_vec.clone(),
                self.sdet_vec.clone(),
                self.odet_vec.clone(),
            )
            self._cached_pix0_vector = self.pix0_vector.clone()
            self._geometry_version += 1

        return self._pixel_coords_cache

    def _calculate_basis_vectors(
        self,
    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Calculate detector basis vectors from configuration.

        This method dynamically computes the detector's fast, slow, and
        normal basis vectors based on user-provided configuration, such as
        detector rotations (`-detector_rot*`) and the two-theta angle.

        The calculation follows this exact sequence:
        1. Initialize basis vectors according to detector convention (MOSFLM or XDS)
        2. Apply detector rotations in order: X-axis, Y-axis, Z-axis
        3. Apply two-theta rotation around the specified axis (if non-zero)

        All rotations preserve the orthonormality of the basis vectors and
        maintain differentiability when rotation angles are provided as tensors
        with requires_grad=True.

        Note: This method takes no parameters as it uses self.config and
        self.device/dtype. The returned vectors are guaranteed to be on the
        same device and have the same dtype as the detector.

        C-Code Implementation Reference (from nanoBragg.c, lines 1319-1412):
        The C code performs these calculations in a large block within main()
        after parsing arguments. The key operations to replicate are:

        ```c
            /* initialize detector origin from a beam center and distance */
            /* there are two conventions here: mosflm and XDS */
            // ... logic to handle different conventions ...

            if(detector_pivot == SAMPLE){
                printf("pivoting detector around sample\n");
                /* initialize detector origin before rotating detector */
                pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
                pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
                pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];

                /* now swing the detector origin around */
                rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
                rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
            }
            /* now orient the detector plane */
            rotate(fdet_vector,fdet_vector,detector_rotx,detector_roty,detector_rotz);
            rotate(sdet_vector,sdet_vector,detector_rotx,detector_roty,detector_rotz);
            rotate(odet_vector,odet_vector,detector_rotx,detector_roty,detector_rotz);

            /* also apply orientation part of twotheta swing */
            rotate_axis(fdet_vector,fdet_vector,twotheta_axis,detector_twotheta);
            rotate_axis(sdet_vector,sdet_vector,twotheta_axis,detector_twotheta);
            rotate_axis(odet_vector,odet_vector,twotheta_axis,detector_twotheta);

            /* make sure beam center is preserved */
            if(detector_pivot == BEAM){
                printf("pivoting detector around direct beam spot\n");
                pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
                pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
                pix0_vector[3] = -Fbeam*fdet_vector[3]-Sbeam*sdet_vector[3]+distance*beam_vector[3];
            }
        ```

        Returns:
            Tuple[torch.Tensor, torch.Tensor, torch.Tensor]: The calculated
            (fdet_vec, sdet_vec, odet_vec) basis vectors, each with shape (3,)
        """
        from ..utils.geometry import angles_to_rotation_matrix, rotate_axis

        # Get configuration parameters
        c = self.config

        # Convert rotation angles to radians (handling both scalar and tensor inputs)
        detector_rotx = degrees_to_radians(c.detector_rotx_deg)
        detector_roty = degrees_to_radians(c.detector_roty_deg)
        detector_rotz = degrees_to_radians(c.detector_rotz_deg)
        detector_twotheta = degrees_to_radians(c.detector_twotheta_deg)

        # Ensure all angles are tensors for consistent handling
        if not isinstance(detector_rotx, torch.Tensor):
            detector_rotx = torch.tensor(
                detector_rotx, device=self.device, dtype=self.dtype
            )
        if not isinstance(detector_roty, torch.Tensor):
            detector_roty = torch.tensor(
                detector_roty, device=self.device, dtype=self.dtype
            )
        if not isinstance(detector_rotz, torch.Tensor):
            detector_rotz = torch.tensor(
                detector_rotz, device=self.device, dtype=self.dtype
            )
        if not isinstance(detector_twotheta, torch.Tensor):
            detector_twotheta = torch.tensor(
                detector_twotheta, device=self.device, dtype=self.dtype
            )

        # Initialize basis vectors based on detector convention
        from ..config import DetectorConvention

        if c.detector_convention == DetectorConvention.MOSFLM:
            # MOSFLM convention: detector surface normal points towards source
            fdet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype
            )
            sdet_vec = torch.tensor(
                [0.0, -1.0, 0.0], device=self.device, dtype=self.dtype
            )
            odet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        elif c.detector_convention == DetectorConvention.XDS:
            # XDS convention: detector surface normal points away from source
            fdet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
            sdet_vec = torch.tensor(
                [0.0, 1.0, 0.0], device=self.device, dtype=self.dtype
            )
            odet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype
            )
        else:
            raise ValueError(f"Unknown detector convention: {c.detector_convention}")

        # Apply detector rotations (rotx, roty, rotz) using the C-code's rotate function logic
        # The C-code applies rotations in order: X, then Y, then Z
        rotation_matrix = angles_to_rotation_matrix(
            detector_rotx, detector_roty, detector_rotz
        )

        # Apply the rotation matrix to all three basis vectors
        fdet_vec = torch.matmul(rotation_matrix, fdet_vec)
        sdet_vec = torch.matmul(rotation_matrix, sdet_vec)
        odet_vec = torch.matmul(rotation_matrix, odet_vec)

        # Apply two-theta rotation around the specified axis
        if isinstance(c.twotheta_axis, torch.Tensor):
            twotheta_axis = c.twotheta_axis.to(device=self.device, dtype=self.dtype)
        else:
            twotheta_axis = torch.tensor(
                c.twotheta_axis, device=self.device, dtype=self.dtype
            )

        # Check if twotheta is non-zero (handle both scalar and tensor cases)
        if _nonzero_scalar(detector_twotheta):
            fdet_vec = rotate_axis(fdet_vec, twotheta_axis, detector_twotheta)
            sdet_vec = rotate_axis(sdet_vec, twotheta_axis, detector_twotheta)
            odet_vec = rotate_axis(odet_vec, twotheta_axis, detector_twotheta)

        return fdet_vec, sdet_vec, odet_vec
</file>

<file path="nanobrag_torch/utils/__init__.py">
"""
Utility functions for nanoBragg PyTorch implementation.

This package contains vectorized PyTorch implementations of geometry and
physics calculations from the original C code.
"""

# Import key functions for easy access
from .geometry import cross_product, dot_product, rotate_axis, unitize
from .physics import polarization_factor, sinc3, sincg

__all__ = [
    "dot_product",
    "cross_product",
    "unitize",
    "rotate_axis",
    "sincg",
    "sinc3",
    "polarization_factor",
]
</file>

<file path="nanobrag_torch/utils/geometry.py">
"""
Vectorized 3D geometry utilities for nanoBragg PyTorch implementation.

This module contains PyTorch implementations of all vector and geometry
operations from the original C code, designed for broadcasting and GPU acceleration.
"""

from typing import Tuple

import torch


def dot_product(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:
    """
    Calculate dot product of vectors x and y.

    Args:
        x, y: Tensors with shape (..., 3) representing 3D vectors

    Returns:
        torch.Tensor: Scalar dot product for each vector pair
    """
    return torch.sum(x * y, dim=-1)


def cross_product(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:
    """
    Calculate cross product of vectors x and y.

    Args:
        x, y: Tensors with shape (..., 3) representing 3D vectors

    Returns:
        torch.Tensor: Cross product vectors with shape (..., 3)
    """
    return torch.cross(x, y, dim=-1)


def magnitude(vector: torch.Tensor) -> torch.Tensor:
    """
    Calculate magnitude of vectors.

    Args:
        vector: Tensor with shape (..., 3) representing 3D vectors

    Returns:
        torch.Tensor: Magnitude for each vector
    """
    return torch.sqrt(torch.sum(vector * vector, dim=-1))


def unitize(vector: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:
    """
    Normalize vectors to unit length.

    Args:
        vector: Tensor with shape (..., 3) representing 3D vectors

    Returns:
        Tuple of (unit_vector, original_magnitude)
    """
    mag = magnitude(vector)
    # Use a small epsilon to avoid division by zero
    safe_mag = torch.where(mag > 1e-12, mag, torch.ones_like(mag))
    unit_vector = vector / safe_mag.unsqueeze(-1)
    # Ensure zero vectors remain zero
    unit_vector = torch.where(
        mag.unsqueeze(-1) > 1e-12, unit_vector, torch.zeros_like(unit_vector)
    )
    return unit_vector, mag


def rotate_axis(v: torch.Tensor, axis: torch.Tensor, phi: torch.Tensor) -> torch.Tensor:
    """
    Rotate vectors around arbitrary axes using Rodrigues' formula.

    Args:
        v: Vectors to rotate with shape (..., 3)
        axis: Unit vectors defining rotation axes with shape (..., 3)
        phi: Rotation angles in radians

    Returns:
        torch.Tensor: Rotated vectors with shape (..., 3)
    """
    # Ensure axis is unit vector for stability
    axis_unit, _ = unitize(axis)

    # Rodrigues' formula: v_rot = v*cos(phi) + (axis × v)*sin(phi) + axis*(axis·v)*(1-cos(phi))
    cos_phi = torch.cos(phi).unsqueeze(-1)
    sin_phi = torch.sin(phi).unsqueeze(-1)

    axis_dot_v = dot_product(axis_unit, v).unsqueeze(-1)
    axis_cross_v = cross_product(axis_unit, v)

    v_rot = (
        v * cos_phi + axis_cross_v * sin_phi + axis_unit * axis_dot_v * (1 - cos_phi)
    )

    return v_rot


def rotate_umat(v: torch.Tensor, umat: torch.Tensor) -> torch.Tensor:
    """
    Rotate vectors using rotation matrices.

    Args:
        v: Vectors to rotate with shape (..., 3)
        umat: Rotation matrices with shape (..., 3, 3)

    Returns:
        torch.Tensor: Rotated vectors with shape (..., 3)
    """
    # Matrix multiplication: umat @ v (broadcasting over leading dimensions)
    return torch.matmul(umat, v.unsqueeze(-1)).squeeze(-1)


def angles_to_rotation_matrix(
    phi_x: torch.Tensor, phi_y: torch.Tensor, phi_z: torch.Tensor
) -> torch.Tensor:
    """
    Convert three Euler angles to a rotation matrix using XYZ convention.

    This implements the same rotation sequence as nanoBragg.c, applying
    rotations in the order: X-axis, then Y-axis, then Z-axis (extrinsic rotations).

    C-Code Implementation Reference (from nanoBragg.c, lines 3295-3345):
    ```c
    double *rotate(double *v, double *newv, double phix, double phiy, double phiz) {
        double rxx,rxy,rxz,ryx,ryy,ryz,rzx,rzy,rzz;
        double new_x,new_y,new_z,rotated_x,rotated_y,rotated_z;

        new_x=v[1];
        new_y=v[2];
        new_z=v[3];

        if(phix != 0){
            /* rotate around x axis */
            //rxx= 1;         rxy= 0;         rxz= 0;
            ryx= 0;         ryy= cos(phix); ryz=-sin(phix);
            rzx= 0;         rzy= sin(phix); rzz= cos(phix);

            rotated_x = new_x;
            rotated_y = new_y*ryy + new_z*ryz;
            rotated_z = new_y*rzy + new_z*rzz;
            new_x = rotated_x; new_y = rotated_y; new_z = rotated_z;
        }

        if(phiy != 0) {
            /* rotate around y axis */
            rxx= cos(phiy); rxy= 0;         rxz= sin(phiy);
            //ryx= 0;         ryy= 1;         ryz= 0;
            rzx=-sin(phiy); rzy= 0;         rzz= cos(phiy);

            rotated_x = new_x*rxx + new_y*rxy + new_z*rxz;
            rotated_y = new_y;
            rotated_z = new_x*rzx + new_y*rzy + new_z*rzz;
            new_x = rotated_x; new_y = rotated_y; new_z = rotated_z;
        }

        if(phiz != 0){
            /* rotate around z axis */
            rxx= cos(phiz); rxy=-sin(phiz); rxz= 0;
            ryx= sin(phiz); ryy= cos(phiz); ryz= 0;
            //rzx= 0;         rzy= 0;         rzz= 1;

            rotated_x = new_x*rxx + new_y*rxy ;
            rotated_y = new_x*ryx + new_y*ryy;
            rotated_z = new_z;
            new_x = rotated_x; new_y = rotated_y; new_z = rotated_z;
        }

        newv[1]=new_x;
        newv[2]=new_y;
        newv[3]=new_z;

        return newv;
    }
    ```

    Args:
        phi_x: Rotation angle around X-axis in radians
        phi_y: Rotation angle around Y-axis in radians
        phi_z: Rotation angle around Z-axis in radians

    Returns:
        torch.Tensor: 3x3 rotation matrix that applies rotations in XYZ order
    """
    # Extract device and dtype from input angles
    # Ensure all angles have the same dtype - convert to the highest precision dtype
    if hasattr(phi_x, "dtype") and hasattr(phi_y, "dtype") and hasattr(phi_z, "dtype"):
        # All are tensors
        dtype = torch.promote_types(
            torch.promote_types(phi_x.dtype, phi_y.dtype), phi_z.dtype
        )
        device = phi_x.device
        phi_x = phi_x.to(dtype=dtype)
        phi_y = phi_y.to(dtype=dtype)
        phi_z = phi_z.to(dtype=dtype)
    else:
        # Mixed or scalar inputs - default to float64
        device = torch.device("cpu")
        dtype = torch.float64
        if not isinstance(phi_x, torch.Tensor):
            phi_x = torch.tensor(phi_x, dtype=dtype, device=device)
        if not isinstance(phi_y, torch.Tensor):
            phi_y = torch.tensor(phi_y, dtype=dtype, device=device)
        if not isinstance(phi_z, torch.Tensor):
            phi_z = torch.tensor(phi_z, dtype=dtype, device=device)

    # Calculate sin and cos for all angles
    cos_x = torch.cos(phi_x)
    sin_x = torch.sin(phi_x)
    cos_y = torch.cos(phi_y)
    sin_y = torch.sin(phi_y)
    cos_z = torch.cos(phi_z)
    sin_z = torch.sin(phi_z)

    # Construct rotation matrix for X-axis rotation
    # Rx = [[1, 0, 0], [0, cos(x), -sin(x)], [0, sin(x), cos(x)]]
    Rx = torch.zeros(3, 3, device=device, dtype=dtype)
    Rx[0, 0] = 1.0
    Rx[1, 1] = cos_x
    Rx[1, 2] = -sin_x
    Rx[2, 1] = sin_x
    Rx[2, 2] = cos_x

    # Construct rotation matrix for Y-axis rotation
    # Ry = [[cos(y), 0, sin(y)], [0, 1, 0], [-sin(y), 0, cos(y)]]
    Ry = torch.zeros(3, 3, device=device, dtype=dtype)
    Ry[0, 0] = cos_y
    Ry[0, 2] = sin_y
    Ry[1, 1] = 1.0
    Ry[2, 0] = -sin_y
    Ry[2, 2] = cos_y

    # Construct rotation matrix for Z-axis rotation
    # Rz = [[cos(z), -sin(z), 0], [sin(z), cos(z), 0], [0, 0, 1]]
    Rz = torch.zeros(3, 3, device=device, dtype=dtype)
    Rz[0, 0] = cos_z
    Rz[0, 1] = -sin_z
    Rz[1, 0] = sin_z
    Rz[1, 1] = cos_z
    Rz[2, 2] = 1.0

    # Compose rotations in XYZ order: R = Rz @ Ry @ Rx
    # This means we first rotate by X, then Y, then Z
    R = torch.matmul(torch.matmul(Rz, Ry), Rx)

    return R
</file>

<file path="nanobrag_torch/utils/physics.py">
"""
Vectorized physics utilities for nanoBragg PyTorch implementation.

This module contains PyTorch implementations of physical models and
calculations from the original C code.
"""

import torch


def sincg(u: torch.Tensor, N: torch.Tensor) -> torch.Tensor:
    """
    Calculate Fourier transform of 1D grating (parallelepiped shape factor).

    Used for crystal shape modeling in the original C code.

    Args:
        u: Input tensor, pre-multiplied by π (e.g., π * h)
        N: Number of elements in grating (scalar or tensor)

    Returns:
        torch.Tensor: Shape factor values sin(Nu)/sin(u)
    """
    # Handle both scalar and tensor N - expand to broadcast with u
    if N.ndim == 0:
        N = N.expand_as(u)

    # Calculates sin(N*u)/sin(u), handling the u=0 case
    # Note: u is already pre-multiplied by π at the call site
    # Handle near-zero case to avoid numerical instability
    eps = 1e-10
    sin_u = torch.sin(u)
    # Use a small threshold to catch near-zero values
    is_near_zero = torch.abs(sin_u) < eps
    result = torch.where(is_near_zero, N, torch.sin(N * u) / sin_u)
    return result


def sinc3(x: torch.Tensor) -> torch.Tensor:
    """
    Calculate 3D Fourier transform of a sphere (spherical shape factor).

    This function is used for the round crystal shape model (`-round_xtal`).
    It provides an alternative to the `sincg` function for modeling the
    lattice/shape factor.

    C-Code Implementation Reference (from nanoBragg.c):

    Function Definition (lines 2341-2346):
    ```c
    /* Fourier transform of a sphere */
    double sinc3(double x) {
        if(x==0.0) return 1.0;

        return 3.0*(sin(x)/x-cos(x))/(x*x);
    }
    ```

    Usage in Main Loop (lines 3045-3054):
    ```c
                                    else
                                    {
                                        /* reciprocal-space distance */
                                        double dx_star = (h-h0)*a_star[1] + (k-k0)*b_star[1] + (l-l0)*c_star[1];
                                        double dy_star = (h-h0)*a_star[2] + (k-k0)*b_star[2] + (l-l0)*c_star[2];
                                        double dz_star = (h-h0)*a_star[3] + (k-k0)*b_star[3] + (l-l0)*c_star[3];
                                        rad_star_sqr = ( dx_star*dx_star + dy_star*dy_star + dz_star*dz_star )
                                                       *Na*Na*Nb*Nb*Nc*Nc;
                                    }
                                    if(xtal_shape == ROUND)
                                    {
                                       /* radius in hkl space, squared */
                                        hrad_sqr = (h-h0)*(h-h0)*Na*Na + (k-k0)*(k-k0)*Nb*Nb + (l-l0)*(l-l0)*Nc*Nc ;

                                         /* use sinc3 for elliptical xtal shape,
                                           correcting for sqrt of volume ratio between cube and sphere */
                                        F_latt = Na*Nb*Nc*0.723601254558268*sinc3(M_PI*sqrt( hrad_sqr * fudge ) );
                                    }
    ```
    """
    raise NotImplementedError("TODO: Port logic from nanoBragg.c for sinc3 function")


def polarization_factor(
    kahn_factor: torch.Tensor,
    incident: torch.Tensor,
    diffracted: torch.Tensor,
    axis: torch.Tensor,
) -> torch.Tensor:
    """
    Calculate the angle-dependent polarization correction factor.

    This function models how the scattered intensity is modulated by the
    polarization state of the incident beam and the scattering geometry.
    The implementation must be vectorized to calculate a unique correction
    factor for each pixel simultaneously.

    C-Code Implementation Reference (from nanoBragg.c):
    The C implementation combines a call site in the main loop with a
    dedicated helper function.

    Usage in Main Loop (lines 2983-2990):
    ```c
                                    /* we now have enough to fix the polarization factor */
                                    if (polar == 0.0 || oversample_polar)
                                    {
                                        /* need to compute polarization factor */
                                        polar = polarization_factor(polarization,incident,diffracted,polar_vector);
                                    }
    ```

    Function Definition (lines 3254-3290):
    ```c
    /* polarization factor */
    double polarization_factor(double kahn_factor, double *incident, double *diffracted, double *axis)
    {
        double cos2theta,cos2theta_sqr,sin2theta_sqr;
        double psi=0;
        double E_in[4];
        double B_in[4];
        double E_out[4];
        double B_out[4];

        unitize(incident,incident);
        unitize(diffracted,diffracted);
        unitize(axis,axis);

        /* component of diffracted unit vector along incident beam unit vector */
        cos2theta = dot_product(incident,diffracted);
        cos2theta_sqr = cos2theta*cos2theta;
        sin2theta_sqr = 1-cos2theta_sqr;

        if(kahn_factor != 0.0){
            /* tricky bit here is deciding which direciton the E-vector lies in for each source
               here we assume it is closest to the "axis" defined above */

            /* cross product to get "vertical" axis that is orthogonal to the cannonical "polarization" */
            cross_product(axis,incident,B_in);
            /* make it a unit vector */
            unitize(B_in,B_in);

            /* cross product with incident beam to get E-vector direction */
            cross_product(incident,B_in,E_in);
            /* make it a unit vector */
            unitize(E_in,E_in);

            /* get components of diffracted ray projected onto the E-B plane */
            E_out[0] = dot_product(diffracted,E_in);
            B_out[0] = dot_product(diffracted,B_in);

            /* compute the angle of the diffracted ray projected onto the incident E-B plane */
            psi = -atan2(B_out[0],E_out[0]);
        }

        /* correction for polarized incident beam */
        return 0.5*(1.0 + cos2theta_sqr - kahn_factor*cos(2*psi)*sin2theta_sqr);
    }
    ```

    Args:
        kahn_factor: Polarization factor (0 to 1).
        incident: Incident beam unit vectors.
        diffracted: Diffracted beam unit vectors.
        axis: Polarization axis unit vectors.

    Returns:
        Tensor of polarization correction factors.
    """
    raise NotImplementedError(
        "TODO: Port logic from nanoBragg.c for polarization_factor"
    )
</file>

<file path="nanobrag_torch/utils/units.py">
"""
Unit conversion utilities for nanoBragg PyTorch implementation.

This module provides functions to convert between user-friendly units (e.g., mm)
and the internal unit system (Angstroms for length, radians for angles).
All functions preserve tensor properties and gradients.
"""

import torch
from typing import Union


def mm_to_angstroms(value: Union[float, torch.Tensor]) -> Union[float, torch.Tensor]:
    """
    Convert millimeters to Angstroms.

    Args:
        value: Value in millimeters

    Returns:
        Value in Angstroms (1 mm = 10,000,000 Å)
    """
    return value * 1e7


def meters_to_angstroms(
    value: Union[float, torch.Tensor],
) -> Union[float, torch.Tensor]:
    """
    Convert meters to Angstroms.

    Args:
        value: Value in meters

    Returns:
        Value in Angstroms (1 m = 1e10 Å)
    """
    return value * 1e10


def degrees_to_radians(value: Union[float, torch.Tensor]) -> Union[float, torch.Tensor]:
    """
    Convert degrees to radians.

    Args:
        value: Angle in degrees

    Returns:
        Angle in radians
    """
    if isinstance(value, torch.Tensor):
        return torch.deg2rad(value)
    else:
        # For scalar values, use torch's function but return scalar
        return torch.deg2rad(torch.tensor(value)).item()


def angstroms_to_mm(value: Union[float, torch.Tensor]) -> Union[float, torch.Tensor]:
    """
    Convert Angstroms to millimeters.

    Args:
        value: Value in Angstroms

    Returns:
        Value in millimeters (1 Å = 1e-7 mm)
    """
    return value * 1e-7


def angstroms_to_meters(
    value: Union[float, torch.Tensor],
) -> Union[float, torch.Tensor]:
    """
    Convert Angstroms to meters.

    Args:
        value: Value in Angstroms

    Returns:
        Value in meters (1 Å = 1e-10 m)
    """
    return value * 1e-10


def radians_to_degrees(value: Union[float, torch.Tensor]) -> Union[float, torch.Tensor]:
    """
    Convert radians to degrees.

    Args:
        value: Angle in radians

    Returns:
        Angle in degrees
    """
    if isinstance(value, torch.Tensor):
        return torch.rad2deg(value)
    else:
        # For scalar values, use torch's function but return scalar
        return torch.rad2deg(torch.tensor(value)).item()
</file>

<file path="nanobrag_torch/__init__.py">
"""
nanoBragg PyTorch Implementation

A PyTorch-based diffraction simulator for nanocrystals, providing GPU acceleration
and automatic differentiation capabilities for the original nanoBragg C code.
"""

__version__ = "0.1.0"
</file>

<file path="nanobrag_torch/config.py">
"""
Configuration dataclasses for nanoBragg PyTorch implementation.

This module defines strongly-typed configuration objects that are intended to
replace the large set of local variables and command-line parsing logic found
in the original C main() function. Each dataclass will correspond to a physical
component of the simulation (Crystal, Detector, Beam).

C-Code Implementation Reference (from nanoBragg.c):
The configuration is currently handled by a large argument-parsing loop
in main(). The future dataclasses will encapsulate the variables set
in this block.

Representative examples from nanoBragg.c (lines 506-1101):

// Crystal Parameters
if(0==strcmp(argv[i], "-N") && (argc > (i+1)))
{
    Na = Nb = Nc = atoi(argv[i+1]);
    continue;
}
if(strstr(argv[i], "-cell") && (argc > (i+1)))
{
    // ...
    a[0] = atof(argv[i+1]);
    // ...
    alpha = atof(argv[i+4])/RTD;
    // ...
}
if((strstr(argv[i], "-mosaic") && ... ) && (argc > (i+1)))
{
    mosaic_spread = atof(argv[i+1])/RTD;
}

// Beam Parameters
if((strstr(argv[i], "-lambda") || strstr(argv[i], "-wave")) && (argc > (i+1)))
{
    lambda0 = atof(argv[i+1])/1.0e10;
}
if(strstr(argv[i], "-fluence") && (argc > (i+1)))
{
    fluence = atof(argv[i+1]);
}

// Detector Parameters
if(strstr(argv[i], "-distance") && (argc > (i+1)))
{
    distance = atof(argv[i+1])/1000.0;
    detector_pivot = BEAM;
}
if(strstr(argv[i], "-pixel") && (argc > (i+1)))
{
    pixel_size = atof(argv[i+1])/1000.0;
}
"""

from dataclasses import dataclass
from enum import Enum
from typing import Optional, Tuple, Union

import torch


class DetectorConvention(Enum):
    """Detector coordinate system convention."""

    MOSFLM = "mosflm"
    XDS = "xds"


class DetectorPivot(Enum):
    """Detector rotation pivot mode."""

    BEAM = "beam"
    SAMPLE = "sample"


@dataclass
class CrystalConfig:
    """Configuration for crystal properties and orientation.

    This configuration class now supports general triclinic unit cells with all
    six cell parameters (a, b, c, α, β, γ). All cell parameters can accept
    either scalar values or PyTorch tensors, enabling gradient-based optimization
    of crystal parameters from diffraction data.
    """

    # Unit cell parameters (in Angstroms and degrees)
    # These can be either float values or torch.Tensor for differentiability
    cell_a: float = 100.0
    cell_b: float = 100.0
    cell_c: float = 100.0
    cell_alpha: float = 90.0
    cell_beta: float = 90.0
    cell_gamma: float = 90.0

    # Static misset rotation (applied once at initialization)
    # Static crystal orientation angles (degrees) applied as XYZ rotations to reciprocal space vectors
    misset_deg: Tuple[float, float, float] = (0.0, 0.0, 0.0)

    # Spindle rotation parameters
    phi_start_deg: float = 0.0
    osc_range_deg: float = 0.0
    phi_steps: int = 1
    spindle_axis: Tuple[float, float, float] = (0.0, 0.0, 1.0)

    # Mosaicity parameters
    mosaic_spread_deg: float = 0.0
    mosaic_domains: int = 1
    mosaic_seed: Optional[int] = None

    # Crystal size (number of unit cells in each direction)
    N_cells: Tuple[int, int, int] = (5, 5, 5)

    # Structure factor parameters
    default_F: float = 100.0  # Default structure factor magnitude


@dataclass
class DetectorConfig:
    """Configuration for detector geometry and properties.

    This configuration class defines all parameters needed to specify detector
    geometry, position, and orientation. All distance/size parameters are in
    user-friendly millimeter units and will be converted to meters internally.
    All angle parameters are in degrees and will be converted to radians internally.
    """

    # Basic geometry (user units: mm)
    distance_mm: Union[float, torch.Tensor] = 100.0
    pixel_size_mm: Union[float, torch.Tensor] = 0.1

    # Detector dimensions
    spixels: int = 1024  # slow axis pixels
    fpixels: int = 1024  # fast axis pixels

    # Beam center (mm from detector origin)
    beam_center_s: Union[float, torch.Tensor] = 51.2  # slow axis
    beam_center_f: Union[float, torch.Tensor] = 51.2  # fast axis

    # Detector rotations (degrees)
    detector_rotx_deg: Union[float, torch.Tensor] = 0.0
    detector_roty_deg: Union[float, torch.Tensor] = 0.0
    detector_rotz_deg: Union[float, torch.Tensor] = 0.0

    # Two-theta rotation (degrees)
    detector_twotheta_deg: Union[float, torch.Tensor] = 0.0
    twotheta_axis: Optional[torch.Tensor] = None  # Will default based on convention

    # Convention and pivot
    detector_convention: DetectorConvention = DetectorConvention.MOSFLM
    detector_pivot: DetectorPivot = DetectorPivot.SAMPLE

    # Sampling
    oversample: int = 1

    def __post_init__(self):
        """Validate configuration and set defaults."""
        # Set default twotheta axis if not provided
        if self.twotheta_axis is None:
            # Default depends on detector convention
            if self.detector_convention == DetectorConvention.MOSFLM:
                # MOSFLM: use +Z for 2θ; flip sign here if your logs show the opposite
                self.twotheta_axis = torch.tensor([0.0, 0.0, 1.0])
            elif self.detector_convention == DetectorConvention.XDS:
                # XDS convention: twotheta axis is [1, 0, 0] (C-code line 1221)
                self.twotheta_axis = torch.tensor([1.0, 0.0, 0.0])
            else:
                # Default fallback
                self.twotheta_axis = torch.tensor([0.0, 1.0, 0.0])

        # Validate pixel counts
        if self.spixels <= 0 or self.fpixels <= 0:
            raise ValueError("Pixel counts must be positive")

        # Validate distance and pixel size
        if isinstance(self.distance_mm, (int, float)):
            if self.distance_mm <= 0:
                raise ValueError("Distance must be positive")

        if isinstance(self.pixel_size_mm, (int, float)):
            if self.pixel_size_mm <= 0:
                raise ValueError("Pixel size must be positive")

        # Validate oversample
        if self.oversample < 1:
            raise ValueError("Oversample must be at least 1")


@dataclass
class BeamConfig:
    """Configuration for X-ray beam properties.

    Simplified implementation for detector geometry testing.
    """

    # Basic beam properties
    wavelength_A: float = 6.2  # X-ray wavelength in Angstroms

    # Source geometry (simplified)
    N_source_points: int = 1  # Number of source points for beam divergence
    source_distance_mm: float = 10000.0  # Distance from source to sample (mm)
    source_size_mm: float = 0.0  # Source size (0 = point source)

    # Beam polarization and flux (simplified)
    polarization_factor: float = 1.0  # Polarization correction factor
    flux: float = 1e12  # Photons per second (simplified)
</file>

<file path="nanobrag_torch/simulator.py">
"""
Main Simulator class for nanoBragg PyTorch implementation.

This module orchestrates the entire diffraction simulation, taking Crystal and
Detector objects as input and producing the final diffraction pattern.
"""

from typing import Optional

import torch

from .config import BeamConfig, CrystalConfig
from .models.crystal import Crystal
from .models.detector import Detector
from .utils.geometry import dot_product
from .utils.physics import sincg


class Simulator:
    """
    Main diffraction simulator class.

    Implements the vectorized PyTorch equivalent of the nested loops in the
    original nanoBragg.c main simulation loop.
    """

    def __init__(
        self,
        crystal: Crystal,
        detector: Detector,
        crystal_config: Optional[CrystalConfig] = None,
        beam_config: Optional[BeamConfig] = None,
        device=None,
        dtype=torch.float64,
    ):
        """
        Initialize simulator with crystal, detector, and configurations.

        Args:
            crystal: Crystal object containing unit cell and structure factors
            detector: Detector object with geometry parameters
            crystal_config: Configuration for crystal rotation parameters (phi, mosaic)
            beam_config: Beam configuration (optional, for future use)
            device: PyTorch device (cpu/cuda)
            dtype: PyTorch data type
        """
        self.crystal = crystal
        self.detector = detector
        self.crystal_config = (
            crystal_config if crystal_config is not None else CrystalConfig()
        )
        self.device = device if device is not None else torch.device("cpu")
        self.dtype = dtype

        # Hard-coded simple_cubic beam parameters (from golden test case)
        # Incident beam direction: [1, 0, 0] (from log: INCIDENT_BEAM_DIRECTION= 1 0 0)
        # Wave: 1 Angstrom
        self.incident_beam_direction = torch.tensor(
            [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
        )
        self.wavelength = 6.2  # Angstroms (matches debug script and C code test case)

        # Physical constants (from nanoBragg.c ~line 240)
        self.r_e_sqr = (
            7.94079248018965e-30  # classical electron radius squared (meters squared)
        )
        self.fluence = (
            125932015286227086360700780544.0  # photons per square meter (C default)
        )
        self.polarization = 1.0  # unpolarized beam

    def run(
        self,
        pixel_batch_size: Optional[int] = None,
        override_a_star: Optional[torch.Tensor] = None,
    ) -> torch.Tensor:
        """
        Run the diffraction simulation with crystal rotation and mosaicity.

        This method vectorizes the simulation over all detector pixels, phi angles,
        and mosaic domains. It integrates contributions from all crystal orientations
        to produce the final diffraction pattern.

        Important: This implementation uses the full Miller indices (h, k, l) for the
        lattice shape factor calculation, not the fractional part (h-h0). This correctly
        models the crystal shape transform and is consistent with the physics of
        diffraction from a finite crystal.

        C-Code Implementation Reference (from nanoBragg.c, lines 2993-3151):
        The vectorized implementation replaces these nested loops. The outer `source`
        loop is future work for handling beam divergence and dispersion.

        ```c
                        /* loop over sources now */
                        for(source=0;source<sources;++source){

                            /* retrieve stuff from cache */
                            incident[1] = -source_X[source];
                            incident[2] = -source_Y[source];
                            incident[3] = -source_Z[source];
                            lambda = source_lambda[source];

                            /* ... scattering vector calculation ... */

                            /* sweep over phi angles */
                            for(phi_tic = 0; phi_tic < phisteps; ++phi_tic)
                            {
                                /* ... crystal rotation ... */

                                /* enumerate mosaic domains */
                                for(mos_tic=0;mos_tic<mosaic_domains;++mos_tic)
                                {
                                    /* ... mosaic rotation ... */
                                    /* ... h,k,l calculation ... */
                                    /* ... F_cell and F_latt calculation ... */

                                    /* convert amplitudes into intensity (photons per steradian) */
                                    I += F_cell*F_cell*F_latt*F_latt;
                                }
                            }
                        }
        ```

        Args:
            pixel_batch_size: Optional batching for memory management.
            override_a_star: Optional override for the a_star vector for testing.

        Returns:
            torch.Tensor: Final diffraction image with shape (spixels, fpixels).
        """
        # Get pixel coordinates (spixels, fpixels, 3) in meters
        pixel_coords_meters = self.detector.get_pixel_coords()
        # Convert to Angstroms for physics calculations
        pixel_coords_angstroms = pixel_coords_meters * 1e10

        # Calculate scattering vectors for each pixel
        # The C code calculates scattering vector as the difference between
        # unit vectors pointing to the pixel and the incident direction

        # Diffracted beam unit vector (from origin to pixel)
        pixel_magnitudes = torch.sqrt(
            torch.sum(
                pixel_coords_angstroms * pixel_coords_angstroms, dim=-1, keepdim=True
            )
        )
        diffracted_beam_unit = pixel_coords_angstroms / pixel_magnitudes

        # Incident beam unit vector [1, 0, 0]
        incident_beam_unit = self.incident_beam_direction.expand_as(
            diffracted_beam_unit
        )

        # Scattering vector using crystallographic convention (nanoBragg.c style)
        # S = (s_out - s_in) / λ where s_out, s_in are unit vectors
        scattering_vector = (
            diffracted_beam_unit - incident_beam_unit
        ) / self.wavelength

        # Get rotated lattice vectors for all phi steps and mosaic domains
        # Shape: (N_phi, N_mos, 3)
        if override_a_star is None:
            (rot_a, rot_b, rot_c), (rot_a_star, rot_b_star, rot_c_star) = (
                self.crystal.get_rotated_real_vectors(self.crystal_config)
            )
        else:
            # For gradient testing with override, use single orientation
            rot_a = override_a_star.view(1, 1, 3)
            rot_b = self.crystal.b.view(1, 1, 3)
            rot_c = self.crystal.c.view(1, 1, 3)
            rot_a_star = override_a_star.view(1, 1, 3)
            rot_b_star = self.crystal.b_star.view(1, 1, 3)
            rot_c_star = self.crystal.c_star.view(1, 1, 3)

        # Broadcast scattering vector to be compatible with rotation dimensions
        # scattering_vector: (S, F, 3) -> (S, F, 1, 1, 3)
        # rot_a: (N_phi, N_mos, 3) -> (1, 1, N_phi, N_mos, 3)
        scattering_broadcast = scattering_vector.unsqueeze(-2).unsqueeze(-2)
        rot_a_broadcast = rot_a.unsqueeze(0).unsqueeze(0)
        rot_b_broadcast = rot_b.unsqueeze(0).unsqueeze(0)
        rot_c_broadcast = rot_c.unsqueeze(0).unsqueeze(0)

        # Calculate dimensionless Miller indices using nanoBragg.c convention
        # nanoBragg.c uses: h = S·a where S is the scattering vector and a is real-space vector
        # IMPORTANT: The real-space vectors a, b, c have already incorporated any misset rotation
        # through the Crystal.compute_cell_tensors() method, which ensures consistency with C-code
        # Result shape: (S, F, N_phi, N_mos)
        h = dot_product(scattering_broadcast, rot_a_broadcast)
        k = dot_product(scattering_broadcast, rot_b_broadcast)
        l = dot_product(scattering_broadcast, rot_c_broadcast)  # noqa: E741

        # Find nearest integer Miller indices for structure factor lookup
        h0 = torch.round(h)
        k0 = torch.round(k)
        l0 = torch.round(l)

        # Look up structure factors F_cell using integer indices
        # TODO: Future implementation must calculate |h*a* + k*b* + l*c*| <= 1/d_min
        # for correct resolution cutoffs in triclinic cells
        F_cell = self.crystal.get_structure_factor(h0, k0, l0)

        # Calculate lattice structure factor F_latt using fractional part (h-h0)
        # CORRECT: Use fractional part (h-h0, k-k0, l-l0) to match C-code behavior
        # The sincg function expects its input pre-multiplied by π
        F_latt_a = sincg(torch.pi * (h - h0), self.crystal.N_cells_a)
        F_latt_b = sincg(torch.pi * (k - k0), self.crystal.N_cells_b)
        F_latt_c = sincg(torch.pi * (l - l0), self.crystal.N_cells_c)
        F_latt = F_latt_a * F_latt_b * F_latt_c

        # Calculate total structure factor and intensity
        # Shape: (S, F, N_phi, N_mos)
        F_total = F_cell * F_latt
        intensity = F_total * F_total  # |F|^2

        # Integrate over phi steps and mosaic domains
        # Sum across the last two dimensions to get final 2D image
        integrated_intensity = torch.sum(intensity, dim=(-2, -1))

        # Apply physical scaling factors (from nanoBragg.c ~line 3050)
        # Solid angle correction, converting all units to meters for calculation
        airpath = pixel_magnitudes.squeeze(-1)  # Remove last dimension for broadcasting
        airpath_m = airpath * 1e-10  # Å to meters
        close_distance_m = self.detector.distance  # Already in meters
        pixel_size_m = self.detector.pixel_size  # Already in meters

        omega_pixel = (
            (pixel_size_m * pixel_size_m)
            / (airpath_m * airpath_m)
            * close_distance_m
            / airpath_m
        )

        # Final intensity with all physical constants in meters
        # Units: [dimensionless] × [steradians] × [m²] × [photons/m²] × [dimensionless] = [photons·steradians]
        physical_intensity = (
            integrated_intensity
            * self.r_e_sqr
            * self.fluence
            * self.polarization
            * omega_pixel
        )

        return physical_intensity
</file>

<file path="nanobrag_torch.egg-info/dependency_links.txt">

</file>

<file path="nanobrag_torch.egg-info/PKG-INFO">
Metadata-Version: 2.4
Name: nanobrag-torch
Version: 0.1.0
Summary: PyTorch implementation of nanoBragg diffraction simulator
Author: nanoBragg Team
License-File: LICENSE
Requires-Dist: torch>=2.3
Requires-Dist: fabio
Requires-Dist: numpy
Requires-Dist: pytest
Requires-Dist: matplotlib
Provides-Extra: dev
Requires-Dist: black; extra == "dev"
Requires-Dist: ruff; extra == "dev"
Requires-Dist: isort; extra == "dev"
Dynamic: license-file
</file>

<file path="nanobrag_torch.egg-info/requires.txt">
torch>=2.3
fabio
numpy
pytest
matplotlib

[dev]
black
ruff
isort
</file>

<file path="nanobrag_torch.egg-info/SOURCES.txt">
LICENSE
README.md
pyproject.toml
src/nanobrag_torch/__init__.py
src/nanobrag_torch/config.py
src/nanobrag_torch/simulator.py
src/nanobrag_torch.egg-info/PKG-INFO
src/nanobrag_torch.egg-info/SOURCES.txt
src/nanobrag_torch.egg-info/dependency_links.txt
src/nanobrag_torch.egg-info/requires.txt
src/nanobrag_torch.egg-info/top_level.txt
src/nanobrag_torch/models/__init__.py
src/nanobrag_torch/models/crystal.py
src/nanobrag_torch/models/detector.py
src/nanobrag_torch/utils/__init__.py
src/nanobrag_torch/utils/geometry.py
src/nanobrag_torch/utils/physics.py
tests/test_crystal_geometry.py
tests/test_gradients.py
tests/test_suite.py
</file>

<file path="nanobrag_torch.egg-info/top_level.txt">
nanobrag_torch
</file>

</files>
