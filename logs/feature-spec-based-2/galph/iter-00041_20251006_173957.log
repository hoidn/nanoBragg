Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=41
To github.com:hoidn/nanoBragg.git
   3750424..b741b06  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T17:40:02] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T17:40:02] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 


Debugging Items — Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‑line rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for this turn.
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
Header:
- Summary: <one‑sentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
  - Note: When the Phase is Evidence, you must not execute tests; any pytest command included here is provided for Ralph’s subsequent loop.
<Do Now guidelines>
Phase Gate (Evidence): If the active plan phase is Evidence, do not run pytest at all (including collection). Limit evidence gathering to non-test probes and command‑line tooling (e.g., scripts/validation/*, minimal parity CLIs). Do not include runnable tests in this loop.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T17:40:05] thinking

**Executing git pull with timeout**
[2025-10-06T17:40:07] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:10] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.32s:
Already up to date.
[2025-10-06T17:40:10] tokens used: 12,889

[2025-10-06T17:40:12] thinking

**Preparing to read galph_memory.md**
[2025-10-06T17:40:13] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:13] bash -lc 'cat galph_memory.md' succeeded in 715ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-06T17:40:13] tokens used: 13,074

[2025-10-06T17:40:18] thinking

**Considering documentation review approach**
[2025-10-06T17:40:19] exec bash -lc "sed -n '1,160p' docs/index.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:19] bash -lc "sed -n '1,160p' docs/index.md" succeeded in 684ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T17:40:19] tokens used: 16,837

[2025-10-06T17:40:22] thinking

**Requesting specifications**
[2025-10-06T17:40:23] exec bash -lc "sed -n '1,200p' specs/spec-a.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:24] bash -lc "sed -n '1,200p' specs/spec-a.md" succeeded in 680ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T17:40:24] tokens used: 19,041

[2025-10-06T17:40:27] thinking

**Considering architecture**
[2025-10-06T17:40:29] exec bash -lc "sed -n '1,200p' arch.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:29] bash -lc "sed -n '1,200p' arch.md" succeeded in 712ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T17:40:29] tokens used: 19,411

[2025-10-06T17:40:32] thinking

**Requesting config_map documentation**
[2025-10-06T17:40:32] exec bash -lc "sed -n '1,200p' docs/development/c_to_pytorch_config_map.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:33] bash -lc "sed -n '1,200p' docs/development/c_to_pytorch_config_map.md" succeeded in 667ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T17:40:33] tokens used: 21,932

[2025-10-06T17:40:35] thinking

**Identifying need for debugging documentation**
[2025-10-06T17:40:36] exec bash -lc "sed -n '1,200p' docs/debugging/debugging.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:37] bash -lc "sed -n '1,200p' docs/debugging/debugging.md" succeeded in 659ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T17:40:37] tokens used: 24,585

[2025-10-06T17:40:42] thinking

**Planning to review docs/fix_plan.md**
[2025-10-06T17:40:46] exec bash -lc "sed -n '1,200p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:46] bash -lc "sed -n '1,200p' docs/fix_plan.md" succeeded in 742ms:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A–C) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2–B4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1–A3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ✅ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
| [CLI-DTYPE-002](#cli-dtype-002-cli-dtype-parity) | CLI dtype parity | High | in_progress |
[2025-10-06T17:40:46] tokens used: 27,336

[2025-10-06T17:40:48] thinking

**Pausing to assess documentation needs**
[2025-10-06T17:40:49] exec bash -lc "sed -n '1,200p' docs/development/testing_strategy.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:50] bash -lc "sed -n '1,200p' docs/development/testing_strategy.md" succeeded in 737ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T17:40:50] tokens used: 30,309

[2025-10-06T17:40:53] thinking

**Preparing for codebase analysis**
[2025-10-06T17:40:54] exec bash -lc "sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:55] bash -lc "sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" succeeded in 711ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
- Documentation anchors for this focus:
  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
  * `docs/development/testing_strategy.md` — authoritative pytest/trace commands for CLI parity evidence.

### Phase A — Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
Prereqs: Ability to run instrumented C binary via `NB_C_BIN` and collect traces.
Exit Criteria: Documented parity notes under `reports/2025-10-cli-flags/phase_a/` with explicit decisions on unit conversions and noise toggle ordering.

[2025-10-06T17:40:55] tokens used: 32,898

[2025-10-06T17:40:57] thinking

**Checking alternative plans**
[2025-10-06T17:40:57] exec bash -lc 'ls plans/active' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:40:58] bash -lc 'ls plans/active' succeeded in 662ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T17:40:58] tokens used: 36,692

[2025-10-06T17:41:00] thinking

**Reviewing vectorization plan**
[2025-10-06T17:41:00] exec bash -lc "sed -n '1,200p' plans/active/vectorization.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:41:01] bash -lc "sed -n '1,200p' plans/active/vectorization.md" succeeded in 681ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B — Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T17:41:01] tokens used: 36,925

[2025-10-06T17:41:10] thinking

**Planning deep codebase analysis**

I’m gathering info about the repo state and reviewing the existing docs and fix_plan to understand the long-term goals around CLI parity and vectorization. My next steps include analyzing current scaling issues and forming hypotheses for debugging, then flipping a coin to decide the following action.
[2025-10-06T17:41:12] exec bash -lc "python - <<'PY'
import random
print('heads' if random.random() < 0.5 else 'tails')
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:41:13] bash -lc "python - <<'PY'
import random
print('heads' if random.random() < 0.5 else 'tails')
PY" succeeded in 853ms:
tails
[2025-10-06T17:41:13] tokens used: 39,766

[2025-10-06T17:41:20] thinking

**Deciding next steps after coin toss**
[2025-10-06T17:41:21] exec bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:41:22] bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' succeeded in 743ms:
21:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
448:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
[2025-10-06T17:41:22] tokens used: 40,203
[2025-10-06T17:41:24] exec bash -lc "sed -n '448,640p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:41:25] bash -lc "sed -n '448,640p' docs/fix_plan.md" succeeded in 699ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A-H complete; polarization Phase I pending)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
[2025-10-06T17:41:25] tokens used: 41,232
[2025-10-06T17:42:57] stream error: stream disconnected before completion: Transport error: error decoding response body; retrying 1/5 in 191ms…

[2025-10-06T17:43:04] thinking

**Evaluating need for plan update**
[2025-10-06T17:43:05] exec bash -lc 'rg -n "Phase H" plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:43:06] bash -lc 'rg -n "Phase H" plans/active/cli-noise-pix0/plan.md' succeeded in 983ms:
5:- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
9:- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
97:| G3 | Trace verification + parity rerun | [D] | ✅ 2025-10-06 Attempt #18 (ralph). Fixed MOSFLM matrix transpose bug (`src/nanobrag_torch/io/mosflm.py:88`). Reciprocal vectors now match C exactly (9/9 components to 16 decimals). Miller indices match: (2,2,-13). F_cell perfect match: 300.58. Real vectors within 0.05Å (<0.2% error). Artifacts: `reports/2025-10-cli-flags/phase_g/trace_summary_orientation_fixed.md`, `traces/trace_c.log`, `traces/trace_py_fixed.log`. Intensity parity still divergent (deferred to Phase H polarization). |
99:### Phase H — Lattice Structure Factor Alignment
109:| H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
118:### Phase H5 — Custom Vector Pix0 Override Parity
120:Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
127:| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
[2025-10-06T17:43:06] tokens used: 42,339

[2025-10-06T17:43:28] thinking

**Assessing plan updates and next steps**

I’m reviewing whether existing plans for CLI parity and vectorization need updates based on new insights and long-term goals. I’ll weigh if task details—especially for K2, K3, and tricubic interpolation—require clarification or expansion, or if a new plan is necessary, all while considering instructions to avoid unnecessary changes.
[2025-10-06T17:43:29] exec bash -lc 'rg -n "VECTOR-TRICUBIC-001" docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:43:30] bash -lc 'rg -n "VECTOR-TRICUBIC-001" docs/fix_plan.md' succeeded in 884ms:
19:| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
1120:## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
[2025-10-06T17:43:30] tokens used: 44,355
[2025-10-06T17:43:38] exec bash -lc "sed -n '1120,1340p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:43:38] bash -lc "sed -n '1120,1340p' docs/fix_plan.md" succeeded in 703ms:
## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
- Spec/AT: specs/spec-a-core.md §4 (structure factor sampling), specs/spec-a-parallel.md §2.3 (tricubic acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4 (vectorization strategy), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, nanoBragg.c lines 2604–3278 (polin3/polin2/polint) and 3375–3450 (detector absorption loop).
- Priority: High
- Status: in_planning (Phase A evidence outstanding)
- Owner/Date: galph/2025-10-17
- Plan Reference: `plans/active/vectorization.md`
- Reproduction (C & PyTorch):
  * PyTorch baseline tests: `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py tests/test_at_abs_001.py -v`
  * Optional microbenchmarks (to be created per plan Phase A): `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/sample_tricubic_baseline.py`
  * Shapes/ROI: 256² & 512² detectors for microbench; oversample 1; structure-factor grid enabling tricubic.
- First Divergence (if known): Current tricubic path drops to nearest-neighbour fallback for batched pixel grids, emitting warnings and forfeiting accuracy/performance; detector absorption still loops over `thicksteps`, preventing full vectorization and creating hotspots in profiler traces (see reports/benchmarks/20250930-165726-compile-cache/analysis.md).
- Next Actions:
  1. Execute plan Phase A tasks A1–A3: author the reusable `scripts/benchmarks/tricubic_baseline.py` and `absorption_baseline.py` harnesses, capture pytest + timing artifacts under `reports/2025-10-vectorization/phase_a/`, and record Attempt #1 in this entry.
  2. Complete Phase B design memo (tensor shapes, broadcasting, gradients) before editing code; update this item with design references (`phase_b/design_notes.md`).
  3. Prioritise Phase C/D implementation work on tricubic interpolation, followed by Phase E parity/perf validation. Detector absorption vectorization (Phase F) follows once tricubic work is stable.
- Attempts History:
  * (pending) — Capture Phase A baseline artifacts and update this log.
- Risks/Assumptions: Must maintain differentiability (no `.item()`, no `torch.linspace` with tensor bounds), preserve device/dtype neutrality (CPU/CUDA parity), and obey Protected Assets rule (all new scripts under `scripts/benchmarks/`). Large tensor indexing may increase memory pressure; ensure ROI caching still works.
- Exit Criteria (quote thresholds from spec):
  * specs/spec-a-parallel.md §2.3 tricubic acceptance tests run without warnings and match C parity within documented tolerances (corr≥0.9995, ≤1e-12 structural duality where applicable).
[2025-10-06T17:43:38] tokens used: 45,511

[2025-10-06T17:43:59] thinking

**Evaluating need for plan update**
[2025-10-06T17:44:00] exec bash -lc 'git log -5 --oneline --decorate' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:44:01] bash -lc 'git log -5 --oneline --decorate' succeeded in 948ms:
b741b06 (HEAD -> feature/spec-based-2, origin/feature/spec-based-2) [SYNC i=41] actor=galph status=running
3750424 [SYNC i=41] actor=ralph → next=galph status=ok ralph_commit=bf9925b
bf9925b CLI-FLAGS-003 H5c trace refresh
09adbe3 [SYNC i=40] actor=ralph status=running
2ba34a4 [SYNC i=40] actor=galph → next=ralph status=ok galph_commit=82cd893
[2025-10-06T17:44:01] tokens used: 48,372

[2025-10-06T17:44:04] thinking

**Reviewing latest commit changes**
[2025-10-06T17:44:05] exec bash -lc 'git show bf9925b --stat' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:44:05] bash -lc 'git show bf9925b --stat' succeeded in 724ms:
commit bf9925b17713ea5bd8c6be63c10c4b35f4feb139
Author: ollie <ohoidn>
Date:   Mon Oct 6 10:38:55 2025 -0700

    CLI-FLAGS-003 H5c trace refresh
    
    Evidence: Attempt #35 (Phase H5c — Post-Attempt #33 trace capture)
    
    Critical finding: Attempt #33's beam-center mm→m conversion had NO impact on pix0 calculation.
    Pix0 deltas identical to 2025-10-22 baseline, confirming the unit fix targeted a different code path.
    
    Pix0 Parity Metrics:
    - ΔF = -1136.4 μm (FAIL: exceeds <50 μm threshold)
    - ΔS = +139.3 μm (FAIL: exceeds threshold)
    - ΔO = -5.6 μm (PASS: within threshold)
    - Magnitude Δ = 1.145 mm
    
    Basis vectors: fdet/sdet match C exactly (orientation confirmed correct)
    
    Hypothesis: _calculate_pix0_vector() has separate unit conversion or pivot-mode logic error
[2025-10-06T17:44:05] tokens used: 48,667

[2025-10-06T17:44:11] thinking

**Verifying plan update after H5c commit**
[2025-10-06T17:44:12] exec bash -lc 'rg "H5c" -n plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:44:13] bash -lc 'rg "H5c" -n plans/active/cli-noise-pix0/plan.md' succeeded in 762ms:
7:- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
127:| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
162:| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
[2025-10-06T17:44:13] tokens used: 49,783

[2025-10-06T17:44:41] thinking

**Updating plan to add Phase H6 for pix0 issues**

I'll mark Phase H5c as in progress since the attempt ran but failed to fix pix0 parity, then draft plan updates to include a new Phase H6 focused on detailed instrumentation to isolate pix0 divergence. This involves outlining new tasks for tracing in C and PyTorch, updating the plan and fix_plan docs with clear task tables and references, and reviewing relevant docs like `architecture/detector.md` to ensure the plan aligns with specifications.
[2025-10-06T17:44:43] exec bash -lc 'rg -n "pix0" docs/architecture/detector.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:44:44] bash -lc 'rg -n "pix0" docs/architecture/detector.md' succeeded in 890ms:
35:## 5. Logic Flow: `pix0_vector` Calculation
37:The calculation of the detector's origin vector (`pix0_vector`) depends on the `detector_pivot` mode:
42:    B -- BEAM --> C["Calculate pix0_vector using BEAM formula<br/>(pivots around beam spot on detector)"];
43:    B -- SAMPLE --> D["Calculate pix0_vector using SAMPLE formula<br/>(pivots around sample position)"];
44:    C --> E[pix0_vector = -Fbeam*fdet - Sbeam*sdet + distance*beam_vec];
45:    D --> F[pix0_vector = detector_origin + pixel_offsets];
53:pix0_vector = -Fbeam * fdet_vec - Sbeam * sdet_vec + distance * beam_vector
64:pix0_vector = detector_origin + s_offset * sdet_vec + f_offset * fdet_vec
86:- `pix0_vector` changes
209:2. **Pixel Coordinate Consistency:** Check `pixel[0,0] == pix0_vector`
[2025-10-06T17:44:44] tokens used: 51,768
[2025-10-06T17:44:46] exec bash -lc "sed -n '35,120p' docs/architecture/detector.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:44:47] bash -lc "sed -n '35,120p' docs/architecture/detector.md" succeeded in 723ms:
## 5. Logic Flow: `pix0_vector` Calculation

The calculation of the detector's origin vector (`pix0_vector`) depends on the `detector_pivot` mode:

```mermaid
graph TD
    A[Start: Calculate Rotated Basis Vectors] --> B{Detector Pivot Mode?};
    B -- BEAM --> C["Calculate pix0_vector using BEAM formula<br/>(pivots around beam spot on detector)"];
    B -- SAMPLE --> D["Calculate pix0_vector using SAMPLE formula<br/>(pivots around sample position)"];
    C --> E[pix0_vector = -Fbeam*fdet - Sbeam*sdet + distance*beam_vec];
    D --> F[pix0_vector = detector_origin + pixel_offsets];
    E --> G[Final Detector Geometry];
    F --> G;
```

### 5.1 BEAM Pivot Mode
When `detector_pivot = BEAM`, the detector rotates around the direct beam spot:
```python
pix0_vector = -Fbeam * fdet_vec - Sbeam * sdet_vec + distance * beam_vector
```
[2025-10-06T17:44:47] tokens used: 52,149

[2025-10-06T17:44:49] thinking

**Checking for relevant spec files**
[2025-10-06T17:44:50] exec bash -lc 'rg -n "pix0" specs/spec-a-cli.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:44:50] bash -lc 'rg -n "pix0" specs/spec-a-cli.md' succeeded in 750ms:
60:    - -pix0_vector x y z: Detector origin offset vector (meters) from sample to the first (min fast,
143:- Custom basis vectors or -pix0_vector set convention to CUSTOM and use provided vectors where
[2025-10-06T17:44:50] tokens used: 53,316
[2025-10-06T17:44:54] exec bash -lc "sed -n '120,200p' specs/spec-a-cli.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:44:54] bash -lc "sed -n '120,200p' specs/spec-a-cli.md" succeeded in 694ms:
- Misc:
    - -printout: Verbose pixel prints (for debugging).
    - -printout_pixel f s: Limit prints to specified pixel.
    - -trace_pixel s f: Instrument trace for a pixel.
    - -noprogress / -progress: Toggle progress meter.
    - -seed <int>: Noise RNG seed (negative used internally), defaults to negative time.
    - -mosaic_seed <int>, -misset_seed <int>: Seeds for mosaic domain rotations and random misset.
    - -misset 10 20 30: Apply misset angles (deg). -misset random: Use a random orientation.
    - -stol <file>, -4stol <file>, -Q <file>, -stolout <file>: Auxiliary S(Q) support is read but
not used further in this version.

Unsupported flags in examples:

- -dispstep (example shows this; not recognized). The supported control is -dispsteps (count).
- -hdiv and -vdiv (examples show these; not recognized). Supported are -hdivrange and -vdivrange.

Precedence and overrides (Normative)

- If both -img and -mask headers are read, the last one read wins for shared header-initialized
quantities.
[2025-10-06T17:44:54] tokens used: 53,610

[2025-10-06T17:45:03] thinking

**Outlining new Phase H6 tasks**

I'm organizing the next phase's tasks by defining steps to instrument code and logging in both C and PyTorch, then comparing results to find divergences. I'll update the plan to reflect these tasks, adjusting H5c status and adding a new H6 section with references to specs and report storage. The patch will carefully include these updates and instructions.
[2025-10-06T17:45:15] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -7,2 +7,3 @@
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
@@ -126,3 +127,15 @@
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
[2025-10-06T17:45:15] apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T17:45:15] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 

[2025-10-06T17:45:15] tokens used: 105,068
[2025-10-06T17:45:15] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:45:20] thinking

**Updating plan documentation**
[2025-10-06T17:45:20] exec bash -lc 'rg "Attempt #35" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:45:21] bash -lc 'rg "Attempt #35" -n docs/fix_plan.md' succeeded in 967ms:
459:  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
520:  * [2025-10-24] Attempt #35 (ralph) — Result: **EVIDENCE COMPLETE** (Phase H5c trace capture). **Critical finding: Attempt #33's beam-center mm→m fix had NO impact on pix0 calculation. Pix0 deltas IDENTICAL to 2025-10-22 baseline.**
1019:      4. Record Attempt #35 metrics after Phase H5 geometry fixes applied
[2025-10-06T17:45:21] tokens used: 106,713
[2025-10-06T17:45:21] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:45:32] thinking

**Updating Next Actions with H6 steps**

I'm adjusting the Next Actions list to incorporate the new H6 instrumentation tasks, revising the previous H5c-focused steps. The plan now emphasizes running H6 tasks to isolate divergence, updating logs and summary, then planning the fix before rerunning verification and proceeding to Phase K. I'll prepare a patch to reflect these changes clearly and succinctly.
[2025-10-06T17:45:40] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -457,7 +457,8 @@
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
[2025-10-06T17:45:40] apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T17:45:40] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 

[2025-10-06T17:45:40] tokens used: 108,174
[2025-10-06T17:45:40] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:45:48] thinking

**Preparing documentation review and input rewrite**

I’m focusing on the CLI-FLAGS-003 pix0 mismatch issue in Phase H6 and will mention key docs like `docs/architecture/detector.md` and `specs/spec-a-cli.md` that inform this. I need to carefully ensure the fix plan isn’t too long and then update `input.md` on the `feature/spec-based-2` branch, so I’ll open the current `input.md` to get its style before rewriting it fully.
[2025-10-06T17:45:51] exec bash -lc "sed -n '1,200p' input.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:45:52] bash -lc "sed -n '1,200p' input.md" succeeded in 886ms:
Summary: Capture post-unit-fix pix0 traces so Phase K consumes fresh geometry evidence before any new code.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase H5c trace refresh
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log
Artifacts: reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout
Artifacts: reports/2025-10-cli-flags/phase_h5/parity_summary.md
Do Now: CLI-FLAGS-003 Phase H5c — Capture post-unit-fix trace; run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log`
If Blocked: Log the failure (command + stderr) to reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/attempt_log.md and halt for supervisor guidance.

Timeline:
01. Confirm `NB_C_BIN=./golden_suite_generator/nanoBragg` remains exported in the shell; note it in attempt log.
02. Ensure editable install still active; no reinstall needed unless torch import fails.
03. Create `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/` before running harness.
04. Execute the Do Now trace harness; tee stdout to trace_py.stdout for later diffing.
05. Immediately copy `trace_py.log` to a scratch diff view against the 2025-10-22 baseline to spot unit-fix deltas.
06. Compute Δpix0, ΔFbeam, ΔSbeam manually (spreadsheet or python) and jot them into attempt log.
07. Verify the trace still reports the corrected `incident_vec` and rotated reciprocal vectors; flag any regressions.
08. Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with the new numeric deltas and tolerance checks.
[2025-10-06T17:45:52] tokens used: 109,582
[2025-10-06T17:45:52] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:46:19] thinking

**Drafting detailed instrumentation memo**

I’m piecing together a 100-200 line memo for Phase H6 focused on CLI-FLAGS-003 instrumentation. It will include structured sections like Summary, Phase, Focus, Branch, Mapped tests, Artifacts, Do Now with exact commands to run, plus sections on priorities, how-to steps, pitfalls, pointers, and optional next steps. I’m resolving how to describe the code instrumentation as Evidence phase despite involving code changes and deciding the best way to present and store traces and fallback instructions. The goal is a clear, thorough guide aligned with existing formatting and user instructions.
[2025-10-06T17:46:43] exec bash -lc "cat <<'EOF' > input.md
Summary: Pin down the pix0 divergence by adding matched C/Py instrumentation before resuming normalization work.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase H6 — Pix0 Divergence Isolation
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log
Artifacts: reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.log
Artifacts: reports/2025-10-cli-flags/phase_h6/analysis.md
Do Now: CLI-FLAGS-003 Phase H6a — capture C pix0 trace; run "'`NB_C_BIN=./golden_suite_generator/nanoBragg ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`
If Blocked: Capture stderr/stdout to `reports/2025-10-cli-flags/phase_h6/attempt_log.md`, note the failing step (instrumentation, build, or run), and halt for supervisor guidance.

Instrumentation Checklist:
- Add `TRACE_C:` lines near pix0 math in `golden_suite_generator/nanoBragg.c` (beam center parsing, Fbeam/Sbeam, r_factor, close_distance, pix0 components).
- Touch `reports/2025-10-cli-flags/phase_h/trace_harness.py` only through hooks; avoid embedding business logic in the script body.
- Keep trace variable names identical between C and PyTorch (`TRACE_C: Fbeam_mm`, `TRACE_PY: Fbeam_mm`, etc.).
- Record git hashes (`git rev-parse HEAD`, `git -C golden_suite_generator rev-parse HEAD`) inside each trace README.
- Store environment snapshot with `env | sort > .../env_snapshot.txt` to replicate runs later.
- Use `shasum -a 256` for each log and include the checksum inside the README.
- After instrumentation, rebuild C binary via `make -C golden_suite_generator` and note compiler flags.
- Preserve existing trace harness CLI; add new options only if strictly necessary and document them in the README.
- Ensure all new directories live under `reports/2025-10-cli-flags/phase_h6/` to keep provenance tidy.
- Update docs/fix_plan.md Attempt #36 immediately after capturing both traces.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:134-153 documents Phase H6 tasks required before K2 resumes.
- docs/fix_plan.md:455-484 now mandates H6 instrumentation and a fresh Attempt #36 log before normalization.
- docs/architecture/detector.md:35-82 contains the canonical BEAM pivot pix0 formula we must validate line-by-line.
- specs/spec-a-cli.md:120-152 reiterates CUSTOM convention precedence and pivot side-effects relevant to pix0 overrides.

How-To Map:
- Step 1: Apply C instrumentation (H6a) — insert `TRACE_C` outputs around `pix0_vector` calculation, rebuild with `make -C golden_suite_generator -j8`, and document changes in `c_trace/README.md`.
- Step 2: Run the Do Now command, tee stdout, and clip the `TRACE_C` lines into `c_trace/trace_c_pix0.log`; append `git status --short` results to the README.
- Step 3: Extend the PyTorch trace harness (H6b) to emit mirrored variables from `_calculate_pix0_vector()`; route output to `phase_h6/py_trace/trace_py_pix0.log` plus a matching README and env snapshot.
- Step 4: Diff the traces (H6c) using `diff -u` or a notebook; summarize the first mismatch (units + magnitude) in `phase_h6/analysis.md` with direct line citations to both logs.
- Step 5: Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with a new section “Attempt #36 (Phase H6 diagnostics)” showing Δpix0/ΔFbeam/ΔSbeam values and the identified divergence.
- Step 6: Edit docs/fix_plan.md Attempt history for CLI-FLAGS-003 with Attempt #36, referencing all new artifacts and proposed fix.
- Step 7: Stage only reports/docs plus temporary instrumentation patches; if `nanoBragg.c` must stay instrumented for multiple loops, document the intent in Attempt history.

Pitfalls To Avoid:
- Do not alter production simulator logic while instrumenting; confine changes to trace hooks and guard with `#ifdef TRACE_PIX0` if necessary.
- Avoid rerunning pytest or nb-compare; Evidence phase forbids tests.
- Keep Protected Assets untouched (docs/index.md, loop.sh, supervisor.sh, input.md).
- Ensure C trace uses meters for pix0 components; note any mm intermediate conversions explicitly.
- Prevent CLIs from emitting ANSI colour codes—use plain text for diffability.
- Do not delete prior H5 assets; they remain the baseline comparator.
- Revert instrumentation diffs after logs are captured unless further loops require them (capture rationale in Attempt #36).
- Maintain device/dtype neutrality in PyTorch trace — no forced `.cpu()` or `.double()` just for logging.
- Respect two-message loop policy: avoid triggering additional automation tracks.
- Keep git history linear; avoid merge commits while instrumentation is in flight.

Pointers:
- plans/active/cli-noise-pix0/plan.md:120-167
- docs/fix_plan.md:448-530
- docs/architecture/detector.md:35-112
- docs/development/c_to_pytorch_config_map.md:60-110
- docs/debugging/debugging.md:20-88

Telemetry Targets:
- Record harness runtime and CPU info in each README.
- Log the executed Do Now command verbatim for reproducibility.
- Archive raw `TRACE_C/PY` snippets inside analysis.md for quick reference.
- Tag Attempt #36 with `Phase H6` in docs/fix_plan.md to keep history searchable.
- Catalog any instrumentation flags (e.g., `TRACE_PIX0=1`) used during builds.

Next Up: Once pix0 parity (<5e-5 m) is proven, transition to Phase H5c closure followed by Phase K2 scaling-chain refresh.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:46:44] bash -lc "cat <<'EOF' > input.md
Summary: Pin down the pix0 divergence by adding matched C/Py instrumentation before resuming normalization work.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase H6 — Pix0 Divergence Isolation
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log
Artifacts: reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.log
Artifacts: reports/2025-10-cli-flags/phase_h6/analysis.md
Do Now: CLI-FLAGS-003 Phase H6a — capture C pix0 trace; run "'`NB_C_BIN=./golden_suite_generator/nanoBragg ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`
If Blocked: Capture stderr/stdout to `reports/2025-10-cli-flags/phase_h6/attempt_log.md`, note the failing step (instrumentation, build, or run), and halt for supervisor guidance.

Instrumentation Checklist:
- Add `TRACE_C:` lines near pix0 math in `golden_suite_generator/nanoBragg.c` (beam center parsing, Fbeam/Sbeam, r_factor, close_distance, pix0 components).
- Touch `reports/2025-10-cli-flags/phase_h/trace_harness.py` only through hooks; avoid embedding business logic in the script body.
- Keep trace variable names identical between C and PyTorch (`TRACE_C: Fbeam_mm`, `TRACE_PY: Fbeam_mm`, etc.).
- Record git hashes (`git rev-parse HEAD`, `git -C golden_suite_generator rev-parse HEAD`) inside each trace README.
- Store environment snapshot with `env | sort > .../env_snapshot.txt` to replicate runs later.
- Use `shasum -a 256` for each log and include the checksum inside the README.
- After instrumentation, rebuild C binary via `make -C golden_suite_generator` and note compiler flags.
- Preserve existing trace harness CLI; add new options only if strictly necessary and document them in the README.
- Ensure all new directories live under `reports/2025-10-cli-flags/phase_h6/` to keep provenance tidy.
- Update docs/fix_plan.md Attempt #36 immediately after capturing both traces.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:134-153 documents Phase H6 tasks required before K2 resumes.
- docs/fix_plan.md:455-484 now mandates H6 instrumentation and a fresh Attempt #36 log before normalization.
- docs/architecture/detector.md:35-82 contains the canonical BEAM pivot pix0 formula we must validate line-by-line.
- specs/spec-a-cli.md:120-152 reiterates CUSTOM convention precedence and pivot side-effects relevant to pix0 overrides.

How-To Map:
- Step 1: Apply C instrumentation (H6a) — insert `TRACE_C` outputs around `pix0_vector` calculation, rebuild with `make -C golden_suite_generator -j8`, and document changes in `c_trace/README.md`.
- Step 2: Run the Do Now command, tee stdout, and clip the `TRACE_C` lines into `c_trace/trace_c_pix0.log`; append `git status --short` results to the README.
- Step 3: Extend the PyTorch trace harness (H6b) to emit mirrored variables from `_calculate_pix0_vector()`; route output to `phase_h6/py_trace/trace_py_pix0.log` plus a matching README and env snapshot.
- Step 4: Diff the traces (H6c) using `diff -u` or a notebook; summarize the first mismatch (units + magnitude) in `phase_h6/analysis.md` with direct line citations to both logs.
- Step 5: Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with a new section “Attempt #36 (Phase H6 diagnostics)” showing Δpix0/ΔFbeam/ΔSbeam values and the identified divergence.
- Step 6: Edit docs/fix_plan.md Attempt history for CLI-FLAGS-003 with Attempt #36, referencing all new artifacts and proposed fix.
- Step 7: Stage only reports/docs plus temporary instrumentation patches; if `nanoBragg.c` must stay instrumented for multiple loops, document the intent in Attempt history.

Pitfalls To Avoid:
- Do not alter production simulator logic while instrumenting; confine changes to trace hooks and guard with `#ifdef TRACE_PIX0` if necessary.
- Avoid rerunning pytest or nb-compare; Evidence phase forbids tests.
- Keep Protected Assets untouched (docs/index.md, loop.sh, supervisor.sh, input.md).
- Ensure C trace uses meters for pix0 components; note any mm intermediate conversions explicitly.
- Prevent CLIs from emitting ANSI colour codes—use plain text for diffability.
- Do not delete prior H5 assets; they remain the baseline comparator.
- Revert instrumentation diffs after logs are captured unless further loops require them (capture rationale in Attempt #36).
- Maintain device/dtype neutrality in PyTorch trace — no forced `.cpu()` or `.double()` just for logging.
- Respect two-message loop policy: avoid triggering additional automation tracks.
- Keep git history linear; avoid merge commits while instrumentation is in flight.

Pointers:
- plans/active/cli-noise-pix0/plan.md:120-167
- docs/fix_plan.md:448-530
- docs/architecture/detector.md:35-112
- docs/development/c_to_pytorch_config_map.md:60-110
- docs/debugging/debugging.md:20-88

Telemetry Targets:
- Record harness runtime and CPU info in each README.
- Log the executed Do Now command verbatim for reproducibility.
- Archive raw `TRACE_C/PY` snippets inside analysis.md for quick reference.
- Tag Attempt #36 with `Phase H6` in docs/fix_plan.md to keep history searchable.
- Catalog any instrumentation flags (e.g., `TRACE_PIX0=1`) used during builds.

Next Up: Once pix0 parity (<5e-5 m) is proven, transition to Phase H5c closure followed by Phase K2 scaling-chain refresh.
EOF
' succeeded in 912ms:

[2025-10-06T17:46:44] tokens used: 115,360
[2025-10-06T17:46:44] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:46:49] thinking

**Verifying changes and preparing summary**
[2025-10-06T17:46:49] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:46:50] bash -lc 'git status --short' succeeded in 757ms:
 M docs/fix_plan.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T17:46:50] tokens used: 117,670
[2025-10-06T17:46:50] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:46:54] thinking

**Reviewing diffs for correctness**
[2025-10-06T17:46:54] exec bash -lc 'git diff' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:46:55] bash -lc 'git diff' succeeded in 725ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb44..8252349 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
[2025-10-06T17:46:55] tokens used: 117,896
[2025-10-06T17:46:55] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:47:00] thinking

**Documenting update in galph_memory.md**
[2025-10-06T17:47:10] exec bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-24 (galph loop — Phase H6 spin-up)
- Coin flip = tails → skipped retrospective review; focused on active CLI parity gap per long-term Goal #1.
- Deep analysis confirms pix0 parity still fails after Attempt #35 (ΔF ≈ -1.136 mm, ΔS ≈ +0.139 mm) even with beam-center mm→m fix; "'`plans/active/cli-noise-pix0/plan.md` lacked follow-up guidance.
- Added Phase H6 section (H6a–H6d) to `plans/active/cli-noise-pix0/plan.md` and updated H5c state to [P]; plan now requires matched C/Py instrumentation to isolate `_calculate_pix0_vector` divergence.
- Refreshed CLI-FLAGS-003 Next Actions in `docs/fix_plan.md` to mandate H6 evidence before resuming normalization (K2/K3).
- Issued new `input.md` (Evidence phase) directing Ralph to instrument nanoBragg.c and the PyTorch trace harness, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and log Attempt #36.
- Follow-up for Ralph: execute Phase H6a/H6b/H6c tasks, update parity_summary + docs/fix_plan (Attempt #36), then coordinate a targeted fix to collapse pix0 deltas <5e-5 m before returning to Phase K.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:47:12] bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-24 (galph loop — Phase H6 spin-up)
- Coin flip = tails → skipped retrospective review; focused on active CLI parity gap per long-term Goal #1.
- Deep analysis confirms pix0 parity still fails after Attempt #35 (ΔF ≈ -1.136 mm, ΔS ≈ +0.139 mm) even with beam-center mm→m fix; "'`plans/active/cli-noise-pix0/plan.md` lacked follow-up guidance.
- Added Phase H6 section (H6a–H6d) to `plans/active/cli-noise-pix0/plan.md` and updated H5c state to [P]; plan now requires matched C/Py instrumentation to isolate `_calculate_pix0_vector` divergence.
- Refreshed CLI-FLAGS-003 Next Actions in `docs/fix_plan.md` to mandate H6 evidence before resuming normalization (K2/K3).
- Issued new `input.md` (Evidence phase) directing Ralph to instrument nanoBragg.c and the PyTorch trace harness, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and log Attempt #36.
- Follow-up for Ralph: execute Phase H6a/H6b/H6c tasks, update parity_summary + docs/fix_plan (Attempt #36), then coordinate a targeted fix to collapse pix0 deltas <5e-5 m before returning to Phase K.
EOF
' succeeded in 1.22s:

[2025-10-06T17:47:12] tokens used: 121,602
[2025-10-06T17:47:12] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:47:14] thinking

**Verifying memory file update**
[2025-10-06T17:47:15] exec bash -lc 'tail -n 40 galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:47:16] bash -lc 'tail -n 40 galph_memory.md' succeeded in 991ms:
- Hypotheses for remaining intensity gap now hinge on normalization once geometry parity returns; no new plan beyond existing Phase K tasks.
- Follow-ups for Ralph: execute Do Now revert + tests, capture PyTorch traces under `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`, update parity_summary.md and docs/fix_plan Attempt history, then pause for supervisor review before Phase K work.

## 2025-10-24 (galph loop — H5c evidence prep)
- Refreshed CLI-FLAGS-003 plan: marked H5b/H5d done, inserted doc anchor list, and rewrote Phase K tasks to target the sincg(h) bug (`plans/active/cli-noise-pix0/plan.md`).
- Updated fix_plan next actions to focus on H5c traces then Phase K1 lattice-factor fix (`docs/fix_plan.md:448-510`).
- Replaced `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with post-revert guidance pointing Ralph to regenerate TRACE_PY logs (2025-10-22 baseline).
- Issued new input.md (Evidence phase) directing Ralph to run the trace harness and archive metrics before code changes.
- Key finding: PyTorch SQUARE lattice factor still feeds sincg with `(h-h0)` (src/nanobrag_torch/simulator.py) vs C’s `sincg(M_PI*h, Na)` (`golden_suite_generator/nanoBragg.c:3063-3080`); Phase K1 must correct this.
- Follow-up expectations: Ralph generates H5c PyTorch traces under `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`, updates parity_summary metrics, and drafts Attempt #32.

## 2025-10-24 (galph loop — Phase H5 unit fix directive)
- Reconfirmed pix0 fast-axis delta (≈1.1 mm) persists post-H5b revert; traced root cause to Detector BEAM pivot still treating beam_center_f/s as pixel counts (mm×m bug).
- Added Phase H5e row to `plans/active/cli-noise-pix0/plan.md` directing mm→m conversion with new trace artifacts; refreshed docs/fix_plan.md Next Actions to prioritise H5a/H5c/H5e sequence before Phase K.
- Issued `input.md` (Implementation phase) instructing Ralph to implement unit fix, capture trace evidence under `reports/2025-10-cli-flags/phase_h5/unit_fix/`, run `tests/test_cli_flags.py::TestCLIPix0Override`, and log Attempt #33.
- No code changes made this loop; planning/docs only. Next follow-up: verify H5e Attempt captures <5e-5 m pix0 deltas, then greenlight Phase K1 (sincg update).

## 2025-10-24 (galph loop — Phase K1 directive)
- Re-ran parity backlog review after clean `git pull`; active focus remains CLI-FLAGS-003. H5c traces still missing post-unit-fix, so emphasized capturing them as part of upcoming Phase K work.
- Deep dive confirmed SQUARE lattice factor still uses `(h-h0)` in `src/nanobrag_torch/simulator.py:200-280`, violating `specs/spec-a-core.md:218` and C reference `golden_suite_generator/nanoBragg.c:3069-3079`. Phase J evidence (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) still shows 3.6e-7 intensity ratio.
[2025-10-06T17:47:16] tokens used: 122,446
[2025-10-06T17:47:16] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:47:20] thinking

**Preparing commit with proper message**
[2025-10-06T17:47:21] exec bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:47:22] bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' succeeded in 848ms:

[2025-10-06T17:47:22] tokens used: 124,320
[2025-10-06T17:47:22] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:47:25] thinking

**Committing with specified message**
[2025-10-06T17:47:26] exec bash -lc 'git commit -m "SUPERVISOR: Phase H6 instrumentation prep - tests: not run"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:47:26] bash -lc 'git commit -m "SUPERVISOR: Phase H6 instrumentation prep - tests: not run"' succeeded in 746ms:
[feature/spec-based-2 666a159] SUPERVISOR: Phase H6 instrumentation prep - tests: not run
 4 files changed, 80 insertions(+), 104 deletions(-)
[2025-10-06T17:47:26] tokens used: 124,506
[2025-10-06T17:47:26] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:47:29] thinking

**Pushing changes to remote**
[2025-10-06T17:47:29] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:47:31] bash -lc 'git push' succeeded in 2.12s:
To github.com:hoidn/nanoBragg.git
   b741b06..666a159  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T17:47:31] tokens used: 141,478
[2025-10-06T17:47:31] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:47:33] thinking

**Verifying clean working tree**
[2025-10-06T17:47:34] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:47:35] bash -lc 'git status --short' succeeded in 820ms:

[2025-10-06T17:47:35] tokens used: 142,432
[2025-10-06T17:47:35] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:47:55] thinking

**Summarizing final response plan**

I’m organizing the final answer to include a concise summary of the deep Step 1 analysis and a ranked list of 1–3 hypotheses explaining the CLI-FLAGS pix0 mismatch, with supporting evidence from key report files. I'll also highlight plan updates, including referencing exact line numbers, and note skipped Step 2 review. Lastly, I’ll outline next action items with clear file path references and mention review of vectorization plans as meeting quality standards. This will keep things clear and well-structured for the user.
[2025-10-06T17:47:58] exec bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '1,220p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:47:59] bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '1,220p'" succeeded in 1.03s:
     1	## Context
     2	- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
     3	- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
     4	- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
     5	- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
     6	- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
     7	- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
     8	- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
     9	- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
    10	- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
    11	- Documentation anchors for this focus:
    12	  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
    13	  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
    14	  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
    15	  * `docs/development/testing_strategy.md` — authoritative pytest/trace commands for CLI parity evidence.
    16	
    17	### Phase A — Requirements & Trace Alignment
    18	Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
    19	Prereqs: Ability to run instrumented C binary via `NB_C_BIN` and collect traces.
    20	Exit Criteria: Documented parity notes under `reports/2025-10-cli-flags/phase_a/` with explicit decisions on unit conversions and noise toggle ordering.
[2025-10-06T17:47:59] tokens used: 143,423
[2025-10-06T17:47:59] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:48:01] thinking

**Preparing line number references**
[2025-10-06T17:48:02] exec bash -lc "nl -ba docs/fix_plan.md | sed -n '448,520p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:48:03] bash -lc "nl -ba docs/fix_plan.md | sed -n '448,520p'" succeeded in 845ms:
   448	## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
   449	- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
   450	- Priority: High
   451	- Status: in_progress (Phases A-H complete; polarization Phase I pending)
   452	- Owner/Date: ralph/2025-10-05
   453	- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
   454	- Reproduction (C & PyTorch):
   455	  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   456	  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
   457	- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
   458	- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
   459	  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
   460	  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
   461	  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
   462	  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
   463	  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
   464	- Attempts History:
   465	  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
   466	    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
   467	    Artifacts:
[2025-10-06T17:48:03] tokens used: 146,526
[2025-10-06T17:48:03] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:48:06] thinking

**Preparing references and hypotheses**
[2025-10-06T17:48:07] exec bash -lc "nl -ba reports/2025-10-cli-flags/phase_h5/parity_summary.md | sed -n '1,200p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:48:08] bash -lc "nl -ba reports/2025-10-cli-flags/phase_h5/parity_summary.md | sed -n '1,200p'" succeeded in 819ms:
     1	# Phase H5 Parity Summary
     2	
     3	**Date:** 2025-10-24 (refreshed from 2025-10-22)
     4	**Task:** CLI-FLAGS-003 Phase H5c — Capture post-unit-fix PyTorch traces after Attempt #33
     5	**Goal:** Verify whether Attempt #33's beam-center mm→m conversion resolved the pix0 discrepancy, then assess readiness for Phase K normalization work.
     6	
     7	## Implementation Snapshot
     8	✅ **Updated 2025-10-24 (Attempt #35):** Fresh PyTorch trace captured post-Attempt #33 unit fix. **Critical finding: Attempt #33's beam-center mm→m conversion did NOT affect pix0 calculation. Pix0 deltas identical to 2025-10-22 baseline, indicating the underlying pix0 discrepancy remains unresolved.**
     9	
    10	### Code Changes (Prior Work)
    11	**File:** `src/nanobrag_torch/models/detector.py`
    12	
    13	1. **H5b - Restored custom-vector guard** (Attempt #31, lines ≈518-540):
    14	   - Added `has_custom_vectors = any([...])` helper mirroring C precedence.
    15	   - Gated pix0 override projection with `if pix0_override_tensor is not None and not has_custom_vectors:`.
    16	   - Refreshed comments to cite `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
    17	
    18	2. **H5e - Beam-center unit correction** (Attempt #33, lines 490-515):
    19	   - Changed BEAM pivot Fbeam/Sbeam calculation to use `self.config.beam_center_f / 1000.0` instead of pixel-based values.
    20	   - Addressed observed 1.1mm ΔF error from 2025-10-22 trace analysis.
[2025-10-06T17:48:08] tokens used: 148,296
[2025-10-06T17:48:08] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:48:11] thinking

**Noting reference details for final message**
[2025-10-06T17:48:12] exec bash -lc "nl -ba plans/active/vectorization.md | sed -n '1,200p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T17:48:12] bash -lc "nl -ba plans/active/vectorization.md | sed -n '1,200p'" succeeded in 778ms:
     1	## Context
     2	- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
     3	- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
     4	- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.
     5	
     6	### Phase A — Evidence & Baseline Capture
     7	Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
     8	Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
     9	Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.
    10	
    11	| ID | Task Description | State | How/Why & Guidance |
    12	| --- | --- | --- | --- |
    13	| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
    14	| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
    15	| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |
    16	
    17	### Phase B — Tricubic Vectorization Design
    18	Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
    19	Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
    20	Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T17:48:12] tokens used: 152,159
[2025-10-06T17:48:12] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T17:48:21] thinking

**Preparing detailed final response**

I’m organizing a comprehensive final message that outlines the plan’s readiness pending Phase A, lists three key hypotheses about vector calculations and beam orientation discrepancies, and includes confidence levels. I’ll highlight review conclusions on the vectorization plan, adherence to instructions, and absence of code changes or tests run, and I’ll structure follow-ups and next steps carefully with precise file references and line numbers to guide the user clearly.
[2025-10-06T17:48:22] codex

**CLI Parity Findings**
- Attempt #35 still shows pix0 fast/slow deltas of −1.136 mm / +0.139 mm despite the beam-center unit fix; basis vectors match exactly, so the fault is isolated to pix0 construction (`reports/2025-10-cli-flags/phase_h5/parity_summary.md:1-152`).
- The active plan now records this regression and requires a new diagnostics phase before normalization resumes (`plans/active/cli-noise-pix0/plan.md:5-153`).
- CLI fix-plan next actions were realigned to block Phase K until this pix0 gap is resolved (`docs/fix_plan.md:448-463`).
- Vectorization work remains in planning; Phase A evidence tasks are ready for Ralph once the CLI focus clears (`plans/active/vectorization.md:1-35`).

**Hypotheses (ranked)**
1. `_calculate_pix0_vector()` is skipping the nanoBragg `close_distance/r_factor` rescaling when custom detector vectors are present, leading to ≈1 mm fast-axis bias. *Confidence: medium.* **Next confirming step:** instrument nanoBragg.c and the PyTorch helper to log `close_distance`, `r_factor`, and the intermediate pix0 components (Phase H6a/H6b).
2. The MOSFLM +0.5 pixel beam-center offset is being applied in a different coordinate frame than C when CUSTOM vectors are active, so F/S beam projections carry residual mm-scale offsets. *Confidence: low-medium.* **Next confirming step:** capture C vs Py traces for raw beam-center values immediately before projection to fdet/sdet.
3. The PyTorch code may still use the un-normalised CLI `beam_vector` inside the pix0 formula while C renormalises after custom vector overrides. *Confidence: low.* **Next confirming step:** log `beam_vector` magnitude in both traces to verify parity.

**Planning & Docs**
- Added Phase H6 (tasks H6a–H6d) and marked H5c as in-progress so instrumentation work is explicitly tracked (`plans/active/cli-noise-pix0/plan.md:118-143`).
- Updated CLI-FLAGS-003 fix-plan actions to mandate Phase H6 evidence, postpone Phase K2/K3, and document success criteria (`docs/fix_plan.md:448-463`).
- Logged today’s decisions in supervisor memory for continuity (`galph_memory.md` latest entry).
- Issued a new engineer memo directing Ralph to capture matched C/Py pix0 traces under `reports/2025-10-cli-flags/phase_h6/` and record Attempt #36 (`input.md:1-70`).

**Next Steps for Ralph**
- Execute the Do Now command from `input.md` to produce the instrumented C trace, then implement Phase H6b/H6c to find the first pix0 divergence.
- Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and `docs/fix_plan.md` with Attempt #36 once evidence lands, keeping pix0 deltas visible to the supervisor before any normalization work proceeds.

Tests: not run (Evidence-only loop).
[2025-10-06T17:48:30] tokens used: 155,261
[2025-10-06T17:48:30] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 91deb4495a8f168b75f6b8efb071f674be17e5de..825234994c85137d868af626bb7e196222c731d0
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,11 +455,12 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, push the remaining evidence before touching new implementation work:
-  1. Phase H5c — rerun `reports/2025-10-cli-flags/phase_h/trace_harness.py` so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` + `parity_summary.md` capture the post-unit-fix pix0/F/S deltas (<5e-5 m) and log Attempt #35.
-  2. Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor now matches C.
-  3. Phase K3 — once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  4. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
+  1. Phase H6 — instrument nanoBragg.c and the PyTorch trace harness around `_calculate_pix0_vector()`, capture logs under `reports/2025-10-cli-flags/phase_h6/`, and document the first divergence (Attempt #36) in both `parity_summary.md` and this fix-plan entry.
+  2. After H6 findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
+  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
+  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index d6911b8487d6d1ee2e1f3f6bf50d759c8e24cd75..6687564d8e5e597d1e6b2fa1a2df27cab04bca1a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,6 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
+- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -124,7 +125,19 @@
 | --- | --- | --- | --- |
 | H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
 | H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
-| H5c | Capture updated PyTorch traces & compare | [ ] | After the H5e unit conversion fix (Attempt #33), rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.log` reflects the corrected pix0 vector. Diff against the 2025-10-22 C trace, refresh `parity_summary.md` with `|Δpix0| < 5e-5 m` and `F_latt` ratio within 1e-3, and log Attempt #35 before resuming Phase K. |
+| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
+
+### Phase H6 — Pix0 Divergence Isolation
+Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
+Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
+Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H6a | Instrument C pix0 calculation | [ ] | Add targeted `TRACE_C` lines around `golden_suite_generator/nanoBragg.c` pix0 math (beam_center → Fbeam/Sbeam, `close_distance`, `r_factor`, final pix0 vector). Run supervisor command with `NB_C_BIN=./golden_suite_generator/nanoBragg`, stash stdout under `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log`, and record build context in `c_trace/README.md`. |
+| H6b | Extend PyTorch trace harness | [ ] | Update `reports/2025-10-cli-flags/phase_h/trace_harness.py` (or companion script) to emit matching `TRACE_PY` lines from `_calculate_pix0_vector()` via instrumentation hooks. Capture output under `phase_h6/py_trace/trace_py_pix0.log` with env snapshot + git context. |
+| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). |
+| H6d | Update fix_plan attempt log | [ ] | File Attempt #36 in `docs/fix_plan.md` summarizing the divergence location, evidence paths, and unblock criteria for returning to Phase K. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 

Reading prompt from stdin...
Already up to date.
To github.com:hoidn/nanoBragg.git
   666a159..4993d26  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=41...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=41
Updating 4993d26..cf0e4d1
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   4993d26..cf0e4d1  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=41
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating cf0e4d1..9ee2ada
Fast-forward
 docs/fix_plan.md                                   |  19 ++
 golden_suite_generator/nanoBragg.c                 |  70 ++++-
 .../2025-10-cli-flags/phase_h6/c_trace/README.md   | 105 ++++++++
 .../phase_h6/c_trace/env_snapshot.txt              |  55 ++++
 .../phase_h6/c_trace/trace_c_pix0.log              | 291 +++++++++++++++++++++
 .../phase_h6/c_trace/trace_c_pix0.log.sha256       |   1 +
 .../phase_h6/c_trace/trace_c_pix0_clean.log        |  24 ++
 7 files changed, 564 insertions(+), 1 deletion(-)
 create mode 100644 reports/2025-10-cli-flags/phase_h6/c_trace/README.md
 create mode 100644 reports/2025-10-cli-flags/phase_h6/c_trace/env_snapshot.txt
 create mode 100644 reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log
 create mode 100644 reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log.sha256
 create mode 100644 reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0_clean.log
From github.com:hoidn/nanoBragg
   cf0e4d1..9ee2ada  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 9ee2ada..fc70cbd
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   9ee2ada..fc70cbd  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=42
Ralph completed iteration 41; proceeding to 42
