Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=48
To github.com:hoidn/nanoBragg.git
   085f4e1..65edd81  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T20:37:21] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T20:37:21] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 


Debugging Items — Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‑line rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for this turn.
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
Header:
- Summary: <one‑sentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
  - Note: When the Phase is Evidence, you must not execute tests; any pytest command included here is provided for Ralph’s subsequent loop.
<Do Now guidelines>
Phase Gate (Evidence): If the active plan phase is Evidence, do not run pytest at all (including collection). Limit evidence gathering to non-test probes and command‑line tooling (e.g., scripts/validation/*, minimal parity CLIs). Do not include runnable tests in this loop.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T20:37:29] thinking

**Preparing for multi-step planning**
[2025-10-06T20:37:30] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:37:32] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && timeout 30 git pull --rebase' succeeded in 2.62s:
Already up to date.
[2025-10-06T20:37:32] tokens used: 12,972

[2025-10-06T20:37:35] thinking

**Preparing to read latest memory entry**
[2025-10-06T20:37:35] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:37:36] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat galph_memory.md' succeeded in 766ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-06T20:37:36] tokens used: 13,936

[2025-10-06T20:37:45] thinking

**Planning to review key docs**
[2025-10-06T20:37:47] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' docs/index.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:37:48] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' docs/index.md" succeeded in 871ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T20:37:48] tokens used: 17,931

[2025-10-06T20:37:51] thinking

**Starting to review spec-a.md**
[2025-10-06T20:38:04] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' specs/spec-a.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:05] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' specs/spec-a.md" succeeded in 956ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T20:38:05] tokens used: 19,709

[2025-10-06T20:38:07] thinking

**Reviewing additional specs**
[2025-10-06T20:38:07] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' arch.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:08] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' arch.md" succeeded in 849ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T20:38:08] tokens used: 20,072

[2025-10-06T20:38:10] thinking

**Opening configuration mapping documentation**
[2025-10-06T20:38:11] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' docs/development/c_to_pytorch_config_map.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:12] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' docs/development/c_to_pytorch_config_map.md" succeeded in 787ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T20:38:12] tokens used: 22,962

[2025-10-06T20:38:13] thinking

**Accessing debugging documentation**
[2025-10-06T20:38:14] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' docs/debugging/debugging.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:14] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' docs/debugging/debugging.md" succeeded in 770ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T20:38:14] tokens used: 25,248

[2025-10-06T20:38:19] thinking

**Reviewing fix_plan.md partially**
[2025-10-06T20:38:20] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:20] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' docs/fix_plan.md" succeeded in 759ms:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A–C) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2–B4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1–A3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ✅ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
| [CLI-DTYPE-002](#cli-dtype-002-cli-dtype-parity) | CLI dtype parity | High | in_progress |
[2025-10-06T20:38:20] tokens used: 27,527

[2025-10-06T20:38:24] thinking

**Identifying key documentation files**
[2025-10-06T20:38:24] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' docs/development/testing_strategy.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:25] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' docs/development/testing_strategy.md" succeeded in 763ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T20:38:25] tokens used: 30,540

[2025-10-06T20:38:29] thinking

**Exploring active plans directory**
[2025-10-06T20:38:29] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && ls plans/active' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:30] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && ls plans/active' succeeded in 779ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T20:38:30] tokens used: 33,051

[2025-10-06T20:38:34] thinking

**Opening relevant plans**
[2025-10-06T20:38:35] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:35] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" succeeded in 712ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
- Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
- Documentation anchors for this focus:
  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
  * `docs/development/testing_strategy.md` — authoritative pytest/trace commands for CLI parity evidence.

### Phase A — Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
[2025-10-06T20:38:35] tokens used: 63,450

[2025-10-06T20:38:39] thinking

**Reviewing relevant plan files**
[2025-10-06T20:38:39] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' plans/active/vectorization.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:40] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' plans/active/vectorization.md" succeeded in 699ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B — Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T20:38:40] tokens used: 67,100

[2025-10-06T20:38:44] thinking

**Preparing to analyze code and review history**
[2025-10-06T20:38:45] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python -c \"import random; print(random.choice(['heads','tails']))\"" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:46] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python -c \"import random; print(random.choice(['heads','tails']))\"" succeeded in 783ms:
tails
[2025-10-06T20:38:46] tokens used: 70,255

[2025-10-06T20:38:52] thinking

**Assessing plan relevance and next steps**
[2025-10-06T20:38:54] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:38:54] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat input.md' succeeded in 865ms:
Summary: Refresh scaling-chain evidence after the SAMPLE-pivot fix so we know where normalization still diverges.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase K2 — Recompute scaling chain & extend diagnostics
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log; reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after_<timestamp>.log; reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json; reports/2025-10-cli-flags/phase_j/scaling_chain.md; reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md; docs/fix_plan.md Attempt update draft
Do Now: CLI-FLAGS-003 Phase K2 — run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` then recompute scaling ratios in `reports/2025-10-cli-flags/phase_j/scaling_chain.md`
If Blocked: Capture stdout/stderr to `reports/2025-10-cli-flags/phase_k/f_latt_fix/attempt_blocked.log`, append `python - <<'PY'` snippet printing `sys.version`, `torch.__version__`, `torch.cuda.is_available()`, and `torch.get_default_dtype()`, snapshot `git status --short`, and note blocker in docs/fix_plan Attempt log before pausing.

Priorities & Rationale:
- docs/fix_plan.md:448-461 — refreshed Next Actions make Phase K2 the gating step for long-term goal #1; we need new scaling evidence before touching normalization code.
- plans/active/cli-noise-pix0/plan.md:171-179 — Phase K2 explicitly demands updated traces explaining `test_metrics_failure.json` ratios.
- reports/2025-10-cli-flags/phase_k/f_latt_fix/test_metrics_failure.json — current correlation≈0.173 data predates the SAMPLE-pivot fix; rerunning will show whether F_latt or F_cell still diverge.
- specs/spec-a-cli.md:1-140 — CLI contract ensures lattice normalization must match C once pixel geometry is correct; cite if residual differences remain.
- docs/architecture/detector.md:5-90 — Confirms SAMPLE pivot geometry assumptions now in effect; scaling analysis should no longer be contaminated by pix0 drift.

How-To Map:
- Ensure clean tree except reports: `git status --short` (no code edits in this loop).
- Create working dir: `mkdir -p reports/2025-10-cli-flags/phase_k/f_latt_fix`.
- Record environment: `python - <<'PY'` writing commit hash, sys.version, torch versions, CUDA availability to `metrics_after.json` skeleton (append later with ratios).
[2025-10-06T20:38:54] tokens used: 71,629

[2025-10-06T20:39:00] thinking

**Preparing for deep analysis of parallel test features**
[2025-10-06T20:39:00] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:01] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' succeeded in 765ms:

[2025-10-06T20:39:01] tokens used: 73,446

[2025-10-06T20:39:04] thinking

**Examining CLI-related report files**
[2025-10-06T20:39:05] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/test_metrics_failure.json' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:06] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/test_metrics_failure.json' succeeded in 735ms:
{
  "c_sum": 1627779.0,
  "py_sum": 2376257.0,
  "sum_ratio": 1.459815502166748,
  "c_max": 27169.591796875,
  "py_max": 58772.1953125,
  "max_ratio": 2.163160800933838,
  "correlation": 0.17327933200876186
}
[2025-10-06T20:39:06] tokens used: 73,722

[2025-10-06T20:39:07] thinking

**Investigating root cause difference**
[2025-10-06T20:39:08] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_j/scaling_chain.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:09] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_j/scaling_chain.md' succeeded in 738ms:
# Scaling Chain Analysis: C vs PyTorch

**Pixel:** (slow=1039, fast=685)

## Key Findings

**First Divergence:** `I_before_scaling`
- C value: 1.480792010454e+15
- PyTorch value: 5.344373483470e+08
- Ratio (Py/C): 3.609132e-07

**Final Intensity Ratio (Py/C):** 1.053e-05

## Full Factor Comparison

| Factor | C Value | PyTorch Value | Ratio (Py/C) | Match? |
|--------|---------|---------------|--------------|--------|
| I_before_scaling | 1.480792e+15 | 5.344373e+08 | 3.609132e-07 | ❌ |
| steps | 1.000000e+01 | 1.000000e+01 | 1.000000e+00 | ✅ |
| r_e_sqr | 7.940792e-30 | 7.940792e-30 | 1.000000e+00 | ✅ |
[2025-10-06T20:39:09] tokens used: 74,125

[2025-10-06T20:39:12] thinking

**Reviewing pre-phase K2 context**
[2025-10-06T20:39:13] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '700,880p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:13] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '700,880p' src/nanobrag_torch/simulator.py" succeeded in 707ms:
        The vectorized implementation replaces these nested loops. The outer `source`
        loop is future work for handling beam divergence and dispersion.

        ```c
                        /* loop over sources now */
                        for(source=0;source<sources;++source){

                            /* retrieve stuff from cache */
                            incident[1] = -source_X[source];
                            incident[2] = -source_Y[source];
                            incident[3] = -source_Z[source];
                            lambda = source_lambda[source];

                            /* ... scattering vector calculation ... */

                            /* sweep over phi angles */
                            for(phi_tic = 0; phi_tic < phisteps; ++phi_tic)
                            {
                                /* ... crystal rotation ... */

[2025-10-06T20:39:13] tokens used: 74,863

[2025-10-06T20:39:15] thinking

**Searching for F_latt portion**
[2025-10-06T20:39:16] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "F_latt" src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:17] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "F_latt" src/nanobrag_torch/simulator.py' succeeded in 793ms:
216:    #     F_latt = sin(M_PI*Na*h)*sin(M_PI*Nb*k)*sin(M_PI*Nc*l)/sin(M_PI*h)/sin(M_PI*k)/sin(M_PI*l);
218:    # F_latt = 1.0;
222:    #     double F_latt_a = 1.0, F_latt_b = 1.0, F_latt_c = 1.0;
224:    #         F_latt_a = sincg(M_PI*h,Na);
225:    #         F_latt *= F_latt_a;
228:    #         F_latt_b = sincg(M_PI*k,Nb);
229:    #         F_latt *= F_latt_b;
232:    #         F_latt_c = sincg(M_PI*l,Nc);
233:    #         F_latt *= F_latt_c;
239:    # "SQUARE (grating): F_latt = sincg(π·h, Na) · sincg(π·k, Nb) · sincg(π·l, Nc)"
250:        F_latt_a = sincg(torch.pi * h, Na)
251:        F_latt_b = sincg(torch.pi * k, Nb)
252:        F_latt_c = sincg(torch.pi * l, Nc)
253:        F_latt = F_latt_a * F_latt_b * F_latt_c
263:        F_latt = Na * Nb * Nc * 0.723601254558268 * sinc3(
282:        F_latt = Na * Nb * Nc * torch.exp(-(rad_star_sqr / 0.63) * fudge)
300:        F_latt = torch.where(inside_cutoff,
307:    F_total = F_cell * F_latt
725:                                    /* ... F_cell and F_latt calculation ... */
728:                                    I += F_cell*F_cell*F_latt*F_latt;
[2025-10-06T20:39:17] tokens used: 77,286

[2025-10-06T20:39:25] thinking

**Analyzing tensor usage and function calls**
[2025-10-06T20:39:27] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "F_cell" src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:27] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "F_cell" src/nanobrag_torch/simulator.py' succeeded in 886ms:
204:    F_cell = crystal_get_structure_factor(h0, k0, l0)
206:    # Ensure F_cell is on the same device as h (device-neutral implementation per Core Rule #16)
208:    if F_cell.device != h.device:
209:        F_cell = F_cell.to(device=h.device)
307:    F_total = F_cell * F_latt
725:                                    /* ... F_cell and F_latt calculation ... */
728:                                    I += F_cell*F_cell*F_latt*F_latt;
1308:                    F_cell = self.crystal.get_structure_factor(
1313:                    print(f"TRACE_PY: F_cell {F_cell:.15g}")
1316:                    I_before_scaling = (F_cell * F_latt) ** 2
[2025-10-06T20:39:27] tokens used: 78,389

[2025-10-06T20:39:37] thinking

**Verifying structure factor definition**
[2025-10-06T20:39:38] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:39] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,200p' src/nanobrag_torch/models/crystal.py" succeeded in 939ms:
"""
Crystal model for nanoBragg PyTorch implementation.

This module defines the Crystal class responsible for managing unit cell,
orientation, and structure factor data.

NOTE: The default parameters in this file are configured to match the 'simple_cubic'
golden test case, which uses a 10 Å unit cell and a 500×500×500 cell crystal size.
"""

from typing import Optional, Tuple

import math
import torch

from ..config import CrystalConfig, BeamConfig
from ..utils.geometry import angles_to_rotation_matrix
from ..io.hkl import read_hkl_file, try_load_hkl_or_fdump


[2025-10-06T20:39:39] tokens used: 79,041

[2025-10-06T20:39:50] thinking

**Analyzing vectorization and scaling goals**
[2025-10-06T20:39:50] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "VECTOR-TRICUBIC-001" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:51] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "VECTOR-TRICUBIC-001" -n docs/fix_plan.md' succeeded in 770ms:
19:| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
1233:## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
[2025-10-06T20:39:51] tokens used: 81,881

[2025-10-06T20:39:53] thinking

**Inspecting section**
[2025-10-06T20:39:53] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1233,1400p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:54] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1233,1400p' docs/fix_plan.md" succeeded in 761ms:
## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
- Spec/AT: specs/spec-a-core.md §4 (structure factor sampling), specs/spec-a-parallel.md §2.3 (tricubic acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4 (vectorization strategy), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, nanoBragg.c lines 2604–3278 (polin3/polin2/polint) and 3375–3450 (detector absorption loop).
- Priority: High
- Status: in_planning (Phase A evidence outstanding)
- Owner/Date: galph/2025-10-17
- Plan Reference: `plans/active/vectorization.md`
- Reproduction (C & PyTorch):
  * PyTorch baseline tests: `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py tests/test_at_abs_001.py -v`
  * Optional microbenchmarks (to be created per plan Phase A): `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/sample_tricubic_baseline.py`
  * Shapes/ROI: 256² & 512² detectors for microbench; oversample 1; structure-factor grid enabling tricubic.
- First Divergence (if known): Current tricubic path drops to nearest-neighbour fallback for batched pixel grids, emitting warnings and forfeiting accuracy/performance; detector absorption still loops over `thicksteps`, preventing full vectorization and creating hotspots in profiler traces (see reports/benchmarks/20250930-165726-compile-cache/analysis.md).
- Next Actions:
  1. Execute plan Phase A tasks A1–A3: author the reusable `scripts/benchmarks/tricubic_baseline.py` and `absorption_baseline.py` harnesses, capture pytest + timing artifacts under `reports/2025-10-vectorization/phase_a/`, and record Attempt #1 in this entry.
  2. Complete Phase B design memo (tensor shapes, broadcasting, gradients) before editing code; update this item with design references (`phase_b/design_notes.md`).
  3. Prioritise Phase C/D implementation work on tricubic interpolation, followed by Phase E parity/perf validation. Detector absorption vectorization (Phase F) follows once tricubic work is stable.
- Attempts History:
  * (pending) — Capture Phase A baseline artifacts and update this log.
- Risks/Assumptions: Must maintain differentiability (no `.item()`, no `torch.linspace` with tensor bounds), preserve device/dtype neutrality (CPU/CUDA parity), and obey Protected Assets rule (all new scripts under `scripts/benchmarks/`). Large tensor indexing may increase memory pressure; ensure ROI caching still works.
- Exit Criteria (quote thresholds from spec):
  * specs/spec-a-parallel.md §2.3 tricubic acceptance tests run without warnings and match C parity within documented tolerances (corr≥0.9995, ≤1e-12 structural duality where applicable).
[2025-10-06T20:39:54] tokens used: 82,216

[2025-10-06T20:39:57] thinking

**Preparing for deep code analysis**
[2025-10-06T20:39:58] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && ls reports/2025-10-cli-flags/phase_k/f_latt_fix' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:39:59] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && ls reports/2025-10-cli-flags/phase_k/f_latt_fix' succeeded in 795ms:
c_image.npy
metrics_after.json
py_image.npy
scaling_summary.md
test_metrics_failure.json
trace_diff.txt
trace_py_after.log
trace_py_after_133134.log
[2025-10-06T20:39:59] tokens used: 84,228

[2025-10-06T20:40:02] thinking

**Investigating existing execution logs**
[2025-10-06T20:40:04] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:05] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md' succeeded in 885ms:
# CLI-FLAGS-003 Phase K2: Scaling Chain Analysis Post SAMPLE-Pivot Fix

**Date:** 2025-10-06
**Commit:** 3d03af4f501f78462a626d15b04a955e5f839b8d
**Pixel:** (slow=1039, fast=685)

## Executive Summary

After implementing the SAMPLE-pivot fix in Phase H6, we regenerated PyTorch traces and recomputed scaling ratios. The analysis reveals:

- **Improved geometry:** F_latt_a and F_latt_c components now match C within ~3% error
- **Remaining blocker:** F_latt_b diverges by 21.6%, causing 25.5% error in total F_latt
- **Secondary issues:** Polarization factor still 1.0 in PyTorch vs 0.913 in C (9.6% error)
- **Final intensity:** 11.4% higher in PyTorch (497 vs 446) due to cascading errors

## Detailed Scaling Chain Analysis

### Perfect Matches (0% error)
- **F_cell:** 300.58 (both) ✅
- **steps:** 10 (both) ✅
[2025-10-06T20:40:05] tokens used: 84,559

[2025-10-06T20:40:07] thinking

**Checking metric discrepancies**
[2025-10-06T20:40:09] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:10] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json' succeeded in 876ms:
{
  "environment": {
    "python_version": "3.13.7 | packaged by Anaconda, Inc. | (main, Sep  9 2025, 19:59:03) [GCC 11.2.0]",
    "torch_version": "2.8.0+cu128",
    "cuda_available": true,
    "default_dtype": "torch.float32",
    "commit_hash": "3d03af4f501f78462a626d15b04a955e5f839b8d"
  },
  "scaling_ratios": {
    "F_cell": {
      "c_value": 300.58,
      "py_value": 300.58,
      "ratio": 1.0,
      "abs_delta": 0.0,
      "rel_error": 0.0
    },
    "F_latt": {
      "c_value": 35636.0822038919,
      "py_value": 44715.9601587609,
      "ratio": 1.2547945058303116,
[2025-10-06T20:40:10] tokens used: 86,796

[2025-10-06T20:40:16] thinking

**Analyzing data inconsistencies and logs**
[2025-10-06T20:40:17] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && head -n 40 reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_diff.txt' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:18] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && head -n 40 reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_diff.txt' succeeded in 794ms:
--- reports/2025-10-cli-flags/phase_j/trace_c_scaling.log	2025-10-06 03:22:03.165000376 -0700
+++ reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log	2025-10-06 13:31:20.985565166 -0700
@@ -1,308 +1,75 @@
-WARNING: auto-generating odet_vector
-nanoBragg nanocrystal diffraction simulator - James Holton and Ken Frankel 5-17-17
-custom convention selected.
-pivoting detector around sample
-DETECTOR_FAST_AXIS 0.999982004873912 -0.00599800002923425 -0.000118000000575132
-DETECTOR_SLOW_AXIS -0.0059979996566955 -0.999969942765222 -0.0049129997187971
-DETECTOR_NORMAL_AXIS -8.85282813644494e-05 0.00491361907271126 -0.999987924182263
-DETECTOR_PIX0_VECTOR -0.216475836204836 0.216343050492215 -0.230192414300537
-XDS incident beam: 0.00063187 0.00490992 0.999988
-reading A.mat
-TRACE: Raw matrix values from file:
-TRACE:   a_star (raw) = [-0.0283771, -0.0287139, 0.0105005]
-TRACE:   b_star (raw) = [-0.00305386, 0.0101955, -0.0320944]
-TRACE:   c_star (raw) = [0.0253582, -0.0140005, -0.0103605]
-TRACE:   lambda0 = 0.9768 Angstroms
-TRACE:   scaling factor = 1e-10/lambda0 = 1.02375
-TRACE: After wavelength correction:
[2025-10-06T20:40:18] tokens used: 88,402

[2025-10-06T20:40:24] thinking

**Comparing trace logs for errors**
[2025-10-06T20:40:25] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "TRACE_PY: Miller" -n reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:26] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "TRACE_PY: Miller" -n reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log' exited 1 in 818ms:

[2025-10-06T20:40:26] tokens used: 110,764

[2025-10-06T20:40:27] thinking

**Checking text near F_latt entries**
[2025-10-06T20:40:28] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '110,170p' reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:29] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '110,170p' reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log" succeeded in 770ms:

[2025-10-06T20:40:29] tokens used: 112,782

[2025-10-06T20:40:32] thinking

**Checking file length**
[2025-10-06T20:40:33] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:34] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log' succeeded in 879ms:
# Tracing pixel (slow=1039, fast=685)
# Trace complete
TRACE_PY:detector_convention=CUSTOM
TRACE_PY:angles_rad=rotx:0 roty:0 rotz:0 twotheta:0
TRACE_PY:beam_center_m=Xclose:0.217742295 Yclose:0.21390708 pixel_mm:0.172
TRACE_PY:initial_fdet=0.999982 -0.005998 -0.000118
TRACE_PY:initial_sdet=-0.005998 -0.99997 -0.004913
TRACE_PY:initial_odet=-8.8e-05 0.004914 -0.999988
TRACE_PY:Fclose_m=0.217742295
TRACE_PY:Sclose_m=0.21390708
TRACE_PY:close_distance_m=0.231274663460392
TRACE_PY:ratio=0.999987814780285
TRACE_PY:distance_m=0.23127748162732
TRACE_PY:term_fast_before_rot=-0.21773837563869 0.00130601828541 2.569359081e-05
TRACE_PY:term_slow_before_rot=0.00128301466584 0.2139006627876 0.00105092548404
TRACE_PY:term_close_before_rot=-2.03521703845145e-05 0.00113648369624436 -0.23127188816443
TRACE_PY:pix0_before_rotation=-0.21647571314293 0.21634316475225 -0.23019526562923
TRACE_PY:pix0_after_rotz=-0.21647571314293 0.21634316475225 -0.23019526562923
TRACE_PY:pix0_after_twotheta=-0.21647571314293 0.21634316475225 -0.23019526562923
TRACE_PY:fdet_after_rotz=0.999982 -0.005998 -0.000118
[2025-10-06T20:40:34] tokens used: 114,024

[2025-10-06T20:40:36] thinking

**Comparing hkl_frac to expected values**
[2025-10-06T20:40:37] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "F_latt" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:38] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "F_latt" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 740ms:
185:TRACE_C: F_latt_a 35.8890618450812
186:TRACE_C: F_latt_b 38.6324938361129
187:TRACE_C: F_latt_c 25.7024842831081
188:TRACE_C: F_latt 35636.0822038919
[2025-10-06T20:40:38] tokens used: 115,872

[2025-10-06T20:40:40] thinking

**Searching for HKL fraction information**
[2025-10-06T20:40:41] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '150,210p' reports/2025-10-cli-flags/phase_j/trace_c_scaling.log" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:41] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '150,210p' reports/2025-10-cli-flags/phase_j/trace_c_scaling.log" succeeded in 776ms:
0% done
0% done
0% done
0% done
0% done
0% done
0% done
0% done
0% done
0% done
0% done
0% done
0% done
0% done
TRACE_C: pix0_vector_meters -0.216475836204836 0.216343050492215 -0.230192414300537
TRACE_C: fdet_vec 0.999982004873912 -0.00599800002923425 -0.000118000000575132
TRACE_C: sdet_vec -0.0059979996566955 -0.999969942765222 -0.0049129997187971
TRACE_C: pixel_pos_meters -0.0996443642887915 0.0368472243540029 -0.231084742080328
TRACE_C: R_distance_meters 0.254336146269938
TRACE_C: omega_pixel_sr 4.15867865980257e-07
[2025-10-06T20:40:41] tokens used: 116,896

[2025-10-06T20:40:52] thinking

**Analyzing discrepancies in rotation and misset calculations**
[2025-10-06T20:40:55] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def get_rotated_real_vectors" -n src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:40:56] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def get_rotated_real_vectors" -n src/nanobrag_torch/models/crystal.py' succeeded in 979ms:
799:    def get_rotated_real_vectors(self, config: "CrystalConfig") -> Tuple[
[2025-10-06T20:40:56] tokens used: 119,407
[2025-10-06T20:40:59] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '799,1040p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:41:00] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '799,1040p' src/nanobrag_torch/models/crystal.py" succeeded in 698ms:
    def get_rotated_real_vectors(self, config: "CrystalConfig") -> Tuple[
        Tuple[torch.Tensor, torch.Tensor, torch.Tensor],
        Tuple[torch.Tensor, torch.Tensor, torch.Tensor],
    ]:
        """
        Get real-space and reciprocal-space lattice vectors after applying all rotations.

        This method applies rotations in the correct physical sequence:
        1. Static missetting rotation (already applied to reciprocal vectors in compute_cell_tensors)
        2. Dynamic spindle (phi) rotation
        3. Mosaic domain rotations

        The method now returns both real-space and reciprocal-space vectors to support
        the correct physics implementation where Miller indices are calculated using
        reciprocal-space vectors.

        C-Code Implementation Reference (from nanoBragg.c):

        ---
        FUTURE WORK: Initial Orientation (`-misset`), applied once (lines 1521-1527):
[2025-10-06T20:41:00] tokens used: 120,183

[2025-10-06T20:41:08] thinking

**Analyzing rotation matrix discrepancies**
[2025-10-06T20:41:09] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def compute_cell_tensors" src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:41:09] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def compute_cell_tensors" src/nanobrag_torch/models/crystal.py' succeeded in 842ms:
412:    def compute_cell_tensors(self) -> dict:
[2025-10-06T20:41:09] tokens used: 123,974
[2025-10-06T20:41:17] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '412,640p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:41:18] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '412,640p' src/nanobrag_torch/models/crystal.py" succeeded in 788ms:
    def compute_cell_tensors(self) -> dict:
        """
        Calculate real and reciprocal space lattice vectors from cell parameters.

        This is the central, differentiable function for all geometry calculations.
        Uses the nanoBragg.c convention to convert cell parameters (a,b,c,α,β,γ)
        to real-space and reciprocal-space lattice vectors.

        This method now supports general triclinic cells and maintains full
        differentiability for all six cell parameters. The computation graph
        is preserved for gradient-based optimization.

        The implementation follows the nanoBragg.c default orientation convention:
        - a* is placed purely along the x-axis
        - b* is placed in the x-y plane
        - c* fills out 3D space

        C-Code Implementation Reference (from nanoBragg.c):

        Volume calculation from cell parameters (lines 1798-1808):
[2025-10-06T20:41:18] tokens used: 183,094

[2025-10-06T20:41:28] thinking

**Continuing to review application**
[2025-10-06T20:41:29] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '640,799p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:41:30] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '640,799p' src/nanobrag_torch/models/crystal.py" succeeded in 951ms:
        ):
            # Apply misset rotation to initial reciprocal vectors only
            # C-code reference (nanoBragg.c lines 2025-2034):
            # rotate(a_star,a_star,misset[1],misset[2],misset[3]);
            # rotate(b_star,b_star,misset[1],misset[2],misset[3]);
            # rotate(c_star,c_star,misset[1],misset[2],misset[3]);
            from ..utils.geometry import angles_to_rotation_matrix, rotate_umat
            # Preserve gradient flow: convert to tensor only if not already a tensor
            misset_rad = []
            for angle in self.config.misset_deg:
                if isinstance(angle, torch.Tensor):
                    # Already a tensor - just convert dtype/device while preserving gradients
                    angle_tensor = angle.to(dtype=self.dtype, device=self.device)
                else:
                    # Scalar - create new tensor
                    angle_tensor = torch.tensor(angle, dtype=self.dtype, device=self.device)
                misset_rad.append(torch.deg2rad(angle_tensor))
            R_misset = angles_to_rotation_matrix(misset_rad[0], misset_rad[1], misset_rad[2])
            a_star = rotate_umat(a_star, R_misset)
            b_star = rotate_umat(b_star, R_misset)
[2025-10-06T20:41:30] tokens used: 186,682

[2025-10-06T20:41:37] thinking

**Investigating rotation discrepancies**
[2025-10-06T20:41:38] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def rotate_axis" -n src/nanobrag_torch/utils/geometry.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:41:38] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def rotate_axis" -n src/nanobrag_torch/utils/geometry.py' succeeded in 871ms:
78:def rotate_axis(v: torch.Tensor, axis: torch.Tensor, phi: torch.Tensor) -> torch.Tensor:
[2025-10-06T20:41:38] tokens used: 192,381
[2025-10-06T20:41:44] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' src/nanobrag_torch/utils/geometry.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:41:45] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' src/nanobrag_torch/utils/geometry.py" succeeded in 810ms:
"""
Vectorized 3D geometry utilities for nanoBragg PyTorch implementation.

This module contains PyTorch implementations of all vector and geometry
operations from the original C code, designed for broadcasting and GPU acceleration.
"""

from typing import Tuple

import torch


def dot_product(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:
    """
    Calculate dot product of vectors x and y.

    Args:
        x, y: Tensors with shape (..., 3) representing 3D vectors

    Returns:
[2025-10-06T20:41:45] tokens used: 194,898

[2025-10-06T20:41:54] thinking

**Analyzing vector and orientation discrepancies**

I’m investigating small differences in vectors and orientations between C and Pyro, noticing tiny deviations likely from geometry or sampling pivots. The discrepancies in `pixel_pos_meters`, `pix0_vector`, and rotated angles hint that orientation handling or tensor conversions might be off, so I plan to verify how real vectors and tensors are computed and check the `A.mat` file for related details.
[2025-10-06T20:41:56] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat A.mat' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:41:57] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && cat A.mat' succeeded in 806ms:
-0.02837711 -0.00305386 0.02535816
-0.02871390 0.01019549 -0.01400049
0.01050048 -0.03209440 -0.01036054
[2025-10-06T20:41:57] tokens used: 197,071

[2025-10-06T20:42:02] thinking

**Investigating CLI parsing for orientation**
[2025-10-06T20:42:03] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "mosflm_a_star" -n src' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:42:04] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "mosflm_a_star" -n src' succeeded in 769ms:
src/nanobrag_torch/__main__.py:432:        config['mosflm_a_star'] = a_star  # numpy array from read_mosflm_matrix
src/nanobrag_torch/__main__.py:844:                mosflm_a_star=config.get('mosflm_a_star'),
src/nanobrag_torch/config.py:126:    mosflm_a_star: Optional[np.ndarray] = None  # MOSFLM a* reciprocal vector (Å⁻¹)
src/nanobrag_torch/models/crystal.py:548:            hasattr(self.config, "mosflm_a_star") and self.config.mosflm_a_star is not None
src/nanobrag_torch/models/crystal.py:555:                self.config.mosflm_a_star,
[2025-10-06T20:42:04] tokens used: 197,393

[2025-10-06T20:42:06] thinking

**Inspecting CLI reading in main.py**
[2025-10-06T20:42:07] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '360,460p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:42:08] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '360,460p' src/nanobrag_torch/__main__.py" succeeded in 758ms:
                        help='Disable progress meter')
    parser.add_argument('-progress', action='store_true',
                        help='Enable progress meter')
    parser.add_argument('-seed', type=int,
                        help='Noise RNG seed')
    parser.add_argument('-show_config', '-echo_config', action='store_true',
                        help='Print configuration parameters for debugging')

    # Performance options (PERF-PYTORCH-006)
    parser.add_argument('-dtype', type=str, choices=['float32', 'float64'],
                        default='float32',
                        help='Floating point precision (float32 for speed, float64 for accuracy)')
    parser.add_argument('-device', type=str, choices=['cpu', 'cuda'],
                        default='cpu',
                        help='Device for computation (cpu or cuda)')

    # Explicitly handle unsupported flags from the spec
    parser.add_argument('-dispstep', dest='_unsupported_dispstep',
                        action=UnsupportedFlagAction,
                        supported_alternative='-dispsteps <int>',
[2025-10-06T20:42:08] tokens used: 197,791

[2025-10-06T20:42:11] thinking

**Searching for read_mosflm_matrix definition**
[2025-10-06T20:42:11] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def read_mosflm_matrix" -n src' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:42:12] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def read_mosflm_matrix" -n src' succeeded in 767ms:
src/nanobrag_torch/io/mosflm.py:12:def read_mosflm_matrix(filepath: Union[str, Path], wavelength_A: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
[2025-10-06T20:42:12] tokens used: 199,167
[2025-10-06T20:42:21] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' src/nanobrag_torch/io/mosflm.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:42:22] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,160p' src/nanobrag_torch/io/mosflm.py" succeeded in 822ms:
"""MOSFLM matrix file I/O utilities.

This module provides functions for reading MOSFLM-style orientation matrices,
which contain reciprocal lattice vectors scaled by wavelength.
"""

import numpy as np
from pathlib import Path
from typing import Tuple, Union


def read_mosflm_matrix(filepath: Union[str, Path], wavelength_A: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Read MOSFLM A matrix file and extract reciprocal lattice vectors.

    The MOSFLM A matrix format contains 9 values (3x3 matrix) where each row
    is a reciprocal lattice vector (a*, b*, c*) in units of Å^-1·(1/λ_Å).

    C-Code Implementation Reference (from nanoBragg.c, lines 3135-3148):
    ```c
    if(matfilename != NULL)
[2025-10-06T20:42:22] tokens used: 199,443

[2025-10-06T20:42:28] thinking

**Analyzing discrepancies in rotation vectors**

I'm examining slight differences in `rot_b_angstroms` values between numpy and pyro, suspecting rounding or scaling effects. I plan to verify actual orientation data from pyro logs and run a Python snippet to check the expected `b_vec` from `mosflm` data for comparison.
[2025-10-06T20:42:37] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python - <<'PY'
import numpy as np
from nanobrag_torch.io.mosflm import read_mosflm_matrix, reciprocal_to_real_cell
from nanobrag_torch.config import CrystalConfig
from nanobrag_torch.models.crystal import Crystal
import torch

A_path = 'A.mat'
a_star, b_star, c_star = read_mosflm_matrix(A_path, wavelength_A=0.9768)
print('a_star', a_star)
print('b_star', b_star)
print('c_star', c_star)

cell = reciprocal_to_real_cell(a_star, b_star, c_star)
print('cell', cell)

config = CrystalConfig(
    cell_a=cell[0], cell_b=cell[1], cell_c=cell[2],
    cell_alpha=cell[3], cell_beta=cell[4], cell_gamma=cell[5],
    mosflm_a_star=a_star, mosflm_b_star=b_star, mosflm_c_star=c_star,
    phi_steps=10,
)

crystal = Crystal(config=config, device=torch.device('cpu'), dtype=torch.float64)
# disable sample clipping? not needed
cell_tensors = crystal.compute_cell_tensors()
print('a vec', cell_tensors['a'])
print('b vec', cell_tensors['b'])
print('c vec', cell_tensors['c'])

(a,b,c),(a_star_rot,b_star_rot,c_star_rot) = crystal.get_rotated_real_vectors(config)
print('rotated a (phi=0, mos=0)', a[0,0])
print('rotated b', b[0,0])
print('rotated c', c[0,0])
PY
" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:42:40] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python - <<'PY'
import numpy as np
from nanobrag_torch.io.mosflm import read_mosflm_matrix, reciprocal_to_real_cell
from nanobrag_torch.config import CrystalConfig
from nanobrag_torch.models.crystal import Crystal
import torch

A_path = 'A.mat'
a_star, b_star, c_star = read_mosflm_matrix(A_path, wavelength_A=0.9768)
print('a_star', a_star)
print('b_star', b_star)
print('c_star', c_star)

cell = reciprocal_to_real_cell(a_star, b_star, c_star)
print('cell', cell)

config = CrystalConfig(
    cell_a=cell[0], cell_b=cell[1], cell_c=cell[2],
    cell_alpha=cell[3], cell_beta=cell[4], cell_gamma=cell[5],
    mosflm_a_star=a_star, mosflm_b_star=b_star, mosflm_c_star=c_star,
    phi_steps=10,
)

crystal = Crystal(config=config, device=torch.device('cpu'), dtype=torch.float64)
# disable sample clipping? not needed
cell_tensors = crystal.compute_cell_tensors()
print('a vec', cell_tensors['a'])
print('b vec', cell_tensors['b'])
print('c vec', cell_tensors['c'])

(a,b,c),(a_star_rot,b_star_rot,c_star_rot) = crystal.get_rotated_real_vectors(config)
print('rotated a (phi=0, mos=0)', a[0,0])
print('rotated b', b[0,0])
print('rotated c', c[0,0])
PY
" succeeded in 3.15s:
a_star [-0.0290511  -0.02939588  0.01074988]
b_star [-0.00312639  0.01043764 -0.03285667]
c_star [ 0.02596044 -0.01433302 -0.01060661]
cell (np.float64(26.751387617035686), np.float64(31.309964100634847), np.float64(33.673354158433106), np.float64(88.68697425973355), np.float64(71.52948214210114), np.float64(68.13752800177875))
a vec tensor([-14.3563, -21.8718,  -5.5820], dtype=torch.float64)
b vec tensor([-11.4987,   0.7173, -29.1132], dtype=torch.float64)
c vec tensor([ 21.0700, -24.3893,  -9.7527], dtype=torch.float64)
rotated a (phi=0, mos=0) tensor([-14.3563, -21.8718,  -5.5820], dtype=torch.float64)
rotated b tensor([-11.4987,   0.7173, -29.1132], dtype=torch.float64)
rotated c tensor([ 21.0700, -24.3893,  -9.7527], dtype=torch.float64)
[2025-10-06T20:42:40] tokens used: 201,949

[2025-10-06T20:42:47] thinking

**Analyzing vector orientation discrepancies**
[2025-10-06T20:42:49] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python - <<'PY'
import numpy as np
from nanobrag_torch.io.mosflm import read_mosflm_matrix

matrix = np.array([
[-0.02837711, -0.00305386, 0.02535816],
[-0.02871390, 0.01019549, -0.01400049],
[0.01050048, -0.03209440, -0.01036054],
])
print('raw matrix', matrix)
print('transposed', matrix.T)
print('no transpose columns', matrix[:,0])
print('C orientation? maybe more?')
PY
" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:42:51] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python - <<'PY'
import numpy as np
from nanobrag_torch.io.mosflm import read_mosflm_matrix

matrix = np.array([
[-0.02837711, -0.00305386, 0.02535816],
[-0.02871390, 0.01019549, -0.01400049],
[0.01050048, -0.03209440, -0.01036054],
])
print('raw matrix', matrix)
print('transposed', matrix.T)
print('no transpose columns', matrix[:,0])
print('C orientation? maybe more?')
PY
" succeeded in 1.73s:
raw matrix [[-0.02837711 -0.00305386  0.02535816]
 [-0.0287139   0.01019549 -0.01400049]
 [ 0.01050048 -0.0320944  -0.01036054]]
transposed [[-0.02837711 -0.0287139   0.01050048]
 [-0.00305386  0.01019549 -0.0320944 ]
 [ 0.02535816 -0.01400049 -0.01036054]]
no transpose columns [-0.02837711 -0.0287139   0.01050048]
C orientation? maybe more?
[2025-10-06T20:42:51] tokens used: 203,941

[2025-10-06T20:43:10] thinking

**Verifying matrix reading and vector discrepancies**

I'm checking that the Python matrix reading matches the C approach exactly, confirming that the orientation of a_star, b_star, and c_star arrays line up correctly. I'm curious about the difference observed in the b vector between the C and Python (pyro) computations and considering replicating the C calculations step-by-step in Python to isolate the cause, including nuances like rescaling, cell volume, and potential sample clipping adjustments. Next, I'll investigate how sample clipping in `Crystal.__init__` might be influencing the vectors.
[2025-10-06T20:43:12] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "_apply_sample_clipping" -n src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:43:13] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "_apply_sample_clipping" -n src/nanobrag_torch/models/crystal.py' succeeded in 1.07s:
65:            self._apply_sample_clipping(beam_config)
1101:    def _apply_sample_clipping(self, beam_config: BeamConfig) -> None:
[2025-10-06T20:43:13] tokens used: 206,382
[2025-10-06T20:43:16] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1101,1250p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:43:17] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1101,1250p' src/nanobrag_torch/models/crystal.py" succeeded in 789ms:
    def _apply_sample_clipping(self, beam_config: BeamConfig) -> None:
        """Apply sample clipping based on beam size (AT-FLU-001).

        Per spec: when beamsize > 0 and smaller than sample_y or sample_z,
        those sample dimensions SHALL be clipped to beamsize and a warning printed.

        Args:
            beam_config: Beam configuration containing beamsize_mm
        """
        beamsize_m = beam_config.beamsize_mm / 1000.0  # Convert mm to meters

        # Check and clip sample_y
        if self.config.sample_y is not None and beamsize_m < self.config.sample_y:
            print(f"Warning: Clipping sample_y from {self.config.sample_y:.6e} m to beamsize {beamsize_m:.6e} m")
            self.config.sample_y = beamsize_m

        # Check and clip sample_z
        if self.config.sample_z is not None and beamsize_m < self.config.sample_z:
            print(f"Warning: Clipping sample_z from {self.config.sample_z:.6e} m to beamsize {beamsize_m:.6e} m")
            self.config.sample_z = beamsize_m
[2025-10-06T20:43:17] tokens used: 206,694

[2025-10-06T20:43:36] thinking

**Analyzing vector discrepancies origins**
[2025-10-06T20:43:37] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "hkl_frac" src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:43:38] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "hkl_frac" src/nanobrag_torch/simulator.py' succeeded in 935ms:
1286:                    print(f"TRACE_PY: hkl_frac {h:.15g} {k:.15g} {l:.15g}")
[2025-10-06T20:43:38] tokens used: 217,427

[2025-10-06T20:43:40] thinking

**Searching for computation location**
[2025-10-06T20:43:41] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1160,1230p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:43:42] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1160,1230p' src/nanobrag_torch/simulator.py" succeeded in 785ms:
        if self.printout_pixel:
            # printout_pixel is [fast, slow] from CLI
            target_fast = self.printout_pixel[0]
            target_slow = self.printout_pixel[1]

            # Only output for this specific pixel
            if 0 <= target_slow < physical_intensity.shape[0] and 0 <= target_fast < physical_intensity.shape[1]:
                print(f"\n=== Pixel ({target_fast}, {target_slow}) [fast, slow] ===")
                print(f"  Final intensity: {physical_intensity[target_slow, target_fast].item():.6e}")
                print(f"  Normalized intensity: {normalized_intensity[target_slow, target_fast].item():.6e}")
                if pixel_coords_meters is not None:
                    coords = pixel_coords_meters[target_slow, target_fast]
                    print(f"  Position (meters): ({coords[0].item():.6e}, {coords[1].item():.6e}, {coords[2].item():.6e})")
                    # Convert to Angstroms for physics display
                    coords_ang = coords * 1e10
                    print(f"  Position (Å): ({coords_ang[0].item():.3f}, {coords_ang[1].item():.3f}, {coords_ang[2].item():.3f})")
                if omega_pixel is not None:
                    print(f"  Solid angle: {omega_pixel[target_slow, target_fast].item():.6e}")
                if polarization is not None:
                    print(f"  Polarization: {polarization[target_slow, target_fast].item():.4f}")
[2025-10-06T20:43:42] tokens used: 218,725

[2025-10-06T20:43:49] thinking

**Searching for physics computations**
[2025-10-06T20:43:49] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "compute_physics_for_position" -n src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:43:50] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "compute_physics_for_position" -n src/nanobrag_torch/simulator.py' succeeded in 794ms:
19:def compute_physics_for_position(
53:    This function was refactored from a bound method (`Simulator._compute_physics_for_position`)
337:            # NOTE: incident_beam_direction is cloned in _compute_physics_for_position wrapper
588:        # The wrapper method _compute_physics_for_position should NOT be compiled
598:            self._compiled_compute_physics = compute_physics_for_position
603:                        compute_physics_for_position
607:                        compute_physics_for_position
612:                self._compiled_compute_physics = compute_physics_for_position
614:    def _compute_physics_for_position(self, pixel_coords_angstroms, rot_a, rot_b, rot_c, rot_a_star, rot_b_star, rot_c_star, incident_beam_direction=None, wavelength=None, source_weights=None):
615:        """Compatibility shim - calls the pure function compute_physics_for_position.
619:        pure function `compute_physics_for_position`. This enables safe cross-instance
622:        See docstring of `compute_physics_for_position` for full documentation.
841:        # Weights are applied during accumulation (inside compute_physics_for_position), then we normalize by count.
916:                physics_intensity_flat = self._compute_physics_for_position(
924:                # The weighted sum over sources is done inside _compute_physics_for_position
928:                physics_intensity_flat = self._compute_physics_for_position(
938:            # PERF-PYTORCH-004 P3.0b: Polarization is now applied per-source inside compute_physics_for_position
999:                intensity = self._compute_physics_for_position(
1005:                # The weighted sum over sources is done inside _compute_physics_for_position
1008:                intensity = self._compute_physics_for_position(
[2025-10-06T20:43:50] tokens used: 220,197

[2025-10-06T20:43:53] thinking

**Checking top-of-file definition**
[2025-10-06T20:43:54] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,220p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:43:55] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,220p' src/nanobrag_torch/simulator.py" succeeded in 827ms:
"""
Main Simulator class for nanoBragg PyTorch implementation.

This module orchestrates the entire diffraction simulation, taking Crystal and
Detector objects as input and producing the final diffraction pattern.
"""

from typing import Optional, Callable

import torch

from .config import BeamConfig, CrystalConfig, CrystalShape
from .models.crystal import Crystal
from .models.detector import Detector
from .utils.geometry import dot_product
from .utils.physics import sincg, sinc3, polarization_factor


def compute_physics_for_position(
    # Geometry inputs
[2025-10-06T20:43:55] tokens used: 220,813

[2025-10-06T20:44:07] thinking

**Analyzing orientation and vector calculation differences**
[2025-10-06T20:44:08] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "vector_rescale" nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:09] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "vector_rescale" nanoBragg.c' exited 2 in 1.01s:
rg: nanoBragg.c: IO error for operation on nanoBragg.c: No such file or directory (os error 2)
[2025-10-06T20:44:09] tokens used: 224,626

[2025-10-06T20:44:13] thinking

**Confirming file location**
[2025-10-06T20:44:14] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && ls' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:14] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && ls' succeeded in 761ms:
1.0
1e6
A.mat
AGENTS.md
AT012_TRACE_ANALYSIS.md
CLAUDE.md
COMMIT_MESSAGE.md
DEBUGGING_NIGHTMARE_PREVENTION_TOOLKIT.md
FINAL_DIAGNOSIS_REPORT.md
HYPOTHESIS_TESTING_RESULTS.md
HYPOTHESIS_TEST_RESULTS.md
LICENSE
Makefile
P1.hkl
PARALLEL_TEST_COMMANDS.md
PARALLEL_VALIDATION_ACCEPTANCE_TESTS.md
PERFORMANCE_ANALYSIS.md
PHASE_4_1_DIAGNOSTIC_REPORT.md
PHASE_5_FINAL_VALIDATION_REPORT.md
PHASE_5_IMPLEMENTATION_SUMMARY.md
[2025-10-06T20:44:14] tokens used: 253,033

[2025-10-06T20:44:27] thinking

**Locating nanoBragg source file**
[2025-10-06T20:44:28] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && find . -name 'nanoBragg.c'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:29] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && find . -name 'nanoBragg.c'" succeeded in 1.30s:
./golden_suite_generator/nanoBragg.c
[2025-10-06T20:44:29] tokens used: 254,807

[2025-10-06T20:44:31] thinking

**Planning to use rg command**
[2025-10-06T20:44:32] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "vector_rescale" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:33] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "vector_rescale" golden_suite_generator/nanoBragg.c' succeeded in 785ms:
116:double vector_rescale(double *vector, double *new_vector, double magnitude);
2145:        vector_rescale(b_star_cross_c_star,b_star_cross_c_star,a[0]/V_cell);
2146:        vector_rescale(c_star_cross_a_star,c_star_cross_a_star,b[0]/V_cell);
2147:        vector_rescale(a_star_cross_b_star,a_star_cross_b_star,c[0]/V_cell);
4353:double vector_rescale(double *vector, double *new_vector, double new_magnitude) {
[2025-10-06T20:44:33] tokens used: 255,073

[2025-10-06T20:44:36] thinking

**Reviewing variable definitions around line 2130**
[2025-10-06T20:44:37] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2060,2180p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:37] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2060,2180p' golden_suite_generator/nanoBragg.c" succeeded in 764ms:
            /* calculate reciprocal cell lengths, store in 0th element */
            printf("TRACE: Raw matrix values from file:\n");
            printf("TRACE:   a_star (raw) = [%g, %g, %g]\n", a_star[1], a_star[2], a_star[3]);
            printf("TRACE:   b_star (raw) = [%g, %g, %g]\n", b_star[1], b_star[2], b_star[3]);
            printf("TRACE:   c_star (raw) = [%g, %g, %g]\n", c_star[1], c_star[2], c_star[3]);
            printf("TRACE:   lambda0 = %g Angstroms\n", lambda0*1e10);
            printf("TRACE:   scaling factor = 1e-10/lambda0 = %g\n", 1e-10/lambda0);
            
            vector_scale(a_star,a_star,1e-10/lambda0);
            vector_scale(b_star,b_star,1e-10/lambda0);
            vector_scale(c_star,c_star,1e-10/lambda0);
            
            printf("TRACE: After wavelength correction:\n");
            printf("TRACE:   a_star = [%g, %g, %g] |a_star| = %g\n", a_star[1], a_star[2], a_star[3], a_star[0]);
            printf("TRACE:   b_star = [%g, %g, %g] |b_star| = %g\n", b_star[1], b_star[2], b_star[3], b_star[0]);
            printf("TRACE:   c_star = [%g, %g, %g] |c_star| = %g\n", c_star[1], c_star[2], c_star[3], c_star[0]);
        }
    }

    /* check for flag to generate random missetting angle */
[2025-10-06T20:44:37] tokens used: 255,445

[2025-10-06T20:44:45] thinking

**Searching for user_cell variable**
[2025-10-06T20:44:48] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "user_cell" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:49] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "user_cell" golden_suite_generator/nanoBragg.c' succeeded in 800ms:
390:    int user_cell = 0;
550:                user_cell = 1;
1962:    if(user_cell)
2140:    if(user_cell)
[2025-10-06T20:44:49] tokens used: 258,169

[2025-10-06T20:44:50] thinking

**Checking configuration timing**
[2025-10-06T20:44:52] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '500,600p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:53] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '500,600p' golden_suite_generator/nanoBragg.c" succeeded in 726ms:
            if(! isnan(test)) Ybeam = test/1000.0;
            test = ValueOf("ORGX",imginfile);
            if(! isnan(test)) ORGX = test;
            test = ValueOf("ORGY",imginfile);
            if(! isnan(test)) ORGY = test;
            test = ValueOf("PHI",imginfile);
            if(! isnan(test)) phi0 = test/RTD;
            test = ValueOf("OSC_RANGE",imginfile);
            if(! isnan(test)) osc = test/RTD;
            test = ValueOf("TWOTHETA",imginfile);
            if(! isnan(test)) twotheta = test/RTD;

            imginfileimage = (float *) calloc(pixels+10,sizeof(float));
            imgidx = imginfile.header_size / sizeof(unsigned short int);
            for(i=0;i<pixels;++i){
                imginfileimage[i] = (float) imginfile.mmapdata[imgidx];
                 ++imgidx;
            }
        }
    }
[2025-10-06T20:44:53] tokens used: 258,383

[2025-10-06T20:44:56] thinking

**Investigating user_cell usage with matrix input**
[2025-10-06T20:44:57] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "matfilename" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:44:58] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "matfilename" golden_suite_generator/nanoBragg.c' succeeded in 793ms:
153:char *matfilename = NULL;
980:                matfilename = argv[i+1];
1307:    if(hklfilename == NULL && Fdumpfile == NULL && default_F == 0.0 || matfilename == NULL && a[0] == 0.0){
2048:    if(matfilename != NULL)
2050:        infile = fopen(matfilename,"r");
2053:            printf("reading %s\n",matfilename);
[2025-10-06T20:44:58] tokens used: 259,807

[2025-10-06T20:45:03] thinking

**Searching for `user_cell` usage**
[2025-10-06T20:45:04] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2020,2100p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:45:05] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2020,2100p' golden_suite_generator/nanoBragg.c" succeeded in 789ms:
        }
        if(sin_alpha_star>1.0) sin_alpha_star=1.0;
        if(sin_beta_star >1.0) sin_beta_star =1.0;
        if(sin_gamma_star>1.0) sin_gamma_star=1.0;
        if(sin_alpha_star<-1.0) sin_alpha_star=-1.0;
        if(sin_beta_star <-1.0) sin_beta_star =-1.0;
        if(sin_gamma_star<-1.0) sin_gamma_star=-1.0;
        if(cos_alpha_star*cos_alpha_star>1.0) cos_alpha_star=1.0;
        if(cos_beta_star *cos_beta_star >1.0) cos_beta_star=1.0;
        if(cos_gamma_star*cos_gamma_star>1.0) cos_gamma_star=1.0;
        alpha_star = atan2(sin_alpha_star,cos_alpha_star);
        beta_star  = atan2(sin_beta_star ,cos_beta_star );
        gamma_star = atan2(sin_gamma_star,cos_gamma_star);


        /* construct default orientation */
        a_star[1] = a_star[0];
        b_star[1] = b_star[0]*cos_gamma_star;
        c_star[1] = c_star[0]*cos_beta_star;
        a_star[2] = 0.0;
[2025-10-06T20:45:05] tokens used: 260,171

[2025-10-06T20:45:42] thinking

**Analyzing rescaling behavior differences****Analyzing rescaling behavior differences**

[2025-10-06T20:45:52] thinking

**Analyzing rescaling differences in lattice computations**
[2025-10-06T20:45:53] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polarization_factor" src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:45:54] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polarization_factor" src/nanobrag_torch/simulator.py' succeeded in 1.07s:
16:from .utils.physics import sincg, sinc3, polarization_factor
357:            polar_flat = polarization_factor(
383:            polar_flat = polarization_factor(
516:        kahn_value = self.beam_config.polarization_factor if not self.beam_config.nopolar else 0.0
1335:                    # This matches the polarization_factor calculation in the main physics
[2025-10-06T20:45:54] tokens used: 263,982

[2025-10-06T20:45:56] thinking

**Inspecting specific lines**
[2025-10-06T20:45:57] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '320,420p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:45:58] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '320,420p' src/nanobrag_torch/simulator.py" succeeded in 708ms:
    # intensity shape before sum: (S, F, N_phi, N_mos) or (n_sources, S, F, N_phi, N_mos) or (n_sources, batch, N_phi, N_mos)
    intensity = torch.sum(intensity, dim=(-2, -1))
    # After sum: (S, F) or (n_sources, S, F) or (n_sources, batch)

    # PERF-PYTORCH-004 P3.0b: Apply polarization PER-SOURCE before weighted sum
    # IMPORTANT: Apply polarization even when kahn_factor==0.0 (unpolarized case)
    # The formula 0.5*(1.0 + cos²(2θ)) is the correct unpolarized correction
    if apply_polarization:
        # Calculate polarization factor for each source
        # Need diffracted beam direction: pixel_coords_angstroms normalized
        pixel_magnitudes = torch.norm(pixel_coords_angstroms, dim=-1, keepdim=True).clamp_min(1e-12)
        diffracted_beam_unit = pixel_coords_angstroms / pixel_magnitudes

        if is_multi_source:
            # Multi-source case: apply per-source polarization
            # diffracted_beam_unit: (S, F, 3) or (batch, 3)
            # incident_beam_direction: (n_sources, 3)
            # NOTE: incident_beam_direction is cloned in _compute_physics_for_position wrapper
            # before entering torch.compile to avoid CUDA graphs aliasing violations

[2025-10-06T20:45:58] tokens used: 265,107

[2025-10-06T20:46:01] thinking

**Verifying polarization factor values**
[2025-10-06T20:46:02] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def polarization_factor" src/nanobrag_torch/utils/physics.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:46:03] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "def polarization_factor" src/nanobrag_torch/utils/physics.py' succeeded in 786ms:
183:def polarization_factor(
[2025-10-06T20:46:03] tokens used: 266,685
[2025-10-06T20:46:10] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '183,260p' src/nanobrag_torch/utils/physics.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:46:10] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '183,260p' src/nanobrag_torch/utils/physics.py" succeeded in 749ms:
def polarization_factor(
    kahn_factor: torch.Tensor,
    incident: torch.Tensor,
    diffracted: torch.Tensor,
    axis: torch.Tensor,
) -> torch.Tensor:
    """
    Calculate the angle-dependent polarization correction factor.

    This function models how the scattered intensity is modulated by the
    polarization state of the incident beam and the scattering geometry.
    The implementation must be vectorized to calculate a unique correction
    factor for each pixel simultaneously.

    C-Code Implementation Reference (from nanoBragg.c):
    The C implementation combines a call site in the main loop with a
    dedicated helper function.

    Usage in Main Loop (lines 2983-2990):
    ```c
[2025-10-06T20:46:10] tokens used: 266,976

[2025-10-06T20:46:14] thinking

**Inspecting code for axis input**
[2025-10-06T20:46:14] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '260,360p' src/nanobrag_torch/utils/physics.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:46:15] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '260,360p' src/nanobrag_torch/utils/physics.py" succeeded in 773ms:
        kahn_factor: Polarization factor (0 to 1). Can be scalar or tensor.
        incident: Incident beam unit vectors [..., 3].
        diffracted: Diffracted beam unit vectors [..., 3].
        axis: Polarization axis unit vectors [..., 3] or [3].

    Returns:
        Tensor of polarization correction factors [...].
    """
    # Normalize vectors to unit length
    eps = 1e-10
    incident_norm = incident / (torch.norm(incident, dim=-1, keepdim=True) + eps)
    diffracted_norm = diffracted / (torch.norm(diffracted, dim=-1, keepdim=True) + eps)

    # Handle axis broadcasting - it might be a single vector for all pixels
    if axis.dim() == 1:
        axis = axis.unsqueeze(0).expand(incident.shape[:-1] + (3,))
    axis_norm = axis / (torch.norm(axis, dim=-1, keepdim=True) + eps)

    # Component of diffracted unit vector along incident beam unit vector
    # cos(2θ) = i·d
[2025-10-06T20:46:15] tokens used: 268,011

[2025-10-06T20:46:19] thinking

**Investigating polarization axis usage**
[2025-10-06T20:46:22] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polarization_axis" src/nanobrag_torch/config.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:46:22] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polarization_axis" src/nanobrag_torch/config.py' succeeded in 734ms:
509:    polarization_axis: tuple[float, float, float] = (0.0, 0.0, 1.0)  # Polarization E-vector direction
[2025-10-06T20:46:22] tokens used: 269,850
[2025-10-06T20:46:44] stream error: stream disconnected before completion: An error occurred while processing your request. You can retry your request, or contact us through our help center at help.openai.com if the error persists. Please include the request ID 98a80201c866cdb0-ATL in your message.; retrying 1/5 in 190ms…

[2025-10-06T20:46:51] thinking

**Checking BeamConfig defaults**
[2025-10-06T20:46:53] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '430,540p' src/nanobrag_torch/config.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:46:54] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '430,540p' src/nanobrag_torch/config.py" succeeded in 1.04s:
        return cls(
            distance_mm=distance_mm if distance_mm is not None else 100.0,
            close_distance_mm=close_distance_mm,
            detector_pivot=detector_pivot,
            **kwargs
        )

    def should_use_custom_convention(self) -> bool:
        """
        Determine if CUSTOM convention should be used based on C code logic.

        The C code switches to CUSTOM convention when:
        1. -twotheta_axis is explicitly passed to the command line
        2. AND the twotheta_axis differs from the default for the current convention

        This exactly replicates the logic in build_nanobragg_command() which only
        passes -twotheta_axis when the axis is NOT the convention default.

        Returns:
            bool: True if CUSTOM convention should be used (no 0.5 pixel offset)
[2025-10-06T20:46:54] tokens used: 270,164

[2025-10-06T20:47:03] thinking

**Examining polarization axis handling**
[2025-10-06T20:47:04] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polarization_axis" src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:47:05] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polarization_axis" src/nanobrag_torch/simulator.py' succeeded in 1.05s:
45:    polarization_axis: Optional[torch.Tensor] = None,
92:        polarization_axis: Polarization axis unit vector (3,) or broadcastable shape
361:                polarization_axis
387:                polarization_axis
518:        self.polarization_axis = torch.tensor(
519:            self.beam_config.polarization_axis, device=self.device, dtype=self.dtype
675:            polarization_axis=self.polarization_axis,
[2025-10-06T20:47:05] tokens used: 272,452

[2025-10-06T20:47:09] thinking

**Inspecting Simulator constructor**
[2025-10-06T20:47:10] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '460,720p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:47:11] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '460,720p' src/nanobrag_torch/simulator.py" succeeded in 758ms:
            if hasattr(crystal_config, 'mosaic_spread_deg'):
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
[2025-10-06T20:47:11] tokens used: 272,792

[2025-10-06T20:47:21] thinking

**Analyzing tensor boolean condition**
[2025-10-06T20:47:24] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python - <<'PY'
import torch
x = torch.tensor(1.0)
print(type(x "'!= 0.0), x != 0.0)
print(bool(x != 0.0))
PY
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:47:25] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && python - <<'PY'
import torch
x = torch.tensor(1.0)
print(type(x "'!= 0.0), x != 0.0)
print(bool(x != 0.0))
PY
' exited 134 in 1.21s:
OMP: Error #15: Initializing libomp.dylib, but found libomp.dylib already initialized.
OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That is dangerous, since it can degrade performance or cause incorrect results. The best thing to do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static linking of the OpenMP runtime in any library. As an unsafe, unsupported, undocumented workaround you can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to continue to execute, but that may cause crashes or silently produce incorrect results. For more information, please see http://openmp.llvm.org/
bash: line 6: 41592 Abort trap: 6              python - <<'PY'
import torch
x = torch.tensor(1.0)
print(type(x != 0.0), x != 0.0)
print(bool(x != 0.0))
PY

[2025-10-06T20:47:25] tokens used: 276,078

[2025-10-06T20:47:28] thinking

**Setting environment variable and re-running**
[2025-10-06T20:47:29] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
x = torch.tensor(1.0)
print(type(x "'!= 0.0), x != 0.0)
print(bool(x != 0.0))
PY
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:47:31] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
x = torch.tensor(1.0)
print(type(x "'!= 0.0), x != 0.0)
print(bool(x != 0.0))
PY
' succeeded in 1.68s:
<class 'torch.Tensor'> tensor(True)
True
[2025-10-06T20:47:31] tokens used: 276,577

[2025-10-06T20:47:43] thinking

**Analyzing polarization factor edge cases**
[2025-10-06T20:47:45] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
incident = torch.tensor([0.00051387949, 0.0, -0.99999986])
diffracted = torch.tensor([-0.391777736781811, 0.144875033930166, -0.908582098385091])
axis = torch.tensor([0.0, 0.0, 1.0])
from nanobrag_torch.utils.physics import polarization_factor

val = polarization_factor(torch.tensor(1.0), incident, diffracted, axis)
print(val)
PY
" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:47:48] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
incident = torch.tensor([0.00051387949, 0.0, -0.99999986])
diffracted = torch.tensor([-0.391777736781811, 0.144875033930166, -0.908582098385091])
axis = torch.tensor([0.0, 0.0, 1.0])
from nanobrag_torch.utils.physics import polarization_factor

val = polarization_factor(torch.tensor(1.0), incident, diffracted, axis)
print(val)
PY
" exited 1 in 3.19s:
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0] failed while attempting to run meta for aten.expand.default
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0] Traceback (most recent call last):
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]   File "/Users/ollie/miniconda3/lib/python3.13/site-packages/torch/_subclasses/fake_tensor.py", line 2427, in _dispatch_impl
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     r = func(*args, **kwargs)
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]   File "/Users/ollie/miniconda3/lib/python3.13/site-packages/torch/_ops.py", line 756, in __call__
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     return self._op(*args, **kwargs)
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]            ~~~~~~~~^^^^^^^^^^^^^^^^^
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]   File "/Users/ollie/miniconda3/lib/python3.13/site-packages/torch/_refs/__init__.py", line 3000, in expand
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     torch._check(
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     ~~~~~~~~~~~~^
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]         len(shape) >= len(a.shape),
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]         lambda: "expand: the requested shape has too few dimensions!",
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     )
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     ^
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]   File "/Users/ollie/miniconda3/lib/python3.13/site-packages/torch/__init__.py", line 1660, in _check
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     _check_with(RuntimeError, cond, message)
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]     ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E1006 13:47:48.319000 42183 site-packages/torch/_subclasses/fake_tensor.py:2431] [0/0]   File "/Users/ollie/miniconda3/lib/python3.13/site-packages/torch/__init__.py", line 1642, in _check_with
[2025-10-06T20:47:48] tokens used: 278,110

[2025-10-06T20:47:51] thinking

**Handling torch.compile issues**
[2025-10-06T20:47:53] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && TORCHDYNAMO_DISABLE=1 KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
incident = torch.tensor([0.00051387949, 0.0, -0.99999986])
diffracted = torch.tensor([-0.391777736781811, 0.144875033930166, -0.908582098385091])
axis = torch.tensor([0.0, 0.0, 1.0])
from nanobrag_torch.utils.physics import polarization_factor
print(polarization_factor(torch.tensor(1.0), incident, diffracted, axis))
PY
" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:47:55] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && TORCHDYNAMO_DISABLE=1 KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
incident = torch.tensor([0.00051387949, 0.0, -0.99999986])
diffracted = torch.tensor([-0.391777736781811, 0.144875033930166, -0.908582098385091])
axis = torch.tensor([0.0, 0.0, 1.0])
from nanobrag_torch.utils.physics import polarization_factor
print(polarization_factor(torch.tensor(1.0), incident, diffracted, axis))
PY
" exited 1 in 2.21s:
Traceback (most recent call last):
  File "<stdin>", line 6, in <module>
  File "/Users/ollie/Documents/nanoBragg3/src/nanobrag_torch/utils/physics.py", line 275, in polarization_factor
    axis = axis.unsqueeze(0).expand(incident.shape[:-1] + (3,))
RuntimeError: expand(torch.FloatTensor{[1, 3]}, size=[3]): the number of sizes provided (1) must be greater or equal to the number of dimensions in the tensor (2)
[2025-10-06T20:47:55] tokens used: 281,027

[2025-10-06T20:48:03] thinking

**Analyzing tensor shape mismatch**
[2025-10-06T20:48:05] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && TORCHDYNAMO_DISABLE=1 KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
from nanobrag_torch.utils.physics import polarization_factor
incident = torch.tensor([[0.00051387949, 0.0, -0.99999986]])
diffracted = torch.tensor([[-0.391777736781811, 0.144875033930166, -0.908582098385091]])
axis = torch.tensor([0.0, 0.0, 1.0])
val = polarization_factor(torch.tensor(1.0), incident, diffracted, axis)
print(val)
PY
" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:08] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && TORCHDYNAMO_DISABLE=1 KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import torch
from nanobrag_torch.utils.physics import polarization_factor
incident = torch.tensor([[0.00051387949, 0.0, -0.99999986]])
diffracted = torch.tensor([[-0.391777736781811, 0.144875033930166, -0.908582098385091]])
axis = torch.tensor([0.0, 0.0, 1.0])
val = polarization_factor(torch.tensor(1.0), incident, diffracted, axis)
print(val)
PY
" succeeded in 2.68s:
tensor([0.8461])
[2025-10-06T20:48:08] tokens used: 309,245

[2025-10-06T20:48:12] thinking

**Comparing polarization factor calculations**
[2025-10-06T20:48:12] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polar_vector" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:13] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polar_vector" golden_suite_generator/nanoBragg.c' succeeded in 802ms:
306:    double polar_vector[4] = {0,0,0,1};
719:            if(strstr(argv[i], "-polar_vector") && (argc > (i+3)))
722:                polar_vector[1] = atof(argv[i+1]);
723:                polar_vector[2] = atof(argv[i+2]);
724:                polar_vector[3] = atof(argv[i+3]);
1202:          polar_vector[1]=  1;   polar_vector[2]=  0;   polar_vector[3]=  0;
1218:          polar_vector[1]=  0;   polar_vector[2]=  0;   polar_vector[3]=  1;
1233:          polar_vector[1]=  0;   polar_vector[2]=  0;   polar_vector[3]=  1;
1248:          polar_vector[1]=  1;   polar_vector[2]=  0;   polar_vector[3]=  0;
1263:          polar_vector[1]=  0;   polar_vector[2]=  1;   polar_vector[3]=  0;
1289:    unitize(polar_vector,polar_vector);
1291:    cross_product(beam_vector,polar_vector,vert_vector);
1384:        printf("\t-polar_vector    \tunit vector of x-ray E-vector polarization (default: %g %g %g)\n",polar_vector[1],polar_vector[2],polar_vector[3]);
2648:                rotate_axis(vector,newvector,polar_vector,vdiv);
2738:    cross_product(beam_vector,polar_vector,vector);
2793:        fdet_vector,sdet_vector,odet_vector,beam_vector,pix0_vector,polar_vector,spindle_vector,\
3036:                                polar = polarization_factor(polarization,incident,diffracted,polar_vector);
[2025-10-06T20:48:13] tokens used: 311,148

[2025-10-06T20:48:17] thinking

**Examining large references and defaults**
[2025-10-06T20:48:18] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1180,1260p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:19] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1180,1260p' golden_suite_generator/nanoBragg.c" succeeded in 749ms:
    if(isnan(Fclose)) Fclose = (detsize_f - 0*pixel_size)/2.0;
    if(isnan(Sclose)) Sclose = (detsize_s + 0*pixel_size)/2.0;
    if(isnan(Xclose)) Xclose = Fclose;
    if(isnan(Yclose)) Yclose = Sclose;
    if(isnan(Fbeam)) Fbeam = Fclose;
    if(isnan(Sbeam)) Sbeam = Sclose;
    if(roi_xmin < 0) roi_xmin = 0;
    if(roi_xmax < 0) roi_xmax = fpixels;
    if(roi_ymin < 0) roi_ymin = 0;
    if(roi_ymax < 0) roi_ymax = spixels;
    progress_pixels = (roi_xmax-roi_xmin+1)*(roi_ymax-roi_ymin+1);

    if(beam_convention == ADXV)
    {
        /* first pixel is at 0,0 pix and pixel_size,pixel_size*npixels mm */
        if(isnan(Xbeam)) Xbeam = (detsize_f + pixel_size)/2.0;
        if(isnan(Ybeam)) Ybeam = (detsize_s - pixel_size)/2.0;
           beam_vector[1]=  0;    beam_vector[2]=  0;    beam_vector[3]=  1;
           fdet_vector[1]=  1;    fdet_vector[2]=  0;    fdet_vector[3]=  0;
           sdet_vector[1]=  0;    sdet_vector[2]= -1;    sdet_vector[3]=  0;
[2025-10-06T20:48:19] tokens used: 311,829

[2025-10-06T20:48:25] thinking

**Investigating polarization factor differences**
[2025-10-06T20:48:26] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2980,3080p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:27] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2980,3080p' golden_suite_generator/nanoBragg.c" succeeded in 764ms:
                            /* fraction of incoming photons absorbed by this detector layer */
                            capture_fraction = exp(-thick_tic*detector_thickstep*detector_mu/parallax)
                                              -exp(-(thick_tic+1)*detector_thickstep*detector_mu/parallax);
                        }

                        /* loop over sources now */
                        for(source=0;source<sources;++source){

                            /* retrieve stuff from cache */
                            incident[1] = -source_X[source];
                            incident[2] = -source_Y[source];
                            incident[3] = -source_Z[source];
                            lambda = source_lambda[source];

                            /* construct the incident beam unit vector while recovering source distance */
                            /* source arrays should already be unit vectors */
//                            source_path = unitize(incident,incident);

                            /* construct the scattering vector for this pixel */
                            scattering[1] = (diffracted[1]-incident[1])/lambda;
[2025-10-06T20:48:27] tokens used: 313,946

[2025-10-06T20:48:31] thinking

**Searching for variable initialization**
[2025-10-06T20:48:32] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "double polar" -n golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:33] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "double polar" -n golden_suite_generator/nanoBragg.c' succeeded in 807ms:
122:double polarization_factor(double kahn_factor, double *incident, double *diffracted, double *axis);
306:    double polar_vector[4] = {0,0,0,1};
308:    double polar=1.0,polarization=0.0;
4391:double polarization_factor(double kahn_factor, double *incident, double *diffracted, double *axis)
[2025-10-06T20:48:33] tokens used: 315,844

[2025-10-06T20:48:37] thinking

**Investigating polar variable behavior**
[2025-10-06T20:48:38] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "oversample_polar" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:39] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "oversample_polar" golden_suite_generator/nanoBragg.c' succeeded in 765ms:
316:    int oversample_polar = 0;
851:            if(strstr(argv[i], "-oversample_polar") )
853:                oversample_polar = 1;
1339:        printf("\t-oversample_polar \tre-calculate polarization effect for sub-pixels (not the default)\n");
2750:    if(oversample_polar) printf(" +polar");
2812:        oversample,oversample_thick,oversample_polar,oversample_omega,\
3033:                            if (polar == 0.0 || oversample_polar)
3337:                                    if(oversample_polar) I *= polar;
3357:            if(! oversample_polar) test *= polar;
3369:                printf("TRACE_C: oversample_polar %d\n", oversample_polar);
[2025-10-06T20:48:39] tokens used: 316,311

[2025-10-06T20:48:44] thinking

**Searching for initial polar assignment**
[2025-10-06T20:48:47] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '3300,3380p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:48] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '3300,3380p' golden_suite_generator/nanoBragg.c" succeeded in 760ms:

                                        /* now populate the "y" values (nearest four structure factors in each direction) */
                                        for (i1=0;i1<4;i1++) {
                                            for (i2=0;i2<4;i2++) {
                                               for (i3=0;i3<4;i3++) {
                                                      sub_Fhkl[i1][i2][i3]= Fhkl[h_interp[i1]-h_min][k_interp[i2]-k_min][l_interp[i3]-l_min];
                                               }
                                            }
                                         }


                                        /* run the tricubic polynomial interpolation */
                                        polin3(h_interp_d,k_interp_d,l_interp_d,sub_Fhkl,h,k,l,&F_cell);
                                    }

                                    if(! interpolate)
                                    {
                                        if ( hkls && (h0<=h_max) && (h0>=h_min) && (k0<=k_max) && (k0>=k_min) && (l0<=l_max) && (l0>=l_min)  ) {
                                            /* just take nearest-neighbor */
                                            F_cell = Fhkl[h0-h_min][k0-k_min][l0-l_min];
[2025-10-06T20:48:48] tokens used: 316,706

[2025-10-06T20:48:53] thinking

**Investigating polar variable initialization**
[2025-10-06T20:48:54] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polar = 0" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:55] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && rg -n "polar = 0" golden_suite_generator/nanoBragg.c' succeeded in 850ms:
309:    int nopolar = 0;
316:    int oversample_polar = 0;
840:                nopolar = 0;
2912:            polar = 0.0;
[2025-10-06T20:48:55] tokens used: 318,077

[2025-10-06T20:48:57] thinking

**Scrolling to line 2912**
[2025-10-06T20:48:58] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2880,2930p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:48:59] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '2880,2930p' golden_suite_generator/nanoBragg.c" succeeded in 761ms:
//    printf("thread: %d mosaic_umats = %p\n", omp_get_thread_num(),mosaic_umats);
//    mosaic_umats = newptr;
//    printf("thread: %d mosaic_umats = %p\n", omp_get_thread_num(),mosaic_umats);
    debug_printed_thread = 1;
}
#endif

        for(fpixel=0;fpixel<fpixels;++fpixel)
        {
            /* allow for just one part of detector to be rendered */
            if(fpixel < roi_xmin || fpixel > roi_xmax || spixel < roi_ymin || spixel > roi_ymax)
            {
                continue;
            }

            /* position in pixel array */
            imgidx = spixel*fpixels+fpixel;

            /* allow for the use of a mask */
            if(maskimage != NULL)
[2025-10-06T20:48:59] tokens used: 318,316

[2025-10-06T20:49:28] thinking

**Comparing polarization computations between Pyro and C**
[2025-10-06T20:50:06] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && TORCHDYNAMO_DISABLE=1 KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import math
incident = [0.000513879494092498, 0.0, -0.999999867963924]
diffracted = [-0.391782158179886, 0.14487608188769, -0.908580024779756]
axis = [0.0, 0.0, 1.0]

# normalize
import numpy as np
incident = np.array(incident)
diffracted = np.array(diffracted)
axis = np.array(axis)

def unit(v):
    n = np.linalg.norm(v)
    if n == 0:
        return v
    return v/n

incident = unit(incident)
diffracted = unit(diffracted)
axis = unit(axis)

cos2theta = np.dot(incident, diffracted)
cos2theta_sqr = cos2theta**2
sin2theta_sqr = 1 - cos2theta_sqr
kahn_factor = 1.0

# compute psi per C code
B_in = np.cross(axis, incident)
B_in = unit(B_in)
E_in = np.cross(incident, B_in)
E_in = unit(E_in)
E_out = np.dot(diffracted, E_in)
B_out = np.dot(diffracted, B_in)
psi = -math.atan2(B_out, E_out)
polar = 0.5 * (1.0 + cos2theta_sqr - kahn_factor * math.cos(2.0 * psi) * sin2theta_sqr)
print('cos2theta', cos2theta)
print('psi', psi)
print('polar', polar)
PY
" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:50:07] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && TORCHDYNAMO_DISABLE=1 KMP_DUPLICATE_LIB_OK=TRUE python - <<'PY'
import math
incident = [0.000513879494092498, 0.0, -0.999999867963924]
diffracted = [-0.391782158179886, 0.14487608188769, -0.908580024779756]
axis = [0.0, 0.0, 1.0]

# normalize
import numpy as np
incident = np.array(incident)
diffracted = np.array(diffracted)
axis = np.array(axis)

def unit(v):
    n = np.linalg.norm(v)
    if n == 0:
        return v
    return v/n

incident = unit(incident)
diffracted = unit(diffracted)
axis = unit(axis)

cos2theta = np.dot(incident, diffracted)
cos2theta_sqr = cos2theta**2
sin2theta_sqr = 1 - cos2theta_sqr
kahn_factor = 1.0

# compute psi per C code
B_in = np.cross(axis, incident)
B_in = unit(B_in)
E_in = np.cross(incident, B_in)
E_in = unit(E_in)
E_out = np.dot(diffracted, E_in)
B_out = np.dot(diffracted, B_in)
psi = -math.atan2(B_out, E_out)
polar = 0.5 * (1.0 + cos2theta_sqr - kahn_factor * math.cos(2.0 * psi) * sin2theta_sqr)
print('cos2theta', cos2theta)
print('psi', psi)
print('polar', polar)
PY
" succeeded in 1.11s:
cos2theta 0.908378575997175
psi -2.7877870282774206
polar 0.846140716433784
[2025-10-06T20:50:07] tokens used: 320,057

[2025-10-06T20:50:13] thinking

**Comparing polarization computations and axes**
[2025-10-06T20:50:14] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1280,1340p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:50:15] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1280,1340p' golden_suite_generator/nanoBragg.c" succeeded in 759ms:
    unitize(beam_vector,beam_vector);
    unitize(fdet_vector,fdet_vector);
    unitize(sdet_vector,sdet_vector);
    if(unitize(odet_vector,odet_vector) != 1.0)
    {
        printf("WARNING: auto-generating odet_vector\n");
        cross_product(fdet_vector,sdet_vector,odet_vector);
        unitize(odet_vector,odet_vector);
    }
    unitize(polar_vector,polar_vector);
    unitize(spindle_vector,spindle_vector);
    cross_product(beam_vector,polar_vector,vert_vector);
    unitize(vert_vector,vert_vector);


    printf("nanoBragg nanocrystal diffraction simulator - James Holton and Ken Frankel 5-17-17\n");

    if(hklfilename == NULL)
    {
        /* see if there are Fs from a previous run */
[2025-10-06T20:50:15] tokens used: 321,077

[2025-10-06T20:50:28] thinking

**Analyzing polarization factor discrepancies**
[2025-10-06T20:50:29] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '780,860p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:50:30] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '780,860p' golden_suite_generator/nanoBragg.c" succeeded in 966ms:
            {
                detector_thicksteps = atoi(argv[i+1]);
            }
            if(strstr(argv[i], "-twotheta") && (argc > (i+1)))
            {
                detector_twotheta = atof(argv[i+1])/RTD;
                detector_pivot = SAMPLE;
            }
            if(strstr(argv[i], "-detector_rotx") && (argc > (i+1)))
            {
                detector_rotx = atof(argv[i+1])/RTD;
            }
            if(strstr(argv[i], "-detector_roty") && (argc > (i+1)))
            {
                detector_roty = atof(argv[i+1])/RTD;
            }
            if(strstr(argv[i], "-detector_rotz") && (argc > (i+1)))
            {
                detector_rotz = atof(argv[i+1])/RTD;
            }
[2025-10-06T20:50:30] tokens used: 323,272

[2025-10-06T20:50:45] thinking

**Reevaluating polarization and rescaling fixes**

I’m sorting through the discrepancies tied to polarization defaults and unconditional rescaling affecting cross products, aiming to align the BeamConfig defaults with the original C version. I see that the existing plan might need updates to reflect these findings and to clarify next steps for verifying and adjusting the CLI flags and associated tasks.
[2025-10-06T20:50:47] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '420,520p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:50:48] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '420,520p' docs/fix_plan.md" succeeded in 1.04s:
    from pathlib import Path
    import torch
    from nanobrag_torch.__main__ import create_parser, parse_and_validate_args

    with tempfile.TemporaryDirectory() as tmp:
        hkl = Path(tmp) / "dtype_precision.hkl"
        hkl.write_text("0 0 0 1.23456789012345\n")
        parser = create_parser()
        args = parser.parse_args([
            "-hkl", str(hkl),
            "-cell", "100", "100", "100", "90", "90", "90",
            "-default_F", "0",
            "-dtype", "float64"
        ])
        config = parse_and_validate_args(args)
        grid, _ = config['hkl_data']
        print(grid.dtype)  # BUG: prints torch.float32 today
    ```
    `PY`
- First Divergence (if known): `parse_and_validate_args` (src/nanobrag_torch/__main__.py:435) calls `read_hkl_file`/`try_load_hkl_or_fdump` without forwarding the parsed dtype, so HKL/Fdump data is always loaded as float32. When the CLI is run with `-dtype float64`, the simulator converts those float32 tensors to float64 later, permanently losing precision relative to the requested double-precision path and violating the DTYPE-DEFAULT-001 guarantee.
[2025-10-06T20:50:48] tokens used: 325,088

[2025-10-06T20:51:26] thinking

**Updating plan with new root cause and tasks**

I’m working through updating the existing CLI-noise-pix0 plan to reflect the newly discovered root cause involving user_cell gating and polarization defaults. I’ll revise Phase K guidance to emphasize verifying orientation rescaling differences, add new subtasks for reproducing and fixing the issue, and align the Next Actions and documentation accordingly before reviewing commit history as part of housekeeping.
[2025-10-06T20:51:29] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '150,220p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:51:30] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '150,220p' plans/active/cli-noise-pix0/plan.md" succeeded in 999ms:
Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
Prereqs: Phases F–H complete; traces show `F_latt` parity.
Exit Criteria: Polarization entries in C/PyTorch traces agree (≈0.9126 for supervisor command) and parity smoke stays green.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |

### Phase J — Intensity Scaling Evidence
Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
Prereqs: Phase I2 complete; beam/pix0/orientation traces from Phases F–H archived.
Exit Criteria: Report under `reports/2025-10-cli-flags/phase_j/scaling_chain.md` documenting C vs PyTorch values for `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, `fluence`, and the resulting per-pixel intensities, with the first mismatched quantity identified and logged in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| J1 | Capture single-pixel scaling traces | [D] | ✅ 2025-10-19: C trace (`trace_c_scaling.log`) and PyTorch trace (`trace_py_scaling.log`) captured for pixel (1039,685) with full scaling chain (`steps`, `I_before_scaling`, `r_e²`, `fluence`, `polar`, `omega`). |
| J2 | Compute factor-by-factor ratios | [D] | ✅ 2025-10-19: `analyze_scaling.py` created and executed; identifies first divergence as `I_before_scaling` with Py/C ratio=3.6e-7. Root cause: F_latt components differ by ~463× (C: 35636 vs PyTorch: 76.9). Markdown report at `scaling_chain.md`. |
| J3 | Update fix_plan Attempt log | [D] | ✅ 2025-10-19: Attempt #28 logged in `docs/fix_plan.md` with complete metrics, artifacts, and hypothesis (F_latt calculation error in sincg lattice shape factor). Phase I3 remains blocked pending Phase K F_latt fix. |
[2025-10-06T20:51:30] tokens used: 329,829

[2025-10-06T20:51:50] thinking

**Updating project plan with new findings**

I'm organizing modifications to the project plan based on recent discoveries about the default value error. I'll update the context summary with the root cause, adjust Phase I entries like I2 to mark it undone or in progress, add new rows for diagnostics in Phase K, and amend K3 guidance with concrete fix steps—all while preserving the plan's structure and formatting using a patch. First, I’ll locate the context bullet section to add the new root cause note.
[2025-10-06T20:51:54] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,60p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:51:55] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '1,60p' plans/active/cli-noise-pix0/plan.md" succeeded in 1.04s:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
- Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
- Documentation anchors for this focus:
  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
  * `docs/development/testing_strategy.md` — authoritative pytest/trace commands for CLI parity evidence.

### Phase A — Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
[2025-10-06T20:51:55] tokens used: 332,318

[2025-10-06T20:52:02] thinking

**Updating context and phase I & K sections**
[2025-10-06T20:52:18] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -10,2 +10,3 @@
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
@@ -156,4 +157,4 @@
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
@@ -178,4 +179,5 @@
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
[2025-10-06T20:52:18] apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T20:52:18] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.

[2025-10-06T20:52:18] tokens used: 336,989
[2025-10-06T20:52:18] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:52:26] thinking

**Updating documentation for new orientation tasks**

I’m aligning the docs/fix_plan.md with the new plan that adds K2b and orientation referencing. I’ll update the Next Actions and First Divergence sections to mention the new tasks, including capturing orientation mismatch, gating, polarization defaults, and the new artifact expectation orientation_delta. This keeps the doc consistent with the revised spec.
[2025-10-06T20:52:36] tokens used: 340,112
[2025-10-06T20:52:36] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:52:41] thinking

**Debugging patch mismatch**
[2025-10-06T20:52:42] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '440,520p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:52:43] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && sed -n '440,520p' docs/fix_plan.md" succeeded in 1.05s:
- Immediate Next Actions (2025-10-15):
  * Update `parse_and_validate_args` (and any helper that constructs `CrystalConfig`) to thread the parsed dtype/device into HKL/Fdump loaders so CLI `-dtype` honours float64 from the start.
  * Add a regression test (e.g., `tests/test_cli_dtype.py`) that invokes the parser with `-dtype float64` and asserts `config['hkl_data'][0].dtype == torch.float64`, covering both HKL and Fdump paths.
  * Re-run AT-IO-003 and the CLI smoke (help + minimal render) to ensure no regressions, capturing logs under `reports/DTYPE-CLI/<date>/`.
- Attempts History: None — new item.
- Risks/Assumptions: Ensure `write_fdump` continues to emit float64 on disk (spec requirement) while the in-memory tensor honours caller dtype; watch for latent callers that relied on the old float64 default during plan DTYPE-DEFAULT-001 migration.
- Exit Criteria: CLI runs with `-dtype float64` produce double-precision HKL/Fdump tensors end-to-end, regression test passes, and existing dtype-sensitive tests (AT-IO-003, CLI smoke, gradchecks) remain green.

## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A–H complete; pivot fix landed via H6f, pending H6g traces + Phase K normalization)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
[2025-10-06T20:52:43] tokens used: 342,885
[2025-10-06T20:52:43] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:52:49] thinking

**Applying precise patch**
[2025-10-06T20:53:11] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -456,7 +456,7 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
[2025-10-06T20:53:11] apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T20:53:11] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.

[2025-10-06T20:53:11] tokens used: 346,051
[2025-10-06T20:53:11] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:53:18] thinking

**Preparing to review recent commits**
[2025-10-06T20:53:19] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git log -5 --oneline' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:53:20] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git log -5 --oneline' succeeded in 1.05s:
65edd81 [SYNC i=48] actor=galph status=running
085f4e1 [SYNC i=48] actor=ralph → next=galph status=ok ralph_commit=cc5a3cb
cc5a3cb [SYNC i=47] actor=ralph status=running
3d03af4 [SYNC i=47] actor=ralph status=running
84d5b63 [SYNC i=47] actor=galph → next=ralph status=ok galph_commit=42fe501
[2025-10-06T20:53:20] tokens used: 374,046
[2025-10-06T20:53:20] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:53:27] thinking

**Reviewing recent commit details**
[2025-10-06T20:53:28] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git show -1 --stat cc5a3cb' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:53:29] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git show -1 --stat cc5a3cb' succeeded in 800ms:
commit cc5a3cbafbdb145f0fed5c0820eeb3f62f7e3678
Author: ollie <ohoidn>
Date:   Mon Oct 6 13:36:15 2025 -0700

    [SYNC i=47] actor=ralph status=running
    
    CLI-FLAGS-003 Phase K2: Scaling chain evidence post SAMPLE-pivot fix
    
    Major improvement: F_latt error reduced from 463× (Phase J) to 25.5%
    - F_cell exact match (300.58) ✅
    - F_latt_a error 0.19% (C=35.89, Py=35.96) ✅
    - F_latt_b error 21.6% (C=38.63, Py=46.98) ❌ BLOCKER
    - F_latt_c error 3.0% (C=25.70, Py=26.47) ⚠️
    - Polarization 9.6% error (C=0.9126, Py=1.0) ⚠️
    - Final intensity 11.4% higher (Py=497 vs C=446)
    
    Artifacts generated:
    - reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log - Fresh PyTorch trace
    - reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json - Complete scaling ratios
    - reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md - Analysis & hypotheses
[2025-10-06T20:53:29] tokens used: 375,889
[2025-10-06T20:53:29] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:53:53] thinking

**Preparing detailed input.md for evidence phase**

I'm organizing a comprehensive `input.md` memo focusing on the CLI-FLAGS-003 Phase K2/K2b evidence tasks, carefully aligning the summary, focus, branch, artifacts, and clear Do Now instructions to run the harness and draft the orientation delta script, while including priorities, pitfalls, pointers, and troubleshooting notes as per the plan and guidelines.
[2025-10-06T20:54:14] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && cat <<'EOF' > input.md
Summary: Capture fresh scaling evidence and quantify the MOSFLM orientation mismatch before touching normalization code.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase K2/K2b — Normalization Diagnostics
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log; reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json; reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md; reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md; reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py
Do Now: CLI-FLAGS-003 Phase K2/K2b — run "'`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`, then author `reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py` to log C vs PyTorch lattice-vector deltas per plan guidance.
If Blocked: Capture stdout/stderr to `reports/2025-10-cli-flags/phase_k/f_latt_fix/attempt_blocked.log`, record env snapshot (commit hash, python/torch versions, CUDA availability), run `git status --short`, describe the blocker in docs/fix_plan Attempt history, and stop.
Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:170 — K2 now requires refreshed scaling metrics plus explicit orientation deltas before implementation starts.
- plans/active/cli-noise-pix0/plan.md:171 — K2b mandates a minimal script proving the `vector_rescale` mismatch; artifacts must live alongside scaling logs.
- docs/fix_plan.md:455 — Updated Next Actions call out the rescale + polarization blockers; evidence is prerequisite for K3 fixes.
- reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json — Current ratios still show F_latt_b ≈1.216 and polar=1.0; need annotated rerun.
- golden_suite_generator/nanoBragg.c:2145 — Reference implementation only rescales cross products when `user_cell` is set, so evidence must compare to this branch.
How-To Map:
- Ensure report directory exists: `mkdir -p reports/2025-10-cli-flags/phase_k/f_latt_fix`.
- Refresh PyTorch trace: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`.
- Update scaling ratios: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_j/analyze_scaling.py --c-log reports/2025-10-cli-flags/phase_j/trace_c_scaling.log --py-log reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`.
- Draft `mosflm_rescale.py` (start from earlier interactive snippet) to print C-style vs PyTorch real vectors; run it with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py > reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md`.
- Sync `metrics_after.json`/`scaling_summary.md` with new findings and cite the new orientation artifact.
Pitfalls To Avoid:
- No pytest or nb-compare invocations this loop—Evidence phase only.
- Do not edit simulator/crystal/detector code yet; gather evidence first.
- Keep env var `KMP_DUPLICATE_LIB_OK=TRUE` on every torch script run.
- Reuse `PYTHONPATH=src`; avoid import-from-installed copies.
- Store new scripts under the existing reports path (Protected Assets rule—no root clutter).
- When writing markdown, stick to ASCII and avoid overwriting prior evidence sections.
- Note beam/polarization values exactly; no rounding beyond 6 sig figs.
- Leave previous artifacts in place; append new sections rather than replacing.
- Confirm `NB_C_BIN` is set before referencing C traces; document if you relied on archived logs instead of rerunning C.
- Respect two-message loop rule—submit Attempt logs after supervisor review.
Pointers:
- plans/active/cli-noise-pix0/plan.md:164
- docs/fix_plan.md:452
- reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md
- golden_suite_generator/nanoBragg.c:2140
- docs/architecture/pytorch_design.md:200
- docs/development/testing_strategy.md:1
Next Up: Prep BeamConfig default fix and regression test updates for K3 once evidence lands.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:54:15] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && cat <<'EOF' > input.md
Summary: Capture fresh scaling evidence and quantify the MOSFLM orientation mismatch before touching normalization code.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase K2/K2b — Normalization Diagnostics
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log; reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json; reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md; reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md; reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py
Do Now: CLI-FLAGS-003 Phase K2/K2b — run "'`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`, then author `reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py` to log C vs PyTorch lattice-vector deltas per plan guidance.
If Blocked: Capture stdout/stderr to `reports/2025-10-cli-flags/phase_k/f_latt_fix/attempt_blocked.log`, record env snapshot (commit hash, python/torch versions, CUDA availability), run `git status --short`, describe the blocker in docs/fix_plan Attempt history, and stop.
Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:170 — K2 now requires refreshed scaling metrics plus explicit orientation deltas before implementation starts.
- plans/active/cli-noise-pix0/plan.md:171 — K2b mandates a minimal script proving the `vector_rescale` mismatch; artifacts must live alongside scaling logs.
- docs/fix_plan.md:455 — Updated Next Actions call out the rescale + polarization blockers; evidence is prerequisite for K3 fixes.
- reports/2025-10-cli-flags/phase_k/f_latt_fix/metrics_after.json — Current ratios still show F_latt_b ≈1.216 and polar=1.0; need annotated rerun.
- golden_suite_generator/nanoBragg.c:2145 — Reference implementation only rescales cross products when `user_cell` is set, so evidence must compare to this branch.
How-To Map:
- Ensure report directory exists: `mkdir -p reports/2025-10-cli-flags/phase_k/f_latt_fix`.
- Refresh PyTorch trace: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`.
- Update scaling ratios: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_j/analyze_scaling.py --c-log reports/2025-10-cli-flags/phase_j/trace_c_scaling.log --py-log reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`.
- Draft `mosflm_rescale.py` (start from earlier interactive snippet) to print C-style vs PyTorch real vectors; run it with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py > reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md`.
- Sync `metrics_after.json`/`scaling_summary.md` with new findings and cite the new orientation artifact.
Pitfalls To Avoid:
- No pytest or nb-compare invocations this loop—Evidence phase only.
- Do not edit simulator/crystal/detector code yet; gather evidence first.
- Keep env var `KMP_DUPLICATE_LIB_OK=TRUE` on every torch script run.
- Reuse `PYTHONPATH=src`; avoid import-from-installed copies.
- Store new scripts under the existing reports path (Protected Assets rule—no root clutter).
- When writing markdown, stick to ASCII and avoid overwriting prior evidence sections.
- Note beam/polarization values exactly; no rounding beyond 6 sig figs.
- Leave previous artifacts in place; append new sections rather than replacing.
- Confirm `NB_C_BIN` is set before referencing C traces; document if you relied on archived logs instead of rerunning C.
- Respect two-message loop rule—submit Attempt logs after supervisor review.
Pointers:
- plans/active/cli-noise-pix0/plan.md:164
- docs/fix_plan.md:452
- reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_summary.md
- golden_suite_generator/nanoBragg.c:2140
- docs/architecture/pytorch_design.md:200
- docs/development/testing_strategy.md:1
Next Up: Prep BeamConfig default fix and regression test updates for K3 once evidence lands.
EOF
' succeeded in 1.03s:

[2025-10-06T20:54:15] tokens used: 379,728
[2025-10-06T20:54:15] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:54:20] thinking

**Preparing to update and commit changes**
[2025-10-06T20:54:22] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:54:23] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' succeeded in 843ms:
 M docs/fix_plan.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T20:54:23] tokens used: 381,186
[2025-10-06T20:54:23] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:54:26] thinking

**Appending findings to galph_memory.md**
[2025-10-06T20:54:29] exec bash -lc "cd /Users/ollie/Documents/nanoBragg3 && cat <<'EOF' >> galph_memory.md

## 2025-10-31 (galph loop — K2 rescope)
- Evidence review shows PyTorch still rescales MOSFLM cross products; C only does so when "'`user_cell` is set. Root cause for F_latt_b ≈ +21.6% identified. K2b added to plan with required `mosflm_rescale.py` artifact.
- Noted BeamConfig Kahn factor should default to 0.0 (C `polarization`). Reopened Phase I2 and updated fix_plan next steps to include default realignment during K3.
- Issued new Evidence memo (input.md) directing Ralph to rerun trace harness, refresh scaling markdown, and capture orientation deltas before touching normalization code.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:54:30] bash -lc "cd /Users/ollie/Documents/nanoBragg3 && cat <<'EOF' >> galph_memory.md

## 2025-10-31 (galph loop — K2 rescope)
- Evidence review shows PyTorch still rescales MOSFLM cross products; C only does so when "'`user_cell` is set. Root cause for F_latt_b ≈ +21.6% identified. K2b added to plan with required `mosflm_rescale.py` artifact.
- Noted BeamConfig Kahn factor should default to 0.0 (C `polarization`). Reopened Phase I2 and updated fix_plan next steps to include default realignment during K3.
- Issued new Evidence memo (input.md) directing Ralph to rerun trace harness, refresh scaling markdown, and capture orientation deltas before touching normalization code.
EOF
' succeeded in 797ms:

[2025-10-06T20:54:30] tokens used: 381,600
[2025-10-06T20:54:30] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:54:44] thinking

**Reviewing code diffs before commit**
[2025-10-06T20:54:47] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git diff' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:54:48] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git diff' succeeded in 1.06s:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 8551206..7de70f4 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
[2025-10-06T20:54:48] tokens used: 382,516
[2025-10-06T20:54:48] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:55:01] thinking

**Verifying changelog entry formatting**
[2025-10-06T20:55:04] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && tail -n 40 galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:55:05] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && tail -n 40 galph_memory.md' succeeded in 1.30s:
## 2025-10-26 (galph loop — H6e pivot evidence setup)
- `git pull --rebase` clean; reviewed Phase H6 artifacts plus docs/index/spec/arch/config map per SOP.
- Deep dive on pix0 traces shows C runs supervisor command in SAMPLE pivot while PyTorch config still defaults to BEAM when custom detector vectors are provided; this aligns with Attempt #38 residual deltas.
- Updated `plans/active/cli-noise-pix0/plan.md` Phase H6 to mark H6c done and add new rows H6e–H6g covering pivot evidence, config fix, and post-fix trace reruns.
- Refreshed `docs/fix_plan.md` Next Actions to require H6e pivot proof, H6f pivot logic change + regression test, then H6g trace rerun before resuming Phase K work.
- Issued new Evidence-phase memo (`input.md`) directing Ralph to capture pivot parity evidence and log it under `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` (no code edits yet).
- Next follow-up for Ralph: execute H6e (document pivot mismatch), update parity_summary + fix_plan Attempt log, then proceed to H6f implementation in a subsequent loop.

## 2025-10-06 (galph loop — H6f pivot enforcement prep)
- `git pull --rebase` clean; reviewed CLI parity backlog vs long-term goal #1 and vectorization plan status (no edits required yet).
- Deep dive on pix0 gap: Phase H6 evidence confirms C forces SAMPLE pivot when custom vectors are supplied; PyTorch still defaults to BEAM. Normalization remains blocked until pivot + lattice parity close.
- Coin flip → heads: inspected Ralph’s last two commits (`5d0a34d`, `0b7eaf7`). Evidence quality is solid, but parity visuals landed in repo root (`img*_*.png`, `intimage*.jpeg`, `noiseimage_preview.jpeg`) — flagged for relocation into reports before further work.
- Updated `docs/fix_plan.md` Next Actions for CLI-FLAGS-003 to mark H6e done, add H6f-prep cleanup, and call H6f/H6g/H6 progressions (Attempt #40 reserved for post-fix evidence).
- Issued new implementation memo (`input.md`) directing Ralph to move the stray images under `reports/2025-10-cli-flags/phase_h6/visuals/`, enforce SAMPLE pivot selection in `DetectorConfig`, add a targeted regression test, rerun focused pytest, and capture post-fix trace output for H6g.
- Follow-up for Ralph: execute H6f per memo, log Attempt update + regression artifacts, then pause for supervisor review before H6g.

## 2025-10-06 (galph loop — H6g evidence kickoff)
- `timeout 30 git pull --rebase` returned "Already up to date"; no conflicts encountered.
- Reviewed CLI-FLAGS-003 entry (`docs/fix_plan.md:448-462`) and Phase H6 table (`plans/active/cli-noise-pix0/plan.md:131-145`); confirmed Attempt #40 landed pivot forcing but H6g artifacts remain outstanding.
- Updated `plans/active/cli-noise-pix0/plan.md` context with Attempt #40 recap and marked H6f as `[D]`; rewrote H6g guidance to require post-fix trace + nb-compare artifacts under `reports/…/phase_h6/post_fix/` and to log Attempt #41.
[2025-10-06T20:55:05] tokens used: 385,763
[2025-10-06T20:55:05] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:55:10] thinking

**Verifying git status before staging**
[2025-10-06T20:55:11] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:55:12] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' succeeded in 848ms:
 M docs/fix_plan.md
 M galph_memory.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T20:55:12] tokens used: 387,575
[2025-10-06T20:55:12] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:55:16] thinking

**Staging all changes**
[2025-10-06T20:55:17] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git add docs/fix_plan.md galph_memory.md input.md plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:55:18] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git add docs/fix_plan.md galph_memory.md input.md plans/active/cli-noise-pix0/plan.md' succeeded in 779ms:

[2025-10-06T20:55:18] tokens used: 387,893
[2025-10-06T20:55:18] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:55:22] thinking

**Checking file status**
[2025-10-06T20:55:22] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:55:23] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git status --short' succeeded in 799ms:
M  docs/fix_plan.md
M  galph_memory.md
M  input.md
M  plans/active/cli-noise-pix0/plan.md
[2025-10-06T20:55:23] tokens used: 388,178
[2025-10-06T20:55:23] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:55:26] thinking

**Preparing commit message**
[2025-10-06T20:55:27] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git commit -m "SUPERVISOR: CLI-FLAGS K2 evidence reshaping - tests: not run"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:55:28] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git commit -m "SUPERVISOR: CLI-FLAGS K2 evidence reshaping - tests: not run"' succeeded in 806ms:
[feature/spec-based-2 aef75b2] SUPERVISOR: CLI-FLAGS K2 evidence reshaping - tests: not run
 4 files changed, 48 insertions(+), 51 deletions(-)
[2025-10-06T20:55:28] tokens used: 388,490
[2025-10-06T20:55:28] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:55:30] thinking

**Pushing changes to remote**
[2025-10-06T20:55:31] exec bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git push' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T20:55:34] bash -lc 'cd /Users/ollie/Documents/nanoBragg3 && git push' succeeded in 2.40s:
To github.com:hoidn/nanoBragg.git
   65edd81..aef75b2  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T20:55:34] tokens used: 388,724
[2025-10-06T20:55:34] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T20:55:45] thinking

**Summarizing analysis and next steps**

I’m putting together a final response that explains the updated CLI parity plan, highlights key modifications, and dives into hypotheses explaining the core issues like MOSFLM rescale gaps and polarization mismatches. I’ll include file references with line numbers, rank hypotheses by severity with confidence and next steps, and note that the vectorization plan is still pending. Finally, I’ll outline next tasks for Ralph as detailed in `input.md`. This way, the user gets a clear, structured overview with actionable insights.
[2025-10-06T20:55:47] codex

Updated CLI parity planning artifacts so Ralph can gather the right evidence before touching normalization code: `plans/active/cli-noise-pix0/plan.md:165` now reopens Phase I2 (Kahn factor default) and adds K2b to require a `mosflm_rescale.py` script, while `docs/fix_plan.md:454` points Next Actions at that rescale proof plus the upcoming implementation work. Logged the findings in `galph_memory.md` and replaced `input.md` with an evidence-phase memo instructing the trace rerun and the new orientation delta capture.

**Gaps vs Goal #1 (CLI parity)**  
- `F_latt_b` still 21.6 % high because PyTorch always rescales MOSFLM cross products to formula lengths; C only does that when `-cell` is provided (`plans/active/cli-noise-pix0/plan.md:176`).  
- Polarization stays at 1.0 because BeamConfig defaults Kahn factor to 1.0, while C leaves `polarization=0.0` (`docs/fix_plan.md:454`).  
- Vectorization initiative remains untouched; Phase A baselines in `plans/active/vectorization.md` are still outstanding.

**Hypotheses & Next Checks**  
1. *MOSFLM rescale mismatch* — Confidence high. B-axis delta (~4.6×10⁻² Å) explains F_latt_b>1.2. Confirm via new `mosflm_rescale.py` comparing PyTorch `Crystal.compute_cell_tensors` to raw C cross products.  
2. *Polarization default regression* — Confidence high. C’s `polarization` starts at 0.0, so we must revert the BeamConfig default and adjust tests; verify by rerunning the scaling harness after the change.

**Next steps for Ralph**  
Follow `input.md` (Evidence phase) to refresh `trace_py_after.log`, regenerate scaling ratios, and drop the orientation delta artifacts before touching normalization or tests.
[2025-10-06T20:55:51] tokens used: 389,846
[2025-10-06T20:55:51] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85512067f9871e2780651d1e5da2684e02c3a179..7de70f45301a97e354cd63351a122593c3e91706
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -454,11 +454,11 @@
 - Reproduction (C & PyTorch):
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
-- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-27 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
-  1. Phase K2 — rerun the Phase J scaling harness with the SAMPLE-pivot geometry (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`), update `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, and explain the current deltas recorded in `phase_k/f_latt_fix/test_metrics_failure.json` (correlation≈0.173, sum_ratio≈1.46). Document whether `F_cell`, `F_latt`, or downstream factors remain off.
-  2. Phase K3 — once scaling ratios match C, run the targeted regression (`env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`), archive the log under `phase_k/f_latt_fix/pytest.log`, and refresh `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected normalization flow.
-  3. Phase L gating — only after K2/K3 evidence is green should Ralph rerun the full supervisor command parity sweep and close the plan; keep normalization blocked until the scaling artifacts land.
+- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Post-pivot traces (2025-10-31) show two remaining blockers: (a) PyTorch always rescales MOSFLM cross products to user-provided cell lengths, whereas C skips `vector_rescale` unless `-cell` was supplied, yielding ~4.6×10⁻² Å error in `rot_b` and F_latt_b ≈ +21.6 %; (b) BeamConfig still defaults the Kahn factor to 1.0, while C leaves `polarization=0.0`, producing polar=1.0 vs 0.9126.
+- Next Actions (2025-10-31 refresh): Pix0 parity (H6g) is complete; normalization remains the blocker before attempting the supervisor command again:
+  1. Phase K2/K2b — refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`, add `phase_k/f_latt_fix/orientation_delta.md` + `mosflm_rescale.py` capturing the rescale mismatch, and ensure `metrics_after.json` explicitly calls out polarization staying at 1.0.
+  2. Phase K3 — implement the fixes: guard the rescale path in `Crystal.compute_cell_tensors` when `mosflm_a_star` is present, realign BeamConfig defaults/tests so `-polar` opt-in is required, update docs, and rerun `tests/test_cli_scaling.py::test_f_latt_square_matches_c` (with `NB_RUN_PARALLEL=1`, log to `phase_k/f_latt_fix/pytest.log`).
+  3. Phase L gating — once scaling ratios are within tolerance, rerun the supervisor command parity sweep and close the plan, keeping normalization blocked until the artifacts land in `phase_l/`.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 85419a2e764d276bfdd33fe057f615b5b2f10841..bb37de54e90ff17bf90c0c185f230266a11fdf59
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -8,6 +8,7 @@
 - Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
 - Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
 - Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
+- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
 - Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
@@ -154,8 +155,8 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
-| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
-| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |
+| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
+| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
 
 ### Phase J — Intensity Scaling Evidence
 Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
@@ -176,8 +177,9 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` (and k/l analogues) with the C-code snippet embedded. Regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
-| K2 | Recompute scaling chain & extend diagnostics | [ ] | After ingesting Attempt #41 geometry, rerun the Phase J harness to emit `reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log` and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`. Quantify Py/C ratios for `F_cell`, `F_latt`, `I_before_scaling`, and downstream factors, explaining the `test_metrics_failure.json` deltas (correlation≈0.173, sum_ratio≈1.46). Spot-check ROUND/GAUSS/TOPHAT against C and log outcomes before closing this row. |
-| K3 | Regression tests & documentation | [ ] | Once H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update `docs/architecture/pytorch_design.md` plus `phase_k/notes.md` with the corrected lattice-factor flow.
+| K2 | Recompute scaling chain & extend diagnostics | [P] | Refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with the SAMPLE-pivot data (trace_py_after.log) and annotate `scaling_summary.md`/`metrics_after.json` so the first divergence calls out (1) F_latt_b ≈ +21.6 % and (2) polarization factor stuck at 1.0. Include a short reproduction under `phase_k/f_latt_fix/orientation_delta.md` showing C vs PyTorch `rot_b` components. |
+| K2b | Document MOSFLM rescale mismatch | [ ] | Produce a minimal script (`reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py`) comparing C-style cross products (no rescale) vs current PyTorch `Crystal.compute_cell_tensors` for `A.mat`. Record the resulting `b` vector deltas (≈+0.0457 Å along y) and cite C code lines 2145-2147 that guard rescale behind `user_cell`. |
+| K3 | Implementation + regression | [ ] | Implement the normalization fixes: (a) gate the cross-product rescale path in `Crystal.compute_cell_tensors` so MOSFLM matrices skip it (mirroring `user_cell==0`), (b) realign BeamConfig defaults so the Kahn factor is 0.0 unless `-polar`/`-nopolar` override it, and (c) update CLI/tests (`tests/test_cli_scaling.py`, `tests/test_cli_flags.py`) plus docs (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`). After changes, rerun the targeted parity harness (`tests/test_cli_scaling.py::test_f_latt_square_matches_c`) and archive logs under `phase_k/f_latt_fix/pytest.log`.
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.

Reading prompt from stdin...
Already up to date.
To github.com:hoidn/nanoBragg.git
   aef75b2..748f7be  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=48...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=48
Updating 748f7be..a82cb13
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   748f7be..a82cb13  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=48
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating a82cb13..eed4eec
Fast-forward
 docs/fix_plan.md                                   |  16 ++
 plans/active/cli-noise-pix0/plan.md                |   4 +-
 .../phase_k/f_latt_fix/analyze_output.txt          |  57 +++++
 .../phase_k/f_latt_fix/mosflm_rescale.py           | 271 +++++++++++++++++++++
 .../phase_k/f_latt_fix/orientation_delta.md        | 128 ++++++++++
 .../phase_k/f_latt_fix/scaling_chain.md            |  30 +++
 6 files changed, 504 insertions(+), 2 deletions(-)
 create mode 100644 reports/2025-10-cli-flags/phase_k/f_latt_fix/analyze_output.txt
 create mode 100644 reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py
 create mode 100644 reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md
 create mode 100644 reports/2025-10-cli-flags/phase_k/f_latt_fix/scaling_chain.md
From github.com:hoidn/nanoBragg
   a82cb13..eed4eec  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating eed4eec..14f86ba
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   eed4eec..14f86ba  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=49
Ralph completed iteration 48; proceeding to 49
