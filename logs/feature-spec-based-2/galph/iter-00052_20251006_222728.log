Current branch feature/spec-based-2 is up to date.
Waiting for expected_actor=galph...
Current branch feature/spec-based-2 is up to date.
[sync] state: actor=galph status=running-galph iter=52
To github.com:hoidn/nanoBragg.git
   e057015..276392a  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T22:27:32] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T22:27:32] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 


Debugging Items — Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‑line rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for this turn.
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
Header:
- Summary: <one‑sentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
  - Note: When the Phase is Evidence, you must not execute tests; any pytest command included here is provided for Ralph’s subsequent loop.
<Do Now guidelines>
Phase Gate (Evidence, supervisor-scoped): When you (galph) select an Evidence-phase task, focus on information collection and do not change the implementation or introduce new tests (with the exception of verification scripts). This gate applies only to galph. Ralph is exempt.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T22:27:36] thinking

**Preparing to update documentation and plans**
[2025-10-06T22:27:36] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:27:38] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.15s:
Already up to date.
[2025-10-06T22:27:38] tokens used: 10,902

[2025-10-06T22:27:41] thinking

**Preparing to view galph_memory.md**
[2025-10-06T22:27:41] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:27:42] bash -lc 'cat galph_memory.md' succeeded in 747ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-06T22:27:42] tokens used: 11,025

[2025-10-06T22:27:45] thinking

**Preparing to review documentation**
[2025-10-06T22:27:46] exec bash -lc 'cat docs/index.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:27:46] bash -lc 'cat docs/index.md' succeeded in 710ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T22:27:46] tokens used: 13,902

[2025-10-06T22:27:49] thinking

**Preparing to read spec-a.md**
[2025-10-06T22:27:49] exec bash -lc 'cat specs/spec-a.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:27:50] bash -lc 'cat specs/spec-a.md' succeeded in 688ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T22:27:50] tokens used: 15,599

[2025-10-06T22:27:51] thinking

**Considering shard reading**
[2025-10-06T22:27:52] exec bash -lc 'cat specs/spec-a-core.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:27:52] bash -lc 'cat specs/spec-a-core.md' succeeded in 758ms:
# nanoBragg Spec A — Core Engine

This shard contains the normative physics, geometry, sampling, and data handling requirements. CLI flag semantics live in [spec-a-cli.md](spec-a-cli.md); cross-implementation profiles and developer tooling are captured in [spec-a-parallel.md](spec-a-parallel.md).

Overview (Normative)

- Purpose: Simulates far-field diffraction from a perfect-lattice nanocrystal on a pixelated area
detector. No near-field propagation or detector PSF beyond pixel solid-angle/obliquity is modeled.
No symmetry is imposed; reflection indexing is P1 only (no Friedel pairing).
- Scope: Renders pixel intensities from a set of sources (beam divergence and spectral dispersion),
crystal orientation (including rotation oscillation and mosaic domains), and detector geometry.
Outputs: raw float image, SMV-format integer image (with and without Poisson noise), and optional
PGM.
- Key constants:
    - Classical electron radius squared r_e^2 = 7.94079248018965e-30 m^2.
    - Avogadro’s number = 6.02214179e23 mol^-1.

Units & Conversions (Normative)

- Length:
[2025-10-06T22:27:52] tokens used: 15,881

[2025-10-06T22:27:54] thinking

**Observing file truncation and planning next steps**
[2025-10-06T22:27:55] exec bash -lc 'cat specs/spec-a-cli.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:27:56] bash -lc 'cat specs/spec-a-cli.md' succeeded in 700ms:
# nanoBragg Spec A — CLI Binding

This shard documents the command-line interface, header precedence, and CLI-focused acceptance tests. It should be read alongside [spec-a-core.md](spec-a-core.md) for the simulation engine requirements and [spec-a-parallel.md](spec-a-parallel.md) for conformance profiles.

CLI Interface (Normative)

All options recognized by this code version are enumerated below. Values with units are converted
immediately as specified in Units & Conversions. Unsupported flags are not recognized even if
present in header comments.

- Input files:
    - -hkl <file>: Text file of “h k l F” (integers h,k,l; real F). Required unless Fdump.bin exists
or -default_F used.
    - -mat <file>: 3×3 MOSFLM-style A matrix (reciprocal cell vectors scaled by 1/λ). Required
unless -cell used.
    - -cell a b c alpha beta gamma: Direct cell in Å and degrees; alternative to -mat.
    - -img <file>: Read SMV header; may set fpixels, spixels, pixel size (mm), distance (mm), close
distance (mm), wavelength (Å), beam centers (mm), ORGX/ORGY (pixels), φ start (deg), oscillation
range (deg), 2θ (deg). Image data is read but not used.
    - -mask <file>: Read SMV mask; uses same headers to initialize geometry as -img. Zero-valued
[2025-10-06T22:27:56] tokens used: 19,056

[2025-10-06T22:27:58] thinking

**Requesting specification details**
[2025-10-06T22:27:59] exec bash -lc 'cat specs/spec-a-parallel.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:27:59] bash -lc 'cat specs/spec-a-parallel.md' succeeded in 730ms:
# nanoBragg Spec A — Conformance & Parallel Tests

This shard enumerates the CLI profile acceptance tests, parallel validation suite, developer tooling expectations, and conformance profiles. Review [spec-a-core.md](spec-a-core.md) for base requirements and [spec-a-cli.md](spec-a-cli.md) for CLI semantics referenced here.

Parallel Validation Tests (Profile: C-PyTorch Equivalence) — Acceptance Tests (Normative)

References: ../docs/development/testing_strategy.md (parallel trace-driven validation), ../docs/debugging/debugging.md (trace SOP), ../docs/debugging/detector_geometry_checklist.md (detector geometry triage), ../docs/architecture/undocumented_conventions.md (hidden C behaviors)
Why: testing_strategy and debugging.md define the parallel trace methodology; the detector checklist accelerates geometry debugging; undocumented_conventions flags hidden C behaviors that often break equivalence.

These tests verify that PyTorch implementation produces outputs equivalent to the C reference implementation. They apply to implementations claiming the C-PyTorch Equivalence Profile. These are black-box behavioral tests comparing outputs without examining internal implementation details.

- AT-PARALLEL-001 Beam Center Scales with Detector Size
  - Setup: Test detector sizes 64x64, 128x128, 256x256, 512x512, 1024x1024 pixels with 0.1mm pixel size, cubic crystal 100Å N=3, λ=6.2Å
  - Expectation: Beam center (mm) SHALL equal detector_pixels/2 × pixel_size_mm; Peak SHALL appear at detector center ±2 pixels; Correlation between C and PyTorch ≥0.9999
  - Failure mode: Fixed beam center at 51.2mm regardless of detector size
  - Implementation:
    - Parity (canonical): `KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest -v tests/test_parity_matrix.py -k "AT-PARALLEL-001"`
    - Supplemental PyTorch-only regression: `pytest -v tests/test_at_parallel_001.py`

- AT-PARALLEL-002 Pixel Size Independence
[2025-10-06T22:27:59] tokens used: 22,080

[2025-10-06T22:28:02] thinking

**Searching for architecture documentation**
[2025-10-06T22:28:02] exec bash -lc 'cat arch.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:03] bash -lc 'cat arch.md' succeeded in 725ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T22:28:03] tokens used: 46,975

[2025-10-06T22:28:05] thinking

**Planning to read config map docs**
[2025-10-06T22:28:05] exec bash -lc 'cat docs/development/c_to_pytorch_config_map.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:06] bash -lc 'cat docs/development/c_to_pytorch_config_map.md' succeeded in 712ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T22:28:06] tokens used: 49,670

[2025-10-06T22:28:10] thinking

**Reviewing debugging documentation**
[2025-10-06T22:28:11] exec bash -lc 'cat docs/debugging/debugging.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:12] bash -lc 'cat docs/debugging/debugging.md' succeeded in 720ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T22:28:12] tokens used: 51,604

[2025-10-06T22:28:15] thinking

**Checking for fix_plan documentation**
[2025-10-06T22:28:16] exec bash -lc 'cat docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:16] bash -lc 'cat docs/fix_plan.md' succeeded in 725ms:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A–C) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2–B4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1–A3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ✅ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
| [CLI-DTYPE-002](#cli-dtype-002-cli-dtype-parity) | CLI dtype parity | High | in_progress |
[2025-10-06T22:28:16] tokens used: 54,155

[2025-10-06T22:28:20] thinking

**Noticing file truncation and locating testing strategy docs**
[2025-10-06T22:28:21] exec bash -lc 'cat docs/development/testing_strategy.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:21] bash -lc 'cat docs/development/testing_strategy.md' succeeded in 677ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T22:28:21] tokens used: 57,056

[2025-10-06T22:28:25] thinking

**Preparing environment variable reminders**
[2025-10-06T22:28:26] exec bash -lc 'ls plans/active' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:27] bash -lc 'ls plans/active' succeeded in 693ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T22:28:27] tokens used: 60,470

[2025-10-06T22:28:29] thinking

**Reviewing vectorization plan**
[2025-10-06T22:28:29] exec bash -lc 'cat plans/active/vectorization.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:30] bash -lc 'cat plans/active/vectorization.md' succeeded in 727ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B — Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T22:28:30] tokens used: 60,724

[2025-10-06T22:28:32] thinking

**Reviewing related plan cli-noise-pix0**
[2025-10-06T22:28:32] exec bash -lc 'cat plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:33] bash -lc 'cat plans/active/cli-noise-pix0/plan.md' succeeded in 698ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
- Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
- Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
- Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
- Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
- Documentation anchors for this focus:
  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
[2025-10-06T22:28:33] tokens used: 63,345

[2025-10-06T22:28:36] thinking

**Considering additional plan files**
[2025-10-06T22:28:37] exec bash -lc 'cat plans/active/gradcheck-tier2-completion/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:38] bash -lc 'cat plans/active/gradcheck-tier2-completion/plan.md' succeeded in 700ms:
# Plan: AT-TIER2-GRADCHECK Completion

**Status:** Active (new 2025-10-15)
**Priority:** High — spec compliance blocker (testing_strategy §4.1)
**Related fix_plan item:** `[AT-TIER2-GRADCHECK]` — docs/fix_plan.md
**Created:** 2025-10-15 by galph

## Context
- Initiative: Ensure differentiability guarantees (long-term goal: autodiff-based refinement showcase).
- Phase Goal: Close the remaining Tier-2 gradcheck gaps called out in testing_strategy.md §4.1: `misset_rot_x`, beam `lambda_A`, and `fluence`.
- Current State: Commit 0e3054c implemented gradchecks for unit-cell lengths/angles and detector distance/beam_center_f. Commit d45a0f3 introduced `NANOBRAGG_DISABLE_COMPILE` to work around torch.compile bugs. However, no coverage exists yet for misset rotations or beam parameters, and the harness still emits contradictory compile-mode toggles (`NB_DISABLE_COMPILE` vs `NANOBRAGG_DISABLE_COMPILE`). The spec remains unmet.
- Dependencies: `tests/test_gradients.py`, `tests/test_suite.py::TestTier2GradientCorrectness`, `docs/development/testing_strategy.md §4.1`, `arch.md §15`, perf plan task B7 (env-var alignment for compile toggles).

### Phase A — Baseline Audit & Environment Alignment
Goal: Capture authoritative evidence of current coverage gaps and ensure the compile-disable switch is consistent across harnesses before adding new tests.
Prereqs: None.
Exit Criteria: Audit note summarising missing parameters, baseline gradcheck log attached, and env-var naming decision recorded (either standardise on `NANOBRAGG_DISABLE_COMPILE` or support both).

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
[2025-10-06T22:28:38] tokens used: 67,008

[2025-10-06T22:28:42] thinking

**Preparing deep codebase analysis**
[2025-10-06T22:28:43] exec bash -lc 'rg -n "CLI-FLAGS-003" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:43] bash -lc 'rg -n "CLI-FLAGS-003" -n docs/fix_plan.md' succeeded in 731ms:
21:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
448:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
[2025-10-06T22:28:43] tokens used: 68,913

[2025-10-06T22:28:45] thinking

**Extracting specific lines from documentation**
[2025-10-06T22:28:46] exec bash -lc "sed -n '448,750p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:28:46] bash -lc "sed -n '448,750p' docs/fix_plan.md" succeeded in 687ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A–H complete; K3a/K3b/K3d landed via Attempts #43–44, pending per-φ evidence + normalization closure)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
- Next Actions (2025-11-07 refresh):
  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/summary.json` - Complete parity metrics (correlation, RMSE, sums, peak distances)
[2025-10-06T22:28:46] tokens used: 69,196

[2025-10-06T22:28:56] thinking

**Preparing analysis and environment steps**

I'm reviewing instructions to set an environment variable for authoritative commands and considering how to handle ephemeral shell exports. I’m also thinking about whether to use the plan tool since the tasks look complex and involve multiple steps. Next, I’ll prepare for the coin toss step using a Python command to decide whether to review recent iterations.
[2025-10-06T22:28:59] exec bash -lc "python - <<'PY'
import random
print('heads' if random.random()<0.5 else 'tails')
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:00] bash -lc "python - <<'PY'
import random
print('heads' if random.random()<0.5 else 'tails')
PY" succeeded in 1.08s:
heads
[2025-10-06T22:29:00] tokens used: 72,910

[2025-10-06T22:29:04] thinking

**Reviewing recent commits**
[2025-10-06T22:29:08] exec bash -lc 'git log --oneline -n 12' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:08] bash -lc 'git log --oneline -n 12' succeeded in 784ms:
276392a SUPERVISOR AUTO: doc/meta hygiene — tests: not run
e057015 SUPERVISOR: CLI parity K3f prep - tests: not run
32f282e update supervisor and main to exempt loop.sh / ralph from evidence-only constraint
06363bc [SYNC i=52] actor=galph status=running
82bbc42 [SYNC i=52] actor=ralph → next=galph status=ok ralph_commit=2467064
2467064 CLI-FLAGS-003 Phase K3e: Per-φ Miller index parity evidence complete
987c4f1 [SYNC i=51] actor=ralph status=running
751c1b7 [SYNC i=51] actor=galph → next=ralph status=ok galph_commit=dfe079a
dfe079a SUPERVISOR: CLI parity plan update - tests: not run
a341694 [SYNC i=51] actor=galph status=running
bf42f7a [SYNC i=51] actor=ralph → next=galph status=ok ralph_commit=271e2b6
271e2b6 CLI-FLAGS-003 Phase K3d: dtype sensitivity evidence - dtype NOT root cause
[2025-10-06T22:29:08] tokens used: 73,195

[2025-10-06T22:29:12] thinking

**Reviewing recent commits by author**
[2025-10-06T22:29:12] exec bash -lc 'git log --oneline --author=ralph -n 6' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:13] bash -lc 'git log --oneline --author=ralph -n 6' succeeded in 732ms:

[2025-10-06T22:29:13] tokens used: 73,843

[2025-10-06T22:29:17] thinking

**Investigating commit author details**
[2025-10-06T22:29:17] exec bash -lc 'git show --stat 2467064' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:18] bash -lc 'git show --stat 2467064' succeeded in 765ms:
commit 24670648292c4768a8410fd8c925864be979d975
Author: ollie <ohoidn>
Date:   Mon Oct 6 15:16:07 2025 -0700

    CLI-FLAGS-003 Phase K3e: Per-φ Miller index parity evidence complete
    
    Module: tooling/diagnostics (evidence generation)
    
    Implemented:
    - Created scripts/trace_per_phi.py to generate PyTorch per-φ traces
    - Instrumented golden_suite_generator/nanoBragg.c:3156-3160 with TRACE_C_PHI
    - Created scripts/compare_per_phi_traces.py for C vs PyTorch comparison
    - Generated evidence artifacts under reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/
    
    Evidence findings:
    - Δk≈6.042 at φ=0° (C k_frac=−3.857, PyTorch k_frac=−9.899)
    - Divergence persists across all φ_tic=0…9
    - Root cause: fundamental lattice/geometry mismatch BEFORE φ rotation
    - Hypothesis: NOT a φ-sampling offset as originally suspected
    
[2025-10-06T22:29:18] tokens used: 74,059

[2025-10-06T22:29:21] thinking

**Reviewing large commit example**
[2025-10-06T22:29:21] exec bash -lc 'git show --stat 271e2b6' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:22] bash -lc 'git show --stat 271e2b6' succeeded in 670ms:
commit 271e2b64d32f687801bbd7fd0f2c2704a99ea756
Author: ollie <ohoidn>
Date:   Mon Oct 6 14:48:23 2025 -0700

    CLI-FLAGS-003 Phase K3d: dtype sensitivity evidence - dtype NOT root cause
    
    Evidence-only loop completing Phase K3d per input.md directive.
    
    Key finding: Float32 vs float64 precision does NOT explain F_latt_b
    discrepancy. Both dtypes produce F_latt_b ≈ 2.33 (93.98% error vs
    C's 38.63). Dtype improvement is only 0.39%, ruling out rounding as
    significant error source.
    
    Metrics:
    - F_latt_b: float32=2.33, float64=2.33, C=38.63 (93.98% error both)
    - Miller index precision: h_frac Δ=1.09e-06 (4.12e-06% rel error)
    - F_latt precision: Δ=1.19e-03 (0.39% rel error)
    - Conclusion: Systematic geometric error, not precision issue
    
    Artifacts:
[2025-10-06T22:29:22] tokens used: 74,806

[2025-10-06T22:29:26] thinking

**Assessing recent commit quality**
[2025-10-06T22:29:27] exec bash -lc "sed -n '1,160p' scripts/trace_per_phi.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:28] bash -lc "sed -n '1,160p' scripts/trace_per_phi.py" succeeded in 702ms:
#!/usr/bin/env python3
"""
CLI-FLAGS-003 Phase K3e: Per-φ Miller Index Parity

This script captures Miller index + lattice factor traces for each φ step
(φ_tic=0…9) to diagnose the φ-grid mismatch between C and PyTorch.

Context: PyTorch reports k≈1.9997 (φ=0°) while C reports k≈1.9928 (φ=0.09°),
causing a 21.6% F_latt_b inflation. This per-φ dump will isolate the first φ
where Δk exceeds tolerance.

Usage:
    PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py \\
        --outdir reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/

Output:
    - per_phi_pytorch.json: Full per-φ trace data (PyTorch)
    - per_phi_summary.md: Comparison summary with first divergence
    - (C trace expected from instrumented nanoBragg.c separately)
"""
[2025-10-06T22:29:28] tokens used: 75,782

[2025-10-06T22:29:37] thinking

**Evaluating plan status and update needs**

I’m thinking through whether multiple `.item()` calls might be okay in tracing, but I need to assess if the plan for vectorization and other tasks remains current. I’ll gather more data by checking git status and relevant plan docs to see if updates or multi-turn planning are necessary, focusing on long-term goals and any stuck tasks.
[2025-10-06T22:29:39] exec bash -lc "sed -n '320,420p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:40] bash -lc "sed -n '320,420p' docs/fix_plan.md" succeeded in 926ms:

---


## [ROUTING-LOOP-001] loop.sh routing guard
- Spec/AT: Prompt routing rules (prompts/meta.md)
- Priority: High
- Status: done (verified compliant 2025-10-01)
- Owner/Date: ralph/2025-10-01 (verification and completion)
- Plan Reference: `plans/active/routing-loop-guard/plan.md`
- Reproduction (C & PyTorch):
  * C: `sed -n '1,80p' loop.sh`
  * PyTorch: n/a
  * Shapes/ROI: n/a
- First Divergence (if known): Commit `c49e3be` reverted the guard—`loop.sh` pipes `prompts/main.md` through `{1..40}` loop, removes `git pull --rebase`, and performs unconditional `git push`.
- Immediate Next Actions (2025-10-13):
  * Run plan Phase A tasks (A1–A3) against commit `c49e3be` so the regression evidence references the latest violation, then confirm the current guarded script via Phase C compliance log before re-archiving the plan.
- Attempts History:
  * [2025-10-12] Attempt #6 — Result: regression reopened. Detected commit `c49e3be` (loop.sh) restoring the 40-iteration `prompts/main.md` pipeline and stripping the timeouted `git pull --rebase`/conditional push added in `ffd9a5c`. No new audit artifacts captured; automation must stay paused until Phase A evidence is refreshed under `reports/routing/`.
    Metrics: n/a (manual inspection).
[2025-10-06T22:29:40] tokens used: 78,554

[2025-10-06T22:29:48] thinking

**Assessing plan update needs**
[2025-10-06T22:29:49] exec bash -lc "sed -n '3000,3200p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:50] bash -lc "sed -n '3000,3200p' golden_suite_generator/nanoBragg.c" succeeded in 746ms:
                            scattering[2] = (diffracted[2]-incident[2])/lambda;
                            scattering[3] = (diffracted[3]-incident[3])/lambda;
                            
                            /* trace output for specific pixel */
                            if(fpixel==trace_fpixel && spixel==trace_spixel && source==0) {
                                printf("TRACE_C: pix0_vector_meters %.15g %.15g %.15g\n", pix0_vector[1], pix0_vector[2], pix0_vector[3]);
                                printf("TRACE_C: fdet_vec %.15g %.15g %.15g\n", fdet_vector[1], fdet_vector[2], fdet_vector[3]);
                                printf("TRACE_C: sdet_vec %.15g %.15g %.15g\n", sdet_vector[1], sdet_vector[2], sdet_vector[3]);
                                printf("TRACE_C: pixel_pos_meters %.15g %.15g %.15g\n", pixel_pos[1], pixel_pos[2], pixel_pos[3]);
                                printf("TRACE_C: R_distance_meters %.15g\n", airpath);
                                printf("TRACE_C: omega_pixel_sr %.15g\n", omega_pixel);
                                printf("TRACE_C: close_distance_meters %.15g\n", close_distance);
                                printf("TRACE_C: obliquity_factor %.15g\n", close_distance/airpath);
                                printf("TRACE_C: diffracted_vec %.15g %.15g %.15g\n", diffracted[1], diffracted[2], diffracted[3]);
                                printf("TRACE_C: incident_vec %.15g %.15g %.15g\n", incident[1], incident[2], incident[3]);
                                printf("TRACE_C: lambda_meters %.15g\n", lambda);
                                printf("TRACE_C: lambda_angstroms %.15g\n", lambda*1e10);
                                printf("TRACE_C: scattering_vec_A_inv %.15g %.15g %.15g\n", scattering[1], scattering[2], scattering[3]);
                            }

[2025-10-06T22:29:50] tokens used: 82,440

[2025-10-06T22:29:53] thinking

**Examining phi increment calculation**
[2025-10-06T22:29:54] exec bash -lc 'rg "phistep" -n golden_suite_generator/nanoBragg.c | head' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:55] bash -lc 'rg "phistep" -n golden_suite_generator/nanoBragg.c | head' succeeded in 711ms:
321:    double phi,phi0=0.0,phistep=-1.0,osc=-1.0;
322:    int phi_tic,phisteps=-1;
966:            if(strstr(argv[i], "-phistep") && strlen(argv[i])==8 && (argc > (i+1)))
968:                phistep = atof(argv[i+1])/RTD;
970:            if(strstr(argv[i], "-phisteps") && (argc > (i+1)))
972:                phisteps = atoi(argv[i+1]);
1353:        printf("\t-phisteps        \tnumber of rotation steps to render\n");
1401:    if(phisteps < 0){
1405:            if(phistep <= 0.0) {
1407:                phisteps = 1;
[2025-10-06T22:29:55] tokens used: 84,934

[2025-10-06T22:29:57] thinking

**Extracting specific code section**
[2025-10-06T22:29:58] exec bash -lc "sed -n '1370,1460p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:29:58] bash -lc "sed -n '1370,1460p' golden_suite_generator/nanoBragg.c" succeeded in 660ms:
        printf("\t-flux            \talternative to -fluence, specify flux, along with -beamsize and -exposure (photons/s)\n");
        printf("\t-beamsize        \talternative to -fluence, specify beam size, along with -flux and -exposure (default: %g mm)\n",beamsize*1000);
        printf("\t-exposure        \talternative to -fluence, specify flux, along with -flux and -beamsize (default: %g s)\n", exposure);
        printf("\t-nonoise         \tdisable generating the noisefile\n");
        printf("\t-noprogress      \tturn off the progress meter\n");
        printf("\t-nopolar         \tturn off the polarization correction\n");
        printf("\t-nointerpolate   \tdisable inter-Bragg peak structure factor interpolation\n");
        printf("\t-interpolate     \tforce inter-Bragg peak structure factor interpolation (default: on if < 3 cells wide)\n");
        printf("\t-point_pixel     \tturn off the pixel solid angle correction\n");
        printf("\t-curved_det      \tall pixels same distance from crystal\n");
        printf("\t-fdet_vector     \tunit vector of increasing fast-axis detector pixel coordinate (default: %g %g %g)\n",fdet_vector[1],fdet_vector[2],fdet_vector[3]);
        printf("\t-sdet_vector     \tunit vector of increasing slow-axis detector pixel coordinate (default: %g %g %g)\n",sdet_vector[1],sdet_vector[2],sdet_vector[3]);
        printf("\t-odet_vector     \tunit vector of increasing detector distance (default: %g %g %g)\n",odet_vector[1],odet_vector[2],odet_vector[3]);
        printf("\t-beam_vector     \tunit vector of x-ray beam direction (default: %g %g %g)\n",beam_vector[1],beam_vector[2],beam_vector[3]);
        printf("\t-polar_vector    \tunit vector of x-ray E-vector polarization (default: %g %g %g)\n",polar_vector[1],polar_vector[2],polar_vector[3]);
        printf("\t-spindle_axis    \tunit vector of right-handed phi rotation axis (default: %g %g %g)\n",spindle_vector[1],spindle_vector[2],spindle_vector[3]);
        printf("\t-pix0_vector     \tvector from crystal to first pixel in image (default: beam centered on detector)\n");
//        printf("\t-source_distance \tdistance of x-ray source from crystal (default: 10 meters)\n");
        exit(9);
    }
[2025-10-06T22:29:58] tokens used: 85,330

[2025-10-06T22:30:12] thinking

**Analyzing phi step discrepancies and lattice differences**

I'm comparing how phi steps are computed in two scripts, noting a slight angle coverage mismatch that might cause differences in results. However, since the difference at phi=0 remains unexplained by step size, I'm shifting focus to how the base lattice vectors are calculated, suspecting possible discrepancies in orientation or scaling between PyTorch and C implementations. I'll check the crystal model computations next.
[2025-10-06T22:30:13] exec bash -lc 'rg -n "compute_cell_tensors" -n src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:30:14] bash -lc 'rg -n "compute_cell_tensors" -n src/nanobrag_torch/models/crystal.py' succeeded in 925ms:
412:    def compute_cell_tensors(self) -> dict:
762:    def _compute_cell_tensors_cached(self):
764:        Cached version of compute_cell_tensors to avoid redundant calculations.
772:        return self.compute_cell_tensors()
777:        return self._compute_cell_tensors_cached()["a"]
782:        return self._compute_cell_tensors_cached()["b"]
787:        return self._compute_cell_tensors_cached()["c"]
792:        return self._compute_cell_tensors_cached()["a_star"]
797:        return self._compute_cell_tensors_cached()["b_star"]
802:        return self._compute_cell_tensors_cached()["c_star"]
807:        return self._compute_cell_tensors_cached()["V"]
822:        1. Static missetting rotation (already applied to reciprocal vectors in compute_cell_tensors)
[2025-10-06T22:30:14] tokens used: 87,579

[2025-10-06T22:30:17] thinking

**Reviewing relevant section**
[2025-10-06T22:30:18] exec bash -lc "sed -n '412,640p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:30:18] bash -lc "sed -n '412,640p' src/nanobrag_torch/models/crystal.py" succeeded in 669ms:
    def compute_cell_tensors(self) -> dict:
        """
        Calculate real and reciprocal space lattice vectors from cell parameters.

        This is the central, differentiable function for all geometry calculations.
        Uses the nanoBragg.c convention to convert cell parameters (a,b,c,α,β,γ)
        to real-space and reciprocal-space lattice vectors.

        This method now supports general triclinic cells and maintains full
        differentiability for all six cell parameters. The computation graph
        is preserved for gradient-based optimization.

        The implementation follows the nanoBragg.c default orientation convention:
        - a* is placed purely along the x-axis
        - b* is placed in the x-y plane
        - c* fills out 3D space

        C-Code Implementation Reference (from nanoBragg.c):

        Volume calculation from cell parameters (lines 1798-1808):
[2025-10-06T22:30:18] tokens used: 88,321

[2025-10-06T22:30:22] thinking

**Checking the pipeline status**
[2025-10-06T22:30:22] exec bash -lc "sed -n '640,880p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:30:23] bash -lc "sed -n '640,880p' src/nanobrag_torch/models/crystal.py" succeeded in 691ms:
        ):
            # Apply misset rotation to initial reciprocal vectors only
            # C-code reference (nanoBragg.c lines 2025-2034):
            # rotate(a_star,a_star,misset[1],misset[2],misset[3]);
            # rotate(b_star,b_star,misset[1],misset[2],misset[3]);
            # rotate(c_star,c_star,misset[1],misset[2],misset[3]);
            from ..utils.geometry import angles_to_rotation_matrix, rotate_umat
            # Preserve gradient flow: convert to tensor only if not already a tensor
            misset_rad = []
            for angle in self.config.misset_deg:
                if isinstance(angle, torch.Tensor):
                    # Already a tensor - just convert dtype/device while preserving gradients
                    angle_tensor = angle.to(dtype=self.dtype, device=self.device)
                else:
                    # Scalar - create new tensor
                    angle_tensor = torch.tensor(angle, dtype=self.dtype, device=self.device)
                misset_rad.append(torch.deg2rad(angle_tensor))
            R_misset = angles_to_rotation_matrix(misset_rad[0], misset_rad[1], misset_rad[2])
            a_star = rotate_umat(a_star, R_misset)
            b_star = rotate_umat(b_star, R_misset)
[2025-10-06T22:30:23] tokens used: 91,762

[2025-10-06T22:30:27] thinking

**Analyzing vector scaling discrepancies**
[2025-10-06T22:30:28] exec bash -lc "sed -n '2060,2130p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:30:28] bash -lc "sed -n '2060,2130p' golden_suite_generator/nanoBragg.c" succeeded in 722ms:
            /* calculate reciprocal cell lengths, store in 0th element */
            printf("TRACE: Raw matrix values from file:\n");
            printf("TRACE:   a_star (raw) = [%g, %g, %g]\n", a_star[1], a_star[2], a_star[3]);
            printf("TRACE:   b_star (raw) = [%g, %g, %g]\n", b_star[1], b_star[2], b_star[3]);
            printf("TRACE:   c_star (raw) = [%g, %g, %g]\n", c_star[1], c_star[2], c_star[3]);
            printf("TRACE:   lambda0 = %g Angstroms\n", lambda0*1e10);
            printf("TRACE:   scaling factor = 1e-10/lambda0 = %g\n", 1e-10/lambda0);
            
            vector_scale(a_star,a_star,1e-10/lambda0);
            vector_scale(b_star,b_star,1e-10/lambda0);
            vector_scale(c_star,c_star,1e-10/lambda0);
            
            printf("TRACE: After wavelength correction:\n");
            printf("TRACE:   a_star = [%g, %g, %g] |a_star| = %g\n", a_star[1], a_star[2], a_star[3], a_star[0]);
            printf("TRACE:   b_star = [%g, %g, %g] |b_star| = %g\n", b_star[1], b_star[2], b_star[3], b_star[0]);
            printf("TRACE:   c_star = [%g, %g, %g] |c_star| = %g\n", c_star[1], c_star[2], c_star[3], c_star[0]);
        }
    }

    /* check for flag to generate random missetting angle */
[2025-10-06T22:30:28] tokens used: 95,070

[2025-10-06T22:30:31] thinking

**Continuing analysis**
[2025-10-06T22:30:31] exec bash -lc "sed -n '2130,2210p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:30:32] bash -lc "sed -n '2130,2210p' golden_suite_generator/nanoBragg.c" succeeded in 709ms:
    /* reciprocal lattice vector "a_star" is defined as perpendicular to both b and c, and must also preserve volume
       converse is true for direct-space lattice: a is perpendicular to both b_star and c_star
       a = ( b_star cross c_star ) / V_star    */

    /* reciprocal unit cell volume, but is it lambda-corrected? */
    V_star = dot_product(a_star,b_star_cross_c_star);
    printf("TRACE: Reciprocal cell volume calculation:\n");
    printf("TRACE:   V_star = a_star . (b_star x c_star) = %g\n", V_star);

    /* make sure any user-supplied cell takes */
    if(user_cell)
    {
        /* a,b,c and V_cell were generated above */

        /* force the cross-product vectors to have proper magnitude: b_star X c_star = a*V_star */
        vector_rescale(b_star_cross_c_star,b_star_cross_c_star,a[0]/V_cell);
        vector_rescale(c_star_cross_a_star,c_star_cross_a_star,b[0]/V_cell);
        vector_rescale(a_star_cross_b_star,a_star_cross_b_star,c[0]/V_cell);
        V_star = 1.0/V_cell;
    }
[2025-10-06T22:30:32] tokens used: 96,793

[2025-10-06T22:30:58] thinking

**Analyzing volume calculation differences**
[2025-10-06T22:31:00] exec bash -lc 'rg -n "V_star_tensor" -n src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:01] bash -lc 'rg -n "V_star_tensor" -n src/nanobrag_torch/models/crystal.py' exited 1 in 970ms:

[2025-10-06T22:31:01] tokens used: 100,054

[2025-10-06T22:31:03] thinking

**Checking recalculation after truncation**
[2025-10-06T22:31:04] exec bash -lc 'rg -n "V_tensor" src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:05] bash -lc 'rg -n "V_tensor" src/nanobrag_torch/models/crystal.py' exited 1 in 731ms:

[2025-10-06T22:31:05] tokens used: 101,023

[2025-10-06T22:31:07] thinking

**Continuing function inspection**
[2025-10-06T22:31:08] exec bash -lc "sed -n '880,1100p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:08] bash -lc "sed -n '880,1100p' src/nanobrag_torch/models/crystal.py" succeeded in 688ms:
            config: CrystalConfig containing rotation parameters.

        Returns:
            Tuple containing:
            - First tuple: rotated (a, b, c) real-space vectors with shape (N_phi, N_mos, 3)
            - Second tuple: rotated (a*, b*, c*) reciprocal-space vectors with shape (N_phi, N_mos, 3)
        """
        from ..utils.geometry import rotate_axis, rotate_umat

        # Generate phi angles
        # Assume config parameters are tensors (enforced at call site)
        # torch.linspace doesn't preserve gradients, so we handle different cases manually
        #
        # CRITICAL: Match C code loop formula: phi = phi0 + phistep*phi_tic
        # where phistep = osc/phisteps and phi_tic ranges from 0 to (phisteps-1)
        #
        # C code reference (nanoBragg.c lines 3004-3009):
        #   for(phi_tic = 0; phi_tic < phisteps; ++phi_tic)
        #   {
        #       phi = phi0 + phistep*phi_tic;
[2025-10-06T22:31:08] tokens used: 102,096

[2025-10-06T22:31:12] thinking

**Investigating usage of _apply_static_orientation**
[2025-10-06T22:31:12] exec bash -lc "sed -n '1100,1380p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:13] bash -lc "sed -n '1100,1380p' src/nanobrag_torch/models/crystal.py" succeeded in 726ms:
        b_cross_c = torch.cross(vectors["b"], vectors["c"], dim=0)
        c_cross_a = torch.cross(vectors["c"], vectors["a"], dim=0)

        # Recalculate volume from the actual rotated vectors
        V_actual = torch.dot(vectors["a"], b_cross_c)
        # PERF-PYTORCH-004 Phase 1: Use clamp_min instead of torch.maximum to avoid allocating tensors inside compiled graph
        V_actual = V_actual.clamp_min(1e-6)
        V_star_actual = 1.0 / V_actual

        # a* = (b × c) / V, etc.
        vectors["a_star"] = b_cross_c * V_star_actual
        vectors["b_star"] = c_cross_a * V_star_actual
        vectors["c_star"] = a_cross_b * V_star_actual

        return vectors

    def _apply_sample_clipping(self, beam_config: BeamConfig) -> None:
        """Apply sample clipping based on beam size (AT-FLU-001).

        Per spec: when beamsize > 0 and smaller than sample_y or sample_z,
[2025-10-06T22:31:13] tokens used: 104,891

[2025-10-06T22:31:16] thinking

**Verifying compute_cell_tensors return**
[2025-10-06T22:31:17] exec bash -lc "rg -n \"return {\\\"a\\\"\" -n src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:17] bash -lc "rg -n \"return {\\\"a\\\"\" -n src/nanobrag_torch/models/crystal.py" exited 2 in 721ms:
rg: regex parse error:
    (?:return {"a")
               ^
error: repetition quantifier expects a valid decimal
[2025-10-06T22:31:17] tokens used: 105,591

[2025-10-06T22:31:19] thinking

**Searching code for return statements**
[2025-10-06T22:31:20] exec bash -lc 'rg -n "return {" src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:20] bash -lc 'rg -n "return {" src/nanobrag_torch/models/crystal.py' exited 2 in 690ms:
rg: regex parse error:
    (?:return {)
               ^
error: repetition quantifier expects a valid decimal
[2025-10-06T22:31:20] tokens used: 106,075

[2025-10-06T22:31:24] thinking

**Adjusting command to use fixed string**
[2025-10-06T22:31:24] exec bash -lc 'rg -nF "return {" src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:25] bash -lc 'rg -nF "return {" src/nanobrag_torch/models/crystal.py' succeeded in 719ms:
752:        return {
[2025-10-06T22:31:25] tokens used: 106,684

[2025-10-06T22:31:29] thinking

**Checking final return statement**
[2025-10-06T22:31:29] exec bash -lc "sed -n '720,780p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:30] bash -lc "sed -n '720,780p' src/nanobrag_torch/models/crystal.py" succeeded in 700ms:
            a_star_cross_b_star = a_star_cross_b_star * (target_mag_a_star_cross_b_star / mag_a_star_cross_b_star)

        # Real-space vectors: a = (b* × c*) × V_cell
        # After rescaling, these will have exactly the user-specified magnitudes
        a_vec = b_star_cross_c_star * V
        b_vec = c_star_cross_a_star * V
        c_vec = a_star_cross_b_star * V

        # Now that we have real-space vectors, re-generate the reciprocal ones
        # This matches the C-code behavior (lines 2103-2119)
        a_cross_b = torch.cross(a_vec, b_vec, dim=0)
        b_cross_c = torch.cross(b_vec, c_vec, dim=0)
        c_cross_a = torch.cross(c_vec, a_vec, dim=0)

        # Recalculate volume from the actual vectors (Core Rule #13)
        # This is crucial - the volume from the vectors is slightly different
        # from the volume calculated by the formula, and we need to use the
        # actual volume for perfect metric duality (a·a* = 1 within 1e-12)
        V_actual = torch.dot(a_vec, b_cross_c)
        # Ensure volume is not too small
[2025-10-06T22:31:30] tokens used: 106,901

[2025-10-06T22:31:40] thinking

**Analyzing fractional Miller index differences**
[2025-10-06T22:31:41] exec bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/per_phi_summary_20251006-151228.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:42] bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/per_phi_summary_20251006-151228.md' succeeded in 818ms:
# CLI-FLAGS-003 Phase K3e: Per-φ Parity Summary

**Generated:** 20251006-151228  
**Target Pixel:** (133, 134)  
**Configuration:** φ ∈ [0°, 0.1°], 10 steps  

## PyTorch Trace

| φ_tic | φ (deg) | h_frac | k_frac | l_frac | F_latt_b | F_latt |
|-------|---------|--------|--------|--------|----------|--------|
| 0 | 0.000000 | 26.415194 | -9.899110 | -11.067192 | 2.326202 | -3.069002e-01 |
| 1 | 0.011111 | 26.419057 | -9.895139 | -11.062391 | 0.688801 | 5.501208e-01 |
| 2 | 0.022222 | 26.422919 | -9.891167 | -11.057591 | -1.055548 | -3.377610e+00 |
| 3 | 0.033333 | 26.426780 | -9.887194 | -11.052792 | -2.341222 | -1.319461e+01 |
| 4 | 0.044444 | 26.430641 | -9.883221 | -11.047993 | -2.786081 | -1.790987e+01 |
| 5 | 0.055556 | 26.434502 | -9.879247 | -11.043194 | -2.300591 | -1.117186e+01 |
| 6 | 0.066667 | 26.438362 | -9.875271 | -11.038395 | -1.098195 | -2.060702e+00 |
| 7 | 0.077778 | 26.442221 | -9.871296 | -11.033597 | 0.390626 | -7.556347e-02 |
| 8 | 0.088889 | 26.446081 | -9.867319 | -11.028800 | 1.668153 | 1.705728e+00 |
| 9 | 0.100000 | 26.449939 | -9.863341 | -11.024003 | 2.332342 | 1.489655e+01 |
[2025-10-06T22:31:42] tokens used: 108,850

[2025-10-06T22:31:45] thinking

**Checking for C trace comparison**
[2025-10-06T22:31:45] exec bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/comparison_summary.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:46] bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/comparison_summary.md' succeeded in 699ms:
# CLI-FLAGS-003 Phase K3e: Per-φ Parity Comparison

**PyTorch:** `per_phi_pytorch_20251006-151228.json`  
**C:**       `per_phi_c_20251006-151228.log`  

## Comparison Table

| φ_tic | φ (deg) | C k_frac | PyTorch k_frac | Δk | Status |
|-------|---------|----------|----------------|-------|--------|
| 0 | 0.000000 | -3.857043 | -9.899110 | 6.042067e+00 | ❌ |
| 1 | 0.011111 | -3.834197 | -9.895139 | 6.060942e+00 | ❌ |
| 2 | 0.022222 | -3.837054 | -9.891167 | 6.054113e+00 | ❌ |
| 3 | 0.033333 | -3.839910 | -9.887194 | 6.047284e+00 | ❌ |
| 4 | 0.044444 | -3.842767 | -9.883221 | 6.040454e+00 | ❌ |
| 5 | 0.055556 | -3.845623 | -9.879247 | 6.033624e+00 | ❌ |
| 6 | 0.066667 | -3.848478 | -9.875271 | 6.026793e+00 | ❌ |
| 7 | 0.077778 | -3.851333 | -9.871296 | 6.019962e+00 | ❌ |
| 8 | 0.088889 | -3.854188 | -9.867319 | 6.013130e+00 | ❌ |
| 9 | 0.100000 | -3.857043 | -9.863341 | 6.006298e+00 | ❌ |

[2025-10-06T22:31:46] tokens used: 109,802

[2025-10-06T22:31:51] thinking

**Analyzing coordinate and pixel vector differences**
[2025-10-06T22:31:51] exec bash -lc 'ls reports/2025-10-cli-flags/phase_h6/post_fix' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:52] bash -lc 'ls reports/2025-10-cli-flags/phase_h6/post_fix' succeeded in 708ms:
SUMMARY.md
attempt_notes.md
env_snapshot.txt
generate_metadata.py
harness_stdout.log
metadata.json
pix0_delta_analysis.py
pix0_delta_analysis.txt
trace_diff.txt
trace_py.log
trace_py_125925.log
trace_py_131503.log
[2025-10-06T22:31:52] tokens used: 110,971

[2025-10-06T22:31:54] thinking

**Reviewing SUMMARY file**
[2025-10-06T22:31:55] exec bash -lc 'cat reports/2025-10-cli-flags/phase_h6/post_fix/SUMMARY.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:31:55] bash -lc 'cat reports/2025-10-cli-flags/phase_h6/post_fix/SUMMARY.md' succeeded in 713ms:
# CLI-FLAGS-003 Phase H6g Evidence Capture - Executive Summary

**Date:** 2025-10-06  
**Commit:** 921780a29a18762d4e4f56c4a819348259afb9bd  
**Status:** ✅ **PASS**

## Result

Phase H6g pix0 trace verification **succeeded**. All pix0 component deltas are well below the 5e-5 m (50 µm) threshold.

## Metrics

| Metric | Value |
|--------|-------|
| Maximum pix0 delta | **2.851 µm** |
| Threshold | 50 µm |
| Margin | **17.5× safety factor** |
| Fast component Δ | 0.123 µm |
| Slow component Δ | 0.114 µm |
| Close component Δ | 2.851 µm |
[2025-10-06T22:31:55] tokens used: 111,271

[2025-10-06T22:32:08] thinking

**Analyzing discrepancies in scattering vector and phi calculations**

I'm comparing how PyTorch and C calculate pixel positions and phi steps, uncovering a mismatch in phi fraction formulas between the script and simulation that might affect results. I see two main hypotheses: scaling differences in crystal vectors or differing scattering vector computations involving `pix0_vector`. I'll check the simulator.py code for scattering calculations to investigate further.
[2025-10-06T22:32:10] exec bash -lc 'rg -n "compute_scattering" -n src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:32:11] bash -lc 'rg -n "compute_scattering" -n src/nanobrag_torch' exited 1 in 861ms:

[2025-10-06T22:32:11] tokens used: 112,645

[2025-10-06T22:32:14] thinking

**Searching for function references**
[2025-10-06T22:32:15] exec bash -lc 'rg -n "diffracted" src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:32:16] bash -lc 'rg -n "diffracted" src/nanobrag_torch' succeeded in 691ms:
src/nanobrag_torch/simulator.py:110:    diffracted_beam_unit = pixel_coords_angstroms / pixel_magnitudes
src/nanobrag_torch/simulator.py:122:        # diffracted_beam_unit: (S, F, 3) or (batch, 3)
src/nanobrag_torch/simulator.py:124:        # Need to add source dimension to diffracted_beam_unit
src/nanobrag_torch/simulator.py:127:        diffracted_expanded = diffracted_beam_unit.unsqueeze(0)
src/nanobrag_torch/simulator.py:137:        # Expand to match diffracted shape
src/nanobrag_torch/simulator.py:138:        incident_beam_unit = incident_expanded.expand(n_sources, *diffracted_beam_unit.shape)
src/nanobrag_torch/simulator.py:139:        diffracted_beam_unit = diffracted_expanded.expand_as(incident_beam_unit)
src/nanobrag_torch/simulator.py:142:        incident_beam_unit = incident_beam_direction.expand_as(diffracted_beam_unit)
src/nanobrag_torch/simulator.py:146:        # wavelength: (n_sources,) -> broadcast shape matching diffracted_beam_unit
src/nanobrag_torch/simulator.py:156:    scattering_vector = (diffracted_beam_unit - incident_beam_unit) / wavelength
src/nanobrag_torch/simulator.py:329:        # Need diffracted beam direction: pixel_coords_angstroms normalized
src/nanobrag_torch/simulator.py:331:        diffracted_beam_unit = pixel_coords_angstroms / pixel_magnitudes
src/nanobrag_torch/simulator.py:335:            # diffracted_beam_unit: (S, F, 3) or (batch, 3)
src/nanobrag_torch/simulator.py:340:            # Expand diffracted to (n_sources, S, F, 3) or (n_sources, batch, 3)
src/nanobrag_torch/simulator.py:343:                diffracted_expanded = diffracted_beam_unit.unsqueeze(0).expand(n_sources, -1, -1)
src/nanobrag_torch/simulator.py:344:                incident_expanded = incident_beam_direction.unsqueeze(1).expand(-1, diffracted_beam_unit.shape[0], -1)
src/nanobrag_torch/simulator.py:347:                diffracted_expanded = diffracted_beam_unit.unsqueeze(0).expand(n_sources, -1, -1, -1)
src/nanobrag_torch/simulator.py:348:                incident_expanded = incident_beam_direction.unsqueeze(1).unsqueeze(1).expand(-1, diffracted_beam_unit.shape[0], diffracted_beam_unit.shape[1], -1)
src/nanobrag_torch/simulator.py:352:            flat_shape = diffracted_expanded.shape
src/nanobrag_torch/simulator.py:354:            diffracted_flat = diffracted_expanded.reshape(-1, 3).contiguous()
[2025-10-06T22:32:16] tokens used: 112,844

[2025-10-06T22:32:42] thinking

**Evaluating and confirming plan stability**

I'm analyzing whether the plan needs updating based on the root cause evidence around detector and lattice differences. After considering detailed factors and existing tasks in Phase K3f, I decide no plan change is needed but will focus on review and housekeeping, selecting CLI-FLAGS-003 K3f base lattice parity as the focus issue. Next, I'll gather relevant docs and prepare instructions for instrumentation and execution in `input.md`, ensuring alignment with the fix plan and clear steps for capturing base traces.
[2025-10-06T22:32:44] exec bash -lc 'ls reports/2025-10-cli-flags/phase_k' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:32:45] bash -lc 'ls reports/2025-10-cli-flags/phase_k' succeeded in 909ms:
f_latt_fix
[2025-10-06T22:32:45] tokens used: 116,312

[2025-10-06T22:32:48] thinking

**Verifying file existence**
[2025-10-06T22:32:49] exec bash -lc 'find reports/2025-10-cli-flags -maxdepth 2 -name "trace_harness.py"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:32:50] bash -lc 'find reports/2025-10-cli-flags -maxdepth 2 -name "trace_harness.py"' succeeded in 714ms:
reports/2025-10-cli-flags/phase_e/trace_harness.py
reports/2025-10-cli-flags/phase_h/trace_harness.py
[2025-10-06T22:32:50] tokens used: 116,579

[2025-10-06T22:33:19] thinking

**Preparing detailed phase K3f instructions**

This plan involves creating or updating a trace harness in `phase_k`, laying out exact build and run commands, and assembling a structured `input.md` with headers for summary, phase, focus, branch, tests, artifacts, and detailed steps. I’m focusing on clearly marking this as an Evidence-phase task since instrumentation code changes support data gathering but no feature changes. I’ll also specify environment variables, logging locations, fallback plans, pitfalls, and relevant doc pointers, while planning to update `galph_memory.md` after finalizing `input.md`. There's also a hypothesis about base lattice vector scaling in C and an investigation needed for Pyro’s parsing of MOSFLM orientation.
[2025-10-06T22:33:24] exec bash -lc 'rg -n "mosflm_a_star" -n src/nanobrag_torch/io' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:33:25] bash -lc 'rg -n "mosflm_a_star" -n src/nanobrag_torch/io' exited 1 in 901ms:

[2025-10-06T22:33:25] tokens used: 118,595

[2025-10-06T22:33:29] thinking

**Searching for read_mosflm_matrix usage**
[2025-10-06T22:33:30] exec bash -lc 'rg -n "read_mosflm" src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:33:31] bash -lc 'rg -n "read_mosflm" src/nanobrag_torch' succeeded in 724ms:
src/nanobrag_torch/__main__.py:31:from .io.mosflm import read_mosflm_matrix, reciprocal_to_real_cell
src/nanobrag_torch/__main__.py:426:        a_star, b_star, c_star = read_mosflm_matrix(args.mat, wavelength_A)
src/nanobrag_torch/__main__.py:431:        # These are in Å⁻¹ and already wavelength-scaled from read_mosflm_matrix
src/nanobrag_torch/__main__.py:432:        config['mosflm_a_star'] = a_star  # numpy array from read_mosflm_matrix
src/nanobrag_torch/io/mosflm.py:12:def read_mosflm_matrix(filepath: Union[str, Path], wavelength_A: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
[2025-10-06T22:33:31] tokens used: 119,044
[2025-10-06T22:33:36] exec bash -lc "sed -n '1,200p' src/nanobrag_torch/io/mosflm.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:33:37] bash -lc "sed -n '1,200p' src/nanobrag_torch/io/mosflm.py" succeeded in 728ms:
"""MOSFLM matrix file I/O utilities.

This module provides functions for reading MOSFLM-style orientation matrices,
which contain reciprocal lattice vectors scaled by wavelength.
"""

import numpy as np
from pathlib import Path
from typing import Tuple, Union


def read_mosflm_matrix(filepath: Union[str, Path], wavelength_A: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Read MOSFLM A matrix file and extract reciprocal lattice vectors.

    The MOSFLM A matrix format contains 9 values (3x3 matrix) where each row
    is a reciprocal lattice vector (a*, b*, c*) in units of Å^-1·(1/λ_Å).

    C-Code Implementation Reference (from nanoBragg.c, lines 3135-3148):
    ```c
    if(matfilename != NULL)
[2025-10-06T22:33:37] tokens used: 119,795

[2025-10-06T22:33:41] thinking

**Verifying detector pix0_vector property**
[2025-10-06T22:33:42] exec bash -lc 'rg -n "pix0_vector" src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:33:43] bash -lc 'rg -n "pix0_vector" src/nanobrag_torch/models/detector.py' succeeded in 738ms:
134:        # Calculate and cache pix0_vector (position of first pixel)
135:        self._calculate_pix0_vector()
144:        self._cached_pix0_vector = self.pix0_vector.clone()
147:        # These will be set properly in _calculate_pix0_vector
152:        if not hasattr(self, 'pix0_vector'):
153:            self.pix0_vector: Optional[torch.Tensor] = None
237:        # Recalculate pix0_vector when geometry changes
238:        self._calculate_pix0_vector()
250:            tuple: (beam_f_m, beam_s_m) in meters for use in pix0_vector calculation
326:    def _calculate_pix0_vector(self):
330:        This follows the C-code convention where pix0_vector represents the
343:        - BEAM pivot: pix0_vector = -Fbeam*fdet_vec - Sbeam*sdet_vec + distance*beam_vec
344:        - SAMPLE pivot: Calculate pix0_vector BEFORE rotations, then rotate it
362:            pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
363:            pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
364:            pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
367:            rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
368:            rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
375:            pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
376:            pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
[2025-10-06T22:33:43] tokens used: 121,744

[2025-10-06T22:33:49] thinking

**Analyzing orientation data handling hypotheses**
[2025-10-06T22:33:50] exec bash -lc 'rg -n "mosflm_a_star" src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:33:51] bash -lc 'rg -n "mosflm_a_star" src/nanobrag_torch' succeeded in 725ms:
src/nanobrag_torch/__main__.py:432:        config['mosflm_a_star'] = a_star  # numpy array from read_mosflm_matrix
src/nanobrag_torch/__main__.py:844:                mosflm_a_star=config.get('mosflm_a_star'),
src/nanobrag_torch/config.py:126:    mosflm_a_star: Optional[np.ndarray] = None  # MOSFLM a* reciprocal vector (Å⁻¹)
src/nanobrag_torch/models/crystal.py:548:            hasattr(self.config, "mosflm_a_star") and self.config.mosflm_a_star is not None
src/nanobrag_torch/models/crystal.py:555:                self.config.mosflm_a_star,
src/nanobrag_torch/models/crystal.py:689:            hasattr(self.config, "mosflm_a_star") and self.config.mosflm_a_star is not None
[2025-10-06T22:33:51] tokens used: 123,698

[2025-10-06T22:33:57] thinking

**Investigating lattice orientation discrepancies**

I'm exploring the possibility that differences in lattice base orientation, maybe due to axis flipping or transposition in `Crystal.compute_cell_tensors`, could be causing mismatched values like the k difference. I want to verify this by inspecting pyro’s `b_star` data in an existing JSON report to see if that gives clues about the orientation or dtype issues.
[2025-10-06T22:33:59] exec bash -lc "jq 'keys' reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/trace_float64.json" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:34:00] bash -lc "jq 'keys' reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/trace_float64.json" succeeded in 731ms:
[
  "F_latt",
  "F_latt_a",
  "F_latt_b",
  "F_latt_c",
  "Na",
  "Nb",
  "Nc",
  "R",
  "h",
  "h_frac",
  "k",
  "k_frac",
  "l",
  "l_frac",
  "omega_pixel",
  "pixel_f",
  "pixel_pos_A",
  "pixel_s",
  "polar",
[2025-10-06T22:34:00] tokens used: 124,277

[2025-10-06T22:34:11] thinking

**Investigating lattice orientation inconsistencies**
[2025-10-06T22:34:13] exec bash -lc "sed -n '804,900p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:34:14] bash -lc "sed -n '804,900p' src/nanobrag_torch/models/detector.py" succeeded in 871ms:
        # Calculate pixel coordinates using pix0_vector as the reference
        # pixel_coords = pix0_vector + s * pixel_size * sdet_vec + f * pixel_size * fdet_vec

        # Expand vectors for broadcasting
        pix0_expanded = self.pix0_vector.unsqueeze(0).unsqueeze(0)  # (1, 1, 3)
        sdet_expanded = self.sdet_vec.unsqueeze(0).unsqueeze(0)  # (1, 1, 3)
        fdet_expanded = self.fdet_vec.unsqueeze(0).unsqueeze(0)  # (1, 1, 3)

        # Calculate pixel coordinates
        pixel_coords = (
            pix0_expanded
            + s_grid.unsqueeze(-1) * self.pixel_size * sdet_expanded
            + f_grid.unsqueeze(-1) * self.pixel_size * fdet_expanded
        )

        return pixel_coords

    def _compute_curved_pixel_coords(self) -> torch.Tensor:
        """
        Compute pixel coordinates for a curved (spherical) detector.
[2025-10-06T22:34:14] tokens used: 125,878

[2025-10-06T22:34:57] thinking

**Analyzing pixel coordinate subtraction error**
[2025-10-06T22:35:04] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -15,2 +15,3 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
@@ -197,3 +198,3 @@
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
[2025-10-06T22:35:04] apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T22:35:04] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 

[2025-10-06T22:35:04] tokens used: 130,986
[2025-10-06T22:35:04] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:35:10] thinking

**Preparing to update documentation and plan**
[2025-10-06T22:35:14] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -457,4 +457,4 @@
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
[2025-10-06T22:35:14] apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T22:35:14] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 

[2025-10-06T22:35:14] tokens used: 132,553
[2025-10-06T22:35:14] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:35:25] thinking

**Preparing detailed input.md content**
[2025-10-06T22:35:26] exec bash -lc "nl -ba specs/spec-a-core.md | sed -n '260,340p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:35:26] bash -lc "nl -ba specs/spec-a-core.md | sed -n '260,340p'" succeeded in 895ms:
   260	    - If -interpolate provided: on.
   261	    - If -nointerpolate provided: off.
   262	    - Otherwise auto: If any of Na, Nb, Nc ≤ 2, interpolation is enabled; else disabled.
   263	- Out-of-range while interpolating:
   264	    - If the required 4×4×4 neighborhood is not fully available within the HKL grid, the program:
   265	        - Emits a one-time warning.
   266	        - Uses default_F for that evaluation.
   267	        - Permanently disables interpolation for the remainder of the run.
   268	
   269	Background & Noise (Normative)
   270	
   271	- Constant background per pixel (added before accumulation):
   272	    - F_bg = 2.57 (dimensionless, “water” forward scattering amplitude).
   273	    - I_bg = (F_bg^2) · r_e^2 · fluence · (water_size^3) · 1e6 · Avogadro / water_MW.
   274	    - water_size is -water in µm converted to meters; water_MW = 18 g/mol.
   275	    - Note: This formula is exactly as implemented; units do not match a physical volume
   276	consistently (the 1e6 factor multiplies the cubic meter term).
   277	- Poisson noise (if enabled by -noisefile):
   278	    - For each pixel, draw from a Poisson distribution with mean = float image value (before scaling
   279	and ADC) to produce an integer noise image. If mean > 1e6, a Gaussian approximation is used: N(mean,
[2025-10-06T22:35:26] tokens used: 133,569
[2025-10-06T22:35:26] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:35:29] thinking

**Searching for scattering vector lines**
[2025-10-06T22:35:30] exec bash -lc 'rg -n "Scattering vector" specs/spec-a-core.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:35:31] bash -lc 'rg -n "Scattering vector" specs/spec-a-core.md' succeeded in 725ms:
43:    - Scattering vector q in m^-1.
[2025-10-06T22:35:31] tokens used: 135,359
[2025-10-06T22:35:31] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:35:34] thinking

**Referencing specific code and plan locations**
[2025-10-06T22:35:35] exec bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '150,260p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:35:35] bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '150,260p'" succeeded in 752ms:
   150	| H6g | Re-run pix0 traces after pivot fix | [D] | ✅ Attempt #41 (2025-10-27) reran the harness with SAMPLE pivot enforced; `phase_h6/post_fix/trace_py.log`, `trace_diff.txt`, and `metadata.json` show |Δpix0| ≤ 2.85 µm and zero beam-center deltas. nb-compare smoke stored alongside traces; docs/fix_plan Attempt #41 updated. |
   151	| H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
   152	| H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
   153	
   154	### Phase I — Polarization Alignment (follow-up)
   155	Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
   156	Prereqs: Phases F–H complete; traces show `F_latt` parity.
   157	Exit Criteria: Polarization entries in C/PyTorch traces agree (≈0.9126 for supervisor command) and parity smoke stays green.
   158	
   159	| ID | Task Description | State | How/Why & Guidance |
   160	| --- | --- | --- | --- |
   161	| I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
   162	| I2 | Implement polarization parity | [P] | ✅ 2025-10-17 update set BeamConfig.polarization_factor default to 1.0, but C traces (2025-10-31) confirm the Kahn factor defaults to 0.0 when `-polar` is absent. Reopen to: (a) restore 0.0 default, (b) keep -polar/-nopolar overrides working, and (c) adjust TestCLIPolarization expectations accordingly. |
   163	| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
   164	
   165	### Phase J — Intensity Scaling Evidence
   166	Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
   167	Prereqs: Phase I2 complete; beam/pix0/orientation traces from Phases F–H archived.
   168	Exit Criteria: Report under `reports/2025-10-cli-flags/phase_j/scaling_chain.md` documenting C vs PyTorch values for `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, `fluence`, and the resulting per-pixel intensities, with the first mismatched quantity identified and logged in docs/fix_plan.md Attempt history.
   169	
[2025-10-06T22:35:35] tokens used: 135,689
[2025-10-06T22:35:35] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:35:38] thinking

**Checking line numbers for notes**
[2025-10-06T22:35:39] exec bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '1,120p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:35:39] bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '1,120p'" succeeded in 702ms:
     1	## Context
     2	- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
     3	- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
     4	- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
     5	- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
     6	- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
     7	- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
     8	- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
     9	- Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
    10	- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
    11	- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
    12	- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
    13	- Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
    14	- Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
    15	- Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
    16	- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
    17	- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
    18	- Documentation anchors for this focus:
    19	  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
    20	  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
[2025-10-06T22:35:39] tokens used: 138,505
[2025-10-06T22:35:39] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:35:43] thinking

**Preparing input.md draft**
[2025-10-06T22:36:03] exec bash -lc "cat <<'EOF' > input.md
Summary: Capture matched base-lattice/scattering traces (C vs PyTorch) to unblock CLI parity normalization.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase K3f — Base lattice trace parity
Branch: main
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log; reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log; reports/2025-10-cli-flags/phase_k/base_lattice/summary.md; scripts/compare_base_lattice.py (or updated harness); reports/2025-10-cli-flags/phase_k/base_lattice/metadata.json
Do Now: CLI-FLAGS-003 Phase K3f — capture base lattice & scattering traces; run "'`NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0` after instrumentation.
If Blocked: If instrumentation cannot compile cleanly, stash current edits, rebuild pristine `golden_suite_generator`, and record the build/log failure under `reports/2025-10-cli-flags/phase_k/base_lattice/attempts/` before retrying with minimal trace injection.
Priorities & Rationale:
- docs/fix_plan.md:451 — Next actions demand K3f1–K3f3 traces before any normalization fix; evidence gap blocks long-term goal #1.
- plans/active/cli-noise-pix0/plan.md:15 — Diagnostic note flags the per-φ harness bug (pix0 double subtraction); corrected harness is prerequisite for trustworthy traces.
- specs/spec-a-core.md:43 — Scattering vector definition requires sample→pixel geometry in meters/Å; baseline traces must respect this contract.
- docs/architecture/detector.md:312 — pix0_vector semantics (sample-origin) prohibit subtracting pix0 twice; ensure harness mirrors detector contract.
- docs/development/testing_strategy.md:52 — Parallel trace-driven validation is mandatory before touching implementation; today’s task fulfills Tier-1 evidence capture.
- golden_suite_generator/nanoBragg.c:2130 — Reference lines for real/reciprocal vector regeneration inform where to instrument TRACE_C_BASE.
How-To Map:
1. Export env vars: `export AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` and `export NB_C_BIN=./golden_suite_generator/nanoBragg`.
2. Instrument C (K3f1): append guarded `TRACE_C_BASE` printf lines after reciprocal→real vector generation and before the phi loop (around `nanoBragg.c:2130`). Include a latch on `fpixel==trace_fpixel && spixel==trace_spixel && source==0 && mosaic_domains>0?0:1` mirroring existing trace gates. Log `a_star`, `b_star`, `c_star`, `a`, `b`, `c`, and φ=0 scattering components.
3. Rebuild C: `make -C golden_suite_generator` (capture stdout in `reports/2025-10-cli-flags/phase_k/base_lattice/build.log`). Abort if warnings appear; store diff under same directory.
4. Run supervisor command with traces enabled (Do Now command). Redirect stderr to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`; archive stdout as `c_stdout.txt` and capture env snapshot (uname, git rev, NB_C_BIN) in `metadata.json`.
5. Author PyTorch harness (K3f2): create `reports/2025-10-cli-flags/phase_k/trace_harness.py` copying the Phase H harness template but emitting `TRACE_PY_BASE` lines, using `detector.get_pixel_coords()` directly (no pix0 subtraction). Store configuration inline referencing `AUTHORITATIVE_CMDS_DOC`.
6. Execute harness: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log` and persist stdout, metadata, and torch dtype/device in the same folder.
7. Diff traces (K3f3): implement `scripts/compare_base_lattice.py` or extend existing comparer to align `TRACE_C_BASE` vs `TRACE_PY_BASE`; emit table of deltas to `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` (highlight first component exceeding 5e-4 tolerance).
8. Record observations + next steps in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` and update docs/fix_plan Attempt log (but do not close item yet).
Pitfalls To Avoid:
- Do not subtract `pix0_vector` from pixel coords; detector coordinates already originate at the sample.
- Keep instrumentation reusable: guard prints with `TRACE_C_BASE` tags to avoid cluttering other traces.
- Maintain device/dtype neutrality in PyTorch harness (no `.cpu()` or `.item()` on tensors that still need gradients).
- Avoid modifying production code paths beyond trace hooks; isolate changes to harness and trace build.
- Capture artifacts under the prescribed `reports/` subtree; no stray files in repo root.
- Remember to rebuild `golden_suite_generator` after instrumentation edits; stale binaries invalidate evidence.
- Ensure command uses the exact CLI from Do Now; do not drop flags like `-pix0_vector_mm` or `-nonoise`.
- Respect Protected Assets (docs/index.md); do not rename referenced files like `loop.sh`.
- When adding scripts, include shebang + chmod + docstring per repo conventions; keep them under `reports/` or `scripts/` as appropriate.
- No ad-hoc pytest runs this loop; evidence only.
Pointers:
- specs/spec-a-core.md:43 — scattering vector units clarifier.
- docs/architecture/detector.md:312 — pix0_vector definition.
- docs/development/testing_strategy.md:52 — parallel trace SOP.
- plans/active/cli-noise-pix0/plan.md:16 — harness bug note + K3f tasks.
- docs/fix_plan.md:451 — CLI-FLAGS-003 outstanding work summary.
- golden_suite_generator/nanoBragg.c:2130 — real/reciprocal regeneration block for instrumentation.
Next Up: If traces align, proceed to K3f4 root-cause write-up and prep regression adjustments for K3c.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:36:04] bash -lc "cat <<'EOF' > input.md
Summary: Capture matched base-lattice/scattering traces (C vs PyTorch) to unblock CLI parity normalization.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase K3f — Base lattice trace parity
Branch: main
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log; reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log; reports/2025-10-cli-flags/phase_k/base_lattice/summary.md; scripts/compare_base_lattice.py (or updated harness); reports/2025-10-cli-flags/phase_k/base_lattice/metadata.json
Do Now: CLI-FLAGS-003 Phase K3f — capture base lattice & scattering traces; run "'`NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0` after instrumentation.
If Blocked: If instrumentation cannot compile cleanly, stash current edits, rebuild pristine `golden_suite_generator`, and record the build/log failure under `reports/2025-10-cli-flags/phase_k/base_lattice/attempts/` before retrying with minimal trace injection.
Priorities & Rationale:
- docs/fix_plan.md:451 — Next actions demand K3f1–K3f3 traces before any normalization fix; evidence gap blocks long-term goal #1.
- plans/active/cli-noise-pix0/plan.md:15 — Diagnostic note flags the per-φ harness bug (pix0 double subtraction); corrected harness is prerequisite for trustworthy traces.
- specs/spec-a-core.md:43 — Scattering vector definition requires sample→pixel geometry in meters/Å; baseline traces must respect this contract.
- docs/architecture/detector.md:312 — pix0_vector semantics (sample-origin) prohibit subtracting pix0 twice; ensure harness mirrors detector contract.
- docs/development/testing_strategy.md:52 — Parallel trace-driven validation is mandatory before touching implementation; today’s task fulfills Tier-1 evidence capture.
- golden_suite_generator/nanoBragg.c:2130 — Reference lines for real/reciprocal vector regeneration inform where to instrument TRACE_C_BASE.
How-To Map:
1. Export env vars: `export AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` and `export NB_C_BIN=./golden_suite_generator/nanoBragg`.
2. Instrument C (K3f1): append guarded `TRACE_C_BASE` printf lines after reciprocal→real vector generation and before the phi loop (around `nanoBragg.c:2130`). Include a latch on `fpixel==trace_fpixel && spixel==trace_spixel && source==0 && mosaic_domains>0?0:1` mirroring existing trace gates. Log `a_star`, `b_star`, `c_star`, `a`, `b`, `c`, and φ=0 scattering components.
3. Rebuild C: `make -C golden_suite_generator` (capture stdout in `reports/2025-10-cli-flags/phase_k/base_lattice/build.log`). Abort if warnings appear; store diff under same directory.
4. Run supervisor command with traces enabled (Do Now command). Redirect stderr to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`; archive stdout as `c_stdout.txt` and capture env snapshot (uname, git rev, NB_C_BIN) in `metadata.json`.
5. Author PyTorch harness (K3f2): create `reports/2025-10-cli-flags/phase_k/trace_harness.py` copying the Phase H harness template but emitting `TRACE_PY_BASE` lines, using `detector.get_pixel_coords()` directly (no pix0 subtraction). Store configuration inline referencing `AUTHORITATIVE_CMDS_DOC`.
6. Execute harness: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log` and persist stdout, metadata, and torch dtype/device in the same folder.
7. Diff traces (K3f3): implement `scripts/compare_base_lattice.py` or extend existing comparer to align `TRACE_C_BASE` vs `TRACE_PY_BASE`; emit table of deltas to `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` (highlight first component exceeding 5e-4 tolerance).
8. Record observations + next steps in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` and update docs/fix_plan Attempt log (but do not close item yet).
Pitfalls To Avoid:
- Do not subtract `pix0_vector` from pixel coords; detector coordinates already originate at the sample.
- Keep instrumentation reusable: guard prints with `TRACE_C_BASE` tags to avoid cluttering other traces.
- Maintain device/dtype neutrality in PyTorch harness (no `.cpu()` or `.item()` on tensors that still need gradients).
- Avoid modifying production code paths beyond trace hooks; isolate changes to harness and trace build.
- Capture artifacts under the prescribed `reports/` subtree; no stray files in repo root.
- Remember to rebuild `golden_suite_generator` after instrumentation edits; stale binaries invalidate evidence.
- Ensure command uses the exact CLI from Do Now; do not drop flags like `-pix0_vector_mm` or `-nonoise`.
- Respect Protected Assets (docs/index.md); do not rename referenced files like `loop.sh`.
- When adding scripts, include shebang + chmod + docstring per repo conventions; keep them under `reports/` or `scripts/` as appropriate.
- No ad-hoc pytest runs this loop; evidence only.
Pointers:
- specs/spec-a-core.md:43 — scattering vector units clarifier.
- docs/architecture/detector.md:312 — pix0_vector definition.
- docs/development/testing_strategy.md:52 — parallel trace SOP.
- plans/active/cli-noise-pix0/plan.md:16 — harness bug note + K3f tasks.
- docs/fix_plan.md:451 — CLI-FLAGS-003 outstanding work summary.
- golden_suite_generator/nanoBragg.c:2130 — real/reciprocal regeneration block for instrumentation.
Next Up: If traces align, proceed to K3f4 root-cause write-up and prep regression adjustments for K3c.
EOF
' succeeded in 854ms:

[2025-10-06T22:36:04] tokens used: 141,834
[2025-10-06T22:36:04] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:36:09] thinking

**Appending session summary to memory**

I’m preparing to update the `galph_memory.md` with a detailed summary that captures key findings from this session, including the harness bug identified, evaluation of ralph's recent commits, and updates to the plan—making sure the format stays consistent and no code changes are made yet.
[2025-10-06T22:36:16] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/galph_memory.md
@@ -1307 +1307,9 @@
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
[2025-10-06T22:36:16] apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M galph_memory.md
[2025-10-06T22:36:16] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 

[2025-10-06T22:36:16] tokens used: 144,610
[2025-10-06T22:36:16] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:36:20] thinking

**Checking git status**
[2025-10-06T22:36:21] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:36:22] bash -lc 'git status --short' succeeded in 934ms:
 M docs/fix_plan.md
 M galph_memory.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T22:36:22] tokens used: 145,453
[2025-10-06T22:36:22] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:36:25] thinking

**Reviewing code diffs**
[2025-10-06T22:36:26] exec bash -lc 'git diff' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:36:26] bash -lc 'git diff' succeeded in 728ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1..b188ac2 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f8..739fd69 100644
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@ Follow-ups for Ralph:
[2025-10-06T22:36:26] tokens used: 145,658
[2025-10-06T22:36:26] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:36:29] thinking

**Preparing commit with proper message**
[2025-10-06T22:36:30] exec bash -lc 'git add docs/fix_plan.md galph_memory.md input.md plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:36:30] bash -lc 'git add docs/fix_plan.md galph_memory.md input.md plans/active/cli-noise-pix0/plan.md' succeeded in 719ms:

[2025-10-06T22:36:30] tokens used: 147,297
[2025-10-06T22:36:30] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:36:33] thinking

**Committing with descriptive message**
[2025-10-06T22:36:34] exec bash -lc 'git commit -m "SUPERVISOR: CLI K3f evidence prep - tests: not run"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:36:34] bash -lc 'git commit -m "SUPERVISOR: CLI K3f evidence prep - tests: not run"' succeeded in 768ms:
[feature/spec-based-2 90164f9] SUPERVISOR: CLI K3f evidence prep - tests: not run
 4 files changed, 49 insertions(+), 31 deletions(-)
[2025-10-06T22:36:34] tokens used: 147,517
[2025-10-06T22:36:35] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:36:41] thinking

**Pushing changes**
[2025-10-06T22:36:43] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:36:45] bash -lc 'git push' succeeded in 2.28s:
To github.com:hoidn/nanoBragg.git
   bf5faeb..90164f9  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T22:36:45] tokens used: 148,132
[2025-10-06T22:36:45] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:36:54] thinking

**Confirming tree cleanliness**
[2025-10-06T22:36:54] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:36:55] bash -lc 'git status --short' succeeded in 764ms:

[2025-10-06T22:36:55] tokens used: 148,346
[2025-10-06T22:36:55] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:37:01] thinking

**Drafting detailed final summary**

I'll now create a thorough final message that covers the analysis, debugging hypotheses with file and line references, evaluation of ralph’s recent work, updates to the plan, focus pointers, and references to inputs like `input.md`, making sure to follow the formatting and instruction compliance carefully.
[2025-10-06T22:37:03] exec bash -lc "nl -ba scripts/trace_per_phi.py | sed -n '40,140p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:37:03] bash -lc "nl -ba scripts/trace_per_phi.py | sed -n '40,140p'" succeeded in 698ms:
    40	from nanobrag_torch.models.detector import Detector
    41	from nanobrag_torch.config import CrystalConfig, DetectorConfig, BeamConfig
    42	from nanobrag_torch.utils.physics import sincg
    43	
    44	
    45	def trace_pixel_per_phi(
    46	    pixel_s, pixel_f,
    47	    crystal, detector, beam_config,
    48	    phi_steps=10, phi_start_deg=0.0, osc_range_deg=0.1,
    49	    device='cpu', dtype=torch.float64
    50	):
    51	    """
    52	    Generate per-φ trace of Miller indices and lattice factors for a single pixel.
    53	
    54	    Args:
    55	        pixel_s, pixel_f: Target pixel coordinates
    56	        crystal: Crystal instance
    57	        detector: Detector instance
    58	        beam_config: BeamConfig instance
    59	        phi_steps: Number of φ steps (default 10)
[2025-10-06T22:37:03] tokens used: 148,778
[2025-10-06T22:37:03] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 


[2025-10-06T22:37:11] thinking

**Preparing structured final message**
[2025-10-06T22:37:11] codex

**Findings**
- Per-φ divergence traces point to instrumentation error: `scripts/trace_per_phi.py:81` subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and inflating Δk≈6 even at φ=0°.  
- CLI parity plan + fix plan now call out the harness bug and require sample-to-pixel vectors before new evidence (`plans/active/cli-noise-pix0/plan.md:16`, `docs/fix_plan.md:455`).  
- Vectorization backlog remains untouched; Phase A of `plans/active/vectorization.md` stays pending until CLI parity frees cycles.  
- Prepared Evidence-phase memo (`input.md`) directing K3f1–K3f3 trace capture with corrected harness and artifact paths.

**Hypotheses (ranked)**
1. High confidence — PyTorch harness double-subtracts pix0 (`scripts/trace_per_phi.py:75-90`); fix by using `detector.get_pixel_coords()` directly. Confirming step: rerun per-φ trace after removing the subtraction and compare against C.  
2. Medium confidence — After fixing the harness, base `a/b/c` vs `a*/b*/c*` may still drift from C due to MOSFLM rescale handling (`src/nanobrag_torch/models/crystal.py:520-735`). Confirming step: execute K3f1–K3f3 to diff TRACE_C_BASE vs TRACE_PY_BASE.  
3. Lower confidence — If residual mismatch persists, investigate scattering vector generation pipeline (`src/nanobrag_torch/simulator.py:329-368`) for device/dtype discrepancies. Confirm by logging incident/diffracted vectors in both traces once harness is corrected.

**Ralph Review (last ~10 loops)**
- Commit 271e2b6 captured dtype sweep cleanly but lacked follow-up to verify geometry; neutral outcome.  
- Commit 2467064 added per-φ scripts and instrumentation (valuable), yet the new harness introduced the pix0 subtraction bug, leading to misleading Δk. Needs correction and a note-to-self on validating trace math before drawing conclusions.

**Updates**
- Plan and fix plan amended to guard Phase K3f harness design (`plans/active/cli-noise-pix0/plan.md:16`, `docs/fix_plan.md:455`).  
- Logged new supervisor memory entry detailing harness diagnosis (`galph_memory.md`).  
- Issued fresh steering memo (`input.md`) with precise commands, artifact targets, and cautions about pix0 handling.

**Next Steps**
- Ralph to follow `input.md` Evidence plan: instrument C, rebuild, capture TRACE_C_BASE/TRACE_PY_BASE, and diff under `reports/2025-10-cli-flags/phase_k/base_lattice/`.  
- After traces align, proceed to K3f4 root-cause documentation and resume normalization parity work.
[2025-10-06T22:37:21] tokens used: 151,454
[2025-10-06T22:37:21] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 6ed8cf1869534b4ab3d16bcb0df69d4f6d411925..b188ac272f7f4c0419eb8363d1b9925c0f20fe49
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,8 +455,8 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-11-07 refresh):
-  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+ - Next Actions (2025-11-07 refresh, amended 2025-11-08):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4. While capturing the PyTorch trace, ensure the harness uses `detector.get_pixel_coords()` directly (no secondary subtraction of `pix0_vector`) so the scattering path matches the C geometry.
   2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
diff --git a/galph_memory.md b/galph_memory.md
index 8cb46f85be00810536bc75e24333cee345ddf1ff..739fd6945d50c4b24ddc585119e4e1a5fff3c9c5
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1305,3 +1305,11 @@
 - Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
 - Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
 - Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
+
+## 2025-11-08 (galph loop — K3f harness correction)
+- `git pull --rebase` clean; read docs/index.md, spec shards, arch.md, config map, debugging SOP, testing strategy, fix_plan, vectorization plan.
+- Reviewed Ralph’s recent evidence commits (271e2b6, 2467064): instrumentation valuable but per-φ script subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors and explaining the 6-unit Δk seen in Attempt #45.
+- Updated `plans/active/cli-noise-pix0/plan.md` (K3f context + K3f2 guidance) and `docs/fix_plan.md` next actions to require sample-to-pixel vectors with no double subtraction before new traces are captured.
+- Chosen focus: CLI-FLAGS-003 Phase K3f base-lattice parity. Hypotheses recorded (primary: trace harness bug; secondary: confirm real/reciprocal vectors + scattering after harness fix). Next confirming step: capture corrected C/Py base traces per plan.
+- Authored Evidence-phase `input.md` directing Ralph to instrument `golden_suite_generator/nanoBragg.c`, rebuild, run the supervisor CLI command, and add a corrected PyTorch harness under `reports/2025-10-cli-flags/phase_k/base_lattice/` with comparison tooling.
+- No additional plan work required for vectorization yet; Phase A still pending once CLI parity unblocks bandwidth.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3..14f3f7380f0210c0aba17ee80aecad3b3b565d61
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -13,6 +13,7 @@
 - Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
 - Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
+- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 - Documentation anchors for this focus:
   * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
@@ -195,7 +196,7 @@
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
-| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Use `detector.get_pixel_coords()` directly as the sample→pixel vector—do **not** subtract `pix0_vector`, because the coordinates already include that origin offset. Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
 | K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
 | K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 

Reading prompt from stdin...
Already up to date.
To github.com:hoidn/nanoBragg.git
   90164f9..7f5b56d  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=52...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=52
Updating 7f5b56d..575fa0d
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   7f5b56d..575fa0d  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=52
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 575fa0d..655f632
Fast-forward
 docs/fix_plan.md                                   |  23 ++
 .../phase_k/base_lattice/README.md                 |  76 ++++++
 .../phase_k/base_lattice/c_stdout.txt              | 291 +++++++++++++++++++++
 .../phase_k/base_lattice/compare_traces.py         | 190 ++++++++++++++
 .../phase_k/base_lattice/metadata.json             |  23 ++
 .../phase_k/base_lattice/run_c_trace.sh            |  42 +++
 .../phase_k/base_lattice/summary.md                |  78 ++++++
 .../phase_k/base_lattice/trace_harness.py          | 182 +++++++++++++
 .../phase_k/base_lattice/trace_py.log              |  37 +++
 9 files changed, 942 insertions(+)
 create mode 100644 reports/2025-10-cli-flags/phase_k/base_lattice/README.md
 create mode 100644 reports/2025-10-cli-flags/phase_k/base_lattice/c_stdout.txt
 create mode 100755 reports/2025-10-cli-flags/phase_k/base_lattice/compare_traces.py
 create mode 100644 reports/2025-10-cli-flags/phase_k/base_lattice/metadata.json
 create mode 100755 reports/2025-10-cli-flags/phase_k/base_lattice/run_c_trace.sh
 create mode 100644 reports/2025-10-cli-flags/phase_k/base_lattice/summary.md
 create mode 100755 reports/2025-10-cli-flags/phase_k/base_lattice/trace_harness.py
 create mode 100644 reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log
From github.com:hoidn/nanoBragg
   575fa0d..655f632  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 655f632..c0c8f46
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   655f632..c0c8f46  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=53
Ralph completed iteration 52; proceeding to 53
