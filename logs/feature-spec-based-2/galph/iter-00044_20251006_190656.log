Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=44
To github.com:hoidn/nanoBragg.git
   ff7a96b..3c346ce  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T19:07:01] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T19:07:01] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 


Debugging Items — Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‑line rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for this turn.
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
Header:
- Summary: <one‑sentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
  - Note: When the Phase is Evidence, you must not execute tests; any pytest command included here is provided for Ralph’s subsequent loop.
<Do Now guidelines>
Phase Gate (Evidence): If the active plan phase is Evidence, do not run pytest at all (including collection). Limit evidence gathering to non-test probes and command‑line tooling (e.g., scripts/validation/*, minimal parity CLIs). Do not include runnable tests in this loop.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T19:07:06] thinking

**Preparing to update codebase**
[2025-10-06T19:07:07] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:07:09] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.47s:
Already up to date.
[2025-10-06T19:07:09] tokens used: 12,885

[2025-10-06T19:07:11] thinking

**Preparing to review latest documentation**
[2025-10-06T19:07:12] exec bash -lc ls in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:07:12] bash -lc ls succeeded in 676ms:
1.0
1e6
A.mat
AGENTS.md
AT012_TRACE_ANALYSIS.md
CLAUDE.md
COMMIT_MESSAGE.md
DEBUGGING_NIGHTMARE_PREVENTION_TOOLKIT.md
FINAL_DIAGNOSIS_REPORT.md
HYPOTHESIS_TESTING_RESULTS.md
HYPOTHESIS_TEST_RESULTS.md
LICENSE
Makefile
P1.hkl
PARALLEL_TEST_COMMANDS.md
PARALLEL_VALIDATION_ACCEPTANCE_TESTS.md
PERFORMANCE_ANALYSIS.md
PHASE_4_1_DIAGNOSTIC_REPORT.md
PHASE_5_FINAL_VALIDATION_REPORT.md
PHASE_5_IMPLEMENTATION_SUMMARY.md
[2025-10-06T19:07:12] tokens used: 13,059

[2025-10-06T19:07:14] thinking

**Checking galph_memory.md**
[2025-10-06T19:07:15] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:07:15] bash -lc 'cat galph_memory.md' succeeded in 695ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-06T19:07:15] tokens used: 15,362

[2025-10-06T19:07:19] thinking

**Checking for latest log entries**
[2025-10-06T19:07:19] exec bash -lc 'tail -n 100 galph_memory.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:07:20] bash -lc 'tail -n 100 galph_memory.md' succeeded in 738ms:
- Updated `plans/active/cli-noise-pix0/plan.md` with new Phases J–L covering scaling evidence → normalization implementation → final parity; marked I3 as blocked and refreshed context to emphasise the scaling gap.
- Synced `docs/fix_plan.md` Next Actions with the Phase J checklist and noted that Attempt #27 directives are superseded; Phase K work now gated on Attempt #28 evidence.
- Regenerated `input.md` (Evidence phase) instructing Ralph to capture C/Py scaling traces, build `scaling_chain.md`, and log Attempt #28 before any simulator edits.
- Follow-ups for Ralph: deliver plan tasks J1–J3 (logs + analysis + fix_plan update) under `reports/2025-10-cli-flags/phase_j/`, then pause for supervisor review before touching normalization code.

## 2025-10-21 (galph loop — Phase H5 reopen)
- Phase J scaling traces revealed C honours `-pix0_vector_mm` even with custom detector vectors; PyTorch still skips override in that path → 1.14 mm pix0 delta, h/k/l drift, F_latt collapse.
- Updated `plans/active/cli-noise-pix0/plan.md` with Phase H5 (C evidence, override reinstatement, trace verification, fix_plan logging) and corrected the prior note that C ignored overrides.
- Synced `docs/fix_plan.md` Next Actions to require H5a–H5c before Phase K; Attempt #28 observations now document the confirmed driver (missing override in custom-vector path).
- Regenerated `input.md` (Implementation phase) directing Ralph to execute Phase H5b with fresh C/PyTorch traces and targeted pytest.
- Follow-up: Expect Attempt #29 after override fix; pause Phase K normalization work until H5 parity evidence lands.

## 2025-10-06 (galph loop — Phase H5 evidence setup)
- Reviewed required guardrails (docs/index.md, specs/spec-a*, arch.md, config map, debugging guide, testing strategy, docs/fix_plan.md). Focus remains CLI-FLAGS-003 Phase H5; vectorization plan untouched until parity lands.
- Confirmed plans/active/cli-noise-pix0/plan.md already tracks Phase H5a–H5d; no new plan needed. docs/fix_plan.md Next Actions (line 448) aligned with H5 checklist.
- Identified outstanding gap: need fresh C traces with and without -pix0_vector_mm to validate override precedence (Phase J evidence shows F_latt divergence from pix0 mismatch). Hypotheses logged in supervisor summary; implementation deferred until traces captured.
- input.md rewritten (Evidence phase) directing Ralph to run long-form C command twice and archive logs under reports/2025-10-cli-flags/phase_h5/c_traces/, plus document derivation in c_precedence.md before touching PyTorch.
- No code/doc changes yet; awaiting H5a artifacts. Next follow-up: after Ralph captures traces, greenlight H5b override reapplication and revisit docs/fix_plan Attempt log.

## 2025-10-22 (galph loop — Phase H5 evidence refresh)
[2025-10-06T19:07:20] tokens used: 18,368

[2025-10-06T19:07:23] thinking

**Verifying full file end**
[2025-10-06T19:07:23] exec bash -lc 'tail -n 20 galph_memory.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:07:24] bash -lc 'tail -n 20 galph_memory.md' succeeded in 674ms:
## 2025-10-25 (galph loop — H6 harness alignment)
- Ran `git pull --rebase` (clean) and reviewed Phase H6 context. Noted PyTorch harness still forces `detector_pivot=BEAM` and likely executes the stale site-package build when `PYTHONPATH` is missing.
- Updated `plans/active/cli-noise-pix0/plan.md` to mark H6a/H6d complete and to call out two guardrails for H6b: import via `PYTHONPATH=src` and fix the BEAM hardcode.
- Added matching guidance to `docs/fix_plan.md` Next Actions so CLI-FLAGS-003 explicitly requires the editable install + SAMPLE pivot trace.
- Rewrote `input.md` (Evidence phase) directing Ralph to patch `trace_harness.py`, capture the new TRACE_PY log under `reports/2025-10-cli-flags/phase_h6/py_trace/`, and stash env/git context before diffing.
- Follow-up for Ralph: deliver Phase H6b artifacts (trace, stderr, env snapshot, git context) and update parity_summary.md; Phase H6c diff comes next.

## 2025-10-25 (galph loop — H6b harness prep refresh)
- Confirmed repo already synced; quick editable-import script reproduces C pix0 within 3e-6 m, so the outstanding 1.14 mm delta is a harness problem.
- Refined Phase H6b guidance in `plans/active/cli-noise-pix0/plan.md` and the CLI-FLAGS-003 Next Actions to demand editable import plus ≤5e-6 m acceptance.
- Issued new implementation memo (`input.md`) directing Ralph to monkey-patch `_calculate_pix0_vector` via the harness, drop the BEAM hardcode, log TRACE_PY with C-style precision, and archive stdout/stderr + env/git metadata under `reports/2025-10-cli-flags/phase_h6/py_trace/`.
- Reviewed Ralph commits 9ee2ada / bf9925b — C instrumentation captured clean, no regressions; remind future loop to unwind trace hooks once parity closes.
- Next follow-up: ensure Phase H6b artifacts land, then proceed to H6c diff analysis before reopening normalization work.
## 2025-10-06 (galph loop — Phase H6c prep)
- `git pull --rebase` clean; no incoming changes.
- Reviewed CLI parity status vs long-term goal #1. Diffed `phase_h6` traces and confirmed first divergence occurs at `beam_center_m` (PyTorch logging millimetres vs C metres).
- Updated `plans/active/cli-noise-pix0/plan.md` to mark H6b complete (Attempt #37) and refocused H6c task description on trace analysis.
- Refreshed `docs/fix_plan.md` Next Actions so bullet #1 now targets H6c diff/analysis rather than instrumentation.
- Authored new `input.md` (Evidence phase) directing Ralph to produce the trace diff, document findings, and log Attempt #38.
- Follow-up for Ralph: execute H6c diff per memo, update `reports/2025-10-cli-flags/phase_h6/analysis.md` + `reports/2025-10-cli-flags/phase_h5/parity_summary.md`, then record Attempt #38 in fix_plan before moving to H6d/H5c.
[2025-10-06T19:07:24] tokens used: 20,976

[2025-10-06T19:08:44] thinking

**Planning file reads**
[2025-10-06T19:09:02] exec bash -lc 'cat docs/index.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:03] bash -lc 'cat docs/index.md' succeeded in 979ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T19:09:03] tokens used: 22,390

[2025-10-06T19:09:05] thinking

**Reading specification file**
[2025-10-06T19:09:06] exec bash -lc 'cat specs/spec-a.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:06] bash -lc 'cat specs/spec-a.md' succeeded in 731ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T19:09:06] tokens used: 24,009

[2025-10-06T19:09:10] thinking

**Planning to review referenced specs**
[2025-10-06T19:09:13] exec bash -lc 'cat specs/spec-a-core.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:14] bash -lc 'cat specs/spec-a-core.md' succeeded in 735ms:
# nanoBragg Spec A — Core Engine

This shard contains the normative physics, geometry, sampling, and data handling requirements. CLI flag semantics live in [spec-a-cli.md](spec-a-cli.md); cross-implementation profiles and developer tooling are captured in [spec-a-parallel.md](spec-a-parallel.md).

Overview (Normative)

- Purpose: Simulates far-field diffraction from a perfect-lattice nanocrystal on a pixelated area
detector. No near-field propagation or detector PSF beyond pixel solid-angle/obliquity is modeled.
No symmetry is imposed; reflection indexing is P1 only (no Friedel pairing).
- Scope: Renders pixel intensities from a set of sources (beam divergence and spectral dispersion),
crystal orientation (including rotation oscillation and mosaic domains), and detector geometry.
Outputs: raw float image, SMV-format integer image (with and without Poisson noise), and optional
PGM.
- Key constants:
    - Classical electron radius squared r_e^2 = 7.94079248018965e-30 m^2.
    - Avogadro’s number = 6.02214179e23 mol^-1.

Units & Conversions (Normative)

- Length:
[2025-10-06T19:09:14] tokens used: 25,194

[2025-10-06T19:09:15] thinking

**Transitioning to architecture document**
[2025-10-06T19:09:16] exec bash -lc 'cat arch.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:17] bash -lc 'cat arch.md' succeeded in 784ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T19:09:17] tokens used: 28,377

[2025-10-06T19:09:19] thinking

**Reading configuration mapping document**
[2025-10-06T19:09:19] exec bash -lc 'cat docs/development/c_to_pytorch_config_map.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:20] bash -lc 'cat docs/development/c_to_pytorch_config_map.md' succeeded in 738ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T19:09:20] tokens used: 31,132

[2025-10-06T19:09:21] thinking

**Checking for debugging documentation**
[2025-10-06T19:09:22] exec bash -lc 'cat docs/debugging/debugging.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:23] bash -lc 'cat docs/debugging/debugging.md' succeeded in 718ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T19:09:23] tokens used: 33,888

[2025-10-06T19:09:26] thinking

**Checking fix_plan location**
[2025-10-06T19:09:26] exec bash -lc 'cat docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:27] bash -lc 'cat docs/fix_plan.md' succeeded in 698ms:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A–C) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2–B4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1–A3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ✅ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
| [CLI-DTYPE-002](#cli-dtype-002-cli-dtype-parity) | CLI dtype parity | High | in_progress |
[2025-10-06T19:09:27] tokens used: 36,936

[2025-10-06T19:09:29] thinking

**Noticing file truncation and test instructions**
[2025-10-06T19:09:30] exec bash -lc 'cat docs/development/testing_strategy.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:30] bash -lc 'cat docs/development/testing_strategy.md' succeeded in 709ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T19:09:30] tokens used: 39,843

[2025-10-06T19:09:35] thinking

**Inspecting active plans directory**
[2025-10-06T19:09:36] exec bash -lc 'ls plans/active' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:37] bash -lc 'ls plans/active' succeeded in 723ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T19:09:37] tokens used: 42,501

[2025-10-06T19:09:41] thinking

**Checking vectorization plan**
[2025-10-06T19:09:42] exec bash -lc 'cat plans/active/vectorization.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:42] bash -lc 'cat plans/active/vectorization.md' succeeded in 744ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B — Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T19:09:42] tokens used: 42,740

[2025-10-06T19:09:46] thinking

**Checking CLI-related plans**
[2025-10-06T19:09:48] exec bash -lc 'cat plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:09:49] bash -lc 'cat plans/active/cli-noise-pix0/plan.md' succeeded in 685ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
- Documentation anchors for this focus:
  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
  * `docs/development/testing_strategy.md` — authoritative pytest/trace commands for CLI parity evidence.

### Phase A — Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
Prereqs: Ability to run instrumented C binary via `NB_C_BIN` and collect traces.
Exit Criteria: Documented parity notes under `reports/2025-10-cli-flags/phase_a/` with explicit decisions on unit conversions and noise toggle ordering.
[2025-10-06T19:09:49] tokens used: 45,350

[2025-10-06T19:09:58] thinking

**Planning codebase analysis against goals**

I'll focus on deeply analyzing the codebase compared to the outlined long-term goals, especially around the CLI support for -nonoise and -pix0_vector_mm in PyTorch. I want to understand what’s done or pending, check relevant modules like `src/nanobrag_torch`, and prepare for next steps including flipping the coin after this analysis. Let’s explore the code and plan details carefully!
[2025-10-06T19:10:00] exec bash -lc 'rg "nonoise" -n src' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:01] bash -lc 'rg "nonoise" -n src' succeeded in 722ms:
src/nanobrag_torch/__main__.py:339:    parser.add_argument('-nonoise', action='store_true',
src/nanobrag_torch/__main__.py:711:    config['suppress_noise'] = args.nonoise
src/nanobrag_torch/__main__.py:1185:        # CLI-FLAGS-003: Honor -nonoise flag
[2025-10-06T19:10:01] tokens used: 49,387

[2025-10-06T19:10:04] thinking

**Preparing to view snippet**
[2025-10-06T19:10:04] exec bash -lc "sed -n '300,360p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:05] bash -lc "sed -n '300,360p' src/nanobrag_torch/__main__.py" succeeded in 847ms:
    parser.add_argument('-oversample_thick', action='store_true',
                        help='Recompute absorption per subpixel')
    parser.add_argument('-oversample_polar', action='store_true',
                        help='Recompute polarization per subpixel')
    parser.add_argument('-oversample_omega', action='store_true',
                        help='Recompute solid angle per subpixel')
    parser.add_argument('-roi', nargs=4, type=int,
                        metavar=('xmin', 'xmax', 'ymin', 'ymax'),
                        help='Pixel index limits (inclusive, zero-based)')

    # Background
    parser.add_argument('-water', type=float, metavar='µm',
                        help='Water background size (µm)')

    # Source intensity
    parser.add_argument('-fluence', type=float, metavar='photons/m^2',
                        help='Fluence (photons/m^2)')
    parser.add_argument('-flux', type=float, metavar='photons/s',
                        help='Flux (photons/s)')
    parser.add_argument('-exposure', type=float, metavar='s',
[2025-10-06T19:10:05] tokens used: 49,662

[2025-10-06T19:10:07] thinking

**Locating noise suppression logic**
[2025-10-06T19:10:07] exec bash -lc "sed -n '1140,1210p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:08] bash -lc "sed -n '1140,1210p' src/nanobrag_torch/__main__.py" succeeded in 679ms:
                    # Calculate scale to achieve 55000 after adding ADC
                    scale = (55000.0 - adc_offset) / max_val if adc_offset < 55000 else 55000.0 / max_val
                else:
                    scale = 1.0

            # Apply scaling per spec: integer pixel = floor(min(65535, float*scale + adc))
            # Only apply to non-zero pixels (AT-CLI-005)
            # Pixels outside ROI should remain zero
            threshold = 1e-10
            roi_mask = intensity > threshold

            # Calculate scaled values
            scaled = intensity * scale + adc_offset
            # Only apply scaling where intensity > 0 (inside ROI)
            scaled = torch.where(roi_mask, scaled, torch.zeros_like(scaled))
            # Clip to valid range and floor
            scaled = scaled.clip(0, 65535)
            scaled_int = torch.floor(scaled).to(torch.int16).cpu().numpy().astype(np.uint16)

            write_smv(
[2025-10-06T19:10:08] tokens used: 50,673

[2025-10-06T19:10:10] thinking

**Investigating detector.py logic**
[2025-10-06T19:10:11] exec bash -lc 'rg "pix0_override" -n src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:12] bash -lc 'rg "pix0_override" -n src/nanobrag_torch/models/detector.py' succeeded in 790ms:
391:        # Convert pix0_override to tensor if provided (CLI-FLAGS-003 Phase F2)
394:        pix0_override_tensor = None
395:        if self.config.pix0_override_m is not None:
396:            override = self.config.pix0_override_m
398:                pix0_override_tensor = torch.tensor(override, device=self.device, dtype=self.dtype)
400:                pix0_override_tensor = override.to(device=self.device, dtype=self.dtype)
402:                raise TypeError(f"pix0_override_m must be tuple, list, or Tensor, got {type(override)}")
521:            # CLI-FLAGS-003 Phase H5b: Handle pix0_override for BEAM pivot
527:            # pix0_override application workflow (when no custom vectors):
528:            # 1. Subtract beam term to get detector offset: pix0_delta = pix0_override - distance*beam
542:            if pix0_override_tensor is not None and not has_custom_vectors:
547:                pix0_override_local = pix0_override_tensor.to(device=self.device, dtype=self.dtype)
553:                pix0_delta = pix0_override_local - beam_term
682:            # The C code (nanoBragg.c:1739-1745) shows that pix0_override is IGNORED for SAMPLE pivot;
[2025-10-06T19:10:12] tokens used: 51,734

[2025-10-06T19:10:13] thinking

**Seeking context around error 521**
[2025-10-06T19:10:14] exec bash -lc "sed -n '500,620p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:15] bash -lc "sed -n '500,620p' src/nanobrag_torch/models/detector.py" succeeded in 722ms:
            # 1. Convert beam_center_f/s from mm to m (÷ 1000)
            # 2. Add the MOSFLM +0.5 pixel offset (in meters)
            #
            # Reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/diff_notes.md documents
            # the 1.1mm ΔF that this fix resolves.

            if self.config.detector_convention == DetectorConvention.MOSFLM:
                # MOSFLM convention: add +0.5 pixel offset (C: nanoBragg.c:1220-1221)
                # beam_center_f/s are in mm; convert to m and add half-pixel in meters
                # Use config values directly (they're in mm) and convert
                Fbeam = (self.config.beam_center_f / 1000.0) + (0.5 * self.pixel_size)
                Sbeam = (self.config.beam_center_s / 1000.0) + (0.5 * self.pixel_size)
            else:
                # Other conventions: convert mm→m without offset
                Fbeam = self.config.beam_center_f / 1000.0
                Sbeam = self.config.beam_center_s / 1000.0

            # Reuse beam_vector from r-factor calculation above
            # This ensures CUSTOM convention overrides (e.g., -beam_vector) are honored
            # beam_vector is already set via self.beam_vector property
[2025-10-06T19:10:15] tokens used: 52,946

[2025-10-06T19:10:21] thinking

**Preparing analysis and data gathering**
[2025-10-06T19:10:21] exec bash -lc 'rg "F_latt" -n src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:22] bash -lc 'rg "F_latt" -n src/nanobrag_torch' succeeded in 753ms:
src/nanobrag_torch/config.py:148:    shape: CrystalShape = CrystalShape.SQUARE  # Crystal shape model for F_latt calculation
src/nanobrag_torch/utils/physics.py:153:                                        F_latt = Na*Nb*Nc*0.723601254558268*sinc3(M_PI*sqrt( hrad_sqr * fudge ) );
src/nanobrag_torch/simulator.py:216:    #     F_latt = sin(M_PI*Na*h)*sin(M_PI*Nb*k)*sin(M_PI*Nc*l)/sin(M_PI*h)/sin(M_PI*k)/sin(M_PI*l);
src/nanobrag_torch/simulator.py:218:    # F_latt = 1.0;
src/nanobrag_torch/simulator.py:222:    #     double F_latt_a = 1.0, F_latt_b = 1.0, F_latt_c = 1.0;
src/nanobrag_torch/simulator.py:224:    #         F_latt_a = sincg(M_PI*h,Na);
src/nanobrag_torch/simulator.py:225:    #         F_latt *= F_latt_a;
src/nanobrag_torch/simulator.py:228:    #         F_latt_b = sincg(M_PI*k,Nb);
src/nanobrag_torch/simulator.py:229:    #         F_latt *= F_latt_b;
src/nanobrag_torch/simulator.py:232:    #         F_latt_c = sincg(M_PI*l,Nc);
src/nanobrag_torch/simulator.py:233:    #         F_latt *= F_latt_c;
src/nanobrag_torch/simulator.py:239:    # "SQUARE (grating): F_latt = sincg(π·h, Na) · sincg(π·k, Nb) · sincg(π·l, Nc)"
src/nanobrag_torch/simulator.py:250:        F_latt_a = sincg(torch.pi * h, Na)
src/nanobrag_torch/simulator.py:251:        F_latt_b = sincg(torch.pi * k, Nb)
src/nanobrag_torch/simulator.py:252:        F_latt_c = sincg(torch.pi * l, Nc)
src/nanobrag_torch/simulator.py:253:        F_latt = F_latt_a * F_latt_b * F_latt_c
src/nanobrag_torch/simulator.py:263:        F_latt = Na * Nb * Nc * 0.723601254558268 * sinc3(
src/nanobrag_torch/simulator.py:282:        F_latt = Na * Nb * Nc * torch.exp(-(rad_star_sqr / 0.63) * fudge)
src/nanobrag_torch/simulator.py:300:        F_latt = torch.where(inside_cutoff,
src/nanobrag_torch/simulator.py:307:    F_total = F_cell * F_latt
[2025-10-06T19:10:22] tokens used: 55,216

[2025-10-06T19:10:29] thinking

**Preparing to analyze fix_plan status**
[2025-10-06T19:10:30] exec bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:30] bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' succeeded in 684ms:
21:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
448:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
[2025-10-06T19:10:30] tokens used: 56,641

[2025-10-06T19:10:32] thinking

**Inspecting section near line 448**
[2025-10-06T19:10:34] exec bash -lc "sed -n '448,640p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:34] bash -lc "sed -n '448,640p' docs/fix_plan.md" succeeded in 682ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A-H complete; polarization Phase I pending)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
[2025-10-06T19:10:34] tokens used: 56,956

[2025-10-06T19:10:45] thinking

**Outlining long-term goals analysis**

I’m framing the Step1 analysis around the user’s long-term goals, focusing on CLI parity issues with -nonoise and -pix0 flags. I’ll identify gaps like pix0 mismatch and scaling, gather evidence from reports, and prepare hypotheses for debugging while planning to summarize these findings later.
[2025-10-06T19:10:49] exec bash -lc 'cat reports/2025-10-cli-flags/phase_h6/analysis.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:50] bash -lc 'cat reports/2025-10-cli-flags/phase_h6/analysis.md' succeeded in 990ms:
# Phase H6c Findings: First Divergence Analysis

**Date:** 2025-10-26
**Phase:** H6c Trace Diff Analysis
**Objective:** Identify first divergence between C and PyTorch pix0 traces

## Summary

**First Divergence Identified:** `beam_center_m` values differ by a factor of ~10³ (millimeters vs meters)

### Critical Finding

The C trace shows:
```
TRACE_C:beam_center_m=Xclose:0.000211818 Yclose:0.000217322 pixel_mm:0.172
```

The PyTorch trace shows:
```
TRACE_PY:beam_center_m=Xclose:0.217742295 Yclose:0.21390708 pixel_mm:0.172
[2025-10-06T19:10:50] tokens used: 60,539

[2025-10-06T19:10:54] thinking

**Preparing to flip a coin in Python**
[2025-10-06T19:10:55] exec bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:10:56] bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" succeeded in 778ms:
heads
[2025-10-06T19:10:56] tokens used: 62,438

[2025-10-06T19:11:00] thinking

**Checking recent commit history**
[2025-10-06T19:11:01] exec bash -lc 'git log --oneline -n 12' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:11:02] bash -lc 'git log --oneline -n 12' succeeded in 697ms:
3c346ce [SYNC i=44] actor=galph status=running
ff7a96b [SYNC i=44] actor=ralph → next=galph status=ok ralph_commit=5d0a34d
5d0a34d CLI-FLAGS-003 Phase H6c: Document first divergence in pix0 trace comparison
c0246fc [SYNC i=43] actor=ralph status=running
e8380e2 [SYNC i=43] actor=galph → next=ralph status=ok galph_commit=ad05ab4
ad05ab4 SUPERVISOR: CLI-FLAGS Phase H6c guidance - tests: not run
6ca7666 [SYNC i=43] actor=galph status=running
51897df [SYNC i=43] actor=ralph → next=galph status=ok ralph_commit=ced93e6
ced93e6 [SYNC i=42] actor=ralph status=ok
cb5daae [SYNC i=42] actor=ralph status=running
008d917 [SYNC i=42] actor=ralph status=running
a57a20f [SYNC i=42] actor=galph → next=ralph status=ok galph_commit=93da9c2
[2025-10-06T19:11:02] tokens used: 62,650

[2025-10-06T19:11:04] thinking

**Reviewing specific commit details**
[2025-10-06T19:11:04] exec bash -lc 'git show --stat 5d0a34d' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:11:05] bash -lc 'git show --stat 5d0a34d' succeeded in 782ms:
commit 5d0a34dd5e976d94eef5435c493533f1337b32c4
Author: ollie <ohoidn>
Date:   Mon Oct 6 12:06:12 2025 -0700

    CLI-FLAGS-003 Phase H6c: Document first divergence in pix0 trace comparison
    
    Evidence loop identifying beam_center_m unit mismatch between C and PyTorch traces.
    
    Key Findings:
    - First divergence: beam_center_m logged in mm (PyTorch) vs m (C) - 1000× scale
    - This is a trace logging issue, NOT a calculation error
    - Fclose/Sclose match exactly (0.217742295, 0.21390708 m), confirming internal calculation correct
    - Pix0 delta persists (ΔF=-1136μm, ΔS=+139μm, ΔO=-6μm) despite correct Fclose/Sclose
    - Indicates divergence in term_fast/term_slow/term_close combination or missing CUSTOM transform
    
    Artifacts:
    - reports/2025-10-cli-flags/phase_h6/trace_diff.txt: Full unified diff
    - reports/2025-10-cli-flags/phase_h6/analysis.md: Detailed numeric analysis with tables
    - reports/2025-10-cli-flags/phase_h5/parity_summary.md: Updated with H6c findings
    - docs/fix_plan.md: Attempt #38 logged with next actions
[2025-10-06T19:11:05] tokens used: 63,151

[2025-10-06T19:11:08] thinking

**Reviewing recent commits for context**
[2025-10-06T19:11:10] exec bash -lc 'git show --stat ced93e6' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:11:10] bash -lc 'git show --stat ced93e6' succeeded in 972ms:
commit ced93e6b7b30fe6e80bd645d46731ac6a7f4e407
Author: ollie <ohoidn>
Date:   Mon Oct 6 11:53:59 2025 -0700

    [SYNC i=42] actor=ralph status=ok
    
    docs/fix_plan.md: Log Attempt #37 (Phase H6b PyTorch trace)
    
    Updated CLI-FLAGS-003 attempts history with Attempt #37 metrics and artifacts.
    
    Documented:
    - Phase H6b completion: PyTorch pix0 trace harness instrumented
    - Trace capture: 73 lines (21 TRACE_PY + 52 simulator lines) under phase_h6/py_trace/
    - Deltas persist: ΔS = -1136 µm despite Phase H5e unit fix
    - Harness improvements: PYTHONPATH=src (editable), pivot auto-selection, term_* for all CUSTOM cases
    - Next action: Phase H6c line-by-line diff to isolate first divergence
    
    No code changes; documentation-only loop per Phase H6b task completion.

 docs/fix_plan.md | 17 +++++++++++++++++
[2025-10-06T19:11:10] tokens used: 63,924

[2025-10-06T19:11:15] thinking

**Reviewing previous code commits**
[2025-10-06T19:11:15] exec bash -lc 'git show --stat 9ee2ada' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:11:16] bash -lc 'git show --stat 9ee2ada' succeeded in 804ms:
commit 9ee2ada97698362a3aa9d48e8f5542f9b6299596
Author: ollie <ohoidn>
Date:   Mon Oct 6 10:53:17 2025 -0700

    CLI-FLAGS-003 Phase H6a: Capture C pix0 trace with SAMPLE pivot instrumentation
    
    - Instrumented golden_suite_generator/nanoBragg.c with TRACE_C outputs for SAMPLE pivot path (lines 1736-1823)
    - Added tracing for: convention, angles, beam_center (Xclose/Yclose), Fclose/Sclose/close_distance/ratio/distance
    - Added term decomposition before pix0 calculation and pix0 values before/after rotations
    - Added basis vector tracing after XYZ rotations and twotheta
    - Rebuilt C binary with -DTRACING=1 flag
    - Executed supervisor command and captured full trace to reports/2025-10-cli-flags/phase_h6/c_trace/
    - Created README with build context, git hash, observations, and key findings
    - Captured environment snapshot and SHA256 checksum for reproducibility
    - Extracted clean TRACE_C lines for easy comparison (trace_c_pix0_clean.log)
    
    Key findings:
    - Convention: CUSTOM (due to explicit detector vectors)
    - Pivot: SAMPLE (custom vectors override -pix0_vector_mm)
    - C pix0 result: (-0.216476, 0.216343, -0.230192) meters
[2025-10-06T19:11:16] tokens used: 64,475

[2025-10-06T19:11:28] thinking

**Evaluating multi-turn planning needs**

I'm reviewing existing detailed plans for long-term goals, especially CLI parity and vectorization, to decide if updates are needed based on new findings. The CLI pix0 issue seems most urgent, so I'll focus on updating that plan with new tasks reflecting recent evidence and next steps like H6d.
[2025-10-06T19:11:29] exec bash -lc 'rg "H6" -n plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:11:30] bash -lc 'rg "H6" -n plans/active/cli-noise-pix0/plan.md' succeeded in 971ms:
128:| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
130:### Phase H6 — Pix0 Divergence Isolation
137:| H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
138:| H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
139:| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
140:| H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
[2025-10-06T19:11:30] tokens used: 66,366

[2025-10-06T19:11:33] thinking

**Continuing after H6c-other tasks**
[2025-10-06T19:11:34] exec bash -lc "sed -n '130,220p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:11:34] bash -lc "sed -n '130,220p' plans/active/cli-noise-pix0/plan.md" succeeded in 720ms:
### Phase H6 — Pix0 Divergence Isolation
Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
| H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
| H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
| H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
| H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |

### Phase I — Polarization Alignment (follow-up)
Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
Prereqs: Phases F–H complete; traces show `F_latt` parity.
Exit Criteria: Polarization entries in C/PyTorch traces agree (≈0.9126 for supervisor command) and parity smoke stays green.

| ID | Task Description | State | How/Why & Guidance |
[2025-10-06T19:11:34] tokens used: 67,122

[2025-10-06T19:12:07] thinking

**Updating plan to reflect completed analysis and add new tasks**

I’m reviewing the plan and commit history to mark task H6c as done since analysis is complete, then adding new tasks like H6d and H6e to investigate the root cause of the lingering pix0 difference. I’m also aligning guidance and Next Actions with the latest findings, cross-referencing relevant docs, and preparing to update the plan carefully to keep numbering and instructions clear and consistent.
[2025-10-06T19:12:10] exec bash -lc 'cat reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/diff_notes.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:12:11] bash -lc 'cat reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/diff_notes.md' succeeded in 922ms:
# PyTorch vs C Trace Comparison — Phase H5c

**Command:**
```bash
PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/trace_py.log
```

**Date:** 2025-10-22
**Pixel:** (slow=1039, fast=685)

## Metrics Summary

### pix0_vector (meters)
- **C (line 8):**   `DETECTOR_PIX0_VECTOR -0.216475836204836 0.216343050492215 -0.230192414300537`
- **PyTorch:**      `TRACE_PY: pix0_vector_meters -0.216336513668519 0.21520668107301 -0.230198008546698`

Component deltas:
- ΔS (slow):   -0.216336513668519 - (-0.216475836204836) = **+1.393e-04 m**
- ΔF (fast):   0.21520668107301 - 0.216343050492215   = **-1.136e-03 m**
- ΔO (normal): -0.230198008546698 - (-0.230192414300537) = **-5.594e-06 m**
[2025-10-06T19:12:11] tokens used: 71,316

[2025-10-06T19:12:18] thinking

**Updating plan with new analysis tasks**

I’m updating the plan to add tasks focused on analyzing differences in final pix0 components by comparing computations from C and PyTorch, including deriving Fbeam and Sbeam from the C trace and verifying intermediate values through logging to pinpoint the actual delta. I’m considering reorganizing steps to include these new subtasks for a thorough comparison.
[2025-10-06T19:12:19] exec bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:12:21] bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.log' succeeded in 1.38s:
TRACE_PY:detector_convention=CUSTOM
TRACE_PY:angles_rad=rotx:0 roty:0 rotz:0 twotheta:0
TRACE_PY:beam_center_m=Xclose:0.217742295 Yclose:0.21390708 pixel_mm:0.172
TRACE_PY:initial_fdet=0.999982 -0.005998 -0.000118
TRACE_PY:initial_sdet=-0.005998 -0.99997 -0.004913
TRACE_PY:initial_odet=-8.8e-05 0.004914 -0.999988
TRACE_PY:Fclose_m=0.217742295
TRACE_PY:Sclose_m=0.21390708
TRACE_PY:close_distance_m=0.231271809414591
TRACE_PY:ratio=0.999987814780285
TRACE_PY:distance_m=0.231274627546742
TRACE_PY:term_fast_before_rot=-0.21773837563869 0.00130601828541 2.569359081e-05
TRACE_PY:term_slow_before_rot=0.00128301466584 0.2139006627876 0.00105092548404
TRACE_PY:term_close_before_rot=-2.0351919228484e-05 0.0011364696714633 -0.231269034152878
TRACE_PY:pix0_before_rotation=-0.216336513668519 0.21520668107301 -0.230198008546698
TRACE_PY:pix0_after_rotz=-0.216336513668519 0.21520668107301 -0.230198008546698
TRACE_PY:pix0_after_twotheta=-0.216336513668519 0.21520668107301 -0.230198008546698
TRACE_PY:fdet_after_rotz=0.999982 -0.005998 -0.000118
TRACE_PY:sdet_after_rotz=-0.005998 -0.99997 -0.004913
TRACE_PY:odet_after_rotz=-8.8e-05 0.004914 -0.999988
[2025-10-06T19:12:21] tokens used: 73,138

[2025-10-06T19:12:23] thinking

**Comparing pre-rotation values with C trace**
[2025-10-06T19:12:24] exec bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0_clean.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:12:25] bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0_clean.log' succeeded in 700ms:
TRACE_C:detector_convention=CUSTOM
TRACE_C:angles_rad=rotx:0 roty:0 rotz:0 twotheta:0
TRACE_C:beam_center_m=Xclose:0.000211818 Yclose:0.000217322 pixel_mm:0.172
TRACE_C:initial_fdet=0.999982004873912 -0.00599800002923425 -0.000118000000575132
TRACE_C:initial_sdet=-0.0059979996566955 -0.999969942765222 -0.0049129997187971
TRACE_C:initial_odet=-8.85282813644494e-05 0.00491361907271126 -0.999987924182263
TRACE_C:Fclose_m=0.217742295
TRACE_C:Sclose_m=0.21390708
TRACE_C:close_distance_m=0.231271826111781
TRACE_C:ratio=0.999987746654913
TRACE_C:distance_m=0.23127466
TRACE_C:term_fast_before_rot=-0.217738376699947 0.00130601829177553 2.56935909352306e-05
TRACE_C:term_slow_before_rot=0.00128301459240474 0.213900650544676 0.00105092542388871
TRACE_C:term_close_before_rot=-2.04740972936938e-05 0.00113638165576361 -0.231269033315361
TRACE_C:pix0_before_rotation=-0.216475836204836 0.216343050492215 -0.230192414300537
TRACE_C:pix0_after_rotz=-0.216475836204836 0.216343050492215 -0.230192414300537
TRACE_C:pix0_after_twotheta=-0.216475836204836 0.216343050492215 -0.230192414300537
TRACE_C:fdet_after_rotz=0.999982004873912 -0.00599800002923425 -0.000118000000575132
TRACE_C:sdet_after_rotz=-0.0059979996566955 -0.999969942765222 -0.0049129997187971
TRACE_C:odet_after_rotz=-8.85282813644494e-05 0.00491361907271126 -0.999987924182263
[2025-10-06T19:12:25] tokens used: 74,381

[2025-10-06T19:12:32] thinking

**Analyzing numerical term discrepancies**
[2025-10-06T19:12:33] exec bash -lc "python - <<'PY'
import decimal
from decimal import Decimal

c = Decimal('-0.217738376699947') + Decimal('0.00128301459240474') + Decimal('-2.04740972936938e-05')
py = Decimal('-0.21773837563869') + Decimal('0.00128301466584') + Decimal('-2.0351919228484e-05')
print('C sum', c)
print('Py sum', py)
print('Difference', py - c)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:12:33] bash -lc "python - <<'PY'
import decimal
from decimal import Decimal

c = Decimal('-0.217738376699947') + Decimal('0.00128301459240474') + Decimal('-2.04740972936938e-05')
py = Decimal('-0.21773837563869') + Decimal('0.00128301466584') + Decimal('-2.0351919228484e-05')
print('C sum', c)
print('Py sum', py)
print('Difference', py - c)
PY" succeeded in 710ms:
C sum -0.2164758362048359538
Py sum -0.216475712892078484
Difference 1.233127574698E-7
[2025-10-06T19:12:33] tokens used: 75,684

[2025-10-06T19:12:44] thinking

**Investigating discrepancy in pix0_before_rotation values**
[2025-10-06T19:12:45] exec bash -lc "sed -n '460,560p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:12:46] bash -lc "sed -n '460,560p' src/nanobrag_torch/models/detector.py" succeeded in 937ms:
                ratio
            )

            # Update distance based on r-factor
            # If close_distance is specified, use it; otherwise calculate from nominal distance
            if hasattr(self.config, 'close_distance_mm') and self.config.close_distance_mm is not None:
                close_distance = self.config.close_distance_mm / 1000.0  # Convert mm to meters
            else:
                close_distance = abs(ratio * self.distance)  # Default from C code

            # Update the actual distance using r-factor (implements AT-GEO-003)
            self.distance_corrected = close_distance / ratio

            # CRITICAL: Update the stored close_distance for obliquity calculations
            # This is needed when detector is rotated (e.g., with twotheta)
            self.close_distance = close_distance

        # Store r-factor for later verification
        # Ensure it's a tensor with correct dtype
        if isinstance(ratio, torch.Tensor):
[2025-10-06T19:12:46] tokens used: 142,050
[2025-10-06T19:12:49] exec bash -lc "sed -n '560,700p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:12:50] bash -lc "sed -n '560,700p' src/nanobrag_torch/models/detector.py" succeeded in 704ms:
                # Override the Fbeam/Sbeam values with derived ones
                Fbeam = Fbeam_override
                Sbeam = Sbeam_override

                # Update beam_center_f/s tensors to maintain header consistency
                # Convert from meters back to pixels: beam_center = offset_m / pixel_size_m
                # Note: For MOSFLM the +0.5 offset was already applied above, so reverse it
                if self.config.detector_convention == DetectorConvention.MOSFLM:
                    # MOSFLM: Fbeam = (beam_center_f + 0.5) * pixel_size
                    # So: beam_center_f = Fbeam / pixel_size - 0.5
                    self.beam_center_f = (Fbeam / self.pixel_size - 0.5).to(device=self.device, dtype=self.dtype)
                    self.beam_center_s = (Sbeam / self.pixel_size - 0.5).to(device=self.device, dtype=self.dtype)
                else:
                    # Other conventions: beam_center = offset / pixel_size
                    self.beam_center_f = (Fbeam / self.pixel_size).to(device=self.device, dtype=self.dtype)
                    self.beam_center_s = (Sbeam / self.pixel_size).to(device=self.device, dtype=self.dtype)

            # Use exact C-code formula WITH distance correction (AT-GEO-003)
            # BEAM pivot formula (C-code reference: nanoBragg.c lines 1833-1835):
            # pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
[2025-10-06T19:12:50] tokens used: 144,565

[2025-10-06T19:12:58] thinking

**Investigating pivot configuration and instrumentation**
[2025-10-06T19:12:59] exec bash -lc 'rg "TRACE_PY" src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:00] bash -lc 'rg "TRACE_PY" src/nanobrag_torch/models/detector.py' exited 1 in 771ms:

[2025-10-06T19:13:00] tokens used: 147,361

[2025-10-06T19:13:05] thinking

**Investigating harness trace outputs**
[2025-10-06T19:13:06] exec bash -lc "sed -n '1,200p' reports/2025-10-cli-flags/phase_h/trace_harness.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:07] bash -lc "sed -n '1,200p' reports/2025-10-cli-flags/phase_h/trace_harness.py" succeeded in 758ms:
#!/usr/bin/env python3
"""
PyTorch trace harness for CLI-FLAGS-003 Phase H1.
Generates TRACE_PY output matching C trace format.
Phase H1: Clean trace without manual beam overrides - Detector.apply_custom_vectors() handles beam_vector from CLI.
"""

import os
import sys
import torch
from pathlib import Path

# Set environment variable for MKL conflicts
os.environ['KMP_DUPLICATE_LIB_OK'] = 'TRUE'

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent / 'src'))

from nanobrag_torch.config import (
    DetectorConfig, CrystalConfig, BeamConfig,
[2025-10-06T19:13:07] tokens used: 147,705

[2025-10-06T19:13:10] thinking

**Continuing to next part**
[2025-10-06T19:13:12] exec bash -lc "sed -n '200,400p' reports/2025-10-cli-flags/phase_h/trace_harness.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:12] bash -lc "sed -n '200,400p' reports/2025-10-cli-flags/phase_h/trace_harness.py" succeeded in 764ms:
    # Let the pivot be determined by the CLI precedence rules
    # (custom vectors imply SAMPLE pivot regardless of -distance)
    detector_config = DetectorConfig(
        spixels=detpixels[0],
        fpixels=detpixels[1],
        pixel_size_mm=pixel_size,
        distance_mm=distance,
        detector_convention=DetectorConvention.CUSTOM,
        beam_center_s=Ybeam,  # Ybeam maps to slow axis
        beam_center_f=Xbeam,  # Xbeam maps to fast axis
        pix0_override_m=tuple(pix0_vector_m),
        custom_fdet_vector=tuple(fdet_vector),
        custom_sdet_vector=tuple(sdet_vector),
        custom_odet_vector=tuple(odet_vector),
        custom_beam_vector=tuple(beam_vector),  # Phase H1: Pass beam_vector to Detector
        oversample=oversample
        # Phase H6b: Omit detector_pivot to let DetectorConfig choose SAMPLE
    )

    # Create beam config
[2025-10-06T19:13:12] tokens used: 150,904

[2025-10-06T19:13:21] thinking

**Analyzing beam_center_f usage and units**
[2025-10-06T19:13:22] exec bash -lc 'rg "beam_center_f" -n src/nanobrag_torch/config.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:23] bash -lc 'rg "beam_center_f" -n src/nanobrag_torch/config.py' succeeded in 913ms:
188:    beam_center_f: Union[float, torch.Tensor, None] = None  # fast axis (auto-calculated if None)
263:        if self.beam_center_s is None or self.beam_center_f is None:
272:                if self.beam_center_f is None:
273:                    self.beam_center_f = (detsize_f + self.pixel_size_mm) / 2.0
279:                if self.beam_center_f is None:
280:                    self.beam_center_f = detsize_f / 2.0
286:                if self.beam_center_f is None:
287:                    self.beam_center_f = (detsize_f + self.pixel_size_mm) / 2.0
293:                if self.beam_center_f is None:
294:                    self.beam_center_f = detsize_f / 2.0
[2025-10-06T19:13:23] tokens used: 152,123

[2025-10-06T19:13:25] thinking

**Opening relevant section**
[2025-10-06T19:13:26] exec bash -lc "sed -n '240,320p' src/nanobrag_torch/config.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:27] bash -lc "sed -n '240,320p' src/nanobrag_torch/config.py" succeeded in 741ms:
        - If only distance_mm is provided (not close_distance_mm): pivot = BEAM
        - If only close_distance_mm is provided: pivot = SAMPLE
        - If detector_pivot is explicitly set: use that (explicit override wins)
        """
        # AT-GEO-002: Automatic pivot selection based on distance parameters
        if self.detector_pivot is None:
            # Determine if distance_mm was explicitly provided (not just defaulted)
            # Note: In real CLI, we'd know if user provided -distance vs -close_distance
            # For testing, we use the presence/absence of close_distance_mm as indicator

            if self.close_distance_mm is not None:
                # Setup B: -close_distance provided -> pivot SHALL be SAMPLE
                self.detector_pivot = DetectorPivot.SAMPLE
                # Use close_distance as the actual distance if distance wasn't provided
                if self.distance_mm == 100.0:  # Default value, likely not explicitly set
                    self.distance_mm = self.close_distance_mm
            else:
                # Setup A: Only -distance provided -> pivot SHALL be BEAM
                self.detector_pivot = DetectorPivot.BEAM
        # Setup C: Explicit -pivot override is already set, keep it
[2025-10-06T19:13:27] tokens used: 152,470

[2025-10-06T19:13:31] thinking

**Verifying unit consistency for beam center and pixel size**
[2025-10-06T19:13:33] exec bash -lc 'rg "self.pixel_size" -n src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:33] bash -lc 'rg "self.pixel_size" -n src/nanobrag_torch/models/detector.py' succeeded in 935ms:
61:        self.pixel_size = config.pixel_size_mm / 1000.0  # Convert mm to meters
268:            adjusted_f = (beam_s_pixels + 0.5) * self.pixel_size  # S→F mapping
269:            adjusted_s = (beam_f_pixels + 0.5) * self.pixel_size  # F→S mapping
510:                Fbeam = (self.config.beam_center_f / 1000.0) + (0.5 * self.pixel_size)
511:                Sbeam = (self.config.beam_center_s / 1000.0) + (0.5 * self.pixel_size)
570:                    self.beam_center_f = (Fbeam / self.pixel_size - 0.5).to(device=self.device, dtype=self.dtype)
571:                    self.beam_center_s = (Sbeam / self.pixel_size - 0.5).to(device=self.device, dtype=self.dtype)
574:                    self.beam_center_f = (Fbeam / self.pixel_size).to(device=self.device, dtype=self.dtype)
575:                    self.beam_center_s = (Sbeam / self.pixel_size).to(device=self.device, dtype=self.dtype)
642:                Fclose = (self.beam_center_f + 0.5) * self.pixel_size
643:                Sclose = (self.beam_center_s + 0.5) * self.pixel_size
646:                Fclose = self.beam_center_f * self.pixel_size
647:                Sclose = self.beam_center_s * self.pixel_size
815:            + s_grid.unsqueeze(-1) * self.pixel_size * sdet_expanded
816:            + f_grid.unsqueeze(-1) * self.pixel_size * fdet_expanded
840:        Sdet = s_grid * self.pixel_size  # meters
841:        Fdet = f_grid * self.pixel_size  # meters
941:            omega = (self.pixel_size * self.pixel_size) / (R * R) * (self.close_distance / R)
1059:            Fbeam_original = (self.beam_center_f + 0.5) * self.pixel_size
1060:            Sbeam_original = (self.beam_center_s + 0.5) * self.pixel_size
[2025-10-06T19:13:33] tokens used: 154,681

[2025-10-06T19:13:39] thinking

**Analyzing unit conversions for beam center**
[2025-10-06T19:13:40] exec bash -lc "sed -n '1,180p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:40] bash -lc "sed -n '1,180p' src/nanobrag_torch/models/detector.py" succeeded in 676ms:
"""
Detector model for nanoBragg PyTorch implementation.

This module defines the Detector class responsible for managing all detector
geometry calculations and pixel coordinate generation.
"""

from typing import Optional, Tuple

import torch

from ..config import DetectorConfig, DetectorConvention
from ..utils.units import mm_to_angstroms, degrees_to_radians


def _nonzero_scalar(x) -> bool:
    """Return a Python bool for 'x != 0' even if x is a 0-dim torch.Tensor."""
    if isinstance(x, torch.Tensor):
        # Use tensor operations to maintain gradient flow
        return bool((torch.abs(x) > 1e-12).item())
[2025-10-06T19:13:40] tokens used: 155,720

[2025-10-06T19:13:50] thinking

**Verifying unit conversions and calculations**
[2025-10-06T19:13:52] exec bash -lc "python - <<'PY'
beam_center_f_mm = 217.742295
pixel_mm = 0.172
beam_center_f_pixels = beam_center_f_mm / pixel_mm
print('beam_center_f_pixels', beam_center_f_pixels)
print('Fclose_m', beam_center_f_pixels * pixel_mm / 1000)
print('Fclose_from_config_mm', beam_center_f_mm / 1000)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:13:53] bash -lc "python - <<'PY'
beam_center_f_mm = 217.742295
pixel_mm = 0.172
beam_center_f_pixels = beam_center_f_mm / pixel_mm
print('beam_center_f_pixels', beam_center_f_pixels)
print('Fclose_m', beam_center_f_pixels * pixel_mm / 1000)
print('Fclose_from_config_mm', beam_center_f_mm / 1000)
PY" succeeded in 957ms:
beam_center_f_pixels 1265.9435755813956
Fclose_m 0.21774229500000003
Fclose_from_config_mm 0.217742295
[2025-10-06T19:13:53] tokens used: 157,995

[2025-10-06T19:14:08] thinking

**Investigating pixel difference causes**

I'm comparing how pixel conversion and term contributions relate, focusing on differences between config-based terms and actual detector computations. I’m checking if vector usage or data types like float64 cause the discrepancy, and questioning whether the pivot setting (SAMPLE vs BEAM) might be switching unexpectedly depending on custom vectors or distance settings. I’ll need to verify pivot logic in config or C code to explain this mismatch.
[2025-10-06T19:14:10] exec bash -lc 'rg "custom_fdet_vector" -n src/nanobrag_torch/config.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:11] bash -lc 'rg "custom_fdet_vector" -n src/nanobrag_torch/config.py' succeeded in 1.02s:
217:    custom_fdet_vector: Optional[Tuple[float, float, float]] = None  # Fast axis direction
[2025-10-06T19:14:11] tokens used: 159,778

[2025-10-06T19:14:17] thinking

**Checking __post_init__ method**
[2025-10-06T19:14:19] exec bash -lc "sed -n '320,420p' src/nanobrag_torch/config.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:20] bash -lc "sed -n '320,420p' src/nanobrag_torch/config.py" succeeded in 730ms:
            raise ValueError("Pixel counts must be positive")

        # Validate distance and pixel size
        if isinstance(self.distance_mm, (int, float)):
            if self.distance_mm <= 0:
                raise ValueError("Distance must be positive")

        if isinstance(self.pixel_size_mm, (int, float)):
            if self.pixel_size_mm <= 0:
                raise ValueError("Pixel size must be positive")

        # Validate oversample (-1 means auto-select)
        if self.oversample < -1 or self.oversample == 0:
            raise ValueError("Oversample must be -1 (auto-select) or >= 1")

        # Validate and set ROI defaults (AT-ROI-001)
        # If ROI not specified, default to full detector
        if self.roi_xmin is None:
            self.roi_xmin = 0
        if self.roi_xmax is None:
[2025-10-06T19:14:20] tokens used: 160,027

[2025-10-06T19:14:27] thinking

**Analyzing pivot type decision logic**
[2025-10-06T19:14:28] exec bash -lc 'rg "has_custom_vectors" -n src' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:29] bash -lc 'rg "has_custom_vectors" -n src' succeeded in 727ms:
src/nanobrag_torch/models/detector.py:535:            has_custom_vectors = any([
src/nanobrag_torch/models/detector.py:542:            if pix0_override_tensor is not None and not has_custom_vectors:
[2025-10-06T19:14:29] tokens used: 161,701

[2025-10-06T19:14:32] thinking

**Checking pivot usage in config**
[2025-10-06T19:14:33] exec bash -lc 'rg "detector_pivot" -n src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:33] bash -lc 'rg "detector_pivot" -n src/nanobrag_torch' succeeded in 712ms:
src/nanobrag_torch/__main__.py:492:    # C-code line 786: -twotheta sets detector_pivot = SAMPLE (even if twotheta=0)
src/nanobrag_torch/__main__.py:764:    print(f"  Pivot: {detector_config.detector_pivot.name}")
src/nanobrag_torch/__main__.py:873:            detector_pivot=DetectorPivot[config.get('pivot', 'BEAM')] if config.get('pivot') else None,
src/nanobrag_torch/__main__.py:893:        #   - `-Xbeam`/`-Ybeam` set detector_pivot = BEAM (line 632, 637)
src/nanobrag_torch/__main__.py:894:        #   - `-Xclose`/`-Yclose` set detector_pivot = SAMPLE (line 642, 647)
src/nanobrag_torch/models/detector.py.backup:297:        1. detector_pivot mode (BEAM vs SAMPLE)
src/nanobrag_torch/models/detector.py.backup:310:        if(detector_pivot == SAMPLE){
src/nanobrag_torch/models/detector.py.backup:324:        if(detector_pivot == BEAM){
src/nanobrag_torch/models/detector.py.backup:342:        if self.config.detector_pivot == DetectorPivot.BEAM:
src/nanobrag_torch/models/detector.py.backup:540:            if(detector_pivot == SAMPLE){
src/nanobrag_torch/models/detector.py.backup:562:            if(detector_pivot == BEAM){
src/nanobrag_torch/models/detector.py:335:        1. detector_pivot mode (BEAM vs SAMPLE)
src/nanobrag_torch/models/detector.py:359:        if(detector_pivot == SAMPLE){
src/nanobrag_torch/models/detector.py:373:        if(detector_pivot == BEAM){
src/nanobrag_torch/models/detector.py:484:        if self.config.detector_pivot == DetectorPivot.BEAM:
src/nanobrag_torch/models/detector.py:1118:            if(detector_pivot == SAMPLE){
src/nanobrag_torch/models/detector.py:1140:            if(detector_pivot == BEAM){
src/nanobrag_torch/config.py:53:    detector_pivot = BEAM;
src/nanobrag_torch/config.py:201:    detector_pivot: Optional[DetectorPivot] = None  # Will be auto-selected per AT-GEO-002
src/nanobrag_torch/config.py:242:        - If detector_pivot is explicitly set: use that (explicit override wins)
[2025-10-06T19:14:33] tokens used: 161,891

[2025-10-06T19:14:36] thinking

**Inspecting Detector geometry configuration**
[2025-10-06T19:14:37] exec bash -lc "sed -n '320,420p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:37] bash -lc "sed -n '320,420p' src/nanobrag_torch/models/detector.py" succeeded in 704ms:

        Returns:
            bool: True if CUSTOM convention should be used
        """
        return self.config.should_use_custom_convention()

    def _calculate_pix0_vector(self):
        """
        Calculate the position of the first pixel (0,0) in 3D space.

        This follows the C-code convention where pix0_vector represents the
        3D position of pixel (0,0), taking into account the beam center offset
        and detector positioning.

        The calculation depends on:
        1. detector_pivot mode (BEAM vs SAMPLE)
        2. detector convention (MOSFLM vs CUSTOM)
        3. r-factor distance correction (AT-GEO-003)

        CRITICAL: C code switches to CUSTOM convention when twotheta_axis is
[2025-10-06T19:14:37] tokens used: 163,450

[2025-10-06T19:14:42] thinking

**Verifying pivot type in PyTorch logs**
[2025-10-06T19:14:44] exec bash -lc 'rg "Pivot" reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:45] bash -lc 'rg "Pivot" reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.log' exited 1 in 721ms:

[2025-10-06T19:14:45] tokens used: 165,086

[2025-10-06T19:14:51] thinking

**Investigating pivot discovery options**
[2025-10-06T19:14:51] exec bash -lc 'ls reports/2025-10-cli-flags/phase_h6' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:53] bash -lc 'ls reports/2025-10-cli-flags/phase_h6' succeeded in 1.40s:
analysis.md
c_trace
py_trace
trace_diff.txt
[2025-10-06T19:14:53] tokens used: 165,484

[2025-10-06T19:14:55] thinking

**Checking contents of py_trace**
[2025-10-06T19:14:56] exec bash -lc 'ls reports/2025-10-cli-flags/phase_h6/py_trace' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:14:57] bash -lc 'ls reports/2025-10-cli-flags/phase_h6/py_trace' succeeded in 859ms:
env_snapshot.txt
git_context.txt
trace_py_pix0.log
trace_py_pix0.stderr
[2025-10-06T19:14:57] tokens used: 165,744

[2025-10-06T19:15:01] thinking

**Opening error log for clues**
[2025-10-06T19:15:02] exec bash -lc 'cat reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.stderr' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:15:03] bash -lc 'cat reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.stderr' succeeded in 812ms:
# Tracing pixel (slow=1039, fast=685)
# Trace complete
[2025-10-06T19:15:03] tokens used: 165,991

[2025-10-06T19:15:08] thinking

**Inspecting detector pivot via code snippet**
[2025-10-06T19:15:12] exec bash -lc "python - <<'PY'
from nanobrag_torch.config import DetectorConfig, DetectorConvention

config = DetectorConfig(
    spixels=2463,
    fpixels=2527,
    pixel_size_mm=0.172,
    distance_mm=231.274660,
    detector_convention=DetectorConvention.CUSTOM,
    beam_center_s=213.907080,
    beam_center_f=217.742295,
    pix0_override_m=(-216.336293/1000, 215.205512/1000, -230.200866/1000),
    custom_fdet_vector=(0.999982, -0.005998, -0.000118),
    custom_sdet_vector=(-0.005998, -0.999970, -0.004913),
    custom_odet_vector=(-0.000088, 0.004914, -0.999988),
    custom_beam_vector=(0.00051387949, 0.0, -0.99999986),
)
print(config.detector_pivot)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:15:13] bash -lc "python - <<'PY'
from nanobrag_torch.config import DetectorConfig, DetectorConvention

config = DetectorConfig(
    spixels=2463,
    fpixels=2527,
    pixel_size_mm=0.172,
    distance_mm=231.274660,
    detector_convention=DetectorConvention.CUSTOM,
    beam_center_s=213.907080,
    beam_center_f=217.742295,
    pix0_override_m=(-216.336293/1000, 215.205512/1000, -230.200866/1000),
    custom_fdet_vector=(0.999982, -0.005998, -0.000118),
    custom_sdet_vector=(-0.005998, -0.999970, -0.004913),
    custom_odet_vector=(-0.000088, 0.004914, -0.999988),
    custom_beam_vector=(0.00051387949, 0.0, -0.99999986),
)
print(config.detector_pivot)
PY" succeeded in 1.70s:
DetectorPivot.BEAM
[2025-10-06T19:15:13] tokens used: 166,450

[2025-10-06T19:15:23] thinking

**Identifying pivot selection mismatch and planning fix**

I’m seeing that PyTorch uses the BEAM pivot while C uses SAMPLE when custom vectors are provided, which explains discrepancies in pix0. To resolve this, I need to update the plan to fix pivot selection—adding tasks to confirm the mismatch, implement pivot override to SAMPLE for custom vectors, and adjust tests accordingly. I’ll also gather relevant documentation to support the fix and update the phased plan with clear task definitions and references.
[2025-10-06T19:15:25] exec bash -lc 'cat specs/spec-a-cli.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:15:26] bash -lc 'cat specs/spec-a-cli.md' succeeded in 926ms:
# nanoBragg Spec A — CLI Binding

This shard documents the command-line interface, header precedence, and CLI-focused acceptance tests. It should be read alongside [spec-a-core.md](spec-a-core.md) for the simulation engine requirements and [spec-a-parallel.md](spec-a-parallel.md) for conformance profiles.

CLI Interface (Normative)

All options recognized by this code version are enumerated below. Values with units are converted
immediately as specified in Units & Conversions. Unsupported flags are not recognized even if
present in header comments.

- Input files:
    - -hkl <file>: Text file of “h k l F” (integers h,k,l; real F). Required unless Fdump.bin exists
or -default_F used.
    - -mat <file>: 3×3 MOSFLM-style A matrix (reciprocal cell vectors scaled by 1/λ). Required
unless -cell used.
    - -cell a b c alpha beta gamma: Direct cell in Å and degrees; alternative to -mat.
    - -img <file>: Read SMV header; may set fpixels, spixels, pixel size (mm), distance (mm), close
distance (mm), wavelength (Å), beam centers (mm), ORGX/ORGY (pixels), φ start (deg), oscillation
range (deg), 2θ (deg). Image data is read but not used.
    - -mask <file>: Read SMV mask; uses same headers to initialize geometry as -img. Zero-valued
[2025-10-06T19:15:26] tokens used: 167,491

[2025-10-06T19:15:31] thinking

**Verifying pivot behavior with custom vectors**
[2025-10-06T19:15:32] exec bash -lc 'rg "custom" docs/architecture/undocumented_conventions.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:15:32] bash -lc 'rg "custom" docs/architecture/undocumented_conventions.md' exited 1 in 740ms:

[2025-10-06T19:15:32] tokens used: 170,613

[2025-10-06T19:15:34] thinking

**Considering reviewing documentation**
[2025-10-06T19:15:35] exec bash -lc 'cat docs/architecture/detector.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:15:35] bash -lc 'cat docs/architecture/detector.md' succeeded in 704ms:
# Detector Architecture Deep Dive

**Status:** Authoritative Specification  
**Last Updated:** Phase 5 Implementation

**⚠️ CRITICAL:** This component uses a [hybrid unit system](#61-critical-hybrid-unit-system-overrides-global-rule) that overrides the global Angstrom-only rule.

This document provides the complete technical specification for the Detector component. For global project rules on units and coordinate systems, see [Global Conventions](./conventions.md).

---

## 1. Overview

The Detector class manages the detector geometry for diffraction simulations, including:
- Position and orientation (basis vectors)
- Pixel coordinate generation and caching
- Support for various detector conventions (MOSFLM, XDS)
- Dynamic geometry with rotations and tilts
- Full differentiability for optimization workflows

[2025-10-06T19:15:35] tokens used: 171,404

[2025-10-06T19:15:41] thinking

**Planning pivot rule updates**
[2025-10-06T19:15:42] exec bash -lc 'rg "Attempt #38" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:15:43] bash -lc 'rg "Attempt #38" -n docs/fix_plan.md' succeeded in 811ms:
573:  * [2025-10-26] Attempt #38 (ralph) — Result: **EVIDENCE COMPLETE** (Phase H6c trace diff analysis). **First divergence identified: beam_center_m unit mismatch (mm vs m in trace logging).**
[2025-10-06T19:15:43] tokens used: 174,031

[2025-10-06T19:15:45] thinking

**Checking context in entry**
[2025-10-06T19:15:46] exec bash -lc "sed -n '560,620p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:15:47] bash -lc "sed -n '560,620p' docs/fix_plan.md" succeeded in 701ms:
      - `reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.stderr` - Stderr confirming pixel (1039, 685) trace completed
      - `reports/2025-10-cli-flags/phase_h6/py_trace/env_snapshot.txt` - Environment variables snapshot (55 lines)
      - `reports/2025-10-cli-flags/phase_h6/py_trace/git_context.txt` - Git commit reference (cb5daae)
      - `reports/2025-10-cli-flags/phase_h/trace_harness.py:30-122` - Patched Detector.__init__ to emit TRACE_PY lines post-geometry-setup
    Observations/Hypotheses:
      - **PyTorch pix0:** (-0.216337, 0.215207, -0.230198) meters
      - **C pix0 (reference):** (-0.216476, 0.216343, -0.230192) meters
      - **Deltas:** ΔX = +139 µm, ΔY = -1136 µm, ΔZ = -6 µm
      - **Large ΔS persists:** 1.1 mm slow-axis error remains after Phase H5e unit fix, indicating deeper divergence in pix0 calculation
      - **Instrumentation complete:** Captured detector_convention, angles (radians), beam_center_m (Xclose/Yclose), initial basis vectors, Fclose/Sclose, close_distance, ratio, distance, term_fast/slow/close_before_rot, pix0 (before/after rotations), final basis vectors, twotheta_axis
      - **Harness improvements:** Removed hard-coded DetectorPivot.BEAM (line 114) to allow natural SAMPLE pivot selection; patched Detector.__init__ instead of non-existent _configure_geometry method; added term_* emission for all CUSTOM cases with custom vectors (not pivot-gated)
      - **Editable install confirmed:** PYTHONPATH=src used throughout (per Phase H6b guardrails); trace reflects current detector.py implementation
    Next Actions: **Phase H6c required** — Diff C vs PyTorch traces line-by-line (use `diff -u reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0_clean.log reports/2025-10-cli-flags/phase_h6/py_trace/trace_py_pix0.log | grep '^[-+]' | head -50`), identify first divergence in term_* or intermediate calculations, document in `reports/2025-10-cli-flags/phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with findings, and propose corrective action (missing MOSFLM offset? beam_vector scaling? Fclose/Sclose calculation difference?).
  * [2025-10-26] Attempt #38 (ralph) — Result: **EVIDENCE COMPLETE** (Phase H6c trace diff analysis). **First divergence identified: beam_center_m unit mismatch (mm vs m in trace logging).**
    Metrics: Evidence-only loop. Wall-clock ~1s. Diff generated between C and PyTorch traces. First divergence at beam_center_m: C logs Xclose/Yclose in meters (0.000211818, 0.000217322), PyTorch logs in mm (0.217742295, 0.21390708). Fclose/Sclose match exactly (0.217742295, 0.21390708 m), confirming calculation uses correct units internally.
    Artifacts:
      - `reports/2025-10-cli-flags/phase_h6/trace_diff.txt` - Full unified diff output (73 lines)
      - `reports/2025-10-cli-flags/phase_h6/analysis.md` - Detailed divergence analysis with numeric tables
      - `reports/2025-10-cli-flags/phase_h5/parity_summary.md` - Updated with H6c findings and metrics table
    Observations/Hypotheses:
[2025-10-06T19:15:47] tokens used: 174,276

[2025-10-06T19:16:16] thinking

**Updating plan tasks and documentation**

I’m revising the fix_plan and related docs to reflect new findings about the pivot mismatch. This involves marking H6c done, adding new detailed tasks H6e to H6g for confirming pivot parity, updating detector config logic, and re-running traces. I’ll carefully insert these into the plan table, keeping H5 tasks separate but aligned, and then update the Next Actions section accordingly. Finally, I’ll prepare the precise patch text for `plans/active/cli-noise-pix0/plan.md`.
[2025-10-06T19:16:36] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -138,4 +138,7 @@
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
[2025-10-06T19:16:36] apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T19:16:36] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 

[2025-10-06T19:16:36] tokens used: 179,786
[2025-10-06T19:16:36] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:16:45] thinking

**Preparing to update task list in documentation**
[2025-10-06T19:16:53] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -457,8 +457,9 @@
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
[2025-10-06T19:16:53] apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T19:16:53] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 

[2025-10-06T19:16:53] tokens used: 183,863
[2025-10-06T19:16:53] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:17:11] thinking

**Coordinating task numbering and input preparation**

I’m making sure the numbering between steps 1 to 6 stays consistent while planning to write `input.md` properly formatted. Before that, I want to confirm the analysis from Step 1 is ready, especially summarizing that pivot mismatch is the root cause, as well as formulating debugging hypotheses. I also need to gather details like the summary goal, phase, focus based on the active plan, and current Git branch to complete the `input.md` content aligned with the instructions.
[2025-10-06T19:17:13] exec bash -lc 'git rev-parse --abbrev-ref HEAD' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:17:14] bash -lc 'git rev-parse --abbrev-ref HEAD' succeeded in 917ms:
feature/spec-based-2
[2025-10-06T19:17:14] tokens used: 185,363
[2025-10-06T19:17:14] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:17:27] thinking

**Outlining evidence-phase instructions**

I’m organizing the plan for the evidence phase on branch feature/spec-based-2. I’ll specify the Do Now step with exact commands to print and record pivot parity without running tests, draft artifact paths, fallback if blocked, and gather file references with approximate line numbers to guide the user clearly through relevant documentation and pitfalls.
[2025-10-06T19:17:28] exec bash -lc "nl -ba specs/spec-a-cli.md | sed -n '70,130p'" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:17:29] bash -lc "nl -ba specs/spec-a-cli.md | sed -n '70,130p'" succeeded in 853ms:
    70	    - -dispsteps <int>: Number of wavelength steps across the dispersion range.
    71	    - -divergence <mrad>: Sets both horizontal and vertical angular ranges (radians internally).
    72	    - -hdivrange <mrad>, -vdivrange <mrad>: Angular ranges (radians internally).
    73	    - -hdivstep <mrad>, -vdivstep <mrad>: Angular step sizes (radians internally).
    74	    - -hdivsteps <int>, -vdivsteps <int>, -divsteps <int>: Step counts for divergence (if only
    75	-divsteps is given, it sets both).
    76	- Polarization:
    77	    - -polar <value>: Kahn polarization factor (dimensionless). Default printed value “polarization”
    78	is used.
    79	    - -nopolar: Disable polarization correction (factor forced to 1).
    80	- Crystal size/shape and mosaicity:
    81	    - -Na <int>, -Nb <int>, -Nc <int>, -N <int>: Number of unit cells along a,b,c. Any values ≤1 are
    82	clamped to 1 later (zero is not preserved).
    83	    - -samplesize <mm> or -xtalsize <mm>: Set crystal full widths in x=y=z (mm); alternative:
    84	-sample_thick|_x, -sample_width|_y|-width, -sample_height|_z|-height, and -xtal_thick|_x,
    85	-xtal_width|_y|-width, -xtal_height|_z|-height for each dimension.
    86	    - -square_xtal (default), -round_xtal, -gauss_xtal, -binary_spots/-tophat_spots: Spot shapes.
    87	See “Lattice factors”.
    88	    - -fudge <value>: Shape parameter scaling (dimensionless).
    89	    - -mosaic, -mosaici, or -mosaic_spr <deg>: Isotropic mosaic spread (degrees).
[2025-10-06T19:17:29] tokens used: 186,365
[2025-10-06T19:17:29] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:17:31] thinking

**Searching for pivot precedence line numbers**
[2025-10-06T19:17:32] exec bash -lc "nl -ba specs/spec-a-cli.md | sed -n '130,200p'" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:17:33] bash -lc "nl -ba specs/spec-a-cli.md | sed -n '130,200p'" succeeded in 714ms:
   130	
   131	Unsupported flags in examples:
   132	
   133	- -dispstep (example shows this; not recognized). The supported control is -dispsteps (count).
   134	- -hdiv and -vdiv (examples show these; not recognized). Supported are -hdivrange and -vdivrange.
   135	
   136	Precedence and overrides (Normative)
   137	
   138	- If both -img and -mask headers are read, the last one read wins for shared header-initialized
   139	quantities.
   140	- Setting beam/detector conventions sets both the basis vectors and the default pivot. Explicit
   141	-pivot overrides this.
   142	- -Xbeam/-Ybeam force pivot to BEAM; -Xclose/-Yclose and -ORGX/-ORGY force pivot to SAMPLE.
   143	- Custom basis vectors or -pix0_vector set convention to CUSTOM and use provided vectors where
   144	specified.
   145	- If both -flux/-exposure/-beamsize and -fluence are provided, fluence is recomputed to be
   146	consistent with flux/exposure/beamsize whenever flux != 0 and exposure > 0 and beamsize ≥ 0;
   147	exposure > 0 also recomputes flux to be consistent with the chosen fluence and beamsize.
   148	- -N and -Na/-Nb/-Nc are clamped later to ≥1 (zero-valued sizes are not preserved, contrary to
   149	header comments).
[2025-10-06T19:17:33] tokens used: 187,974
[2025-10-06T19:17:33] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:17:36] thinking

**Checking line numbers in detector.md**
[2025-10-06T19:17:38] exec bash -lc "nl -ba docs/architecture/detector.md | sed -n '120,220p'" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:17:39] bash -lc "nl -ba docs/architecture/detector.md | sed -n '120,220p'" succeeded in 715ms:
   120	3. When in doubt, generate a trace with both modes and compare pixel positions
   121	
   122	### 8.2 Beam Center Calculation
   123	
   124	**CRITICAL:** Beam center values are physical distances in mm, NOT pixel coordinates:
   125	
   126	```python
   127	# For a 512×512 detector with 0.1mm pixels:
   128	# Center pixel: (256, 256)
   129	# Physical center: 256 × 0.1mm = 25.6mm
   130	config = DetectorConfig(
   131	    spixels=512,
   132	    fpixels=512,
   133	    pixel_size_mm=0.1,
   134	    beam_center_s=25.6,  # mm from detector edge
   135	    beam_center_f=25.6   # mm from detector edge
   136	)
   137	
   138	# For a 1024×1024 detector with 0.1mm pixels:
   139	# Center pixel: (512, 512)
[2025-10-06T19:17:39] tokens used: 190,662
[2025-10-06T19:17:39] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:17:41] thinking

**Retrieving earlier pivot discussion**
[2025-10-06T19:17:42] exec bash -lc "nl -ba docs/architecture/detector.md | sed -n '80,140p'" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:17:43] bash -lc "nl -ba docs/architecture/detector.md | sed -n '80,140p'" succeeded in 705ms:
    80	self._cached_basis_vectors  # For change detection
    81	```
    82	
    83	### 7.2 Cache Invalidation
    84	The cache is invalidated when:
    85	- Basis vectors change (detected via tensor comparison)
    86	- `pix0_vector` changes
    87	- Device or dtype changes
    88	
    89	## 8. Differentiability
    90	
    91	### 8.1 Differentiable Parameters
    92	All geometric parameters support gradient computation:
    93	- `distance_mm`
    94	- `beam_center_s`, `beam_center_f`
    95	- `detector_rotx_deg`, `detector_roty_deg`, `detector_rotz_deg`
    96	- `detector_twotheta_deg`
    97	
    98	### 8.2 Gradient Flow
    99	```
[2025-10-06T19:17:43] tokens used: 192,197
[2025-10-06T19:17:43] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:17:46] thinking

**Preparing to reference plan file lines**
[2025-10-06T19:17:47] exec bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '120,220p'" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:17:48] bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '120,220p'" succeeded in 716ms:
   120	Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14 mm delta driving the `F_latt` mismatch.
   121	Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
   122	Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
   123	
   124	| ID | Task Description | State | How/Why & Guidance |
   125	| --- | --- | --- | --- |
   126	| H5a | Verify C precedence with explicit derivation | [D] | ✅ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
   127	| H5b | Revert PyTorch override when custom vectors supplied | [D] | ✅ 2025-10-22 Attempt #31 (commit 831b670). `Detector._calculate_pix0_vector` now gates pix0 overrides behind a `has_custom_vectors` check; regression log captured in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`. Comments cite `c_precedence_2025-10-22.md`. |
   128	| H5c | Capture updated PyTorch traces & compare | [P] | ✅ Attempt #35 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/trace_py.stdout` and refreshed `parity_summary.md`, but deltas remain large (ΔF = −1136 µm, ΔS = +139 µm). Keep this row in progress until follow-up Phase H6 diagnostics shrink |Δpix0| below the 5e-5 m threshold. |
   129	
   130	### Phase H6 — Pix0 Divergence Isolation
   131	Goal: Instrument both implementations to pinpoint the exact step in `_calculate_pix0_vector()` where the PyTorch BEAM-pivot math diverges from nanoBragg.c when custom detector vectors are present.
   132	Prereqs: Phase H5 artifacts archived (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-24/`), C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`, familiarity with `docs/architecture/detector.md` §5 and specs/spec-a-cli.md precedence rules.
   133	Exit Criteria: New traces under `reports/2025-10-cli-flags/phase_h6/` showing matched step-by-step values, the first divergence documented in `parity_summary.md`, and docs/fix_plan Attempt #36 logging the diagnosis with remediation guidance.
   134	
   135	| ID | Task Description | State | How/Why & Guidance |
   136	| --- | --- | --- | --- |
   137	| H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
   138	| H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
   139	| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
[2025-10-06T19:17:48] tokens used: 193,358
[2025-10-06T19:17:48] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:03] thinking

**Preparing detailed input.md draft**

I'm gathering all necessary commands, references, and instructions to create a comprehensive `input.md` file. This includes documenting how to run the Python snippet to confirm pivot parity, directions to capture relevant C trace messages, and clear steps for synthesizing all results into the appropriate report. I'll also incorporate priorities, pitfalls to avoid, useful pointers to documentation, and possibly next steps to ensure everything is thorough and actionable.
[2025-10-06T19:18:13] exec bash -lc "cat <<'EOF' > input.md
Summary: Capture concrete evidence that PyTorch still selects BEAM pivot while C runs the supervisor case in SAMPLE.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase H6e — pivot parity proof
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_h6/pivot_parity.md
Do Now: CLI-FLAGS-003 H6e — Confirm pivot parity; run "'`PYTHONPATH=src python - <<'"'PY'\\nfrom nanobrag_torch.config import DetectorConfig, DetectorConvention\\nconfig = DetectorConfig(spixels=2463, fpixels=2527, pixel_size_mm=0.172, distance_mm=231.274660, detector_convention=DetectorConvention.CUSTOM, beam_center_s=213.907080, beam_center_f=217.742295, pix0_override_m=(-216.336293/1000, 215.205512/1000, -230.200866/1000), custom_fdet_vector=(0.999982, -0.005998, -0.000118), custom_sdet_vector=(-0.005998, -0.999970, -0.004913), custom_odet_vector=(-0.000088, 0.004914, -0.999988), custom_beam_vector=(0.00051387949, 0.0, -0.99999986))\\nprint(config.detector_pivot)\\nPY"'` and summarise alongside the C trace message in the artifact.
If Blocked: Record pivot evidence attempt (command + stderr) in reports/2025-10-cli-flags/phase_h6/attempts.log and flag in Attempts History before proceeding.
Priorities & Rationale:
- specs/spec-a-cli.md:136 — custom vectors force CUSTOM convention; document how C treats pivot.
- docs/architecture/detector.md:109 — pivot determination checklist to cite in parity memo.
- plans/active/cli-noise-pix0/plan.md:130 — Phase H6e freshly added; this memo executes that row.
- docs/fix_plan.md:448 — Next Actions now require pivot proof before implementation.
How-To Map:
- Extract C evidence: `grep -n "pivoting" reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log >> reports/2025-10-cli-flags/phase_h6/pivot_parity.md`.
- Run the inline Python snippet above (use PYTHONPATH=src) and append output with context to the same markdown.
- In the artifact, note that SAMPLE pivot message appears in C while the Python snippet reports DetectorPivot.BEAM.
Pitfalls To Avoid:
- Do not modify source files yet; this loop is evidence-only.
- Keep PYTHONPATH pointing at src so the editable build is used.
- Avoid running pytest or nb-compare in Evidence phase.
- Preserve existing trace logs; add new files instead of overwriting.
- Document units (mm vs m) explicitly in the memo.
- Capture command invocations verbatim for reproducibility.
- Respect Protected Assets (docs/index.md, loop.sh, input.md).
Pointers:
- specs/spec-a-cli.md:136
- docs/architecture/detector.md:109
- plans/active/cli-noise-pix0/plan.md:130
- docs/fix_plan.md:448
Next Up: Phase H6f — adjust DetectorConfig pivot logic and add regression test once pivot parity evidence lands.
EOF
' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:13] bash -lc "cat <<'EOF' > input.md
Summary: Capture concrete evidence that PyTorch still selects BEAM pivot while C runs the supervisor case in SAMPLE.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase H6e — pivot parity proof
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_h6/pivot_parity.md
Do Now: CLI-FLAGS-003 H6e — Confirm pivot parity; run "'`PYTHONPATH=src python - <<'"'PY'\\nfrom nanobrag_torch.config import DetectorConfig, DetectorConvention\\nconfig = DetectorConfig(spixels=2463, fpixels=2527, pixel_size_mm=0.172, distance_mm=231.274660, detector_convention=DetectorConvention.CUSTOM, beam_center_s=213.907080, beam_center_f=217.742295, pix0_override_m=(-216.336293/1000, 215.205512/1000, -230.200866/1000), custom_fdet_vector=(0.999982, -0.005998, -0.000118), custom_sdet_vector=(-0.005998, -0.999970, -0.004913), custom_odet_vector=(-0.000088, 0.004914, -0.999988), custom_beam_vector=(0.00051387949, 0.0, -0.99999986))\\nprint(config.detector_pivot)\\nPY"'` and summarise alongside the C trace message in the artifact.
If Blocked: Record pivot evidence attempt (command + stderr) in reports/2025-10-cli-flags/phase_h6/attempts.log and flag in Attempts History before proceeding.
Priorities & Rationale:
- specs/spec-a-cli.md:136 — custom vectors force CUSTOM convention; document how C treats pivot.
- docs/architecture/detector.md:109 — pivot determination checklist to cite in parity memo.
- plans/active/cli-noise-pix0/plan.md:130 — Phase H6e freshly added; this memo executes that row.
- docs/fix_plan.md:448 — Next Actions now require pivot proof before implementation.
How-To Map:
- Extract C evidence: `grep -n "pivoting" reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log >> reports/2025-10-cli-flags/phase_h6/pivot_parity.md`.
- Run the inline Python snippet above (use PYTHONPATH=src) and append output with context to the same markdown.
- In the artifact, note that SAMPLE pivot message appears in C while the Python snippet reports DetectorPivot.BEAM.
Pitfalls To Avoid:
- Do not modify source files yet; this loop is evidence-only.
- Keep PYTHONPATH pointing at src so the editable build is used.
- Avoid running pytest or nb-compare in Evidence phase.
- Preserve existing trace logs; add new files instead of overwriting.
- Document units (mm vs m) explicitly in the memo.
- Capture command invocations verbatim for reproducibility.
- Respect Protected Assets (docs/index.md, loop.sh, input.md).
Pointers:
- specs/spec-a-cli.md:136
- docs/architecture/detector.md:109
- plans/active/cli-noise-pix0/plan.md:130
- docs/fix_plan.md:448
Next Up: Phase H6f — adjust DetectorConfig pivot logic and add regression test once pivot parity evidence lands.
EOF
' succeeded in 860ms:

[2025-10-06T19:18:13] tokens used: 196,654
[2025-10-06T19:18:13] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:17] thinking

**Ensuring proper command formatting**
[2025-10-06T19:18:18] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:18] bash -lc 'git status --short' succeeded in 760ms:
 M docs/fix_plan.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T19:18:18] tokens used: 197,889
[2025-10-06T19:18:18] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:21] thinking

**Staging and reviewing changes**
[2025-10-06T19:18:22] exec bash -lc 'git diff' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:22] bash -lc 'git diff' succeeded in 733ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05c..ce80501 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
[2025-10-06T19:18:22] tokens used: 198,111
[2025-10-06T19:18:22] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:26] thinking

**Verifying complete file modifications**
[2025-10-06T19:18:27] exec bash -lc 'cat input.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:28] bash -lc 'cat input.md' succeeded in 713ms:
Summary: Capture concrete evidence that PyTorch still selects BEAM pivot while C runs the supervisor case in SAMPLE.
Phase: Evidence
Focus: CLI-FLAGS-003 Phase H6e — pivot parity proof
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_h6/pivot_parity.md
Do Now: CLI-FLAGS-003 H6e — Confirm pivot parity; run `PYTHONPATH=src python - <<'PY'\nfrom nanobrag_torch.config import DetectorConfig, DetectorConvention\nconfig = DetectorConfig(spixels=2463, fpixels=2527, pixel_size_mm=0.172, distance_mm=231.274660, detector_convention=DetectorConvention.CUSTOM, beam_center_s=213.907080, beam_center_f=217.742295, pix0_override_m=(-216.336293/1000, 215.205512/1000, -230.200866/1000), custom_fdet_vector=(0.999982, -0.005998, -0.000118), custom_sdet_vector=(-0.005998, -0.999970, -0.004913), custom_odet_vector=(-0.000088, 0.004914, -0.999988), custom_beam_vector=(0.00051387949, 0.0, -0.99999986))\nprint(config.detector_pivot)\nPY` and summarise alongside the C trace message in the artifact.
If Blocked: Record pivot evidence attempt (command + stderr) in reports/2025-10-cli-flags/phase_h6/attempts.log and flag in Attempts History before proceeding.
Priorities & Rationale:
- specs/spec-a-cli.md:136 — custom vectors force CUSTOM convention; document how C treats pivot.
- docs/architecture/detector.md:109 — pivot determination checklist to cite in parity memo.
- plans/active/cli-noise-pix0/plan.md:130 — Phase H6e freshly added; this memo executes that row.
- docs/fix_plan.md:448 — Next Actions now require pivot proof before implementation.
How-To Map:
- Extract C evidence: `grep -n "pivoting" reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log >> reports/2025-10-cli-flags/phase_h6/pivot_parity.md`.
- Run the inline Python snippet above (use PYTHONPATH=src) and append output with context to the same markdown.
- In the artifact, note that SAMPLE pivot message appears in C while the Python snippet reports DetectorPivot.BEAM.
Pitfalls To Avoid:
- Do not modify source files yet; this loop is evidence-only.
- Keep PYTHONPATH pointing at src so the editable build is used.
[2025-10-06T19:18:28] tokens used: 201,209
[2025-10-06T19:18:28] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:36] thinking

**Preparing to stage and commit changes**
[2025-10-06T19:18:37] exec bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:38] bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md' succeeded in 893ms:

[2025-10-06T19:18:38] tokens used: 202,456
[2025-10-06T19:18:38] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:41] thinking

**Preparing commit message**
[2025-10-06T19:18:41] exec bash -lc 'git commit -m "SUPERVISOR: CLI pivot parity guidance - tests: not run"' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:42] bash -lc 'git commit -m "SUPERVISOR: CLI pivot parity guidance - tests: not run"' succeeded in 709ms:
[feature/spec-based-2 7cfe02c] SUPERVISOR: CLI pivot parity guidance - tests: not run
 3 files changed, 36 insertions(+), 106 deletions(-)
[2025-10-06T19:18:42] tokens used: 202,639
[2025-10-06T19:18:42] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:44] thinking

**Pushing changes to remote**
[2025-10-06T19:18:45] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:47] bash -lc 'git push' succeeded in 2.09s:
To github.com:hoidn/nanoBragg.git
   3c346ce..7cfe02c  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T19:18:47] tokens used: 203,102
[2025-10-06T19:18:47] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:18:52] thinking

**Appending update to galph_memory.md**
[2025-10-06T19:18:56] exec bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-26 (galph loop — H6e pivot evidence setup)
- "'`git pull --rebase` clean; reviewed Phase H6 artifacts plus docs/index/spec/arch/config map per SOP.
- Deep dive on pix0 traces shows C runs supervisor command in SAMPLE pivot while PyTorch config still defaults to BEAM when custom detector vectors are provided; this aligns with Attempt #38 residual deltas.
- Updated `plans/active/cli-noise-pix0/plan.md` Phase H6 to mark H6c done and add new rows H6e–H6g covering pivot evidence, config fix, and post-fix trace reruns.
- Refreshed `docs/fix_plan.md` Next Actions to require H6e pivot proof, H6f pivot logic change + regression test, then H6g trace rerun before resuming Phase K work.
- Issued new Evidence-phase memo (`input.md`) directing Ralph to capture pivot parity evidence and log it under `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` (no code edits yet).
- Next follow-up for Ralph: execute H6e (document pivot mismatch), update parity_summary + fix_plan Attempt log, then proceed to H6f implementation in a subsequent loop.
EOF
' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:18:57] bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-26 (galph loop — H6e pivot evidence setup)
- "'`git pull --rebase` clean; reviewed Phase H6 artifacts plus docs/index/spec/arch/config map per SOP.
- Deep dive on pix0 traces shows C runs supervisor command in SAMPLE pivot while PyTorch config still defaults to BEAM when custom detector vectors are provided; this aligns with Attempt #38 residual deltas.
- Updated `plans/active/cli-noise-pix0/plan.md` Phase H6 to mark H6c done and add new rows H6e–H6g covering pivot evidence, config fix, and post-fix trace reruns.
- Refreshed `docs/fix_plan.md` Next Actions to require H6e pivot proof, H6f pivot logic change + regression test, then H6g trace rerun before resuming Phase K work.
- Issued new Evidence-phase memo (`input.md`) directing Ralph to capture pivot parity evidence and log it under `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` (no code edits yet).
- Next follow-up for Ralph: execute H6e (document pivot mismatch), update parity_summary + fix_plan Attempt log, then proceed to H6f implementation in a subsequent loop.
EOF
' succeeded in 750ms:

[2025-10-06T19:18:57] tokens used: 204,088
[2025-10-06T19:18:57] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:19:02] thinking

**Deciding on committing new changes**
[2025-10-06T19:19:03] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:19:04] bash -lc 'git status --short' succeeded in 746ms:
 M galph_memory.md
[2025-10-06T19:19:04] tokens used: 205,207
[2025-10-06T19:19:04] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:19:08] thinking

**Staging and committing changes**
[2025-10-06T19:19:09] exec bash -lc 'git add galph_memory.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:19:09] bash -lc 'git add galph_memory.md' succeeded in 695ms:

[2025-10-06T19:19:09] tokens used: 205,437
[2025-10-06T19:19:09] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:19:13] thinking

**Committing with descriptive message**
[2025-10-06T19:19:16] exec bash -lc 'git commit -m "SUPERVISOR: log update - tests: not run"' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:19:16] bash -lc 'git commit -m "SUPERVISOR: log update - tests: not run"' succeeded in 742ms:
[feature/spec-based-2 8b9de95] SUPERVISOR: log update - tests: not run
 1 file changed, 8 insertions(+)
[2025-10-06T19:19:16] tokens used: 205,628
[2025-10-06T19:19:16] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:19:18] thinking

**Pushing changes to remote**
[2025-10-06T19:19:19] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T19:19:21] bash -lc 'git push' succeeded in 2.21s:
To github.com:hoidn/nanoBragg.git
   7cfe02c..8b9de95  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T19:19:21] tokens used: 205,815
[2025-10-06T19:19:21] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 


[2025-10-06T19:19:36] thinking

**Summarizing final response plan**

I'll summarize key tasks and step requirements, covering pivot mismatch analysis, debugging hypotheses with confidence levels, coin flip review of recent commits, vectorization plan status, and canonical next steps for Ralph—with clear file references and a minimal bullet format.
[2025-10-06T19:19:36] codex

**CLI Pivot Findings**  
- Added Phase H6e–H6g to the CLI parity plan so we now track pivot evidence, config fix, and post-fix trace reruns before resuming normalization (`plans/active/cli-noise-pix0/plan.md:135`).  
- Refreshed the CLI-FLAGS-003 Next Actions to mandate SAMPLE-vs-BEAM pivot proof, the DetectorConfig change, and the follow-on trace validation prior to Phase K work (`docs/fix_plan.md:455`).  
- Reissued the evidence-phase memo guiding Ralph to capture the pivot mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` (see `input.md`).  
- Vectorization plan already meets SOP expectations; no updates required today.

**Debugging Hypotheses (ranked)**  
1. PyTorch still forces `detector_pivot=BEAM` when custom detector vectors are supplied, while nanoBragg switches to SAMPLE, producing the 1.1 mm pix0 delta (confidence: high; shown by the C trace message and live DetectorConfig output). Confirming step: run the inline DetectorConfig snippet and log the result alongside the C trace message (now assigned as H6e).  
2. Residual unit mismatches in trace logging might mislead analysis even though calculations are correct (confidence: medium; Attempt #38 shows logging-only divergence). Confirming step: keep units explicit in the pivot parity memo to avoid misinterpretation.  
3. If pivot logic is fixed, remaining pix0 error could stem from stale regen of cached geometry (confidence: low). Confirming step: after H6f/H6g, invalidate detector caches and rerun traces if deltas persist.

**Ralph Retrospective (coin flip = heads)**  
- Reviewed commits through 5d0a34d; work stayed in evidence-only mode (analysis.md, parity_summary.md) and kept the tree clean. Momentum is good—just need the pivot proof queued in H6e.

**Next Actions for Ralph**  
- Follow `input.md` and execute Phase H6e: document SAMPLE-vs-BEAM pivot behavior, append the findings to `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, and update parity_summary + fix_plan attempts before moving on.

Tests: not run (evidence + planning only).
[2025-10-06T19:19:44] tokens used: 206,899
[2025-10-06T19:19:44] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 69af05cb9d36246cbb0a3a2fc48f3405ef30f498..ce805011a2f2ea0921df19f8fa821fbc29553c7b
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,12 +455,13 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-24 refresh): With H5a/H5b/H5e complete and K1 landed, focus on isolating the pix0 mismatch before returning to normalization work:
-  1. Phase H6c — diff the new TRACE_C/TRACE_PY logs under `reports/2025-10-cli-flags/phase_h6/`, identify the first mismatched quantity (with units), and document it in `phase_h6/analysis.md` plus `phase_h5/parity_summary.md`. Updated harness already satisfies the editable-import and SAMPLE-pivot guardrails (Attempt #37); focus on isolating the delta before code changes.
-  2. After H6c findings land, implement the targeted pix0 fix, rerun the trace harness to bring |Δpix0| below 5e-5 m, and close out Phase H5c with updated metrics.
-  3. Once pix0 parity is confirmed, resume Phase K2 — regenerate the scaling chain using the updated PyTorch trace (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md` to confirm the SQUARE lattice factor matches C.
-  4. Phase K3 — when H5c/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
-  5. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
+- Next Actions (2025-10-26 refresh): With H6c completed and the unit-only divergence documented, focus on correcting the pivot mismatch before resuming normalization work:
+  1. Phase H6e — capture explicit pivot evidence: cite the SAMPLE pivot message in `trace_c_pix0.log`, record the current PyTorch configuration (`DetectorConfig.from_cli_args(...).detector_pivot`) showing BEAM, and summarise the mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md` plus `phase_h5/parity_summary.md`.
+  2. Phase H6f — update `DetectorConfig` pivot selection so any custom detector vectors or pix0 override force SAMPLE (matching nanoBragg), add a targeted regression test, and log implementation notes under `phase_h6/pivot_fix.md` with pytest evidence.
+  3. Phase H6g — rerun the PyTorch trace harness and nb-compare smoke to verify |Δpix0| < 5e-5 m before closing H6; archive artifacts under `phase_h6/post_fix/` and record Attempt #39 in this ledger.
+  4. Once pivot and pix0 parity are confirmed, resume Phase K2 — regenerate the scaling chain with the updated traces (`phase_k/f_latt_fix/trace_py_after.log`) and refresh `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
+  5. Phase K3 — when H5c/H6g/K2 evidence is green, run `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 NB_C_BIN=./golden_suite_generator/nanoBragg pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, archive the log under `phase_k/f_latt_fix/pytest.log`, and update the lattice notes in `docs/architecture/pytorch_design.md`.
+  6. Do not advance to Phase L until these artifacts land; keep normalization blocked on the refreshed traces.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 71487c47aa8d4a22e0b36d88c35eb01d5882bb39..ed8e314115ab0c112d503d1e9248f73939ea0d47
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -136,8 +136,11 @@
 | --- | --- | --- | --- |
 | H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
 | H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
-| H6c | Diff traces & isolate first divergence | [ ] | Use `diff -u` or notebook tooling to compare C vs PyTorch logs. Document the first mismatched quantity (units included) in `phase_h6/analysis.md`, update `phase_h5/parity_summary.md` with the new findings, and propose the corrective action (e.g., missing MOSFLM +0.5 offset or incorrect `beam_vector` scaling). Note: verify both traces use matching dtype and pivot (SAMPLE) before diffing. |
+| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
 | H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
+| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [ ] | Capture evidence that nanoBragg runs the supervisor command in SAMPLE pivot (use existing `trace_c_pix0.log` message) while PyTorch defaults to BEAM. Document results in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`, including a `python` snippet printing `DetectorConfig.from_cli_args(...).detector_pivot`. Update `phase_h5/parity_summary.md` with the pivot mismatch and cite spec references (`specs/spec-a-cli.md`, `docs/architecture/detector.md`). |
+| H6f | Align pivot selection when custom vectors provided | [ ] | Modify `DetectorConfig.__post_init__`/`from_cli_args` so any custom detector basis (`custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, or `pix0_override_m`) forces `detector_pivot=DetectorPivot.SAMPLE`, matching nanoBragg. Add regression `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA) and log implementation notes under `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`. |
+| H6g | Re-run pix0 traces after pivot fix | [ ] | Execute the PyTorch trace harness with the updated pivot logic (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out .../post_fix/trace_py.log`) and diff against C. Require |Δpix0| < 5e-5 m before closing H6. Archive logs under `phase_h6/post_fix/` and record Attempt #39 in fix_plan. |
 | H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
 | H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |
 

Reading prompt from stdin...
Already up to date.
To github.com:hoidn/nanoBragg.git
   8b9de95..d43d5b0  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=44...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=44
Updating d43d5b0..fe945d3
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   d43d5b0..fe945d3  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=44
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating fe945d3..0b7eaf7
Fast-forward
 docs/fix_plan.md                                   |  14 +++
 imgC_bin_highcontrast.png                          | Bin 0 -> 425669 bytes
 imgC_bin_hot.png                                   | Bin 0 -> 67424 bytes
 imgC_bin_log.png                                   | Bin 0 -> 21552 bytes
 img_bin_converted.png                              | Bin 0 -> 7073 bytes
 img_bin_highcontrast.png                           | Bin 0 -> 1557070 bytes
 img_bin_hot.png                                    | Bin 0 -> 735920 bytes
 img_bin_log.png                                    | Bin 0 -> 1151776 bytes
 intimage_hq.jpeg                                   | Bin 0 -> 217997 bytes
 intimage_preview.jpeg                              | Bin 0 -> 161217 bytes
 noiseimage_preview.jpeg                            | Bin 0 -> 70727 bytes
 plans/active/cli-noise-pix0/plan.md                |   2 +-
 .../2025-10-cli-flags/phase_h5/parity_summary.md   |  34 +++++-
 reports/2025-10-cli-flags/phase_h6/pivot_parity.md | 117 +++++++++++++++++++++
 14 files changed, 164 insertions(+), 3 deletions(-)
 create mode 100644 imgC_bin_highcontrast.png
 create mode 100644 imgC_bin_hot.png
 create mode 100644 imgC_bin_log.png
 create mode 100644 img_bin_converted.png
 create mode 100644 img_bin_highcontrast.png
 create mode 100644 img_bin_hot.png
 create mode 100644 img_bin_log.png
 create mode 100644 intimage_hq.jpeg
 create mode 100644 intimage_preview.jpeg
 create mode 100644 noiseimage_preview.jpeg
 create mode 100644 reports/2025-10-cli-flags/phase_h6/pivot_parity.md
From github.com:hoidn/nanoBragg
   fe945d3..0b7eaf7  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 0b7eaf7..87bb104
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   0b7eaf7..87bb104  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=45
Ralph completed iteration 44; proceeding to 45
