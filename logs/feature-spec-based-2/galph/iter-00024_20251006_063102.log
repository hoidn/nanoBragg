Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=24
To github.com:hoidn/nanoBragg.git
   3279ed9..ae4ac7f  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T06:31:06] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T06:31:06] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 
Phase Gate (Evidence): If the active plan phase is Evidence, Do Now SHALL be evidence‑only: run the authoritative reference reproduction commands and capture the required artifacts; at most run the project’s test discovery (no execution). Do not include runnable tests.

Validation Preflight (tests): Before listing any test file/identifier in Do Now, validate that it resolves via the project’s documented test discovery; if validation fails, omit tests and note “(none — evidence‑only this loop)” and add a TODO in docs/fix_plan.md documenting the missing mapping.

Human Summary (input.md header): Prepend a short summary block with the following lines (validated where applicable):
- Summary: <one‑sentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>

Debugging Items — Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it relate to? 
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? if not, fix. things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, this should be addressed. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
- Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
- Header: timestamp, current commit hash (short), author “galph”, and Active Focus summary.
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it. If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T06:31:10] thinking

**Clarifying allowed modifications**
[2025-10-06T06:31:10] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:13] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.58s:
Already up to date.
[2025-10-06T06:31:13] tokens used: 12,804

[2025-10-06T06:31:15] thinking

**Preparing to read galph_memory.md**
[2025-10-06T06:31:15] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:16] bash -lc 'cat galph_memory.md' succeeded in 837ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-06T06:31:16] tokens used: 13,082

[2025-10-06T06:31:19] thinking

**Verifying complete file contents**
[2025-10-06T06:31:20] exec bash -lc 'tail -n 60 galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:20] bash -lc 'tail -n 60 galph_memory.md' succeeded in 820ms:
- Refreshed `[CLI-FLAGS-003]` next actions in docs/fix_plan.md to mandate the F2 refit + parity redo prior to Phase G orientation work; added supervisor note flagging F2’s incomplete state.
- Issued new input.md directing Ralph to implement the transform, rerun pix0 tests, capture traces, and only then loop back to parity. No new plans required; vectorization roadmap unchanged.
- Feedback for Ralph: formality around parity artifacts is good, but we still need the CUSTOM transform and A* orientation before metrics improve.
## 2025-10-06 (galph loop — CLI Phase G prep)
- Synced clean (`git pull --rebase` up to date). Reviewed core docs plus plans; long-term focus stays on CLI parity + vectorization roadmap.
- Deep dive confirmed `[CLI-FLAGS-003]` now blocked on Phase G orientation: CLI still discards MOSFLM A* vectors, parity metrics remain ≈−5e-06 (reports/2025-10-cli-flags/phase_f/parity_after_detector_fix/metrics.json).
- Detected new regression from Phase F2: `Detector.close_distance` now stored via `.item()`, severing gradients. Logged remediation in docs/fix_plan.md:448 and updated plan Phase F row to flag tensor retention.
- Updated plans/active/cli-noise-pix0/plan.md (F2 → [D], F3 marked pending orientation) and refreshed fix_plan next actions to push G1–G3 plus gradient fix.
- Rewrote input.md (Do Now = Phase G1 orientation + grad hygiene, mapped pytest command, parity harness instructions) with artifact expectations under reports/2025-10-cli-flags/phase_g/.
- Upcoming asks for Ralph: preserve MOSFLM A* in config/Crystal, keep close_distance differentiable, rerun supervisor parity with new traces, then proceed toward Phase H.

## 2025-10-06 (galph loop — Phase G2 orientation prep)
- `git pull --rebase` fast-forward; no conflicts. Reviewed required specs/arch/testing docs plus `plans/active/*` and fix_plan per SOP.
- Deep analysis vs long-term goals:
  * Goal 1 (CLI parity) still blocked by missing MOSFLM orientation in `Crystal`; commit 28fc584 wired A* through the CLI/config but Crystal ignores it, keeping canonical vectors → parity metrics ≈−5e-06.
  * Goal 1 also needs sustained differentiability—close_distance tensor fix (b049227) confirmed, but parity harness remains pending Phase G2/G3.
  * Goal 2 (vectorization) untouched since roadmap rewrite; Phase A evidence not yet captured, so we deferred until CLI parity stabilises.
- Updated `plans/active/cli-noise-pix0/plan.md` marking Phase G1 as [D] with commit 28fc584 context; highlighted G2 as the next actionable blocker.
- Replaced `input.md` directing Ralph to execute Phase G2 (Crystal orientation ingestion), with explicit artifact directory, trace workflow, and pytest commands.
- No new plans required; vectorization roadmap stands. Next follow-ups for Ralph: implement Crystal orientation per Core Rules 12–13, capture trace evidence under `reports/2025-10-cli-flags/phase_g/`, then proceed to Phase G3 parity rerun.
[2025-10-06T06:31:20] tokens used: 15,871

[2025-10-06T06:31:22] thinking

**Listing active plans directory**
[2025-10-06T06:31:23] exec bash -lc 'ls plans/active' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:23] bash -lc 'ls plans/active' succeeded in 777ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T06:31:23] tokens used: 18,446

[2025-10-06T06:31:26] thinking

**Identifying relevant plans**
[2025-10-06T06:31:28] exec bash -lc 'cat plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:28] bash -lc 'cat plans/active/cli-noise-pix0/plan.md' succeeded in 814ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-17 refresh): Phase F1/F2 delivered custom beam-vector wiring and the full CUSTOM pix0 transform, with validation artifacts under `reports/2025-10-cli-flags/phase_f*/`. The parity rerun (F3) remains outstanding. Traces now confirm MOSFLM orientation parity, but `hkl_frac` and lattice structure factor terms still diverge (PyTorch `F_latt≈6.3e1` vs C `3.6e4`). We must align the scattering/lattice pipeline (new Phase H) before tackling polarization (Phase I) where C’s Kahn factor ≈0.913 vs PyTorch 1.0.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Current harness injects the custom beam vector manually; CLI parity requires native wiring.

### Phase A — Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
Prereqs: Ability to run instrumented C binary via `NB_C_BIN` and collect traces.
Exit Criteria: Documented parity notes under `reports/2025-10-cli-flags/phase_a/` with explicit decisions on unit conversions and noise toggle ordering.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Extract C reference for `-nonoise` | [D] | ✅ 2025-10-05: Supervisor command captured with/without `-nonoise`; logs stored under `reports/2025-10-cli-flags/phase_a/`. |
| A2 | Capture pix0 vector ground truth | [D] | ✅ 2025-10-05: Instrumented C trace recorded pix0 vector values; confirms outputs remain in meters even for `_mm` flag. |
| A3 | Update findings memo | [D] | ✅ 2025-10-05: Phase A summary authored in `reports/2025-10-cli-flags/phase_a/README.md` documenting semantics and CUSTOM convention side effects. |

### Phase B — CLI & Config Wiring
Goal: Teach the PyTorch CLI to parse both flags, thread them through configs, and respect overrides in Detector/Noise handling without breaking existing behavior.
[2025-10-06T06:31:28] tokens used: 18,621

[2025-10-06T06:31:30] thinking

**Handling truncated file output**
[2025-10-06T06:31:31] exec bash -lc "sed -n '200,400p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:32] bash -lc "sed -n '200,400p' plans/active/cli-noise-pix0/plan.md" succeeded in 764ms:

[2025-10-06T06:31:32] tokens used: 20,160

[2025-10-06T06:31:33] thinking

**Confirming file length and next steps**
[2025-10-06T06:31:34] exec bash -lc 'cat plans/active/vectorization.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:35] bash -lc 'cat plans/active/vectorization.md' succeeded in 766ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B — Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T06:31:35] tokens used: 20,296

[2025-10-06T06:31:38] thinking

**Planning review of fix_plan.md**
[2025-10-06T06:31:38] exec bash -lc 'rg -n "CLI-FLAGS-003" docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:39] bash -lc 'rg -n "CLI-FLAGS-003" docs/fix_plan.md' succeeded in 914ms:
21:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
448:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
[2025-10-06T06:31:39] tokens used: 22,880

[2025-10-06T06:31:40] thinking

**Extracting code section around line 448**
[2025-10-06T06:31:42] exec bash -lc "sed -n '430,530p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:43] bash -lc "sed -n '430,530p' docs/fix_plan.md" succeeded in 863ms:
            "-cell", "100", "100", "100", "90", "90", "90",
            "-default_F", "0",
            "-dtype", "float64"
        ])
        config = parse_and_validate_args(args)
        grid, _ = config['hkl_data']
        print(grid.dtype)  # BUG: prints torch.float32 today
    ```
    `PY`
- First Divergence (if known): `parse_and_validate_args` (src/nanobrag_torch/__main__.py:435) calls `read_hkl_file`/`try_load_hkl_or_fdump` without forwarding the parsed dtype, so HKL/Fdump data is always loaded as float32. When the CLI is run with `-dtype float64`, the simulator converts those float32 tensors to float64 later, permanently losing precision relative to the requested double-precision path and violating the DTYPE-DEFAULT-001 guarantee.
- Immediate Next Actions (2025-10-15):
  * Update `parse_and_validate_args` (and any helper that constructs `CrystalConfig`) to thread the parsed dtype/device into HKL/Fdump loaders so CLI `-dtype` honours float64 from the start.
  * Add a regression test (e.g., `tests/test_cli_dtype.py`) that invokes the parser with `-dtype float64` and asserts `config['hkl_data'][0].dtype == torch.float64`, covering both HKL and Fdump paths.
  * Re-run AT-IO-003 and the CLI smoke (help + minimal render) to ensure no regressions, capturing logs under `reports/DTYPE-CLI/<date>/`.
- Attempts History: None — new item.
- Risks/Assumptions: Ensure `write_fdump` continues to emit float64 on disk (spec requirement) while the in-memory tensor honours caller dtype; watch for latent callers that relied on the old float64 default during plan DTYPE-DEFAULT-001 migration.
- Exit Criteria: CLI runs with `-dtype float64` produce double-precision HKL/Fdump tensors end-to-end, regression test passes, and existing dtype-sensitive tests (AT-IO-003, CLI smoke, gradchecks) remain green.

## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
[2025-10-06T06:31:43] tokens used: 23,108

[2025-10-06T06:31:46] thinking

**Preparing to review key documentation**
[2025-10-06T06:31:46] exec bash -lc 'head -n 40 docs/index.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:47] bash -lc 'head -n 40 docs/index.md' succeeded in 733ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T06:31:47] tokens used: 24,814

[2025-10-06T06:31:49] thinking

**Starting to review spec-a.md**
[2025-10-06T06:31:52] exec bash -lc 'head -n 40 specs/spec-a.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:53] bash -lc 'head -n 40 specs/spec-a.md' succeeded in 833ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T06:31:53] tokens used: 25,816

[2025-10-06T06:31:54] thinking

**Reviewing documentation and specs**
[2025-10-06T06:31:55] exec bash -lc 'head -n 40 arch.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:56] bash -lc 'head -n 40 arch.md' succeeded in 811ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T06:31:56] tokens used: 26,131

[2025-10-06T06:31:57] thinking

**Searching for additional documentation**
[2025-10-06T06:31:57] exec bash -lc 'head -n 40 docs/development/c_to_pytorch_config_map.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:31:58] bash -lc 'head -n 40 docs/development/c_to_pytorch_config_map.md' succeeded in 855ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T06:31:58] tokens used: 27,083

[2025-10-06T06:32:02] thinking

**Requesting debugging documentation**
[2025-10-06T06:32:02] exec bash -lc 'head -n 40 docs/debugging/debugging.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:03] bash -lc 'head -n 40 docs/debugging/debugging.md' succeeded in 859ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T06:32:03] tokens used: 28,810

[2025-10-06T06:32:04] thinking

**Identifying need for testing strategy document**
[2025-10-06T06:32:05] exec bash -lc 'head -n 40 docs/development/testing_strategy.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:06] bash -lc 'head -n 40 docs/development/testing_strategy.md' succeeded in 784ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T06:32:06] tokens used: 29,530

[2025-10-06T06:32:19] thinking

**Preparing for deep analysis and environment setup**
[2025-10-06T06:32:20] exec bash -lc 'rg -n "nonoise" -n src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:21] bash -lc 'rg -n "nonoise" -n src/nanobrag_torch' succeeded in 986ms:
src/nanobrag_torch/__main__.py:339:    parser.add_argument('-nonoise', action='store_true',
src/nanobrag_torch/__main__.py:711:    config['suppress_noise'] = args.nonoise
src/nanobrag_torch/__main__.py:1185:        # CLI-FLAGS-003: Honor -nonoise flag
[2025-10-06T06:32:21] tokens used: 31,215

[2025-10-06T06:32:22] thinking

**Reviewing code context around line 1185**
[2025-10-06T06:32:23] exec bash -lc "sed -n '650,780p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:23] bash -lc "sed -n '650,780p' src/nanobrag_torch/__main__.py" succeeded in 732ms:
                config['mask_file'] = args.mask  # Still try to load mask data

    # ROI
    if args.roi:
        config['roi'] = args.roi

    # Background
    if args.water:
        config['water_size_um'] = args.water

    # Fluence calculation
    if args.flux and args.exposure and args.beamsize:
        config['flux'] = args.flux
        config['exposure'] = args.exposure
        config['beamsize_mm'] = args.beamsize
    elif args.fluence:
        config['fluence'] = args.fluence

    # Polarization
    if args.nopolar:
[2025-10-06T06:32:23] tokens used: 31,557

[2025-10-06T06:32:25] thinking

**Inspecting noise handling code**
[2025-10-06T06:32:25] exec bash -lc "sed -n '1160,1250p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:26] bash -lc "sed -n '1160,1250p' src/nanobrag_torch/__main__.py" succeeded in 723ms:
                filepath=config['intfile'],
                image_data=scaled_int,
                pixel_size_mm=detector_config.pixel_size_mm,
                distance_mm=detector_config.distance_mm,
                wavelength_angstrom=beam_config.wavelength_A,
                beam_center_x_mm=detector_config.beam_center_s,
                beam_center_y_mm=detector_config.beam_center_f,
                close_distance_mm=detector_config.close_distance_mm,
                phi_deg=config.get('phi_deg', 0.0),
                osc_start_deg=config.get('phi_deg', 0.0),
                osc_range_deg=config.get('osc_deg', 0.0),
                twotheta_deg=config.get('twotheta_deg', 0.0),
                convention=detector_config.detector_convention.name,
                scale=1.0,  # Already scaled
                adc_offset=0.0  # Already applied ADC
            )
            print(f"Wrote SMV image to {config['intfile']}")

        if config.get('pgmfile'):
            # Write PGM per AT-CLI-006
[2025-10-06T06:32:26] tokens used: 33,510

[2025-10-06T06:32:28] thinking

**Checking noise and vector handling**
[2025-10-06T06:32:28] exec bash -lc 'rg -n "pix0_vector" src/nanobrag_torch -g"*.py"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:29] bash -lc 'rg -n "pix0_vector" src/nanobrag_torch -g"*.py"' succeeded in 749ms:
src/nanobrag_torch/__main__.py:187:    parser.add_argument('-pix0_vector', nargs=3, type=float,
src/nanobrag_torch/__main__.py:190:    parser.add_argument('-pix0_vector_mm', nargs=3, type=float,
src/nanobrag_torch/__main__.py:462:            args.pix0_vector, args.pix0_vector_mm]):
src/nanobrag_torch/__main__.py:557:    if args.pix0_vector and args.pix0_vector_mm:
src/nanobrag_torch/__main__.py:558:        raise ValueError("Cannot specify both -pix0_vector and -pix0_vector_mm simultaneously")
src/nanobrag_torch/__main__.py:560:    if args.pix0_vector:
src/nanobrag_torch/__main__.py:561:        config['custom_pix0_vector'] = tuple(args.pix0_vector)
src/nanobrag_torch/__main__.py:562:        # pix0_vector is in meters, convert to config
src/nanobrag_torch/__main__.py:563:        config['pix0_override_m'] = tuple(args.pix0_vector)
src/nanobrag_torch/__main__.py:564:    elif args.pix0_vector_mm:
src/nanobrag_torch/__main__.py:566:        config['pix0_override_m'] = tuple(x * 0.001 for x in args.pix0_vector_mm)
src/nanobrag_torch/__main__.py:567:        config['custom_pix0_vector'] = config['pix0_override_m']
src/nanobrag_torch/simulator.py:1169:                # Output pix0_vector first
src/nanobrag_torch/simulator.py:1170:                pix0 = self.detector.pix0_vector
src/nanobrag_torch/simulator.py:1171:                print(f"TRACE_PY: pix0_vector_meters {pix0[0].item():.15g} {pix0[1].item():.15g} {pix0[2].item():.15g}")
src/nanobrag_torch/models/detector.py:134:        # Calculate and cache pix0_vector (position of first pixel)
src/nanobrag_torch/models/detector.py:135:        self._calculate_pix0_vector()
src/nanobrag_torch/models/detector.py:144:        self._cached_pix0_vector = self.pix0_vector.clone()
src/nanobrag_torch/models/detector.py:147:        # These will be set properly in _calculate_pix0_vector
src/nanobrag_torch/models/detector.py:152:        if not hasattr(self, 'pix0_vector'):
[2025-10-06T06:32:29] tokens used: 34,733

[2025-10-06T06:32:31] thinking

**Checking override logic in source**
[2025-10-06T06:32:32] exec bash -lc "sed -n '500,620p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:33] bash -lc "sed -n '500,620p' src/nanobrag_torch/__main__.py" succeeded in 729ms:

    # Detector parameters
    config['pixel_size_mm'] = args.pixel if args.pixel else 0.1

    # Pixel counts - detpixels takes precedence over detsize
    if args.detpixels:
        config['fpixels'] = args.detpixels
        config['spixels'] = args.detpixels
    elif args.detpixels_f or args.detpixels_s:
        config['fpixels'] = args.detpixels_f if args.detpixels_f else 1024
        config['spixels'] = args.detpixels_s if args.detpixels_s else 1024
    elif args.detsize:
        # Only use detsize if detpixels not specified
        config['fpixels'] = int(args.detsize / config['pixel_size_mm'])
        config['spixels'] = int(args.detsize / config['pixel_size_mm'])
    elif args.detsize_f and args.detsize_s:
        config['fpixels'] = int(args.detsize_f / config['pixel_size_mm'])
        config['spixels'] = int(args.detsize_s / config['pixel_size_mm'])
    else:
        # Default values
[2025-10-06T06:32:33] tokens used: 37,350

[2025-10-06T06:32:37] thinking

**Evaluating project analysis steps**
[2025-10-06T06:32:37] exec bash -lc 'git rev-parse --abbrev-ref HEAD' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:38] bash -lc 'git rev-parse --abbrev-ref HEAD' succeeded in 743ms:
feature/spec-based-2
[2025-10-06T06:32:38] tokens used: 39,454

[2025-10-06T06:32:39] thinking

**Retrieving current commit hash**
[2025-10-06T06:32:40] exec bash -lc 'git rev-parse --short HEAD' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:41] bash -lc 'git rev-parse --short HEAD' succeeded in 710ms:
ae4ac7f
[2025-10-06T06:32:41] tokens used: 39,636

[2025-10-06T06:32:44] thinking

**Reviewing active plan phase and input**
[2025-10-06T06:32:44] exec bash -lc 'cat input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:45] bash -lc 'cat input.md' succeeded in 698ms:
timestamp: 2025-10-06 06:22:50Z
commit: 15fdec5
author: galph
Active Focus: [CLI-FLAGS-003] Phase H3 lattice mismatch diagnosis

Do Now: [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm — run `env KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py > reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log 2> reports/2025-10-cli-flags/phase_h/trace_py_after_H3.stderr`; finish with `pytest --collect-only -q`
If Blocked: Capture the failing stdout/stderr, append a short note to `reports/2025-10-cli-flags/phase_h/attempt_log.txt`, and diff against `trace_py_after_H2.log` to pinpoint where execution diverged before asking for guidance.

Priorities & Rationale:
- docs/fix_plan.md:448 — Next actions call for confirming the `(h-h0)` usage before any simulator edits.
- plans/active/cli-noise-pix0/plan.md:100 — Phase H3 checklist now requires a manual `sincg` reproduction and hypothesis log.
- reports/2025-10-cli-flags/phase_h/trace_comparison_after_H2.md:1 — Existing trace diff highlights the `F_latt` magnitude gap we must quantify.
- reports/2025-10-cli-flags/phase_h/implementation_notes.md:1 — Hypotheses already point at the `sincg` argument order; extend this with today’s evidence.
- golden_suite_generator/nanoBragg.c:3063 — Canonical formula uses absolute `h/k/l`; reproduce these numbers for our comparison.
- src/nanobrag_torch/simulator.py:218 — Current PyTorch path feeds `(h-h0)` into `sincg`; verify this is the culprit before touching code.

How-To Map:
- `env KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py > reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log 2> reports/2025-10-cli-flags/phase_h/trace_py_after_H3.stderr` — regenerate the PyTorch trace with the post-H2 wiring; keep stderr for run metadata.
- `python - <<'PY'` (see below) → pipe output to `reports/2025-10-cli-flags/phase_h/manual_sincg.md` to compute `sincg` for the exact `h,k,l` tuples from the C trace and compare against PyTorch results:
  ```python
[2025-10-06T06:32:45] tokens used: 39,848

[2025-10-06T06:32:48] thinking

**Preparing to analyze Phase H3 evidence**
[2025-10-06T06:32:49] exec bash -lc 'ls reports/2025-10-cli-flags/phase_h' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:49] bash -lc 'ls reports/2025-10-cli-flags/phase_h' succeeded in 686ms:
attempt_log.txt
implementation_notes.md
manual_sincg.md
pytest_collect.log
trace_comparison.md
trace_comparison_after_H2.md
trace_diff.log
trace_diff_after_H2.log
trace_harness.py
trace_py.log
trace_py.stderr
trace_py_after_H2.log
trace_py_after_H2.stderr
trace_py_after_H3.log
trace_py_after_H3.stderr
[2025-10-06T06:32:49] tokens used: 41,647

[2025-10-06T06:32:52] thinking

**Checking implementation notes**
[2025-10-06T06:32:52] exec bash -lc 'tail -n 60 reports/2025-10-cli-flags/phase_h/implementation_notes.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:53] bash -lc 'tail -n 60 reports/2025-10-cli-flags/phase_h/implementation_notes.md' succeeded in 709ms:

- PyTorch sincg: `src/nanobrag_torch/utils/physics.py`
- PyTorch lattice calc: `src/nanobrag_torch/models/crystal.py` (get_structure_factor)
- C reference: `nanoBragg.c:3063-3178`
- Trace harness: `reports/2025-10-cli-flags/phase_h/trace_harness.py`

---

## 2025-10-06 Update: sincg Hypothesis REJECTED

**Investigation Summary:**
Performed manual `sincg` calculation to test Hypothesis 1 (sincg argument order).

**Key Findings:**
1. ✅ **sincg arguments are CORRECT** - C uses `sincg(π*h, Na)` with absolute `h`, PyTorch uses `sincg(π*(h-h0), Na)` with fractional component
2. ⚠️ **Both approaches produce IDENTICAL results** (difference ~2.8e-12, float64 noise level)
3. 🔴 **ROOT CAUSE IDENTIFIED:** The Miller indices (h,k,l) themselves are different between C and PyTorch!

**Evidence from manual_sincg.md:**
```
[2025-10-06T06:32:53] tokens used: 41,884

[2025-10-06T06:32:55] thinking

**Reviewing hypothesis and reference document**
[2025-10-06T06:32:55] exec bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h/trace_comparison.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:56] bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h/trace_comparison.md' succeeded in 705ms:
# Phase H1 Trace Comparison

## Summary
PyTorch trace captured without manual `simulator.incident_beam_direction` override. The Detector received `custom_beam_vector` via DetectorConfig, but the simulator is NOT using it.

## First Divergence: Incident Beam Direction

**Line:** incident_vec
**C value:** `[0.000513879494092498, 0.0, -0.999999867963924]`
**PyTorch value:** `[1, 0, 0]`

### Root Cause
The simulator is using the default MOSFLM incident beam direction `[1, 0, 0]` instead of the custom beam vector from the CLI.

The flow is broken:
1. ✅ CLI provides `beam_vector = [0.00051387949, 0.0, -0.99999986]`
2. ✅ Harness passes it to `DetectorConfig.custom_beam_vector`
3. ❌ Detector does NOT propagate this to simulator's `incident_beam_direction`
4. ❌ Simulator uses default convention beam direction instead

[2025-10-06T06:32:56] tokens used: 43,019

[2025-10-06T06:32:58] thinking

**Identifying relevant trace comparison**
[2025-10-06T06:32:58] exec bash -lc 'head -n 60 reports/2025-10-cli-flags/phase_h/trace_comparison_after_H2.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:32:59] bash -lc 'head -n 60 reports/2025-10-cli-flags/phase_h/trace_comparison_after_H2.md' succeeded in 702ms:
# Phase H3 Trace Comparison After H2 Beam Vector Fix

**Date:** 2025-10-05
**Commit:** 8c1583d (H2 beam vector delegation complete)
**Purpose:** Identify residual lattice factor divergence after incident beam parity achieved

## Executive Summary

✅ **Incident Beam Vector:** Perfect match (0.00051387949 0 -0.99999986)
⚠️ **Lattice Factors:** Significant divergence remains in F_latt components
⚠️ **Intensity:** Orders of magnitude difference (C: 446.25, PyTorch: unknown - need full trace)

## Key Divergence Points

### 1. Incident Vector (RESOLVED ✅)
- **C:**  `0.000513879494092498 0 -0.999999867963924`
- **Py:** `0.00051387949 0 -0.99999986`
- **Status:** Match to machine precision

### 2. Scattering Vector (Minor Difference)
[2025-10-06T06:32:59] tokens used: 43,724

[2025-10-06T06:33:02] thinking

**Verifying Miller indices via logs**
[2025-10-06T06:33:02] exec bash -lc 'rg "hkl_frac" -n reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:03] bash -lc 'rg "hkl_frac" -n reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log' succeeded in 713ms:
20:TRACE_PY: hkl_frac 2.09798050664602 2.01711220186376 -12.8706105317799
[2025-10-06T06:33:03] tokens used: 45,624

[2025-10-06T06:33:05] thinking

**Checking for comparisons with C trace**
[2025-10-06T06:33:05] exec bash -lc 'rg "F_latt" reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:06] bash -lc 'rg "F_latt" reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log' succeeded in 706ms:
TRACE_PY: F_latt_a -3.28845155738463
TRACE_PY: F_latt_b 10.7357461247154
TRACE_PY: F_latt_c -1.77545331582756
TRACE_PY: F_latt 62.6805702411159
[2025-10-06T06:33:06] tokens used: 45,918

[2025-10-06T06:33:09] thinking

**Searching for C trace logs**
[2025-10-06T06:33:10] exec bash -lc 'ls reports/2025-10-cli-flags/phase_h | grep trace_c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:10] bash -lc 'ls reports/2025-10-cli-flags/phase_h | grep trace_c' succeeded in 694ms:
trace_comparison.md
trace_comparison_after_H2.md
[2025-10-06T06:33:10] tokens used: 46,201

[2025-10-06T06:33:12] thinking

**Searching for C trace files**
[2025-10-06T06:33:13] exec bash -lc 'head -n 120 reports/2025-10-cli-flags/phase_h/trace_harness.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:14] bash -lc 'head -n 120 reports/2025-10-cli-flags/phase_h/trace_harness.py' succeeded in 726ms:
#!/usr/bin/env python3
"""
PyTorch trace harness for CLI-FLAGS-003 Phase H1.
Generates TRACE_PY output matching C trace format.
Phase H1: Clean trace without manual beam overrides - Detector.apply_custom_vectors() handles beam_vector from CLI.
"""

import os
import sys
import torch
from pathlib import Path

# Set environment variable for MKL conflicts
os.environ['KMP_DUPLICATE_LIB_OK'] = 'TRUE'

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent / 'src'))

from nanobrag_torch.config import (
    DetectorConfig, CrystalConfig, BeamConfig,
[2025-10-06T06:33:14] tokens used: 46,430

[2025-10-06T06:33:19] thinking

**Investigating unit conversions and data context**
[2025-10-06T06:33:20] exec bash -lc 'tail -n 40 reports/2025-10-cli-flags/phase_h/attempt_log.txt' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:20] bash -lc 'tail -n 40 reports/2025-10-cli-flags/phase_h/attempt_log.txt' succeeded in 718ms:
.                                                                        [100%]
1 passed in 0.94s
[2025-10-06T06:33:20] tokens used: 48,447

[2025-10-06T06:33:23] thinking

**Checking complete file contents**
[2025-10-06T06:33:23] exec bash -lc 'cat reports/2025-10-cli-flags/phase_h/attempt_log.txt' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:24] bash -lc 'cat reports/2025-10-cli-flags/phase_h/attempt_log.txt' succeeded in 705ms:
.                                                                        [100%]
1 passed in 0.94s
[2025-10-06T06:33:24] tokens used: 49,537

[2025-10-06T06:33:30] thinking

**Investigating lattice mismatch root cause**
[2025-10-06T06:33:31] exec bash -lc 'rg -n "hkl_frac" -g"*.py" src' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:31] bash -lc 'rg -n "hkl_frac" -g"*.py" src' succeeded in 733ms:
src/nanobrag_torch/simulator.py:1255:                    print(f"TRACE_PY: hkl_frac {h:.15g} {k:.15g} {l:.15g}")
[2025-10-06T06:33:31] tokens used: 49,814

[2025-10-06T06:33:33] thinking

**Reviewing code segment in simulator.py**
[2025-10-06T06:33:34] exec bash -lc "sed -n '1120,1320p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:34] bash -lc "sed -n '1120,1320p' src/nanobrag_torch/simulator.py" succeeded in 699ms:
            pixel_coords_meters: Pixel coordinates in meters
            rot_a, rot_b, rot_c: Rotated real-space lattice vectors (Angstroms)
            rot_a_star, rot_b_star, rot_c_star: Rotated reciprocal vectors (Angstroms^-1)
            oversample: Oversampling factor
            omega_pixel: Solid angle (if computed)
            polarization: Polarization factor (if computed)
        """

        # Check if we should limit output to specific pixel
        if self.printout_pixel:
            # printout_pixel is [fast, slow] from CLI
            target_fast = self.printout_pixel[0]
            target_slow = self.printout_pixel[1]

            # Only output for this specific pixel
            if 0 <= target_slow < physical_intensity.shape[0] and 0 <= target_fast < physical_intensity.shape[1]:
                print(f"\n=== Pixel ({target_fast}, {target_slow}) [fast, slow] ===")
                print(f"  Final intensity: {physical_intensity[target_slow, target_fast].item():.6e}")
                print(f"  Normalized intensity: {normalized_intensity[target_slow, target_fast].item():.6e}")
                if pixel_coords_meters is not None:
[2025-10-06T06:33:34] tokens used: 50,285

[2025-10-06T06:33:38] thinking

**Investigating scattering vector origins**
[2025-10-06T06:33:39] exec bash -lc 'rg -n "scattering_vec" src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:39] bash -lc 'rg -n "scattering_vec" src/nanobrag_torch/simulator.py' succeeded in 693ms:
156:    scattering_vector = (diffracted_beam_unit - incident_beam_unit) / wavelength
161:        stol = 0.5 * torch.norm(scattering_vector, dim=-1)
166:    # scattering_vector shape: (S, F, 3) single source, or
172:        scattering_broadcast = scattering_vector.unsqueeze(-2).unsqueeze(-2)
188:        scattering_broadcast = scattering_vector.unsqueeze(-2).unsqueeze(-2)
1215:                    scattering_vec_ang_inv = (diffracted_vec - incident_vec) / self.wavelength
1216:                    scattering_vec_m_inv = scattering_vec_ang_inv * 1e10  # Å^-1 to m^-1
1217:                    print(f"TRACE_PY: scattering_vec_A_inv {scattering_vec_m_inv[0].item():.15g} {scattering_vec_m_inv[1].item():.15g} {scattering_vec_m_inv[2].item():.15g}")
1244:                    scattering_vec = (diffracted_unit - incident_unit) / self.wavelength
1247:                    h = dot_product(scattering_vec.unsqueeze(0), a_vec.unsqueeze(0)).item()
1248:                    k = dot_product(scattering_vec.unsqueeze(0), b_vec.unsqueeze(0)).item()
1249:                    l = dot_product(scattering_vec.unsqueeze(0), c_vec.unsqueeze(0)).item()
[2025-10-06T06:33:39] tokens used: 52,926

[2025-10-06T06:33:41] thinking

**Checking scattering_vec calculation**
[2025-10-06T06:33:42] exec bash -lc "sed -n '1200,1260p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:43] bash -lc "sed -n '1200,1260p' src/nanobrag_torch/simulator.py" succeeded in 710ms:
                    # Calculate diffracted and incident vectors
                    coords_ang = coords * 1e10  # m to Å
                    pixel_mag = torch.sqrt(torch.sum(coords_ang * coords_ang))
                    diffracted_vec = coords_ang / pixel_mag
                    incident_vec = self.incident_beam_direction

                    print(f"TRACE_PY: diffracted_vec {diffracted_vec[0].item():.15g} {diffracted_vec[1].item():.15g} {diffracted_vec[2].item():.15g}")
                    print(f"TRACE_PY: incident_vec {incident_vec[0].item():.15g} {incident_vec[1].item():.15g} {incident_vec[2].item():.15g}")

                    # Wavelength
                    lambda_m = self.wavelength.item() * 1e-10
                    print(f"TRACE_PY: lambda_meters {lambda_m:.15g}")
                    print(f"TRACE_PY: lambda_angstroms {self.wavelength.item():.15g}")

                    # Scattering vector (in m^-1, not Å^-1!)
                    scattering_vec_ang_inv = (diffracted_vec - incident_vec) / self.wavelength
                    scattering_vec_m_inv = scattering_vec_ang_inv * 1e10  # Å^-1 to m^-1
                    print(f"TRACE_PY: scattering_vec_A_inv {scattering_vec_m_inv[0].item():.15g} {scattering_vec_m_inv[1].item():.15g} {scattering_vec_m_inv[2].item():.15g}")

                # Trace reciprocal space information if available
[2025-10-06T06:33:43] tokens used: 53,450

[2025-10-06T06:33:45] thinking

**Checking incident_beam_direction definition**
[2025-10-06T06:33:45] exec bash -lc 'rg -n "incident_beam_direction" -g"*.py" src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:46] bash -lc 'rg -n "incident_beam_direction" -g"*.py" src/nanobrag_torch' succeeded in 687ms:
src/nanobrag_torch/simulator.py:29:    incident_beam_direction: torch.Tensor,
src/nanobrag_torch/simulator.py:77:        incident_beam_direction: Incident beam direction.
src/nanobrag_torch/simulator.py:100:    is_multi_source = incident_beam_direction.dim() == 2
src/nanobrag_torch/simulator.py:101:    n_sources = incident_beam_direction.shape[0] if is_multi_source else 1
src/nanobrag_torch/simulator.py:116:    # PERF-PYTORCH-004 Phase 1: No .to() call needed - incident_beam_direction is already on correct device
src/nanobrag_torch/simulator.py:123:        # incident_beam_direction: (n_sources, 3)
src/nanobrag_torch/simulator.py:132:            incident_expanded = incident_beam_direction.view(n_sources, 1, 3)
src/nanobrag_torch/simulator.py:135:            incident_expanded = incident_beam_direction.view(n_sources, 1, 1, 3)
src/nanobrag_torch/simulator.py:142:        incident_beam_unit = incident_beam_direction.expand_as(diffracted_beam_unit)
src/nanobrag_torch/simulator.py:305:            # incident_beam_direction: (n_sources, 3)
src/nanobrag_torch/simulator.py:306:            # NOTE: incident_beam_direction is cloned in _compute_physics_for_position wrapper
src/nanobrag_torch/simulator.py:313:                incident_expanded = incident_beam_direction.unsqueeze(1).expand(-1, diffracted_beam_unit.shape[0], -1)
src/nanobrag_torch/simulator.py:317:                incident_expanded = incident_beam_direction.unsqueeze(1).unsqueeze(1).expand(-1, diffracted_beam_unit.shape[0], diffracted_beam_unit.shape[1], -1)
src/nanobrag_torch/simulator.py:346:                incident_flat = incident_beam_direction.unsqueeze(0).unsqueeze(0).expand(diffracted_beam_unit.shape[0], diffracted_beam_unit.shape[1], -1).reshape(-1, 3).contiguous()
src/nanobrag_torch/simulator.py:348:                incident_flat = incident_beam_direction.unsqueeze(0).expand(diffracted_beam_unit.shape[0], -1).reshape(-1, 3).contiguous()
src/nanobrag_torch/simulator.py:467:            self.incident_beam_direction = self.detector.beam_vector.clone()
src/nanobrag_torch/simulator.py:470:            self.incident_beam_direction = torch.tensor(
src/nanobrag_torch/simulator.py:558:        # because it needs to clone incident_beam_direction before passing to the
src/nanobrag_torch/simulator.py:583:    def _compute_physics_for_position(self, pixel_coords_angstroms, rot_a, rot_b, rot_c, rot_a_star, rot_b_star, rot_c_star, incident_beam_direction=None, wavelength=None, source_weights=None):
src/nanobrag_torch/simulator.py:597:            incident_beam_direction: Optional incident beam direction (defaults to self.incident_beam_direction)
[2025-10-06T06:33:46] tokens used: 54,918

[2025-10-06T06:33:48] thinking

**Checking Simulator initialization**
[2025-10-06T06:33:49] exec bash -lc "sed -n '430,520p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:50] bash -lc "sed -n '430,520p' src/nanobrag_torch/simulator.py" succeeded in 706ms:
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
        else:
[2025-10-06T06:33:50] tokens used: 56,086

[2025-10-06T06:33:52] thinking

**Inspecting pixel coordinate calculation issues**
[2025-10-06T06:33:53] exec bash -lc "sed -n '450,620p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:54] bash -lc "sed -n '450,620p' src/nanobrag_torch/models/detector.py" succeeded in 703ms:
            min_ratio = torch.tensor(1e-10, device=self.device, dtype=self.dtype)
            ratio = torch.where(
                torch.abs(ratio) < min_ratio,
                torch.sign(ratio) * min_ratio,
                ratio
            )
            # Handle zero case
            ratio = torch.where(
                ratio == 0,
                min_ratio,
                ratio
            )

            # Update distance based on r-factor
            # If close_distance is specified, use it; otherwise calculate from nominal distance
            if hasattr(self.config, 'close_distance_mm') and self.config.close_distance_mm is not None:
                close_distance = self.config.close_distance_mm / 1000.0  # Convert mm to meters
            else:
                close_distance = abs(ratio * self.distance)  # Default from C code

[2025-10-06T06:33:54] tokens used: 57,597

[2025-10-06T06:33:56] thinking

**Checking pix0_override_tensor usage**
[2025-10-06T06:33:57] exec bash -lc 'rg -n "pix0_override_tensor" src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:33:57] bash -lc 'rg -n "pix0_override_tensor" src/nanobrag_torch/models/detector.py' succeeded in 722ms:
394:        pix0_override_tensor = None
398:                pix0_override_tensor = torch.tensor(override, device=self.device, dtype=self.dtype)
400:                pix0_override_tensor = override.to(device=self.device, dtype=self.dtype)
520:            if pix0_override_tensor is not None:
521:                self.pix0_vector = pix0_override_tensor
[2025-10-06T06:33:57] tokens used: 60,324

[2025-10-06T06:34:00] thinking

**Reviewing config overrides section**
[2025-10-06T06:34:00] exec bash -lc "sed -n '360,420p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:01] bash -lc "sed -n '360,420p' src/nanobrag_torch/models/detector.py" succeeded in 735ms:
            printf("pivoting detector around sample\n");
            /* initialize detector origin before rotating detector */
            pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
            pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
            pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];

            /* now swing the detector origin around */
            rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
            rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
        }
        ```
        For BEAM pivot (lines 398-403):
        ```c
        if(detector_pivot == BEAM){
            printf("pivoting detector around direct beam spot\n");
            pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
            pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
            pix0_vector[3] = -Fbeam*fdet_vector[3]-Sbeam*sdet_vector[3]+distance*beam_vector[3];
        }
        ```
[2025-10-06T06:34:01] tokens used: 61,347

[2025-10-06T06:34:23] thinking

**Analyzing pix0 vector differences and upcoming debug steps**

I'm comparing pixel0 vectors from CLI, C, and Pyro, noticing Pyro uses a direct mm-to-m override while C applies additional transformations causing millimeter-scale differences. I want to confirm if Pyro should replicate C's transform to fix this. Next, I plan to gather more evidence by inspecting Crystal orientation calculations and detector pixel coordinate computations to understand parity gaps better, especially around Miller indices and pixel vector handling.
[2025-10-06T06:34:24] exec bash -lc 'rg -n "pixel_coords" src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:25] bash -lc 'rg -n "pixel_coords" src/nanobrag_torch/models/detector.py' succeeded in 745ms:
137:        self._pixel_coords_cache: Optional[torch.Tensor] = None
235:        self._pixel_coords_cache = None
632:    def get_pixel_coords(self) -> torch.Tensor:
671:        if self._pixel_coords_cache is None or geometry_changed:
674:                pixel_coords = self._compute_curved_pixel_coords()
677:                pixel_coords = self._compute_planar_pixel_coords()
679:            self._pixel_coords_cache = pixel_coords
690:        return self._pixel_coords_cache
692:    def _compute_planar_pixel_coords(self) -> torch.Tensor:
709:        # pixel_coords = pix0_vector + s * pixel_size * sdet_vec + f * pixel_size * fdet_vec
717:        pixel_coords = (
723:        return pixel_coords
725:    def _compute_curved_pixel_coords(self) -> torch.Tensor:
808:        pixel_coords = self.distance * direction_normalized
810:        return pixel_coords
812:    def get_solid_angle(self, pixel_coords: Optional[torch.Tensor] = None) -> torch.Tensor:
821:            pixel_coords: Optional pre-computed pixel coordinates. If None, will compute them.
828:        if pixel_coords is None:
829:            pixel_coords = self.get_pixel_coords()
832:        R = torch.norm(pixel_coords, dim=-1)  # Shape: (spixels, fpixels)
[2025-10-06T06:34:25] tokens used: 63,594

[2025-10-06T06:34:26] thinking

**Inspecting _compute_planar_pixel_coords function**
[2025-10-06T06:34:27] exec bash -lc "sed -n '692,780p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:28] bash -lc "sed -n '692,780p' src/nanobrag_torch/models/detector.py" succeeded in 708ms:
    def _compute_planar_pixel_coords(self) -> torch.Tensor:
        """
        Compute pixel coordinates for a standard planar detector.

        Returns:
            torch.Tensor: Pixel coordinates with shape (spixels, fpixels, 3) in meters
        """
        # Create pixel index grids - pixel centers to match C code behavior
        # The C code uses pixel centers (0.5, 1.5, 2.5, ...) not corners
        # Adding 0.5 to indices places coordinates at pixel centers
        s_indices = torch.arange(self.spixels, device=self.device, dtype=self.dtype) + 0.5
        f_indices = torch.arange(self.fpixels, device=self.device, dtype=self.dtype) + 0.5

        # Create meshgrid of indices
        s_grid, f_grid = torch.meshgrid(s_indices, f_indices, indexing="ij")

        # Calculate pixel coordinates using pix0_vector as the reference
        # pixel_coords = pix0_vector + s * pixel_size * sdet_vec + f * pixel_size * fdet_vec

        # Expand vectors for broadcasting
[2025-10-06T06:34:28] tokens used: 64,078

[2025-10-06T06:34:33] thinking

**Formulating hypotheses for coordinate differences**
[2025-10-06T06:34:34] exec bash -lc 'rg -n "pix0_vector" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:35] bash -lc 'rg -n "pix0_vector" golden_suite_generator/nanoBragg.c' succeeded in 747ms:
266:    double pix0_vector[4]  = {0,0,0,0};
740:            if(strstr(argv[i], "-pix0_vector") && (argc > (i+3)))
743:                pix0_vector[0] = 1.0;
744:                pix0_vector[1] = atof(argv[i+1]);
745:                pix0_vector[2] = atof(argv[i+2]);
746:                pix0_vector[3] = atof(argv[i+3]);
1386:        printf("\t-pix0_vector     \tvector from crystal to first pixel in image (default: beam centered on detector)\n");
1739:        pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
1740:        pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
1741:        pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
1744:        rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
1745:        rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
1833:        pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
1834:        pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
1835:        pix0_vector[3] = -Fbeam*fdet_vector[3]-Sbeam*sdet_vector[3]+distance*beam_vector[3];
1838:        /* Log final pix0_vector */
1839:        trace_vec("pix0_vector", pix0_vector[1], pix0_vector[2], pix0_vector[3]);
1844:    Fclose         = -dot_product(pix0_vector,fdet_vector);
1845:    Sclose         = -dot_product(pix0_vector,sdet_vector);
1846:    close_distance =  dot_product(pix0_vector,odet_vector);
[2025-10-06T06:34:35] tokens used: 65,565

[2025-10-06T06:34:38] thinking

**Analyzing pix0_vector flag logic**
[2025-10-06T06:34:39] exec bash -lc 'rg -n "pix0_vector_mm" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:39] bash -lc 'rg -n "pix0_vector_mm" golden_suite_generator/nanoBragg.c' exited 1 in 701ms:

[2025-10-06T06:34:39] tokens used: 67,495

[2025-10-06T06:34:42] thinking

**Investigating flag differences**
[2025-10-06T06:34:42] exec bash -lc 'rg -n "pix0" -g"*.c"' in /Users/ollie/Documents/nanoBragg3/golden_suite_generator
[2025-10-06T06:34:43] bash -lc 'rg -n "pix0" -g"*.c"' succeeded in 709ms:
trace_patch.c:4:    printf("TRACE_C: pix0_vector=(%.10e, %.10e, %.10e)\n", pix0[1], pix0[2], pix0[3]);
nanoBragg.c:266:    double pix0_vector[4]  = {0,0,0,0};
nanoBragg.c:287:    /* similar to pix0,vector but with dials-default vectors */
nanoBragg.c:740:            if(strstr(argv[i], "-pix0_vector") && (argc > (i+3)))
nanoBragg.c:743:                pix0_vector[0] = 1.0;
nanoBragg.c:744:                pix0_vector[1] = atof(argv[i+1]);
nanoBragg.c:745:                pix0_vector[2] = atof(argv[i+2]);
nanoBragg.c:746:                pix0_vector[3] = atof(argv[i+3]);
nanoBragg.c:1386:        printf("\t-pix0_vector     \tvector from crystal to first pixel in image (default: beam centered on detector)\n");
nanoBragg.c:1739:        pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
nanoBragg.c:1740:        pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
nanoBragg.c:1741:        pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
nanoBragg.c:1744:        rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
nanoBragg.c:1745:        rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
nanoBragg.c:1827:        /* Log the terms before calculating pix0 */
nanoBragg.c:1833:        pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
nanoBragg.c:1834:        pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
nanoBragg.c:1835:        pix0_vector[3] = -Fbeam*fdet_vector[3]-Sbeam*sdet_vector[3]+distance*beam_vector[3];
nanoBragg.c:1838:        /* Log final pix0_vector */
nanoBragg.c:1839:        trace_vec("pix0_vector", pix0_vector[1], pix0_vector[2], pix0_vector[3]);
[2025-10-06T06:34:43] tokens used: 67,706

[2025-10-06T06:34:48] thinking

**Assessing vectorization and CLI plans**

I'm reviewing the current C code's vector support and considering how CLI features might be handled or replicated. My focus is on outlining the gaps and approach for the long-term goals around CLI parity and vectorization, and next I’m planning to run a simple Python coin flip to support step 2 as instructed.
[2025-10-06T06:34:49] exec bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:49] bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" succeeded in 727ms:
heads
[2025-10-06T06:34:49] tokens used: 70,273

[2025-10-06T06:34:53] thinking

**Reviewing recent commits**
[2025-10-06T06:34:53] exec bash -lc 'git log --oneline -n 10' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:54] bash -lc 'git log --oneline -n 10' succeeded in 753ms:
ae4ac7f [SYNC i=24] actor=galph status=running
3279ed9 [SYNC i=24] actor=ralph → next=galph status=ok ralph_commit=4e0e36e
4e0e36e [CLI-FLAGS-003] Phase H3 evidence gathering: sincg hypothesis rejected
8d77152 [SYNC i=23] actor=ralph status=running
3c3b35d [SYNC i=23] actor=galph → next=ralph status=ok galph_commit=f0bb461
f0bb461 SUPERVISOR: CLI H3 plan guidance + vectorization baseline prep - tests: not run
15fdec5 [SYNC i=23] actor=galph status=running
65fb387 [SYNC i=23] actor=ralph → next=galph status=ok ralph_commit=ce28187
ce28187 [CLI-FLAGS-003] Phase H3 evidence: incident beam parity achieved, lattice factor divergence isolated
e4de39e [SYNC i=22] actor=ralph status=running
[2025-10-06T06:34:54] tokens used: 70,479

[2025-10-06T06:34:57] thinking

**Preparing to inspect commit details**
[2025-10-06T06:34:58] exec bash -lc 'git show --stat 4e0e36e' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:34:58] bash -lc 'git show --stat 4e0e36e' succeeded in 720ms:
commit 4e0e36ed0f15bcddcfd42c5e45c3253ed2dbd25b
Author: ollie <ohoidn>
Date:   Sun Oct 5 23:30:09 2025 -0700

    [CLI-FLAGS-003] Phase H3 evidence gathering: sincg hypothesis rejected
    
    Evidence-only loop per input.md Do Now - no code changes.
    
    Investigation Summary:
    - Ran trace harness after H2 beam vector fix
    - Performed manual sincg calculation to test argument hypothesis
    - Updated implementation notes with findings
    - Verified pytest collection (625 tests, no breakage)
    
    Key Finding: sincg arguments are CORRECT
    - Both C (sincg(π*h, Na)) and PyTorch (sincg(π*(h-h0), Na)) produce
      identical results (Δ ~2.8e-12, float64 noise level)
    - Manual calculation with h=2.001203, Na=36 yields 35.889 for both
    - This matches C expected value within 0.001%
    
[2025-10-06T06:34:58] tokens used: 71,469

[2025-10-06T06:35:01] thinking

**Verifying regressions absence**
[2025-10-06T06:35:02] exec bash -lc 'git show --stat ce28187' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:03] bash -lc 'git show --stat ce28187' succeeded in 688ms:
commit ce28187bf6efee9e232246e7aaed214509d190ff
Author: ollie <ohoidn>
Date:   Sun Oct 5 23:17:05 2025 -0700

    [CLI-FLAGS-003] Phase H3 evidence: incident beam parity achieved, lattice factor divergence isolated
    
    Evidence gathering after H2 beam vector fix (commit 8c1583d):
    - Incident beam vector: perfect match (0.00051387949 0 -0.99999986)
    - Miller indices: diverge by 0.097/0.024/0.120 (exceeds 1e-3 threshold)
    - F_latt components: critical divergence (Py [-3.29,10.74,-1.78] vs C [35.89,38.63,25.70])
    - F_latt product: 568× difference (62.68 vs 35636)
    
    Primary suspect: sincg() argument order in get_structure_factor()
    Secondary suspect: Missing Na/Nb/Nc scaling after sincg
    
    Artifacts:
    - reports/2025-10-cli-flags/phase_h/trace_py_after_H2.log (PyTorch trace)
    - reports/2025-10-cli-flags/phase_h/trace_comparison_after_H2.md (analysis)
    - reports/2025-10-cli-flags/phase_h/implementation_notes.md (hypotheses)
    - reports/2025-10-cli-flags/phase_h/trace_diff_after_H2.log (diff)
[2025-10-06T06:35:03] tokens used: 73,216

[2025-10-06T06:35:09] thinking

**Analyzing attempt log and hypothesis formation**

I'm investigating why the attempt log only shows two lines now, possibly overwritten by test output, and checking recent commits for relevant code changes. I'm focusing on hypothesis generation to explain the main difference in Miller indices, considering pixel coordinate transformations and discrepancies between PyTorch and C implementations, while planning to compare trace outputs for confirmation.
[2025-10-06T06:35:11] exec bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h/trace_diff_after_H2.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:12] bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h/trace_diff_after_H2.log' succeeded in 723ms:
--- reports/2025-10-cli-flags/phase_g/traces/trace_c.log	2025-10-05 22:07:45.987359901 -0700
+++ reports/2025-10-cli-flags/phase_h/trace_py_after_H2.log	2025-10-05 23:14:41.634789662 -0700
@@ -1,40 +1,49 @@
-TRACE_C: pix0_vector_meters -0.216475836204836 0.216343050492215 -0.230192414300537
-TRACE_C: fdet_vec 0.999982004873912 -0.00599800002923425 -0.000118000000575132
-TRACE_C: sdet_vec -0.0059979996566955 -0.999969942765222 -0.0049129997187971
-TRACE_C: pixel_pos_meters -0.0996443642887915 0.0368472243540029 -0.231084742080328
-TRACE_C: R_distance_meters 0.254336146269938
-TRACE_C: omega_pixel_sr 4.15867865980257e-07
-TRACE_C: close_distance_meters 0.231271826111781
-TRACE_C: obliquity_factor 0.909315602613253
-TRACE_C: diffracted_vec -0.391782158179886 0.14487608188769 -0.908580024779756
-TRACE_C: incident_vec 0.000513879494092498 -0 -0.999999867963924
-TRACE_C: lambda_meters 9.768e-11
-TRACE_C: lambda_angstroms 0.9768
-TRACE_C: scattering_vec_A_inv -4016134701.82206 1483170371.49559 935911580.509501
-TRACE_C: rot_a_angstroms -14.3562690335399 -21.8805340763623 -5.5476578307123
-TRACE_C: rot_b_angstroms -11.4986968432508 0.671588233999813 -29.1143056268565
-TRACE_C: rot_c_angstroms 21.0699500320179 -24.4045855811067 -9.7143290320006
-TRACE_C: rot_a_star_A_inv -0.0290510954135954 -0.0293958845208845 0.0107498771498771
[2025-10-06T06:35:12] tokens used: 74,292

[2025-10-06T06:35:14] thinking

**Continuing with Pyro differences**
[2025-10-06T06:35:14] exec bash -lc "sed -n '40,120p' reports/2025-10-cli-flags/phase_h/trace_diff_after_H2.log" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:15] bash -lc "sed -n '40,120p' reports/2025-10-cli-flags/phase_h/trace_diff_after_H2.log" succeeded in 747ms:
-TRACE_C: omega_pixel 4.15867865980257e-07
-TRACE_C: cos_2theta 0.908378575997175
-TRACE_C: I_pixel_final 446.254110667806
-TRACE_C: floatimage_accumulated 446.254119873047
+TRACE_PY: pix0_vector_meters -0.216336293 0.215205512 -0.230200866
+TRACE_PY: fdet_vec 0.999982 -0.005998 -0.000118
+TRACE_PY: sdet_vec -0.005998 -0.99997 -0.004913
+TRACE_PY: pixel_pos_meters -0.09950482172 0.035709675632 -0.23109319383
+TRACE_PY: R_distance_meters 0.254126847684029
+TRACE_PY: omega_pixel_sr 4.16901347764618e-07
+TRACE_PY: close_distance_meters 0.23127466106936
+TRACE_PY: obliquity_factor 0.910075669599922
+TRACE_PY: diffracted_vec -0.391555723556294 0.140519098857276 -0.909361588262143
+TRACE_PY: incident_vec 0.00051387949 0 -0.99999986
+TRACE_PY: lambda_meters 9.768e-11
+TRACE_PY: lambda_angstroms 0.9768
+TRACE_PY: scattering_vec_A_inv -4013816575.00301 1438565713.11708 927910234.82655
+TRACE_PY: rot_a_angstroms -14.3562690335399 -21.8717928453817 -5.58202083498661
+TRACE_PY: rot_b_angstroms -11.4986968432508 0.717320030990266 -29.1132147806318
+TRACE_PY: rot_c_angstroms 21.0699500320179 -24.3892962470766 -9.75265166505327
[2025-10-06T06:35:15] tokens used: 76,041

[2025-10-06T06:35:22] thinking

**Analyzing pixel vector discrepancies and planning updates**

I'm exploring how pix0 vector differences lead to pixel position shifts, questioning earlier claims that F2 fixed this. I want to check `docs/fix_plan` to see if `attempt_log` should hold more content, as it seems overwritten. Next, I'll review recent iterations for progress assessments and consider whether the existing plan—especially Phase H—needs updates to focus on pixel coordinate and scattering vector verification. I'll search the plan file for "Phase H" to get full details on current tasks.
[2025-10-06T06:35:24] exec bash -lc 'rg -n "Phase H" plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:25] bash -lc 'rg -n "Phase H" plans/active/cli-noise-pix0/plan.md' succeeded in 763ms:
5:- Current gap snapshot (2025-10-17 refresh): Phase F1/F2 delivered custom beam-vector wiring and the full CUSTOM pix0 transform, with validation artifacts under `reports/2025-10-cli-flags/phase_f*/`. The parity rerun (F3) remains outstanding. Traces now confirm MOSFLM orientation parity, but `hkl_frac` and lattice structure factor terms still diverge (PyTorch `F_latt≈6.3e1` vs C `3.6e4`). We must align the scattering/lattice pipeline (new Phase H) before tackling polarization (Phase I) where C’s Kahn factor ≈0.913 vs PyTorch 1.0.
89:| G3 | Trace verification + parity rerun | [D] | ✅ 2025-10-06 Attempt #18 (ralph). Fixed MOSFLM matrix transpose bug (`src/nanobrag_torch/io/mosflm.py:88`). Reciprocal vectors now match C exactly (9/9 components to 16 decimals). Miller indices match: (2,2,-13). F_cell perfect match: 300.58. Real vectors within 0.05Å (<0.2% error). Artifacts: `reports/2025-10-cli-flags/phase_g/trace_summary_orientation_fixed.md`, `traces/trace_c.log`, `traces/trace_py_fixed.log`. Intensity parity still divergent (deferred to Phase H polarization). |
91:### Phase H — Lattice Structure Factor Alignment
99:| H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
[2025-10-06T06:35:25] tokens used: 78,257

[2025-10-06T06:35:26] thinking

**Reviewing Phase H table continuation**
[2025-10-06T06:35:27] exec bash -lc "sed -n '91,150p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:28] bash -lc "sed -n '91,150p' plans/active/cli-noise-pix0/plan.md" succeeded in 697ms:
### Phase H — Lattice Structure Factor Alignment
Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
| H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
| H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |

### Phase I — Polarization Alignment (follow-up)
Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
Prereqs: Phases F–H complete; traces show `F_latt` parity.
Exit Criteria: Polarization entries in C/PyTorch traces agree (≈0.9126 for supervisor command) and parity smoke stays green.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| I1 | Audit polarization inputs | [ ] | Review CLI defaults/flags (`-polar`, `-nopolar`) and C calculations (nanoBragg.c:2080-2155); map them to PyTorch simulator inputs. |
[2025-10-06T06:35:28] tokens used: 78,842

[2025-10-06T06:35:33] thinking

**Reviewing and updating plan tasks**

I’m looking into the current tasks under H3 since new findings about Miller indices differences might mean updates are needed there. I want to check how the guidance in `docs/fix_plan.md` directs next steps, especially around inspecting `(h-h0)`, because our new evidence suggests we should shift focus. I'll review lines 470 to 560 to ensure the plan reflects the latest understanding and captures necessary new steps.
[2025-10-06T06:35:34] exec bash -lc "sed -n '470,560p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:35] bash -lc "sed -n '470,560p' docs/fix_plan.md" succeeded in 760ms:
      - C code treats `-pix0_vector` and `-pix0_vector_mm` identically (strstr match, no unit conversion)
      - **Critical finding:** C code does NOT divide by 1000 for `_mm` suffix; caller must provide pre-scaled values
      - Both pix0 flags trigger `beam_convention = CUSTOM` side effect
      - Output pix0_vector: -0.216475836 0.216343050 -0.230192414 (meters)
  * [2025-10-05] Phase C1 Complete — Task C1 executed (CLI regression tests).
    Metrics: 18 test cases, 18 passed, 0 failed, 0 skipped (CPU); 17 passed, 1 skipped (CUDA unavailable in environment).
    Runtime: 3.34s
    Artifacts:
      - `tests/test_cli_flags.py` - 293 lines, 18 comprehensive test cases
      - `reports/2025-10-cli-flags/phase_c/pytest/test_cli_flags.log` - pytest output log
    Test Coverage:
      - ✅ pix0_vector meters alias parsing and config storage
      - ✅ pix0_vector_mm millimeters alias parsing with conversion to meters (mm * 0.001)
      - ✅ Equivalence of meters and millimeters aliases (tolerance: 1e-12)
      - ✅ Mutual exclusivity enforcement (ValueError on dual-flag usage)
      - ✅ Signed combination parametrization (3 scenarios including negatives, zero, small values)
      - ✅ Detector override persistence through cache invalidation (CPU)
      - ✅ Detector override persistence through cache invalidation (CUDA, device check)
      - ✅ Detector override dtype preservation (float32, float64)
      - ✅ r_factor=1.0 and close_distance consistency when override provided
[2025-10-06T06:35:35] tokens used: 80,751

[2025-10-06T06:35:37] thinking

**Reviewing section continuation**
[2025-10-06T06:35:38] exec bash -lc "sed -n '560,680p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:38] bash -lc "sed -n '560,680p' docs/fix_plan.md" succeeded in 704ms:
      - PyTorch produces sparse concentrated peaks (1.88% non-zero), C produces dense diffuse pattern (99.22% non-zero)
      - Intensity ratio ≈256 suspicious (2⁸) but likely coincidental given geometry mismatch
      - Steps normalization verified correct: `steps = 1×10×1×1 = 10` (line 831)
      - **Likely causes:** (1) pix0_vector override not applied, (2) CUSTOM basis vectors wrong, (3) SAMPLE pivot calculation error, (4) incident_beam_direction wrong, (5) Miller index/scattering vector bug
    Next Actions: **MANDATORY parallel trace comparison** per `docs/debugging/debugging.md` §2.1 - instrument C to print pix0_vector, incident_beam_direction, scattering_vector, h/k/l, F_cell, F_latt, omega for pixel (1039,685); generate matching PyTorch trace; compare line-by-line to find first divergence. Only after trace identifies root cause should implementation fixes begin.
  * [2025-10-06] Phase E Complete (ralph) — Result: success. **First divergence identified: pix0_vector mismatch at line 1 of trace.**
    Metrics: C trace (40 vars), PyTorch trace (40 vars). C pix0_vector = `-0.216475836, 0.216343050, -0.230192414` m; PyTorch pix0_vector = `-0.216336293, 0.215205512, -0.230200866` m. Y-component error = **1.14 mm** (explains 1535-pixel horizontal displacement: 1535px × 0.172mm/px ≈ 264mm geometry shift).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_e/c_trace.log` - C reference trace (40 TRACE_C lines)
      - `reports/2025-10-cli-flags/phase_e/pytorch_trace.log` - PyTorch trace (40 TRACE_PY lines)
      - `reports/2025-10-cli-flags/phase_e/trace_diff.txt` - Unified diff output
      - `reports/2025-10-cli-flags/phase_e/trace_comparison.md` - Complete analysis report
      - `reports/2025-10-cli-flags/phase_e/instrumentation_notes.md` - C instrumentation docs
      - `reports/2025-10-cli-flags/phase_e/pytorch_instrumentation_notes.md` - PyTorch trace harness docs
      - `reports/2025-10-cli-flags/phase_e/trace_harness.py` - Evidence-only trace script
      - `reports/2025-10-cli-flags/phase_e/c_trace.patch` - C instrumentation diff
    Observations/Hypotheses:
      - **ROOT CAUSE CONFIRMED:** pix0_vector override is not being applied correctly in PyTorch
      - C transforms the input: `-pix0_vector_mm -216.336... 215.205... -230.200...` → output pix0 = `-0.216475... 0.216343... -0.230192...` (note Y changed from 215.2 to 216.3 mm)
      - **Key finding:** C code applies CUSTOM convention transformation to pix0_vector AFTER override
[2025-10-06T06:35:38] tokens used: 83,310

[2025-10-06T06:35:49] thinking

**Reassessing plan updates around Miller indices**
[2025-10-06T06:35:50] exec bash -lc "rg -n \"pix0_vector\\[0\\]\" golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:51] bash -lc "rg -n \"pix0_vector\\[0\\]\" golden_suite_generator/nanoBragg.c" succeeded in 717ms:
743:                pix0_vector[0] = 1.0;
[2025-10-06T06:35:51] tokens used: 85,612

[2025-10-06T06:35:53] thinking

**Investigating pix0_vector usage**
[2025-10-06T06:35:53] exec bash -lc 'rg -n "pix0_vector" -n golden_suite_generator/nanoBragg.c | head' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:35:54] bash -lc 'rg -n "pix0_vector" -n golden_suite_generator/nanoBragg.c | head' succeeded in 719ms:
266:    double pix0_vector[4]  = {0,0,0,0};
740:            if(strstr(argv[i], "-pix0_vector") && (argc > (i+3)))
743:                pix0_vector[0] = 1.0;
744:                pix0_vector[1] = atof(argv[i+1]);
745:                pix0_vector[2] = atof(argv[i+2]);
746:                pix0_vector[3] = atof(argv[i+3]);
1386:        printf("\t-pix0_vector     \tvector from crystal to first pixel in image (default: beam centered on detector)\n");
1739:        pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
1740:        pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
1741:        pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
[2025-10-06T06:35:54] tokens used: 85,824

[2025-10-06T06:35:58] thinking

**Analyzing potential value overrides in code**
[2025-10-06T06:35:59] exec bash -lc "sed -n '1700,1885p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:36:00] bash -lc "sed -n '1700,1885p' golden_suite_generator/nanoBragg.c" succeeded in 699ms:
    }
    if(vdivrange <= 0.0 || vdivstep <= 0.0 || vdivsteps <= 0) {
        vdivsteps = 1;
        vdivrange = 0.0;
        vdivstep = 0.0;
    }
    if(dispersion <= 0.0 || dispstep <= 0.0 || dispsteps <= 0) {
        dispsteps = 1;
        dispersion = 0.0;
        dispstep = 0.0;
    }
    if(detector_thick <= 0.0 || detector_thickstep <= 0.0 || detector_thicksteps <= 0) {
        detector_thicksteps = 1;
        detector_thick = 0.0;
        detector_thickstep = 0.0;
    }


    /* initialize detector origin from a beam center and distance */
    /* there are two conventions here: mosflm and XDS */
[2025-10-06T06:36:00] tokens used: 86,453

[2025-10-06T06:36:10] thinking

**Investigating pix0_vector usage**
[2025-10-06T06:36:11] exec bash -lc 'rg -n "CUSTOM transform" -g"*.py" src' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:36:12] bash -lc 'rg -n "CUSTOM transform" -g"*.py" src' exited 1 in 914ms:

[2025-10-06T06:36:12] tokens used: 90,266

[2025-10-06T06:36:23] thinking

**Evaluating hypotheses for pix0_vector differences**
[2025-10-06T06:36:24] exec bash -lc 'grep -n "pix0_vector" -n golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:36:25] bash -lc 'grep -n "pix0_vector" -n golden_suite_generator/nanoBragg.c' succeeded in 949ms:
266:    double pix0_vector[4]  = {0,0,0,0};
740:            if(strstr(argv[i], "-pix0_vector") && (argc > (i+3)))
743:                pix0_vector[0] = 1.0;
744:                pix0_vector[1] = atof(argv[i+1]);
745:                pix0_vector[2] = atof(argv[i+2]);
746:                pix0_vector[3] = atof(argv[i+3]);
1386:        printf("\t-pix0_vector     \tvector from crystal to first pixel in image (default: beam centered on detector)\n");
1739:        pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
1740:        pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
1741:        pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
1744:        rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
1745:        rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
1833:        pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
1834:        pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
1835:        pix0_vector[3] = -Fbeam*fdet_vector[3]-Sbeam*sdet_vector[3]+distance*beam_vector[3];
1838:        /* Log final pix0_vector */
1839:        trace_vec("pix0_vector", pix0_vector[1], pix0_vector[2], pix0_vector[3]);
1844:    Fclose         = -dot_product(pix0_vector,fdet_vector);
1845:    Sclose         = -dot_product(pix0_vector,sdet_vector);
1846:    close_distance =  dot_product(pix0_vector,odet_vector);
[2025-10-06T06:36:25] tokens used: 90,968

[2025-10-06T06:36:37] thinking

**Analyzing pix0_vector usage and potential causes**

I'm puzzling over whether the `-pix0_vector` input actually affects calculations here or is ignored, since the code doesn't seem to use it directly. There might be hidden interplay elsewhere or conversions I haven’t spotted yet. I’m forming hypotheses around differences in pixel position computations, beam conventions, and offsets, trying to rationalize subtle numeric discrepancies and plan to locate definitions of key variables like `Fbeam` to clarify.
[2025-10-06T06:36:39] exec bash -lc 'rg -n "Fbeam" golden_suite_generator/nanoBragg.c | head' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:36:40] bash -lc 'rg -n "Fbeam" golden_suite_generator/nanoBragg.c | head' succeeded in 896ms:
278:    double Fbeam=NAN,Sbeam=NAN;
1184:    if(isnan(Fbeam)) Fbeam = Fclose;
1204:        Fbeam = Xbeam;
1220:        Fbeam = Ybeam + 0.5*pixel_size;
1235:        Fbeam = Ybeam + 0.0*pixel_size;
1250:        Fbeam = Xbeam;
1265:        Fbeam = Xbeam;
1273:        Fbeam = Xbeam;
1822:        printf("TRACE_C:convention_mapping=Fbeam←Ybeam_mm(+0.5px),Sbeam←Xbeam_mm(+0.5px),beam_vec=[1 0 0]\n");
1823:        trace_scalar("Fbeam_m", Fbeam);
[2025-10-06T06:36:40] tokens used: 92,744

[2025-10-06T06:36:42] thinking

**Expanding view for context**
[2025-10-06T06:36:43] exec bash -lc "sed -n '1160,1300p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:36:44] bash -lc "sed -n '1160,1300p' golden_suite_generator/nanoBragg.c" succeeded in 753ms:
            printf("WARNING: clipping sample (%lg m wide) with beam (%lg m)\n",sample_z,beamsize);
            sample_z = beamsize;
        }
    }
    if(exposure > 0.0)
    {
        /* make sure flux is consistent with everything else */
        flux = fluence/exposure*beamsize*beamsize;
    }

    /* straighten up sample properties */
//    volume = sample_x*sample_y*sample_z;
//    molecules = volume*density*Avogadro/molecular_weight;


    /* defaults? */
    if(! isnan(ORGX)) Fclose = (ORGX-0.5)*pixel_size;
    if(! isnan(ORGY)) Sclose = (ORGY-0.5)*pixel_size;
    /* place beam center halfway between four middle pixels */
    /* place beam center at int(npix/2) location */
[2025-10-06T06:36:44] tokens used: 93,137

[2025-10-06T06:37:21] thinking

**Analyzing pix0 transformation discrepancies and updating plan**

I’m examining why the CUSTOM beam vector formula in C differs slightly from Pyro’s override approach, suspecting the need for Pyro to replicate C’s calculation rather than directly override. This leads me to update the plan and documentation to reflect diagnosing and fixing the pix0/pixel coordinate mismatch, including new evidence gathering and detailed instructions to restore accurate attempt logs and verify pixel calculations.
[2025-10-06T06:37:27] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -93,3 +93,3 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
@@ -99,3 +99,3 @@
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
[2025-10-06T06:37:27] apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T06:37:27] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)

[2025-10-06T06:37:27] tokens used: 98,430
[2025-10-06T06:37:27] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:37:31] thinking

**Updating documentation next actions**
[2025-10-06T06:37:35] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -457,3 +457,3 @@
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
[2025-10-06T06:37:35] apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T06:37:35] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)

[2025-10-06T06:37:35] tokens used: 100,135
[2025-10-06T06:37:35] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:37:43] thinking

**Organizing update plan and preparing new input memo**
[2025-10-06T06:37:44] exec bash -lc 'date -u +"%Y-%m-%d %H:%M:%SZ"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:37:45] bash -lc 'date -u +"%Y-%m-%d %H:%M:%SZ"' succeeded in 965ms:
2025-10-06 06:37:45Z
[2025-10-06T06:37:45] tokens used: 101,356
[2025-10-06T06:37:45] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:37:48] thinking

**Retrieving short commit hash**
[2025-10-06T06:37:49] exec bash -lc 'git rev-parse --short HEAD' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:37:50] bash -lc 'git rev-parse --short HEAD' succeeded in 702ms:
ae4ac7f
[2025-10-06T06:37:50] tokens used: 101,554
[2025-10-06T06:37:50] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:38:46] thinking

**Preparing detailed evidence plan and instructions**

I'm organizing a thorough plan for CLI-FLAGS-003 focused on lattice mismatch evidence gathering. This includes precise commands to rerun the trace harness with output logging, a new inline Python snippet replicating the C pix0 formula with torch tensors and unit conversions, and instructions to collect test mappings using pytest. I'll draft a structured input.md with metadata, do-now line referencing the commands, fallback actions, rationale bullets referencing docs and plans, how-to command maps including the full Python snippet, pitfalls to watch for, pointers to files with line numbers, and optional next steps. I'll ensure environment variables like AUTHORITATIVE_CMDS_DOC are set, clarify artifact storage paths, and direct log and note updates to keep attempt tracking clean and accurate. This setup will enable precise, reproducible pix0 verification bridging C and Python calculations, all stepwise and well documented.
[2025-10-06T06:39:13] exec bash -lc "cat <<'EOF' > input.md
timestamp: 2025-10-06 06:37:45Z
commit: ae4ac7f
author: galph
Active Focus: [CLI-FLAGS-003] Phase H3 lattice mismatch diagnosis
Summary: Prove the pix0-driven lattice divergence and log an evidence-backed fix plan before touching detector code.
Phase: Evidence
Focus: CLI-FLAGS-003
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.log; reports/2025-10-cli-flags/phase_h/pix0_reproduction.md; reports/2025-10-cli-flags/phase_h/attempt_log.txt

Do Now: [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm — evidence: execute the trace harness + pix0 reproduction per How-To Map, then run "'`pytest --collect-only -q`.
If Blocked: Capture stdout/stderr for any failing command under `reports/2025-10-cli-flags/phase_h/blocked/` and diff against the prior attempt before escalating.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:105 — Phase H3 now requires a C-style pix0 reconstruction plus restored attempt log before implementation.
- docs/fix_plan.md:472 — Next Actions call for demonstrating the ~1.14 mm pix0 delta and propagating it through to h/k/l.
- reports/2025-10-cli-flags/phase_h/implementation_notes.md:54 — Latest entry flags Miller index divergence but leaves the detector fix plan blank.
- reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log:1 — Current trace still reflects the mismatched pix0; we need a refreshed run tied to today’s evidence.
- docs/development/testing_strategy.md:1 — Authoritative commands doc; keep `pytest --collect-only -q` as the validation touchpoint for evidence loops.

How-To Map:
- Export the authoritative commands doc before running anything: `export AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md`.
- Trace refresh (store stderr for provenance):
  `env KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py > reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.log 2> reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.stderr`
- Pix0 + lattice reproduction (captures both raw override and C formula) — pipe output to the Markdown evidence file:
  ```bash
  python - <<'"'PY' > reports/2025-10-cli-flags/phase_h/pix0_reproduction.md
  import torch, math

  mm_to_m = 1e-3
  pixel_size_mm = 0.172
  distance_mm = 231.274660
  xbeam_mm = 217.742295
  ybeam_mm = 213.907080
  target_fast = 685
  target_slow = 1039
  wavelength_A = 0.9768

  fdet = torch.tensor([0.999982004873912, -0.00599800002923425, -0.000118000000575132], dtype=torch.float64)
  sdet = torch.tensor([-0.0059979996566955, -0.999969942765222, -0.0049129997187971], dtype=torch.float64)
  beam = torch.tensor([0.000513879494092498, 0.0, -0.999999867963924], dtype=torch.float64)

  pix0_override_m = torch.tensor([-216.336293, 215.205512, -230.200866], dtype=torch.float64) * mm_to_m
  Fbeam_m = xbeam_mm * mm_to_m
  Sbeam_m = ybeam_mm * mm_to_m
  distance_m = distance_mm * mm_to_m
  pix0_c_m = -Fbeam_m * fdet - Sbeam_m * sdet + distance_m * beam

  pixel_size_m = pixel_size_mm * mm_to_m
  center_fast = (target_fast + 0.5) * pixel_size_m
  center_slow = (target_slow + 0.5) * pixel_size_m
  pixel_py = pix0_override_m + center_slow * sdet + center_fast * fdet
  pixel_c = pix0_c_m + center_slow * sdet + center_fast * fdet

  def scattering_and_hkl(pixel_vec, label):
      coords_ang = pixel_vec * 1e10
      diffracted_unit = coords_ang / coords_ang.norm()
      scattering = (diffracted_unit - beam) / wavelength_A
      a_vec = torch.tensor([-14.3562690335399, -21.8805340763623, -5.5476578307123], dtype=torch.float64)
      b_vec = torch.tensor([-11.4986968432508, 0.671588233999813, -29.1143056268565], dtype=torch.float64)
      c_vec = torch.tensor([21.0699500320179, -24.4045855811067, -9.7143290320006], dtype=torch.float64)
      h = torch.dot(scattering, a_vec).item()
      k = torch.dot(scattering, b_vec).item()
      l = torch.dot(scattering, c_vec).item()
      return scattering, (h, k, l)

  scattering_py, hkl_py = scattering_and_hkl(pixel_py, \"Py override\")
  scattering_c, hkl_c = scattering_and_hkl(pixel_c, \"C formula\")

  def fmt(vec):
      return ', '.join(f\"{v:.12f}\" for v in vec)

  print(\"# Pix0 + Lattice Reproduction\")
  print(\"pix0_override_m:\", fmt(pix0_override_m))
  print(\"pix0_c_formula_m:\", fmt(pix0_c_m))
  diff = pix0_c_m - pix0_override_m
  print(\"pix0_delta_m:\", fmt(diff))
  print(\"\\n## Pixel positions (meters)\")
  print(\"pixel_py:\", fmt(pixel_py))
  print(\"pixel_c:\", fmt(pixel_c))
  print(\"pixel_delta:\", fmt(pixel_c - pixel_py))
  print(\"\\n## Scattering vectors (1/Å)\")
  print(\"scattering_py:\", fmt(scattering_py))
  print(\"scattering_c:\", fmt(scattering_c))
  print(\"scattering_delta:\", fmt(scattering_c - scattering_py))
  print(\"\\n## Miller indices (fractional)\")
  print(\"hkl_py:\", ', '.join(f\"{v:.12f}\" for v in hkl_py))
  print(\"hkl_c:\", ', '.join(f\"{v:.12f}\" for v in hkl_c))
  print(\"hkl_delta:\", ', '.join(f\"{(c - p):.12f}\" for p, c in zip(hkl_py, hkl_c)))

  # Quick sincg check for completeness
  def sincg(arg, n):
      arg = torch.tensor(arg, dtype=torch.float64)
      n = torch.tensor(float(n), dtype=torch.float64)
      return torch.where(arg == 0, n, torch.sin(arg * n) / torch.sin(arg))

  Na, Nb, Nc = 36, 47, 29
  import math
  pi = math.pi
  for label, hkl in (\"py\", hkl_py), (\"c\", hkl_c):
      ha, ka, la = hkl
      Fa = sincg(pi * (ha - round(ha)), Na)
      Fb = sincg(pi * (ka - round(ka)), Nb)
      Fc = sincg(pi * (la - round(la)), Nc)
      print(f\"\\nF_latt components ({label}): {Fa.item():.6f}, {Fb.item():.6f}, {Fc.item():.6f}\")
  PY
  "'```
- Restore the attempt log by overwriting `reports/2025-10-cli-flags/phase_h/attempt_log.txt` with a concise Attempt #21 entry summarising today’s evidence (remove the stray pytest output before committing anything).
- Append a 2025-10-06 section to `reports/2025-10-cli-flags/phase_h/implementation_notes.md` capturing the quantified pix0/pixel/scattering deltas and outlining the detector override fix you plan to implement next loop.
- Validation touchpoint: `pytest --collect-only -q > reports/2025-10-cli-flags/phase_h/pytest_collect_refresh.log`

Pitfalls To Avoid:
- Stay evidence-only; no code or config edits while Phase H3 remains open.
- Do not overwrite prior trace artifacts—use the `_refresh` suffixes above.
- Keep all scratch outputs under `reports/2025-10-cli-flags/phase_h/`; no repo-root temp files.
- Maintain float64 throughout the reproduction script (no `.float()` shortcuts).
- Set `AUTHORITATIVE_CMDS_DOC` before running commands to comply with testing SOP.
- Ensure attempt_log.txt is human-readable (summary + metrics); never paste raw pytest output again.
- Avoid running broader pytest suites; `--collect-only -q` is the sole test this loop.
- No manual beam overrides in the harness—rely on CLI wiring now that H2 landed.
- Preserve Protected Assets listed in docs/index.md (do not rename/remove input.md, loop.sh, etc.).
- Keep git tree clean at end; evidence artifacts must be committed with this memo.

Pointers:
- docs/development/testing_strategy.md:1 — Authoritative commands + evidence-only loop guidance.
- docs/debugging/debugging.md:18 — Parallel trace SOP to contextualise today’s trace refresh.
- plans/active/cli-noise-pix0/plan.md:95 — Phase H checklist with the new pix0 reproduction requirement.
- docs/fix_plan.md:448 — `[CLI-FLAGS-003]` entry housing Next Actions and attempt history.
- reports/2025-10-cli-flags/phase_h/trace_comparison_after_H2.md:1 — Prior diff highlighting pix0 as the first divergence (use as baseline).

Next Up:
- After the detector pix0 fix plan is locked, schedule Phase H4 parity rerun (still `[CLI-FLAGS-003]`).
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:14] bash -lc "cat <<'EOF' > input.md
timestamp: 2025-10-06 06:37:45Z
commit: ae4ac7f
author: galph
Active Focus: [CLI-FLAGS-003] Phase H3 lattice mismatch diagnosis
Summary: Prove the pix0-driven lattice divergence and log an evidence-backed fix plan before touching detector code.
Phase: Evidence
Focus: CLI-FLAGS-003
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.log; reports/2025-10-cli-flags/phase_h/pix0_reproduction.md; reports/2025-10-cli-flags/phase_h/attempt_log.txt

Do Now: [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm — evidence: execute the trace harness + pix0 reproduction per How-To Map, then run "'`pytest --collect-only -q`.
If Blocked: Capture stdout/stderr for any failing command under `reports/2025-10-cli-flags/phase_h/blocked/` and diff against the prior attempt before escalating.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:105 — Phase H3 now requires a C-style pix0 reconstruction plus restored attempt log before implementation.
- docs/fix_plan.md:472 — Next Actions call for demonstrating the ~1.14 mm pix0 delta and propagating it through to h/k/l.
- reports/2025-10-cli-flags/phase_h/implementation_notes.md:54 — Latest entry flags Miller index divergence but leaves the detector fix plan blank.
- reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log:1 — Current trace still reflects the mismatched pix0; we need a refreshed run tied to today’s evidence.
- docs/development/testing_strategy.md:1 — Authoritative commands doc; keep `pytest --collect-only -q` as the validation touchpoint for evidence loops.

How-To Map:
- Export the authoritative commands doc before running anything: `export AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md`.
- Trace refresh (store stderr for provenance):
  `env KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py > reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.log 2> reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.stderr`
- Pix0 + lattice reproduction (captures both raw override and C formula) — pipe output to the Markdown evidence file:
  ```bash
  python - <<'"'PY' > reports/2025-10-cli-flags/phase_h/pix0_reproduction.md
  import torch, math

  mm_to_m = 1e-3
  pixel_size_mm = 0.172
  distance_mm = 231.274660
  xbeam_mm = 217.742295
  ybeam_mm = 213.907080
  target_fast = 685
  target_slow = 1039
  wavelength_A = 0.9768

  fdet = torch.tensor([0.999982004873912, -0.00599800002923425, -0.000118000000575132], dtype=torch.float64)
  sdet = torch.tensor([-0.0059979996566955, -0.999969942765222, -0.0049129997187971], dtype=torch.float64)
  beam = torch.tensor([0.000513879494092498, 0.0, -0.999999867963924], dtype=torch.float64)

  pix0_override_m = torch.tensor([-216.336293, 215.205512, -230.200866], dtype=torch.float64) * mm_to_m
  Fbeam_m = xbeam_mm * mm_to_m
  Sbeam_m = ybeam_mm * mm_to_m
  distance_m = distance_mm * mm_to_m
  pix0_c_m = -Fbeam_m * fdet - Sbeam_m * sdet + distance_m * beam

  pixel_size_m = pixel_size_mm * mm_to_m
  center_fast = (target_fast + 0.5) * pixel_size_m
  center_slow = (target_slow + 0.5) * pixel_size_m
  pixel_py = pix0_override_m + center_slow * sdet + center_fast * fdet
  pixel_c = pix0_c_m + center_slow * sdet + center_fast * fdet

  def scattering_and_hkl(pixel_vec, label):
      coords_ang = pixel_vec * 1e10
      diffracted_unit = coords_ang / coords_ang.norm()
      scattering = (diffracted_unit - beam) / wavelength_A
      a_vec = torch.tensor([-14.3562690335399, -21.8805340763623, -5.5476578307123], dtype=torch.float64)
      b_vec = torch.tensor([-11.4986968432508, 0.671588233999813, -29.1143056268565], dtype=torch.float64)
      c_vec = torch.tensor([21.0699500320179, -24.4045855811067, -9.7143290320006], dtype=torch.float64)
      h = torch.dot(scattering, a_vec).item()
      k = torch.dot(scattering, b_vec).item()
      l = torch.dot(scattering, c_vec).item()
      return scattering, (h, k, l)

  scattering_py, hkl_py = scattering_and_hkl(pixel_py, \"Py override\")
  scattering_c, hkl_c = scattering_and_hkl(pixel_c, \"C formula\")

  def fmt(vec):
      return ', '.join(f\"{v:.12f}\" for v in vec)

  print(\"# Pix0 + Lattice Reproduction\")
  print(\"pix0_override_m:\", fmt(pix0_override_m))
  print(\"pix0_c_formula_m:\", fmt(pix0_c_m))
  diff = pix0_c_m - pix0_override_m
  print(\"pix0_delta_m:\", fmt(diff))
  print(\"\\n## Pixel positions (meters)\")
  print(\"pixel_py:\", fmt(pixel_py))
  print(\"pixel_c:\", fmt(pixel_c))
  print(\"pixel_delta:\", fmt(pixel_c - pixel_py))
  print(\"\\n## Scattering vectors (1/Å)\")
  print(\"scattering_py:\", fmt(scattering_py))
  print(\"scattering_c:\", fmt(scattering_c))
  print(\"scattering_delta:\", fmt(scattering_c - scattering_py))
  print(\"\\n## Miller indices (fractional)\")
  print(\"hkl_py:\", ', '.join(f\"{v:.12f}\" for v in hkl_py))
  print(\"hkl_c:\", ', '.join(f\"{v:.12f}\" for v in hkl_c))
  print(\"hkl_delta:\", ', '.join(f\"{(c - p):.12f}\" for p, c in zip(hkl_py, hkl_c)))

  # Quick sincg check for completeness
  def sincg(arg, n):
      arg = torch.tensor(arg, dtype=torch.float64)
      n = torch.tensor(float(n), dtype=torch.float64)
      return torch.where(arg == 0, n, torch.sin(arg * n) / torch.sin(arg))

  Na, Nb, Nc = 36, 47, 29
  import math
  pi = math.pi
  for label, hkl in (\"py\", hkl_py), (\"c\", hkl_c):
      ha, ka, la = hkl
      Fa = sincg(pi * (ha - round(ha)), Na)
      Fb = sincg(pi * (ka - round(ka)), Nb)
      Fc = sincg(pi * (la - round(la)), Nc)
      print(f\"\\nF_latt components ({label}): {Fa.item():.6f}, {Fb.item():.6f}, {Fc.item():.6f}\")
  PY
  "'```
- Restore the attempt log by overwriting `reports/2025-10-cli-flags/phase_h/attempt_log.txt` with a concise Attempt #21 entry summarising today’s evidence (remove the stray pytest output before committing anything).
- Append a 2025-10-06 section to `reports/2025-10-cli-flags/phase_h/implementation_notes.md` capturing the quantified pix0/pixel/scattering deltas and outlining the detector override fix you plan to implement next loop.
- Validation touchpoint: `pytest --collect-only -q > reports/2025-10-cli-flags/phase_h/pytest_collect_refresh.log`

Pitfalls To Avoid:
- Stay evidence-only; no code or config edits while Phase H3 remains open.
- Do not overwrite prior trace artifacts—use the `_refresh` suffixes above.
- Keep all scratch outputs under `reports/2025-10-cli-flags/phase_h/`; no repo-root temp files.
- Maintain float64 throughout the reproduction script (no `.float()` shortcuts).
- Set `AUTHORITATIVE_CMDS_DOC` before running commands to comply with testing SOP.
- Ensure attempt_log.txt is human-readable (summary + metrics); never paste raw pytest output again.
- Avoid running broader pytest suites; `--collect-only -q` is the sole test this loop.
- No manual beam overrides in the harness—rely on CLI wiring now that H2 landed.
- Preserve Protected Assets listed in docs/index.md (do not rename/remove input.md, loop.sh, etc.).
- Keep git tree clean at end; evidence artifacts must be committed with this memo.

Pointers:
- docs/development/testing_strategy.md:1 — Authoritative commands + evidence-only loop guidance.
- docs/debugging/debugging.md:18 — Parallel trace SOP to contextualise today’s trace refresh.
- plans/active/cli-noise-pix0/plan.md:95 — Phase H checklist with the new pix0 reproduction requirement.
- docs/fix_plan.md:448 — `[CLI-FLAGS-003]` entry housing Next Actions and attempt history.
- reports/2025-10-cli-flags/phase_h/trace_comparison_after_H2.md:1 — Prior diff highlighting pix0 as the first divergence (use as baseline).

Next Up:
- After the detector pix0 fix plan is locked, schedule Phase H4 parity rerun (still `[CLI-FLAGS-003]`).
EOF
' succeeded in 886ms:

[2025-10-06T06:39:14] tokens used: 107,822
[2025-10-06T06:39:14] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:21] thinking

**Organizing final documentation updates**

I’m focusing on properly updating `galph_memory.md` with a concise summary of recent activities, including plan changes, coin flip review results, commit history insights, and new instructions, making sure everything’s well documented before wrapping up.
[2025-10-06T06:39:27] exec bash -lc "cat <<'EOF' >> galph_memory.md
## 2025-10-06 (galph loop — Phase H3 pix0 evidence refresh)
- Re-read core docs + active plans; long-term Goal 1 still blocked by Phase H3 lattice parity, Goal 2 (vectorization) queued until CLI parity stabilises.
- Evidence review: trace diff shows 1.14 mm gap between PyTorch "'`pix0_override_m` and C’s BEAM-pivot transform, cascading to pixel_pos, scattering_vec, and h/k/l deltas. Sincg confirmed equivalent; root cause is detector pix0 override handling.
- Plan upkeep: updated `plans/active/cli-noise-pix0/plan.md` Phase H exit criteria and H3 task to require reproducing C’s pix0 math + restoring attempt log. docs/fix_plan.md Next Actions now point at capturing `pix0_reproduction.md`, propagating deltas, and logging Attempt #21 properly before code edits.
- Coin flip = heads → reviewed Ralph commits `ce28187`, `4e0e36e` (evidence-only, productive; no regressions). Feedback captured in input.md.
- Authored new input.md directing Ralph to rerun trace harness, build pix0 reproduction notebook, clean up `attempt_log.txt`, append implementation notes, and run `pytest --collect-only -q` (evidence loop).
- Follow-ups for Ralph next loop: produce the refreshed trace + pix0 reproduction artifacts, restore the attempt log with human-readable Attempt #21, log findings in implementation_notes.md, keep work evidence-only pending detector fix design.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:28] bash -lc "cat <<'EOF' >> galph_memory.md
## 2025-10-06 (galph loop — Phase H3 pix0 evidence refresh)
- Re-read core docs + active plans; long-term Goal 1 still blocked by Phase H3 lattice parity, Goal 2 (vectorization) queued until CLI parity stabilises.
- Evidence review: trace diff shows 1.14 mm gap between PyTorch "'`pix0_override_m` and C’s BEAM-pivot transform, cascading to pixel_pos, scattering_vec, and h/k/l deltas. Sincg confirmed equivalent; root cause is detector pix0 override handling.
- Plan upkeep: updated `plans/active/cli-noise-pix0/plan.md` Phase H exit criteria and H3 task to require reproducing C’s pix0 math + restoring attempt log. docs/fix_plan.md Next Actions now point at capturing `pix0_reproduction.md`, propagating deltas, and logging Attempt #21 properly before code edits.
- Coin flip = heads → reviewed Ralph commits `ce28187`, `4e0e36e` (evidence-only, productive; no regressions). Feedback captured in input.md.
- Authored new input.md directing Ralph to rerun trace harness, build pix0 reproduction notebook, clean up `attempt_log.txt`, append implementation notes, and run `pytest --collect-only -q` (evidence loop).
- Follow-ups for Ralph next loop: produce the refreshed trace + pix0 reproduction artifacts, restore the attempt log with human-readable Attempt #21, log findings in implementation_notes.md, keep work evidence-only pending detector fix design.
EOF
' succeeded in 913ms:

[2025-10-06T06:39:28] tokens used: 110,905
[2025-10-06T06:39:28] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:34] thinking

**Preparing to check git status**
[2025-10-06T06:39:34] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:35] bash -lc 'git status --short' succeeded in 768ms:
 M docs/fix_plan.md
 M galph_memory.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T06:39:35] tokens used: 112,197
[2025-10-06T06:39:35] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:39] thinking

**Reviewing diffs before commit**
[2025-10-06T06:39:40] exec bash -lc 'git diff docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:40] bash -lc 'git diff docs/fix_plan.md' succeeded in 674ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee5244..93d21fc 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
[2025-10-06T06:39:40] tokens used: 112,349
[2025-10-06T06:39:40] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:42] thinking

**Reviewing plan differences**
[2025-10-06T06:39:43] exec bash -lc 'git diff plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:44] bash -lc 'git diff plans/active/cli-noise-pix0/plan.md' succeeded in 673ms:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29..79a8564 100644
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@ Exit Criteria: Crystal trace (rotated a/b/c vectors) aligns with C for the super
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)
[2025-10-06T06:39:44] tokens used: 113,293
[2025-10-06T06:39:44] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:46] thinking

**Checking galph_memory diff**
[2025-10-06T06:39:47] exec bash -lc 'git diff galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:47] bash -lc 'git diff galph_memory.md' succeeded in 702ms:
diff --git a/galph_memory.md b/galph_memory.md
index 9f47df4..7f2e948 100644
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1056,3 +1056,10 @@ Follow-ups for Ralph:
 - Long-term Goal 2: `plans/active/vectorization.md` Phase A updated to author reusable tricubic/absorption benchmark harnesses under `scripts/benchmarks/` so baseline timings can be captured once CLI parity stabilises; fix_plan Next Actions adjusted accordingly.
 - Authored new input.md (Do Now: rerun trace harness, compute manual sincg table, pytest collect) and staged reporting guardrails for today’s evidence-only loop.
 - Follow-ups for Ralph: regenerate PyTorch trace under `trace_py_after_H3.log`, create `manual_sincg.md` comparing `(h-h0)` vs absolute arguments, append findings to `implementation_notes.md`, and keep Attempt log current before proposing the simulator fix.
+## 2025-10-06 (galph loop — Phase H3 pix0 evidence refresh)
+- Re-read core docs + active plans; long-term Goal 1 still blocked by Phase H3 lattice parity, Goal 2 (vectorization) queued until CLI parity stabilises.
+- Evidence review: trace diff shows 1.14 mm gap between PyTorch `pix0_override_m` and C’s BEAM-pivot transform, cascading to pixel_pos, scattering_vec, and h/k/l deltas. Sincg confirmed equivalent; root cause is detector pix0 override handling.
+- Plan upkeep: updated `plans/active/cli-noise-pix0/plan.md` Phase H exit criteria and H3 task to require reproducing C’s pix0 math + restoring attempt log. docs/fix_plan.md Next Actions now point at capturing `pix0_reproduction.md`, propagating deltas, and logging Attempt #21 properly before code edits.
+- Coin flip = heads → reviewed Ralph commits `ce28187`, `4e0e36e` (evidence-only, productive; no regressions). Feedback captured in input.md.
+- Authored new input.md directing Ralph to rerun trace harness, build pix0 reproduction notebook, clean up `attempt_log.txt`, append implementation notes, and run `pytest --collect-only -q` (evidence loop).
+- Follow-ups for Ralph next loop: produce the refreshed trace + pix0 reproduction artifacts, restore the attempt log with human-readable Attempt #21, log findings in implementation_notes.md, keep work evidence-only pending detector fix design.
[2025-10-06T06:39:47] tokens used: 114,341
[2025-10-06T06:39:47] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:50] thinking

**Checking input.md changes**
[2025-10-06T06:39:50] exec bash -lc 'git diff input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:51] bash -lc 'git diff input.md' succeeded in 722ms:
diff --git a/input.md b/input.md
index 8e75099..e311f48 100644
--- a/input.md
+++ b/input.md
@@ -1,70 +1,133 @@
-timestamp: 2025-10-06 06:22:50Z
-commit: 15fdec5
+timestamp: 2025-10-06 06:37:45Z
+commit: ae4ac7f
 author: galph
 Active Focus: [CLI-FLAGS-003] Phase H3 lattice mismatch diagnosis
+Summary: Prove the pix0-driven lattice divergence and log an evidence-backed fix plan before touching detector code.
+Phase: Evidence
+Focus: CLI-FLAGS-003
+Branch: feature/spec-based-2
+Mapped tests: pytest --collect-only -q
+Artifacts: reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.log; reports/2025-10-cli-flags/phase_h/pix0_reproduction.md; reports/2025-10-cli-flags/phase_h/attempt_log.txt
 
-Do Now: [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm — run `env KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py > reports/2025-10-cli-flags/phase_h/trace_py_after_H3.log 2> reports/2025-10-cli-flags/phase_h/trace_py_after_H3.stderr`; finish with `pytest --collect-only -q`
-If Blocked: Capture the failing stdout/stderr, append a short note to `reports/2025-10-cli-flags/phase_h/attempt_log.txt`, and diff against `trace_py_after_H2.log` to pinpoint where execution diverged before asking for guidance.
[2025-10-06T06:39:51] tokens used: 115,126
[2025-10-06T06:39:51] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:54] thinking

**Preparing to commit changes**
[2025-10-06T06:39:54] exec bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:55] bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' succeeded in 672ms:

[2025-10-06T06:39:55] tokens used: 118,322
[2025-10-06T06:39:55] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:39:56] thinking

**Verifying staged changes**
[2025-10-06T06:39:57] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:39:58] bash -lc 'git status --short' succeeded in 713ms:
M  docs/fix_plan.md
M  galph_memory.md
M  input.md
M  plans/active/cli-noise-pix0/plan.md
[2025-10-06T06:39:58] tokens used: 118,556
[2025-10-06T06:39:58] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:40:00] thinking

**Preparing commit message**
[2025-10-06T06:40:01] exec bash -lc 'git commit -m "SUPERVISOR: CLI H3 evidence plan refresh - tests: not run"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:40:01] bash -lc 'git commit -m "SUPERVISOR: CLI H3 evidence plan refresh - tests: not run"' succeeded in 702ms:
[feature/spec-based-2 88092d3] SUPERVISOR: CLI H3 evidence plan refresh - tests: not run
 4 files changed, 128 insertions(+), 58 deletions(-)
[2025-10-06T06:40:01] tokens used: 118,794
[2025-10-06T06:40:01] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:40:03] thinking

**Pushing changes to repository**
[2025-10-06T06:40:03] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T06:40:06] bash -lc 'git push' succeeded in 2.13s:
To github.com:hoidn/nanoBragg.git
   ae4ac7f..88092d3  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T06:40:06] tokens used: 119,074
[2025-10-06T06:40:06] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)


[2025-10-06T06:40:16] thinking

**Summarizing final response content**

I'll organize a clear, structured final message covering completed tasks, deep analysis with hypotheses and triage outcomes, plan updates, relevant file references, and suggested next steps—all while keeping the tone friendly and concise as instructed.
[2025-10-06T06:40:17] codex

**Status**
- Updated phase goals and H3 guidance in `plans/active/cli-noise-pix0/plan.md:91` to focus on reproducing C’s BEAM-pivot pix0 transform, tightening exit criteria, and cleaning the attempt log before any detector edits.
- Refreshed `[CLI-FLAGS-003]` Next Actions in `docs/fix_plan.md:455` so Ralph captures the pix0 delta, propagates it through pixel/scattering math, and restores `reports/2025-10-cli-flags/phase_h/attempt_log.txt` with a real Attempt #21 entry.
- Logged the supervision outcome in `galph_memory.md:1059` and rewrote `input.md` with today’s evidence-only Do Now, detailed commands, and guardrails.
- No tests were run (evidence loop); instructions direct Ralph to execute only `pytest --collect-only -q` after gathering artifacts.

**Hypotheses & Triage**
- Detector pix0 override skips the BEAM-pivot transform (confidence: high). Trace diff `reports/2025-10-cli-flags/phase_h/trace_diff_after_H2.log` shows the PyTorch pix0 lags the C result by ≈1.14 mm; reproduced in plan/docs. Next confirming step: run the new pix0 reconstruction snippet and log the deltas (`pix0_reproduction.md`).
- Pixel coordinates inherit the pix0 error (confidence: high). Diff reveals ~0.14 m offsets in `pixel_pos_meters`; next step is to compute pixel positions for both vectors inside the reproduction notebook and quantify the shift.
- Miller indices diverge because of the bad pixel geometry, not sincg (confidence: high). Manual sincg experiment already matched; next step is to propagate both scattering vectors to h/k/l in the reproduction output and document the first divergence line in `implementation_notes.md`.

**Ralph Review (coin = heads)**
- Examined the latest engineer commits (`ce28187`, `4e0e36e`); both were disciplined evidence captures with no regressions. Good focus on traces and documentation; upcoming loop should keep momentum by quantifying the pix0-driven deltas and fixing the attempt log.

**Next Steps**
1. Execute the commands in the new `input.md` (trace refresh, pix0 reproduction, pytest collect) and rewrite Attempt #21 accordingly.
2. Draft the detector override fix plan inside `implementation_notes.md`, then proceed to Phase H4 parity once the evidence set is complete.

No tests run.
[2025-10-06T06:40:24] tokens used: 120,280
[2025-10-06T06:40:24] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index cee52445ca27536008a8b7b62382c3fbfa56ab3f..93d21fc53f22077a148a9dd6ba6e978295a1ca12
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,7 +455,7 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions: (1) Drive plan Phase H3 by replaying `reports/2025-10-cli-flags/phase_h/trace_harness.py`, reproducing the C `sincg(M_PI*h, Na)` values, and confirming the PyTorch lattice path still feeds `(h-h0)` (log hypotheses + proposed fix/test plan in `phase_h/implementation_notes.md`); (2) After correcting the lattice calculation, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (3) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
+- Next Actions: (1) Complete Phase H3 evidence by re-running `reports/2025-10-cli-flags/phase_h/trace_harness.py` and reproducing C’s BEAM-pivot pix0 calculation in a scratch script (`phase_h/pix0_reproduction.md`) to show the ~1.14 mm delta between C’s transformed pix0 and the raw PyTorch override; (2) Propagate both pix0 vectors through pixel position → scattering vector → Miller index math, documenting the first divergence plus proposed detector-side fix plan in `phase_h/implementation_notes.md` and restoring `phase_h/attempt_log.txt` with a proper Attempt #21 entry (pytest output currently clobbered it); (3) After the detector fix is staged, execute Phase H4 parity smoke (polarization disabled) and archive <0.5% `F_latt` deltas + <10× intensity gap under `phase_h/parity_after_lattice_fix/`, updating the Attempt log; (4) With lattice settled, resume Phase I polarization alignment (I1–I3) and the follow-on cleanup (e.g., removing `scaled.hkl.1`).
 - Attempts History:
   * [2025-10-05] Phase A Complete — Tasks A1-A3 executed per plan.
     Metrics: C reference behavior captured for both flags via parallel command execution.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 0d00d29fcb0e84a457f18be6a4dac35b18a92e03..79a85644f5ccdcacd408eb13c7db50d455275dce
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -91,13 +91,13 @@
 ### Phase H — Lattice Structure Factor Alignment
 Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
-Exit Criteria: Trace comparison shows `h`, `k`, `l` fractional components within 1e-3 of C, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
+Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
 | H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
 | H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
-| H3 | Diagnose & fix residual lattice mismatch | [ ] | Re-run `phase_h/trace_harness.py` after H2, then reproduce the C-side `sincg(M_PI*h, Na)` numbers in a scratch harness (store under `phase_h/manual_sincg.md`). Inspect `src/nanobrag_torch/simulator.py` (lines ~210-225) to confirm the PyTorch path is using `(h-h0)` instead of the absolute fractional `h`; document findings plus any Na/Nb/Nc scaling checks in `phase_h/implementation_notes.md`. Close with a proposed fix/test plan that preserves vectorization + device neutrality before code edits begin. |
+| H3 | Diagnose & fix residual lattice mismatch | [ ] | Capture fresh PyTorch trace output (`trace_py_after_H3.log`), then rebuild the C BEAM-pivot pix0 computation in a scratch notebook (`phase_h/pix0_reproduction.md`) using the supervisor CLI parameters. Show numerically that PyTorch’s raw `pix0_override_m` differs by ~1.14 mm from C’s transformed vector, propagate both through the pixel position and scattering vector calculations, and update `phase_h/implementation_notes.md` with the confirmed first divergence and proposed detector-side fix plan. Include an explicit TODO to restore `phase_h/attempt_log.txt` (currently clobbered by pytest output) with a human-readable Attempt #21 entry before requesting code changes. |
 | H4 | Validate lattice parity | [ ] | Once the fix is staged, rerun the supervisor command with polarization disabled; capture aligned traces, `F_latt` comparisons (<0.5% delta), and intensity ratios (<10×) under `phase_h/parity_after_lattice_fix/`. Update docs/fix_plan Attempt log with metrics and attach any targeted pytest node you leverage. |
 
 ### Phase I — Polarization Alignment (follow-up)

Reading prompt from stdin...
Already up to date.
To github.com:hoidn/nanoBragg.git
   88092d3..2c30055  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=24...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=24
Updating 2c30055..6b4ae59
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   2c30055..6b4ae59  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=24
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 6b4ae59..0f18548
Fast-forward
 docs/fix_plan.md                                   |  18 +
 reports/2025-10-cli-flags/phase_h/attempt_log.txt  |  65 ++-
 .../phase_h/implementation_notes.md                |  78 +++
 .../2025-10-cli-flags/phase_h/pix0_reproduction.md |  23 +
 .../phase_h/pytest_collect_refresh.log             | 637 +++++++++++++++++++++
 .../phase_h/trace_py_after_H3_refresh.log          |  49 ++
 .../phase_h/trace_py_after_H3_refresh.stderr       |   2 +
 7 files changed, 870 insertions(+), 2 deletions(-)
 create mode 100644 reports/2025-10-cli-flags/phase_h/pix0_reproduction.md
 create mode 100644 reports/2025-10-cli-flags/phase_h/pytest_collect_refresh.log
 create mode 100644 reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.log
 create mode 100644 reports/2025-10-cli-flags/phase_h/trace_py_after_H3_refresh.stderr
From github.com:hoidn/nanoBragg
   6b4ae59..0f18548  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 0f18548..e26f8c6
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   0f18548..e26f8c6  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=25
Ralph completed iteration 24; proceeding to 25
