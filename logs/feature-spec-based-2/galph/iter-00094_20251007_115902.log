Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=94
To github.com:hoidn/nanoBragg.git
   4938d95..acde53e  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-07T11:59:07] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-07T11:59:07] User instructions:
<role>
planning, review and analysis. do not make implementation code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly, for multiple iterations. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

During the main, central phase of invocation you will be doing essentially three things:
<main analysis step 1> 
An initial analysis pass in which you gather and review information in order to choose a <focus issue> for the turn, corresponding to <instructions> steps <0> through <3>. This will involve a multi-category selection process. You will choose both a <focus issue> and an associated <Action type> for the remainder of the iteration. The available <Action type>s are the following:
<Action type> list:
<1>
<Evidence collection> (i.e. Evidence task)
No full pytest runs. Allowed: non-mutating probes and CLI validation tools (e.g., scripts/validation/*, nb-compare, pixel trace); pytest --collect-only to validate selectors; and in TDD mode only, a single targeted pytest run to confirm the newly authored test fails. Do not change production code. This gate applies only to galph. Ralph is exempt. Do not include any Phase label in input.md.

Evidence collection includes the following subtype:
    Callchain Tracing (Evidence subtype)
    - When to use: before code edits when the pipeline/factor order relevant to the current issue is unclear; when onboarding a new surface; or upon parity failures where the locus is unknown.
    - Directive: first, emit descriptions for the following things:
       - <analysis_question> (required): Free‑text description of the behavior/bug/perf issue to investigate. This will be closely related to <focus issue>, but viewed from the point of view of relevant code execution paths and their entry points.
       - <initiative_id> and <scope_hints> 

    - Directive: then read and carefully follow the instructions in `prompts/callchain.md` with the question‑driven invocation (<analysis_question>) and produce standardized artifacts under `reports/<initiative_id>/`.
    - Example invocation variables (fill at run time):
      analysis_question: "<what are we trying to understand or fix?>"
      initiative_id: "<short‑slug>"
      scope_hints: ["CLI flags", "normalization", "scaling"]
      roi_hint: "<minimal input/ROI>"
      namespace_filter: "<project primary package>"
      time_budget_minutes: 30
    - Expected outputs:
      - `reports/<initiative_id>/callchain/static.md` (entry→sink with file:line anchors)
      - `reports/<initiative_id>/callgraph/dynamic.txt` (optional, module‑filtered)
      - `reports/<initiative_id>/trace/tap_points.md` (proposed numeric taps with owners)
      - `reports/<initiative_id>/summary.md` (question‑oriented narrative + next steps)
      - `reports/<initiative_id>/env/trace_env.json`
    - Guardrails: evidence‑only (no prod edits), module/device/dtype neutrality, small ROI, respect Protected Assets, stable key names in traces.
</Evidence collection>
</1>
<2>
<Debug> i.e. Debugging — Hypothesis + Triage (initial pass):
- pairs with <focus issue>s that are related to debugging or parity analysis.
<steps>
- Formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</steps>
</Debug>
</2>
<3>
<Planning>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‑line rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance (including API / document / artifact / source file references) |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</Planning>
</3>

<4>
<Review or housekeeping>
- Review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</Review or housekeeping>
</4>

In addition to selecting an <Action type> and <focus issue> you will choose a <Mode> flag. 
 - Mode flags are combinable and refine execution, and are applicable to both the supervisor (you) and ralph; do not include any Phase label in input.md.
 - available modes: <TDD | Parity | Perf | Docs | none>
<mode descriptions>
TDD mode (supervisor-scoped): When operating in supervisor evidence mode, author/update a single minimal failing test that encodes the acceptance criterion. Confirm it fails via a targeted pytest selector; record the selector and expected failure text in input.md. Do not change production code, and do not include any Phase label in input.md.
</mode descriptions>

</main analysis step 1>

<main analysis step 2>
Here you will do a deep analysis. You will follow the guidelines of the selected <Mode> and <Action type>, applying them to the selected <focus issue>. This corresponds to <instructions> step <3.2>.


</main analysis step 2>

<main analysis step 3>
Here you synthesize the analysis findings into output files (<instructions> steps <3.5> to <4>)
</main analysis step 3>


Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 
At this point, you can do a premature <Callchain tracing> action ahead of time, if it helps you gather information needed for this analysis.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
This plan-related work is now your <focus issue>.
You will be following the <Planning> <Action type> instructions. Think about what this will entail but don't execute the <Planning> instructions yet.
</yes case>
</no case>
Since you are not <Planning>, you must select one of the other <Action type>s and an associated <focus issue> based on what you think is the most productive work increment for this iteration. Think about the associated work, but don't execute it yet.
</no case>
</3>
<3.2>
- Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for the impending analysis.
- Then carefully follow the guidelines of the selected <Mode> and <Action type>, applying them to the selected <focus issue>. Complete the task that you selected in step <3>.
</3.2>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
Header:
- Summary: <one‑sentence goal for this loop>
 - Mode: <TDD | Parity | Perf | Docs | none>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
  - Note: If operating in supervisor <Evidence collection> (internal-only), do not run the full suite. Allowed: pytest --collect-only to validate selectors; in TDD mode only, run one targeted selector to confirm a new failing test. All other test execution is deferred to Ralph. Do not include any Phase label in input.md.
<Do Now guidelines>
Verification scripts: You may run nb-compare and scripts/validation/* to collect metrics and artifacts (no code changes). Record outputs under reports/.
Mapped tests under supervisor evidence mode: Include exact selectors in input.md; validate with --collect-only; do not run them (except the TDD failure confirmation). Do not include any Phase label in input.md.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
Implementation: refer to phased plans, checklists, and all associated artifacts
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
 </3.5>

<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>, while keeping in mind the <task> directives.


[2025-10-07T11:59:10] thinking

**Preparing to run git pull with rebase**
[2025-10-07T11:59:12] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:14] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.31s:
Already up to date.
[2025-10-07T11:59:14] tokens used: 859

[2025-10-07T11:59:16] thinking

**Reviewing galph_memory.md next**
[2025-10-07T11:59:17] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:17] bash -lc 'cat galph_memory.md' succeeded in 697ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-07T11:59:17] tokens used: 1,049

[2025-10-07T11:59:22] thinking

**Preparing to read key documentation**
[2025-10-07T11:59:23] exec bash -lc 'cat docs/index.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:24] bash -lc 'cat docs/index.md' succeeded in 672ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-07T11:59:24] tokens used: 3,895

[2025-10-07T11:59:25] thinking

**Moving to next spec file**
[2025-10-07T11:59:25] exec bash -lc 'cat specs/spec-a.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:26] bash -lc 'cat specs/spec-a.md' succeeded in 705ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-07T11:59:26] tokens used: 5,549

[2025-10-07T11:59:28] thinking

**Planning spec review**
[2025-10-07T11:59:28] exec bash -lc 'cat arch.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:29] bash -lc 'cat arch.md' succeeded in 713ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-07T11:59:29] tokens used: 24,305

[2025-10-07T11:59:30] thinking

**Checking configuration documentation**
[2025-10-07T11:59:31] exec bash -lc 'cat docs/development/c_to_pytorch_config_map.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:32] bash -lc 'cat docs/development/c_to_pytorch_config_map.md' succeeded in 683ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-07T11:59:32] tokens used: 27,029

[2025-10-07T11:59:33] thinking

**Opening debugging documentation**
[2025-10-07T11:59:35] exec bash -lc 'cat docs/debugging/debugging.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:36] bash -lc 'cat docs/debugging/debugging.md' succeeded in 711ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-07T11:59:36] tokens used: 28,990

[2025-10-07T11:59:38] thinking

**Checking fix_plan.md location**
[2025-10-07T11:59:39] exec bash -lc 'wc -l docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:39] bash -lc 'wc -l docs/fix_plan.md' succeeded in 715ms:
    2101 docs/fix_plan.md
[2025-10-07T11:59:39] tokens used: 31,377

[2025-10-07T11:59:43] thinking

**Planning to read relevant sections**
[2025-10-07T11:59:44] exec bash -lc 'cat docs/development/testing_strategy.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:44] bash -lc 'cat docs/development/testing_strategy.md' succeeded in 686ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-07T11:59:44] tokens used: 38,682

[2025-10-07T11:59:46] thinking

**Reviewing fix_plan selectively**
[2025-10-07T11:59:47] exec bash -lc "sed -n '1,200p' docs/fix_plan.md'" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:48] bash -lc "sed -n '1,200p' docs/fix_plan.md'" exited 2 in 677ms:
bash: -c: line 1: unexpected EOF while looking for matching `''
[2025-10-07T11:59:48] tokens used: 41,221

[2025-10-07T11:59:49] thinking

**Fixing string escape issue**
[2025-10-07T11:59:50] exec bash -lc "sed -n '1,200p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:51] bash -lc "sed -n '1,200p' docs/fix_plan.md" succeeded in 726ms:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A–C) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2–B4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1–A3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ✅ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_progress |
| [ABS-OVERSAMPLE-001](#abs-oversample-001-fix-oversample_thick-subpixel-absorption) | Fix -oversample_thick subpixel absorption | High | in_planning |
[2025-10-07T11:59:51] tokens used: 41,474

[2025-10-07T11:59:55] thinking

**Locating relevant CLI flags section**
[2025-10-07T11:59:55] exec bash -lc 'rg -n "CLI-FLAGS-003" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:56] bash -lc 'rg -n "CLI-FLAGS-003" -n docs/fix_plan.md' succeeded in 728ms:
22:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
450:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
[2025-10-07T11:59:56] tokens used: 44,559
[2025-10-07T11:59:58] exec bash -lc "sed -n '450,650p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T11:59:59] bash -lc "sed -n '450,650p' docs/fix_plan.md" succeeded in 737ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A–H complete; K3a/K3b/K3d landed via Attempts #43–44, pending per-φ evidence + normalization closure)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
- Next Actions (2025-11-20 refresh → updated by galph):
  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
- Attempts History:
  * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
    Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
    Artifacts:
      - `src/nanobrag_torch/simulator.py:1313-1322` - Spindle instrumentation (emit raw/normalized/magnitude)
      - `reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_rot_vector.log` - Refreshed φ=0 trace with spindle data
[2025-10-07T11:59:59] tokens used: 44,762

[2025-10-07T12:00:03] thinking

**Preparing for deep code analysis**

I’m going to review the `plans/active` directory first to gather relevant information before starting a deep analysis of the codebase in relation to the long-term goals. I’ll focus on the CLI flags plan under `plans/active/cli-noise-pix0/plan.md` to align my understanding with the instructions.
[2025-10-07T12:00:04] exec bash -lc 'cat plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:05] bash -lc 'cat plans/active/cli-noise-pix0/plan.md' succeeded in 803ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
- Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
- Gap snapshot refresh (2025-11-09): Attempt #49 closed Phase K3g3 — `tests/test_cli_scaling.py::test_f_latt_square_matches_c` now passes after isolating the HKL cache, but the full supervisor command still shows correlation ≈ 0.9965 and sum_ratio ≈ 1.26×10⁵. Need fresh HKL/normalization parity evidence (Phase L) before rerunning nb-compare.
- Gap snapshot refresh (2025-11-10): Attempt #56 (evidence loop) proved the existing `TRACE_PY` path prints placeholder scaling data (`capture_fraction 1`, `polar 1.0`, `steps`=φ-steps only). Without exposing the real per-pixel factors computed in `Simulator.run`, Phase L2b cannot produce a trustworthy PyTorch trace. Instrumentation must pull actual values from `_apply_detector_absorption`, polarization kernels, and total-step calculation before rerunning the harness.
- Gap snapshot update (2025-10-17): Attempt #53 (Phase L1c) realigned HKL Fdump I/O with C padding (`read_fdump`/`write_fdump`) and added regression coverage (`TestHKLFdumpParity::test_scaled_hkl_roundtrip`) with max |ΔF| = 0.0. Proceed to L1d to regenerate parity metrics before reviving scaling traces.
- Gap snapshot update (2025-11-11): Discovered the trace harness omitted `-beam_vector`, `-flux`, and `-beamsize`, forcing oversample=4 and a +Z beam; Py traces zeroed `F_cell` and inflated `steps`. Marked unresolved pending harness fix.
- Gap snapshot refresh (2025-11-12): Attempt #66 (commit 1d2e6ac) completed Phase L2b0 — the trace harness now feeds the full supervisor flag set, and the refreshed `trace_py_scaling.log` confirms `steps=10`, `fluence≈1.0e24`, and `r_e^2` parity with C. TRACE_PY still reports `I_before_scaling NOT_EXTRACTED`, `polar=0`, and `I_pixel_final=0`, so Phase L2b instrumentation must surface the real polarization/absorption tensors before we can quantify the K3e k_frac drift.
- Gap snapshot update (2025-11-13): Latest harness rerun aborted because `trace_harness.py` still expected the legacy `read_hkl_file` return tuple (see `trace_py_fullrun.log`). **Resolved in Attempt #74, which updated the harness to the `(F_grid, metadata)` signature.**
- Gap snapshot refresh (2025-11-14): Attempt #73 showed `Crystal.hkl_data` unset (leading to `F_cell=0`), keeping L2b open; **Attempt #74 fixed this by wiring the HKL tensor/metadata before Simulator construction.**
- Gap snapshot refresh (2025-11-15): Attempts #69/#71/#74 finished Phase L2 — TRACE_PY now reports real scaling factors, `scaling_audit_summary.md` flags `I_before_scaling` as the lone divergence, and C shows `F_cell=190.27` for hkl=(-7,-1,-14) while PyTorch remains at 0. Next phase focuses on understanding how C derives that amplitude (likely via generated `Fdump.bin`) before touching normalization code.
- Gap snapshot refresh (2025-11-17): Attempt #77 reran Phase L3a probe on the current workstation, logged `probe_20251117.log` (F_cell=190.270004 for hkl=(-7,-1,-14)), and confirmed scaled.hkl already covers the supervisor reflection. Remaining blockers shift to wiring that data through the harness/CLI path (Phase L3c onward).
- Gap snapshot update (2025-11-17 late): Attempt #78 completed the Phase L3c harness rerun; TRACE_PY now reports F_cell=190.27 with matching metadata, so the immediate focus moves to auditing CLI ingestion (L3c) and adding regression coverage (L3d).
[2025-10-07T12:00:05] tokens used: 54,001

[2025-10-07T12:00:09] thinking

**Beginning long-term goal analysis**
[2025-10-07T12:00:09] exec bash -lc 'cat plans/active/vectorization.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:10] bash -lc 'cat plans/active/vectorization.md' succeeded in 720ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md.
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.
- Gap Snapshot (2025-11-18): Phase A1–A3 evidence captured under `reports/2025-10-vectorization/phase_a/` (pytest logs plus tricubic/absorption baselines). **Phase B design memo landed in Attempt #3 (`reports/2025-10-vectorization/phase_b/design_notes.md`) covering tensor shapes, polynomial mapping, and gradient/device checklists.** Next blocker is executing Phase C implementation tasks using that design as the contract.
- Supervisory note (2025-11-18 → refreshed 2025-11-18b): fix_plan#VECTOR-TRICUBIC-001 now pivots to Phase C execution (tasks C1–C3). Keep `KMP_DUPLICATE_LIB_OK=TRUE` exported, reuse the design memo’s Section 2/3 diagrams, and stage changes behind feature-flag-friendly commits to ease review if batching becomes necessary.
- Gap snapshot refresh (2025-11-20): No code changes have landed since the design memo; Phase C remains unstarted. The updated guidance below locks in artifact destinations (`reports/2025-10-vectorization/phase_c/`) and reproduction commands so Ralph can take the first implementation step without further supervisor clarification.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [D] | ✅ Completed 2025-10-06 (`reports/2025-10-vectorization/phase_a/test_at_str_002.log`, `.collect.log`, `test_at_abs_001.log`, `env.json`). Re-run only if dependencies change or new warnings appear. |
| A2 | Measure current tricubic runtime | [D] | ✅ Completed 2025-10-07 (`scripts/benchmarks/tricubic_baseline.py` created; CPU & CUDA baselines captured in `phase_a/tricubic_baseline.md` and `phase_a/tricubic_baseline_results.json`). Key finding: scalar-only implementation @ ~1.4 ms/call (CPU), ~5.5 ms/call (CUDA). |
| A3 | Record detector absorption baseline | [D] | ✅ Completed 2025-10-07 (`scripts/benchmarks/absorption_baseline.py` created; CPU & CUDA baselines captured in `phase_a/absorption_baseline.md` and `phase_a/absorption_baseline_results.json`). GPU shows 5.4× speedup for 512² detector. |

### Phase B — Tricubic Vectorization Design
[2025-10-07T12:00:10] tokens used: 57,098

[2025-10-07T12:00:12] thinking

**Checking if file ends**
[2025-10-07T12:00:12] exec bash -lc "sed -n '120,240p' plans/active/vectorization.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:13] bash -lc "sed -n '120,240p' plans/active/vectorization.md" succeeded in 704ms:

[2025-10-07T12:00:13] tokens used: 58,533

[2025-10-07T12:00:17] thinking

**Checking file end for truncation**
[2025-10-07T12:00:18] exec bash -lc 'tail -n 20 plans/active/vectorization.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:18] bash -lc 'tail -n 20 plans/active/vectorization.md' succeeded in 777ms:
### Phase F — Detector Absorption Vectorization
Goal: Apply the same vectorization discipline to `_apply_detector_absorption`, eliminating Python loops over `thicksteps` while preserving physics.
Prereqs: Phase E validated so tricubic changes are stable; absorption baseline from Phase A available.
Exit Criteria: Vectorized absorption path merged, tests updated, and performance improvements documented similar to tricubic work.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| F1 | Refresh design notes | [ ] | Append absorption section to `design_notes.md` describing tensor shapes (`(T,S,F)`), numerical stability considerations, and potential reuse of exponential precomputation. |
| F2 | Implement vectorized absorption | [ ] | Modify `_apply_detector_absorption` to broadcast layer indices and parallax tensors as described; maintain differentiability and device neutrality. Record implementation notes in `phase_f/implementation.md`. |
| F3 | Validate & benchmark | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v` plus microbenchmark update; capture results under `phase_f/summary.md` comparing against Phase A data. |

### Phase G — Documentation & Closure
Goal: Ensure documentation, plans, and fix_plan reflect the new vectorized behavior and that artifacts are archived.
Prereqs: Phases A–F complete.
Exit Criteria: Plan archived or marked complete, docs updated, and fix_plan entry closed.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| G1 | Update documentation | [ ] | Revise `docs/architecture/pytorch_design.md` (vectorization subsections) and `docs/development/pytorch_runtime_checklist.md` with the new expectations; note script locations in `docs/development/testing_strategy.md`. |
| G2 | Close planning artifacts | [ ] | Move key reports to `reports/archive/` (retain relative paths), update docs/fix_plan.md Attempts with final metrics, and archive this plan per SOP. |
[2025-10-07T12:00:18] tokens used: 58,725

[2025-10-07T12:00:21] thinking

**Checking for truncated content**
[2025-10-07T12:00:21] exec bash -lc 'cat -n plans/active/vectorization.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:22] bash -lc 'cat -n plans/active/vectorization.md' succeeded in 687ms:
     1	## Context
     2	- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md.
     3	- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
     4	- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.
     5	- Gap Snapshot (2025-11-18): Phase A1–A3 evidence captured under `reports/2025-10-vectorization/phase_a/` (pytest logs plus tricubic/absorption baselines). **Phase B design memo landed in Attempt #3 (`reports/2025-10-vectorization/phase_b/design_notes.md`) covering tensor shapes, polynomial mapping, and gradient/device checklists.** Next blocker is executing Phase C implementation tasks using that design as the contract.
     6	- Supervisory note (2025-11-18 → refreshed 2025-11-18b): fix_plan#VECTOR-TRICUBIC-001 now pivots to Phase C execution (tasks C1–C3). Keep `KMP_DUPLICATE_LIB_OK=TRUE` exported, reuse the design memo’s Section 2/3 diagrams, and stage changes behind feature-flag-friendly commits to ease review if batching becomes necessary.
     7	- Gap snapshot refresh (2025-11-20): No code changes have landed since the design memo; Phase C remains unstarted. The updated guidance below locks in artifact destinations (`reports/2025-10-vectorization/phase_c/`) and reproduction commands so Ralph can take the first implementation step without further supervisor clarification.
     8	
     9	### Phase A — Evidence & Baseline Capture
    10	Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
    11	Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
    12	Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.
    13	
    14	| ID | Task Description | State | How/Why & Guidance |
    15	| --- | --- | --- | --- |
    16	| A1 | Re-run tricubic acceptance tests | [D] | ✅ Completed 2025-10-06 (`reports/2025-10-vectorization/phase_a/test_at_str_002.log`, `.collect.log`, `test_at_abs_001.log`, `env.json`). Re-run only if dependencies change or new warnings appear. |
    17	| A2 | Measure current tricubic runtime | [D] | ✅ Completed 2025-10-07 (`scripts/benchmarks/tricubic_baseline.py` created; CPU & CUDA baselines captured in `phase_a/tricubic_baseline.md` and `phase_a/tricubic_baseline_results.json`). Key finding: scalar-only implementation @ ~1.4 ms/call (CPU), ~5.5 ms/call (CUDA). |
    18	| A3 | Record detector absorption baseline | [D] | ✅ Completed 2025-10-07 (`scripts/benchmarks/absorption_baseline.py` created; CPU & CUDA baselines captured in `phase_a/absorption_baseline.md` and `phase_a/absorption_baseline_results.json`). GPU shows 5.4× speedup for 512² detector. |
    19	
    20	### Phase B — Tricubic Vectorization Design
[2025-10-07T12:00:22] tokens used: 67,009

[2025-10-07T12:00:29] thinking

**Investigating CLI output truncation**

I’m noticing that the cat command’s output is truncated around line 31, showing “[... omitted 0 of 84 lines ...]”, which suggests the CLI is auto-limiting output size to avoid overwhelming display. It looks like this happens even though the file has about 200 lines. To see the full range of lines without truncation, I’m planning to use sed with a specific line range like ‘sed -n 31,90p’ to bypass the CLI’s summary and get a clearer view.
[2025-10-07T12:00:31] exec bash -lc "sed -n '31,120p' plans/active/vectorization.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:32] bash -lc "sed -n '31,120p' plans/active/vectorization.md" succeeded in 674ms:
### Phase C — Implementation: Neighborhood Gather
Goal: Replace scalar neighbor gathering with fully batched advanced indexing inside `Crystal._tricubic_interpolation` while keeping fallbacks for out-of-range queries.
Prereqs: Phase B design finalized; create feature branch per SOP if needed.
Exit Criteria: Vectorized gather merged, unit tests covering neighborhood assembly added, and plan task C1–C3 marked done with artifact references.
Implementation notes: capture all Phase C artifacts under `reports/2025-10-vectorization/phase_c/` (see table for filenames). Confirm every new test collects via `pytest --collect-only` before running the selector.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| C1 | Implement batched neighborhood gather | [D] | ✅ Completed 2025-10-17 (Attempt #5). Batched gather infrastructure validated; all tests passing. Artifacts: `reports/2025-10-vectorization/phase_c/{gather_notes.md, collect_log.txt, test_*.log, diff_snapshot.json, runtime_probe.json}`. Scalar path (B=1) uses existing polin3; batched path (B>1) falls back to nearest-neighbor pending Phase D. |
| C2 | Preserve fallback semantics | [ ] | Maintain existing out-of-bounds detection and warning (single emission); add/extend regression `tests/test_tricubic_vectorized.py::test_oob_warning_single_fire` that forces one OOB lookup and asserts interpolation disables thereafter. Record test logs in `phase_c/test_tricubic_vectorized.log` (`pytest -k oob_warning -v`). |
| C3 | Add shape assertions & cache hooks | [ ] | Introduce lightweight assertions to catch unexpected shapes; ensure caches remain device-aware (use `.type_as` instead of `.cpu()`). Summarize tensor shapes + cache invalidation rules in `phase_c/implementation_notes.md`, and include `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py::test_tricubic_interpolation_enabled -v` output once assertions are in place. |

### Phase D — Implementation: Polynomial Evaluation
Goal: Vectorize `polint`, `polin2`, and `polin3` so they consume batches from Phase C without Python loops.
Prereqs: Phase C merged or staged with passing tests.
Exit Criteria: All polynomial helpers accept batched tensors, no Python loops over pixels remain, and helper-level unit tests exist.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| D1 | Vectorize `polint` | [ ] | Rewrite using tensor broadcasting; support trailing batch dims and ensure numerical stability matches C (consider Kahan-style compensation if necessary). Add regression test in `tests/test_tricubic_vectorized.py::test_polint_vectorized_matches_scalar`. |
[2025-10-07T12:00:32] tokens used: 68,850

[2025-10-07T12:00:36] thinking

**Analyzing long-term goals and gaps**

I'm mapping out the current state and missing elements for CLI flag support and vectorization goals. I'll dig into fix plans and related docs to identify what’s done, what’s missing, and what needs coordination to push these features forward.
[2025-10-07T12:00:37] exec bash -lc 'cat plans/active/gradcheck-tier2-completion/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:38] bash -lc 'cat plans/active/gradcheck-tier2-completion/plan.md' succeeded in 790ms:
# Plan: AT-TIER2-GRADCHECK Completion

**Status:** Active (new 2025-10-15)
**Priority:** High — spec compliance blocker (testing_strategy §4.1)
**Related fix_plan item:** `[AT-TIER2-GRADCHECK]` — docs/fix_plan.md
**Created:** 2025-10-15 by galph

## Context
- Initiative: Ensure differentiability guarantees (long-term goal: autodiff-based refinement showcase).
- Phase Goal: Close the remaining Tier-2 gradcheck gaps called out in testing_strategy.md §4.1: `misset_rot_x`, beam `lambda_A`, and `fluence`.
- Current State: Commit 0e3054c implemented gradchecks for unit-cell lengths/angles and detector distance/beam_center_f. Commit d45a0f3 introduced `NANOBRAGG_DISABLE_COMPILE` to work around torch.compile bugs. However, no coverage exists yet for misset rotations or beam parameters, and the harness still emits contradictory compile-mode toggles (`NB_DISABLE_COMPILE` vs `NANOBRAGG_DISABLE_COMPILE`). The spec remains unmet.
- Dependencies: `tests/test_gradients.py`, `tests/test_suite.py::TestTier2GradientCorrectness`, `docs/development/testing_strategy.md §4.1`, `arch.md §15`, perf plan task B7 (env-var alignment for compile toggles).

### Phase A — Baseline Audit & Environment Alignment
Goal: Capture authoritative evidence of current coverage gaps and ensure the compile-disable switch is consistent across harnesses before adding new tests.
Prereqs: None.
Exit Criteria: Audit note summarising missing parameters, baseline gradcheck log attached, and env-var naming decision recorded (either standardise on `NANOBRAGG_DISABLE_COMPILE` or support both).

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
[2025-10-07T12:00:38] tokens used: 70,761

[2025-10-07T12:00:45] thinking

**Conducting thorough codebase analysis**

I'll dig into the codebase and long-term goals to map out what’s done and what’s missing. I’m particularly interested in CLI support for `-nonoise` and `-pix0`, the state of the rotation vector fixes (L3j tasks), and vectorization plans, so I’ll check relevant source files and CLI argument parsing to get a clear picture before moving on.
[2025-10-07T12:00:47] exec bash -lc 'rg "nonoise" -n' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:48] bash -lc 'rg "nonoise" -n' succeeded in 800ms:
noisify.c:247:            if(strstr(argv[i], "-nonoise") )
src/nanobrag_torch/__main__.py:339:    parser.add_argument('-nonoise', action='store_true',
src/nanobrag_torch/__main__.py:711:    config['suppress_noise'] = args.nonoise
src/nanobrag_torch/__main__.py:1185:        # CLI-FLAGS-003: Honor -nonoise flag
context:248:            if(strstr(argv[i], "-nonoise") )
context:2276:            if(strstr(argv[i], "-nonoise") )
context:2609:        printf("\t-nonoise         \tdisable generating the noisefile\n");
context:6274:            if(strstr(argv[i], "-nonoise") )
context:8812:***-nonoise***
docs/fix_plan.md:22:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
docs/fix_plan.md:450:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
docs/fix_plan.md:457:  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
docs/fix_plan.md:458:  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
docs/fix_plan.md:1115:      - `reports/2025-10-cli-flags/phase_a/c_with_nonoise.log` - C run WITH -nonoise
docs/fix_plan.md:1116:      - `reports/2025-10-cli-flags/phase_a/c_with_noise.log` - C run WITHOUT -nonoise
docs/fix_plan.md:1120:      - `-nonoise` suppresses noise parameters section AND noise image generation (noiseimage.img not written)
docs/fix_plan.md:1121:      - Float/int/PGM images still generated when -nonoise is active
docs/fix_plan.md:1142:      - ✅ -nonoise suppresses noisefile generation (suppress_noise=True)
docs/fix_plan.md:1143:      - ✅ -nonoise doesn't mutate adc default (40.0) or seed handling
docs/fix_plan.md:1144:      - ✅ -noisefile without -nonoise enables noise generation (suppress_noise=False)
[2025-10-07T12:00:48] tokens used: 72,932

[2025-10-07T12:00:51] thinking

**Verifying no-noise feature implementation**
[2025-10-07T12:00:51] exec bash -lc 'rg "pix0_vector" -n' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:52] bash -lc 'rg "pix0_vector" -n' succeeded in 745ms:
src/nanobrag_torch/__main__.py:187:    parser.add_argument('-pix0_vector', nargs=3, type=float,
src/nanobrag_torch/__main__.py:190:    parser.add_argument('-pix0_vector_mm', nargs=3, type=float,
src/nanobrag_torch/__main__.py:462:            args.pix0_vector, args.pix0_vector_mm]):
src/nanobrag_torch/__main__.py:557:    if args.pix0_vector and args.pix0_vector_mm:
src/nanobrag_torch/__main__.py:558:        raise ValueError("Cannot specify both -pix0_vector and -pix0_vector_mm simultaneously")
src/nanobrag_torch/__main__.py:560:    if args.pix0_vector:
src/nanobrag_torch/__main__.py:561:        config['custom_pix0_vector'] = tuple(args.pix0_vector)
src/nanobrag_torch/__main__.py:562:        # pix0_vector is in meters, convert to config
src/nanobrag_torch/__main__.py:563:        config['pix0_override_m'] = tuple(args.pix0_vector)
src/nanobrag_torch/__main__.py:564:    elif args.pix0_vector_mm:
src/nanobrag_torch/__main__.py:566:        config['pix0_override_m'] = tuple(x * 0.001 for x in args.pix0_vector_mm)
src/nanobrag_torch/__main__.py:567:        config['custom_pix0_vector'] = config['pix0_override_m']
src/nanobrag_torch/simulator.py:1252:                # Output pix0_vector first
src/nanobrag_torch/simulator.py:1253:                pix0 = self.detector.pix0_vector
src/nanobrag_torch/simulator.py:1254:                print(f"TRACE_PY: pix0_vector_meters {pix0[0].item():.15g} {pix0[1].item():.15g} {pix0[2].item():.15g}")
src/nanobrag_torch/models/detector.py.backup:103:        # Calculate and cache pix0_vector (position of first pixel)
src/nanobrag_torch/models/detector.py.backup:104:        self._calculate_pix0_vector()
src/nanobrag_torch/models/detector.py.backup:113:        self._cached_pix0_vector = self.pix0_vector.clone()
src/nanobrag_torch/models/detector.py.backup:197:        # Recalculate pix0_vector when geometry changes
src/nanobrag_torch/models/detector.py.backup:198:        self._calculate_pix0_vector()
[2025-10-07T12:00:52] tokens used: 74,957

[2025-10-07T12:00:57] thinking

**Summarizing analysis and plans**
[2025-10-07T12:00:58] exec bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:00:58] bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" succeeded in 714ms:
heads
[2025-10-07T12:00:58] tokens used: 78,844

[2025-10-07T12:01:01] thinking

**Reviewing recent commit history**

I'll check the last 10 commits using `git log -10` to evaluate productivity, regressions, and feedback based on Ralph's recent work.
[2025-10-07T12:01:02] exec bash -lc 'git log -10 --oneline --decorate' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:01:02] bash -lc 'git log -10 --oneline --decorate' succeeded in 723ms:
acde53e (HEAD -> feature/spec-based-2, origin/feature/spec-based-2) [SYNC i=94] actor=galph status=running
4938d95 [SYNC i=94] actor=ralph → next=galph status=ok ralph_commit=c16e9c3
c16e9c3 CLI-FLAGS-003 Phase L3i: C MOSFLM trace & diff rules out H3
4c3f3c8 [SYNC i=93] actor=ralph status=running
60bcfce [SYNC i=93] actor=galph → next=ralph status=ok galph_commit=5872c0e
c0b2449 SUPERVISOR AUTO: doc/meta hygiene — tests: not run
5872c0e SUPERVISOR: CLI-FLAGS instrumentation plan - tests: not run
d5208fb [SYNC i=93] actor=galph status=running
9eab179 [SYNC i=93] actor=ralph → next=galph status=ok ralph_commit=8b5ab67
8b5ab67 CLI-FLAGS-003 Phase L3h: MOSFLM matrix probe evidence — ruled out Hypothesis H2
[2025-10-07T12:01:02] tokens used: 79,161

[2025-10-07T12:01:05] thinking

**Reviewing specific contributor commits**
[2025-10-07T12:01:05] exec bash -lc 'git show --stat c16e9c3' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:01:06] bash -lc 'git show --stat c16e9c3' succeeded in 712ms:
commit c16e9c360997e51bf3ee3e29331c55a6c8b4c67e
Author: ollie <ohoidn>
Date:   Tue Oct 7 04:57:54 2025 -0700

    CLI-FLAGS-003 Phase L3i: C MOSFLM trace & diff rules out H3
    
    - Captured full C MOSFLM pipeline trace (291 lines) using existing instrumentation in golden_suite_generator/nanoBragg.c:2050-2199
    - Executed supervisor command, performed component-level diff vs Phase L3h PyTorch probe
    - Key finding: H3 (MOSFLM transpose hypothesis) RULED OUT - real-space b_Y matches within float32 precision (Δ=1.35e-07 Å, 0.00002%)
    - Artifacts: c_trace_mosflm.log, c_trace_extract.txt, mosflm_matrix_diff.md, updated analysis.md with H5-H7 hypotheses
    - Test collection: 652 tests passed
    - Next: Phase L3j fix checklist focusing on H5 (phi rotation verification)
    
    pytest --collect-only: 652 passed / 0 skipped / 0 failed

 plans/active/cli-noise-pix0/plan.md                |   2 +-
 .../phase_l/rot_vector/analysis.md                 |  83 ++-
 .../phase_l/rot_vector/attempt_notes.md            |   8 +
 .../phase_l/rot_vector/c_trace_extract.txt         |  56 ++
 .../phase_l/rot_vector/c_trace_mosflm.log          | 291 +++++++++
[2025-10-07T12:01:06] tokens used: 79,642

[2025-10-07T12:01:08] thinking

**Reviewing earlier commit**
[2025-10-07T12:01:08] exec bash -lc 'git show --stat 8b5ab67' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:01:09] bash -lc 'git show --stat 8b5ab67' succeeded in 712ms:
commit 8b5ab672c1948454fb909e194c95efd1e82ad004
Author: ollie <ohoidn>
Date:   Tue Oct 7 04:38:42 2025 -0700

    CLI-FLAGS-003 Phase L3h: MOSFLM matrix probe evidence — ruled out Hypothesis H2
    
    Evidence-only loop per input.md (galph i=92 replayed as ralph):
    - Created trace_harness.py in rot_vector/ adapted from scaling_audit pattern
    - Captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals)
    - Proved V_formula ≈ V_actual (Δ=1.5e-11 Å³) — RULES OUT Hypothesis H2 (volume mismatch)
    - Confirmed reciprocal re-derivation exact to 15 digits (CLAUDE.md Rule #13 validated)
    - Updated analysis.md: H1/H2 ruled out, H3 (MOSFLM matrix semantics) promoted to primary suspect
    - Primary evidence: mosflm_matrix_probe.md with full methodology and findings
    
    Artifacts:
    - reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_probe.md (primary doc)
    - reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_probe_output.log (12 probe lines)
    - reports/2025-10-cli-flags/phase_l/rot_vector/trace_harness.py (harness source)
    - reports/2025-10-cli-flags/phase_l/rot_vector/harness_run.log (execution log)
    - reports/2025-10-cli-flags/phase_l/rot_vector/test_collect.log (pytest: 579 tests collected)
[2025-10-07T12:01:09] tokens used: 80,657

[2025-10-07T12:01:33] thinking

**Assessing need for plan refinement**

I'm weighing whether the current CLI fix checklist plan needs more detail to guide the complex F_latt fix properly, especially to ensure parity testing and instrumentation. It seems wise to update the plan with clear tasks and references before proceeding, so I'll next review relevant documentation to inform that update.
[2025-10-07T12:01:35] exec bash -lc 'cat specs/spec-a-cli.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:01:36] bash -lc 'cat specs/spec-a-cli.md' succeeded in 978ms:
# nanoBragg Spec A — CLI Binding

This shard documents the command-line interface, header precedence, and CLI-focused acceptance tests. It should be read alongside [spec-a-core.md](spec-a-core.md) for the simulation engine requirements and [spec-a-parallel.md](spec-a-parallel.md) for conformance profiles.

CLI Interface (Normative)

All options recognized by this code version are enumerated below. Values with units are converted
immediately as specified in Units & Conversions. Unsupported flags are not recognized even if
present in header comments.

- Input files:
    - -hkl <file>: Text file of “h k l F” (integers h,k,l; real F). Required unless Fdump.bin exists
or -default_F used.
    - -mat <file>: 3×3 MOSFLM-style A matrix (reciprocal cell vectors scaled by 1/λ). Required
unless -cell used.
    - -cell a b c alpha beta gamma: Direct cell in Å and degrees; alternative to -mat.
    - -img <file>: Read SMV header; may set fpixels, spixels, pixel size (mm), distance (mm), close
distance (mm), wavelength (Å), beam centers (mm), ORGX/ORGY (pixels), φ start (deg), oscillation
range (deg), 2θ (deg). Image data is read but not used.
    - -mask <file>: Read SMV mask; uses same headers to initialize geometry as -img. Zero-valued
[2025-10-07T12:01:36] tokens used: 82,844

[2025-10-07T12:01:43] thinking

**Reviewing plan update requirements**

I’m gathering what’s needed to update the Phase L3j plan thoroughly—checking related docs and reports to list relevant materials, expanding the task table with detailed checklist items, and ensuring tests and verification steps like doping checks and instrumentation details are included. I'll make sure the plan stays well organized and references the right artifacts before crafting the update.
[2025-10-07T12:01:44] exec bash -lc 'cat reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:01:45] bash -lc 'cat reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md' succeeded in 707ms:
# Rotation Vector φ=0 Drift Analysis

## Executive Summary

Phase L3f rotation-vector audit reveals component-level discrepancies in real-space vectors at φ=0 while reciprocal vectors remain highly aligned. Key finding: **Y-component drift in all three real-space vectors (0.04-6.8% deltas)** explains the k_frac offset observed in Phase L2c/L3e.

## Key Metrics

### Metric Duality (from invariant_probe.md)
- **Volume discrepancy**: +3.35e-03 Å³ (+0.000014%)
- **a·a* deviation**: -6.264e-04 (C=1.000626, Py=1.000000)
- **b·b* deviation**: +4.414e-04 (C=0.999559, Py=1.000000)
- **c·c* deviation**: +1.872e-04 (C=0.999813, Py=1.000000)

**Interpretation**: PyTorch achieves near-perfect metric duality (a·a* ≈ 1.0 within 7.5e-05) as required by crystallographic convention. C implementation shows O(1e-3) deviations from unity, suggesting accumulated numerical drift in the reciprocal-space recalculation pipeline.

## Component-Level Findings

### Real-Space Vector Deltas (from rot_vector_comparison.md)

[2025-10-07T12:01:45] tokens used: 86,134

[2025-10-07T12:01:49] thinking

**Updating plan with new hypotheses**

I need to revise the plan to include new hypotheses H5, H6, and H7, focusing on tasks for creating a fix checklist that references them. I’ll also specify necessary tests like the per-phi trace and include instructions for verifying the phi rotation pipeline. Before making changes, I want to review related documentation like `mosflm_matrix_correction.md` to ensure alignment.
[2025-10-07T12:01:51] exec bash -lc 'ls reports/2025-10-cli-flags/phase_l/rot_vector' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:01:52] bash -lc 'ls reports/2025-10-cli-flags/phase_l/rot_vector' succeeded in 696ms:
analysis.md
attempt_notes.md
c_trace_extract.txt
c_trace_mosflm.log
c_trace_mosflm.sha256
collect_only.log
config_snapshot.json
harness_run.log
input_files.sha256
invariant_probe.md
mosflm_matrix_correction.md
mosflm_matrix_diff.md
mosflm_matrix_probe.log
mosflm_matrix_probe.md
mosflm_matrix_probe_output.log
rot_vector_comparison.md
spindle_audit.log
spindle_probe.py
test_collect.log
trace_harness.py
[2025-10-07T12:01:52] tokens used: 89,476

[2025-10-07T12:01:55] thinking

**Opening documentation file**
[2025-10-07T12:01:56] exec bash -lc 'cat reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:01:57] bash -lc 'cat reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md' succeeded in 726ms:
# MOSFLM Matrix Correction Plan (Phase L3i)

## Observed Divergence
- Evidence runs on the supervisor command (`reports/2025-10-cli-flags/phase_l/scaling_audit/c_trace_scaling.log`, `reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_rot_vector.log`) show the first mismatch at φ=0:
  - `rot_b_angstroms` Y component: C = `0.671588233999813` (`c_trace_scaling.log:268`), PyTorch = `0.717319786548615` (`trace_py_rot_vector.log:16`). Relative delta ≈ `+6.81%` (logged in `rot_vector_comparison.md`).
  - Fractional Miller index at φ=0: C reports `k_frac = -0.607255839576692`, PyTorch reports `k_frac = -0.589141607284546`, shifting the peak search window and flipping the sign of `F_latt_b`.
  - Reciprocal vectors match to `O(1e-9)` Å⁻¹ (see `rot_vector_comparison.md`), so the defect is isolated to the real-space reconstruction step.
- Downstream effect: PyTorch computes `F_latt` with the wrong orientation, yielding `I_before_scaling = 7.13e5` while C logs `9.44e5` for the same pixel.

## nanoBragg.c Reference Pipeline
The C implementation constructs MOSFLM orientation as follows:
1. **Matrix load and wavelength scaling** — `golden_suite_generator/nanoBragg.c:2050-2075` (reads three rows, transposes implicitly by assigning into `a_star`, `b_star`, `c_star`, then scales by `1e-10/lambda0`).
2. **Misset rotation (if any)** — `nanoBragg.c:2095-2109` rotates the reciprocal vectors before any real-space work.
3. **Cross products and volumes** — `nanoBragg.c:2121-2153` forms `a_star×b_star`, `b_star×c_star`, `c_star×a_star`, computes `V_star`, and derives `V_cell = 1/V_star`.
4. **Real-space reconstruction** — `nanoBragg.c:2155-2164` scales the cross products by `V_cell` to obtain `a`, `b`, `c` in Å (these values appear in the trace quoted above).
5. **Reciprocal regeneration for metric duality** — `nanoBragg.c:2171-2185` recomputes `a*`, `b*`, `c*` from the real vectors (completing CLAUDE Rule #13).

## PyTorch Implementation Snapshot
- `Crystal.compute_cell_tensors` mirrors the same stages (`src/nanobrag_torch/models/crystal.py:568-780`). When `mosflm_*` vectors are present, it:
  1. Loads them as tensors (lines 572-588).
[2025-10-07T12:01:57] tokens used: 89,859

[2025-10-07T12:02:09] thinking

**Adjusting plan to reflect new hypothesis**

I’m updating the plan to align with hypothesis H5 instead of the outdated H3, focusing on revising Phase L3j and integrating the new findings into the fix-checklist instructions. I’ll gather relevant documentation references to support this update and ensure plan changes stay within planning scope without altering other docs unnecessarily.
[2025-10-07T12:02:11] exec bash -lc 'rg -n "pix0" docs/architecture/detector.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:02:12] bash -lc 'rg -n "pix0" docs/architecture/detector.md' succeeded in 1.01s:
35:## 5. Logic Flow: `pix0_vector` Calculation
37:The calculation of the detector's origin vector (`pix0_vector`) depends on the `detector_pivot` mode:
42:    B -- BEAM --> C["Calculate pix0_vector using BEAM formula<br/>(pivots around beam spot on detector)"];
43:    B -- SAMPLE --> D["Calculate pix0_vector using SAMPLE formula<br/>(pivots around sample position)"];
44:    C --> E[pix0_vector = -Fbeam*fdet - Sbeam*sdet + distance*beam_vec];
45:    D --> F[pix0_vector = detector_origin + pixel_offsets];
53:pix0_vector = -Fbeam * fdet_vec - Sbeam * sdet_vec + distance * beam_vector
64:pix0_vector = detector_origin + s_offset * sdet_vec + f_offset * fdet_vec
86:- `pix0_vector` changes
209:2. **Pixel Coordinate Consistency:** Check `pixel[0,0] == pix0_vector`
[2025-10-07T12:02:12] tokens used: 92,363

[2025-10-07T12:02:16] thinking

**Verifying plan references**
[2025-10-07T12:02:17] exec bash -lc "sed -n '35,120p' docs/architecture/detector.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:02:17] bash -lc "sed -n '35,120p' docs/architecture/detector.md" succeeded in 702ms:
## 5. Logic Flow: `pix0_vector` Calculation

The calculation of the detector's origin vector (`pix0_vector`) depends on the `detector_pivot` mode:

```mermaid
graph TD
    A[Start: Calculate Rotated Basis Vectors] --> B{Detector Pivot Mode?};
    B -- BEAM --> C["Calculate pix0_vector using BEAM formula<br/>(pivots around beam spot on detector)"];
    B -- SAMPLE --> D["Calculate pix0_vector using SAMPLE formula<br/>(pivots around sample position)"];
    C --> E[pix0_vector = -Fbeam*fdet - Sbeam*sdet + distance*beam_vec];
    D --> F[pix0_vector = detector_origin + pixel_offsets];
    E --> G[Final Detector Geometry];
    F --> G;
```

### 5.1 BEAM Pivot Mode
When `detector_pivot = BEAM`, the detector rotates around the direct beam spot:
```python
pix0_vector = -Fbeam * fdet_vec - Sbeam * sdet_vec + distance * beam_vector
```
[2025-10-07T12:02:17] tokens used: 92,800

[2025-10-07T12:02:44] thinking

**Organizing detailed plan updates**

I'm preparing to expand the L3j phase in the plan with several specific tasks related to updating correction docs, authoring a fix checklist, and syncing next actions in docs/fix_plan.md. The update will add clarity by breaking L3j into subtasks (L3j1, L3j2, L3j3), refresh the gap snapshot with new hypotheses like H5, and ensure reproduction commands and doc storage paths are well documented before applying the patch to the plan.
[2025-10-07T12:03:04] tokens used: 96,956

[2025-10-07T12:03:07] thinking

**Inspecting patch failure lines**
[2025-10-07T12:03:08] exec bash -lc "sed -n '30,150p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:03:08] bash -lc "sed -n '30,150p' plans/active/cli-noise-pix0/plan.md" succeeded in 911ms:
- Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
- Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
- Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
- Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
- Documentation anchors for this focus:
  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
  * `docs/development/testing_strategy.md` — authoritative pytest/trace commands for CLI parity evidence.

### Phase A — Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
Prereqs: Ability to run instrumented C binary via `NB_C_BIN` and collect traces.
Exit Criteria: Documented parity notes under `reports/2025-10-cli-flags/phase_a/` with explicit decisions on unit conversions and noise toggle ordering.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Extract C reference for `-nonoise` | [D] | ✅ 2025-10-05: Supervisor command captured with/without `-nonoise`; logs stored under `reports/2025-10-cli-flags/phase_a/`. |
| A2 | Capture pix0 vector ground truth | [D] | ✅ 2025-10-05: Instrumented C trace recorded pix0 vector values; confirms outputs remain in meters even for `_mm` flag. |
[2025-10-07T12:03:08] tokens used: 99,924

[2025-10-07T12:03:13] thinking

**Verifying target section location**
[2025-10-07T12:03:13] exec bash -lc "rg -n \"Gap snapshot update \\(2025-11-15\" plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:03:14] bash -lc "rg -n \"Gap snapshot update \\(2025-11-15\" plans/active/cli-noise-pix0/plan.md" exited 1 in 718ms:

[2025-10-07T12:03:14] tokens used: 101,537

[2025-10-07T12:03:18] thinking

**Searching for specific snapshot update**
[2025-10-07T12:03:19] exec bash -lc 'rg -n "Gap snapshot update" plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:03:20] bash -lc 'rg -n "Gap snapshot update" plans/active/cli-noise-pix0/plan.md' succeeded in 682ms:
6:- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
8:- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
10:- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
13:- Gap snapshot update (2025-10-17): Attempt #53 (Phase L1c) realigned HKL Fdump I/O with C padding (`read_fdump`/`write_fdump`) and added regression coverage (`TestHKLFdumpParity::test_scaled_hkl_roundtrip`) with max |ΔF| = 0.0. Proceed to L1d to regenerate parity metrics before reviving scaling traces.
14:- Gap snapshot update (2025-11-11): Discovered the trace harness omitted `-beam_vector`, `-flux`, and `-beamsize`, forcing oversample=4 and a +Z beam; Py traces zeroed `F_cell` and inflated `steps`. Marked unresolved pending harness fix.
16:- Gap snapshot update (2025-11-13): Latest harness rerun aborted because `trace_harness.py` still expected the legacy `read_hkl_file` return tuple (see `trace_py_fullrun.log`). **Resolved in Attempt #74, which updated the harness to the `(F_grid, metadata)` signature.**
20:- Gap snapshot update (2025-11-17 late): Attempt #78 completed the Phase L3c harness rerun; TRACE_PY now reports F_cell=190.27 with matching metadata, so the immediate focus moves to auditing CLI ingestion (L3c) and adding regression coverage (L3d).
22:- Gap snapshot update (2025-11-18 late): Attempt #81 implemented `.to(device=device, dtype=dtype)` and added the `TestHKLDevice::test_hkl_tensor_respects_device` regression (CPU/CUDA × float32/float64). Next blocker: Phase L3e scaling validation to prove all factors match C (≤1e-6) before rerunning nb-compare in Phase L4.
27:- Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
33:- Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
[2025-10-07T12:03:20] tokens used: 102,092

[2025-10-07T12:03:26] thinking

**Reviewing plan update approach**
[2025-10-07T12:03:27] exec bash -lc "rg -n \"Next Actions \\(2025-11-20\" plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:03:28] bash -lc "rg -n \"Next Actions \\(2025-11-20\" plans/active/cli-noise-pix0/plan.md" exited 1 in 708ms:

[2025-10-07T12:03:28] tokens used: 103,737

[2025-10-07T12:03:31] thinking

**Searching for "Next Actions ("**
[2025-10-07T12:03:32] exec bash -lc 'rg -n "Next Actions" plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:03:33] bash -lc 'rg -n "Next Actions" plans/active/cli-noise-pix0/plan.md' succeeded in 714ms:
218:| K3f4 | Record root cause & fix outline | [D] | 2025-11-08 update appended to `base_lattice/summary.md` documenting the placeholder-volume root cause and the 46ba36b fix; evidence lives under `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/`. Coordinate docs/fix_plan Next Actions so K3g3 focuses on scaling parity. |
[2025-10-07T12:03:33] tokens used: 103,971

[2025-10-07T12:03:38] thinking

**Clarifying plan source and structure**
[2025-10-07T12:03:38] exec bash -lc 'rg -n "Phase L3" plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:03:39] bash -lc 'rg -n "Phase L3" plans/active/cli-noise-pix0/plan.md' succeeded in 717ms:
19:- Gap snapshot refresh (2025-11-17): Attempt #77 reran Phase L3a probe on the current workstation, logged `probe_20251117.log` (F_cell=190.270004 for hkl=(-7,-1,-14)), and confirmed scaled.hkl already covers the supervisor reflection. Remaining blockers shift to wiring that data through the harness/CLI path (Phase L3c onward).
20:- Gap snapshot update (2025-11-17 late): Attempt #78 completed the Phase L3c harness rerun; TRACE_PY now reports F_cell=190.27 with matching metadata, so the immediate focus moves to auditing CLI ingestion (L3c) and adding regression coverage (L3d).
21:- Gap snapshot refresh (2025-11-18): Attempt #80 (evidence loop) closed Phase L3c — `cli_hkl_audit.md` now documents the missing `.to(device=device)` transfer at `__main__.py:1073`, confirmed probe artifacts, and queued the device fix + regression test for L3d.
22:- Gap snapshot update (2025-11-18 late): Attempt #81 implemented `.to(device=device, dtype=dtype)` and added the `TestHKLDevice::test_hkl_tensor_respects_device` regression (CPU/CUDA × float32/float64). Next blocker: Phase L3e scaling validation to prove all factors match C (≤1e-6) before rerunning nb-compare in Phase L4.
29:- Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
30:- Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
254:### Phase L3 — Normalization Fix Implementation
268:| L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
[2025-10-07T12:03:39] tokens used: 104,384

[2025-10-07T12:03:41] thinking

**Navigating to table location**
[2025-10-07T12:03:43] exec bash -lc "sed -n '240,310p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:03:43] bash -lc "sed -n '240,310p' plans/active/cli-noise-pix0/plan.md" succeeded in 692ms:
| L1c | Align PyTorch HKL cache reader/writer with confirmed layout | [D] | ✅ Attempt #53 (2025-10-17): Updated `src/nanobrag_torch/io/hkl.py` to honour `(range+1)` padding, added C-code docstring quotes per Rule #11, and introduced `tests/test_cli_flags.py::TestHKLFdumpParity::test_scaled_hkl_roundtrip` (max |ΔF| = 0.0, mismatches = 0). |
| L1d | Re-run parity script after fixes and update artefacts | [D] | ✅ Attempt #54 (2025-10-17): Regenerated C cache using supervisor command flags, achieved perfect HKL parity (max |ΔF|=0.0, 0 mismatches). Artifacts: `reports/2025-10-cli-flags/phase_l/hkl_parity/{Fdump_c_20251109.bin, summary_20251109.md, metrics_20251109.json}`. Phase L2 prerequisites now met—structure factors match C exactly. |

### Phase L2 — Scaling Chain Audit
Goal: Capture a side-by-side breakdown of the intensity scaling pipeline (I_before_scaling → ω → polarization → r_e² → fluence → steps) for the supervisor command to isolate the first divergence that drives the 1.26×10⁵ sum ratio.
Prereqs: Phase L1d artifacts in place; Ralph working under `prompts/debug.md`; C binary instrumentable via `golden_suite_generator/` per CLAUDE Rule #0.3.
Exit Criteria: C and PyTorch traces capturing scaling factors are stored under `reports/2025-10-cli-flags/phase_l/scaling_audit/`, a comparison summary identifies the first mismatched term with quantitative deltas, and docs/fix_plan.md Attempt log references the findings.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| L2a | Instrument C scaling chain | [D] | ✅ 2025-10-06 Attempt #55: Reused existing TRACE_C hooks (nanoBragg.c 3367-3382), captured `c_trace_scaling.log` for pixel (685,1039), and recorded setup in `instrumentation_notes.md`. Artifacts live under `reports/2025-10-cli-flags/phase_l/scaling_audit/`; ready to mirror fields on the PyTorch side. |
| L2b | Expose and log PyTorch scaling factors | [D] | ✅ Attempts #69, #72, and #74 (commits `1cf77b5`, `0f3de26`) now drive the harness through the updated HKL API, attach `crystal.hkl_data` / `crystal.hkl_metadata`, and capture live TRACE_PY output for pixel (685,1039). `reports/2025-10-cli-flags/phase_l/scaling_audit/trace_py_scaling.log` shows real polarization/omega/steps, and `harness_hkl_state_fixed.txt` confirms the HKL tensor lives on the simulator device. |
| L2c | Diff traces & record first divergence | [D] | ✅ Attempt #71 refreshed `scaling_audit_summary.md` via `scripts/validation/compare_scaling_traces.py`, highlighting `I_before_scaling` as the first divergence (C=9.4365e5, Py=0) while all downstream scaling factors match within 2e-3%. This establishes that the remaining gap stems from missing structure-factor coverage rather than normalization math. |

### Phase L3 — Normalization Fix Implementation
Goal: Patch the PyTorch scaling pipeline so every factor (omega, polarization, capture_fraction, r_e², fluence, steps) matches the C implementation within 1e-6 relative error.
Prereqs: L2 comparison summary pointing to the exact divergent factor; relevant C references documented; regression tests identified.
Exit Criteria: PyTorch source changes with inline C-code docstring references are merged, targeted regression tests cover the corrected scaling semantics, and new artifacts demonstrate matching intermediate values. docs/fix_plan.md records the fix attempt and resulting metrics.

| ID | Task Description | State | How/Why & Guidance |
[2025-10-07T12:03:43] tokens used: 105,360

[2025-10-07T12:03:52] thinking

**Preparing to expand L3j row and update bullets**
[2025-10-07T12:04:04] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -30,2 +30,3 @@
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
[2025-10-07T12:04:04] apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-07T12:04:04] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..02fb6c2617b5206232e25aecb4d9708740b8fa07
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.

[2025-10-07T12:04:04] tokens used: 109,288
[2025-10-07T12:04:04] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..02fb6c2617b5206232e25aecb4d9708740b8fa07
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.


[2025-10-07T12:04:07] thinking

**Updating L3j row**
[2025-10-07T12:04:21] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -270,3 +270,5 @@
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
[2025-10-07T12:04:21] apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-07T12:04:21] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.

[2025-10-07T12:04:21] tokens used: 110,664
[2025-10-07T12:04:21] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:04:25] thinking

**Updating fix_plan.md next actions**
[2025-10-07T12:04:30] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -460,5 +460,5 @@
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
[2025-10-07T12:04:30] apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-07T12:04:30] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.

[2025-10-07T12:04:30] tokens used: 112,613
[2025-10-07T12:04:30] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:04:52] thinking

**Detailing input.md content and structure**

I’m working through the requirements to create the `input.md` for Ralph, focusing on including a clear summary, specifying Mode as Parity, identifying the focused plan item with ID and title, referencing the current git branch, and clarifying mapped tests though none run immediately. I'll also include detailed sections like Artifacts, Do Now commands, blocking contingencies, priorities, how-to commands, pitfalls, and pointers all designed to guide Ralph through the Phase L3j documentation updates thoroughly.
[2025-10-07T12:04:54] exec bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '250,310p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:04:55] bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '250,310p'" succeeded in 889ms:
   250	| --- | --- | --- | --- |
   251	| L2a | Instrument C scaling chain | [D] | ✅ 2025-10-06 Attempt #55: Reused existing TRACE_C hooks (nanoBragg.c 3367-3382), captured `c_trace_scaling.log` for pixel (685,1039), and recorded setup in `instrumentation_notes.md`. Artifacts live under `reports/2025-10-cli-flags/phase_l/scaling_audit/`; ready to mirror fields on the PyTorch side. |
   252	| L2b | Expose and log PyTorch scaling factors | [D] | ✅ Attempts #69, #72, and #74 (commits `1cf77b5`, `0f3de26`) now drive the harness through the updated HKL API, attach `crystal.hkl_data` / `crystal.hkl_metadata`, and capture live TRACE_PY output for pixel (685,1039). `reports/2025-10-cli-flags/phase_l/scaling_audit/trace_py_scaling.log` shows real polarization/omega/steps, and `harness_hkl_state_fixed.txt` confirms the HKL tensor lives on the simulator device. |
   253	| L2c | Diff traces & record first divergence | [D] | ✅ Attempt #71 refreshed `scaling_audit_summary.md` via `scripts/validation/compare_scaling_traces.py`, highlighting `I_before_scaling` as the first divergence (C=9.4365e5, Py=0) while all downstream scaling factors match within 2e-3%. This establishes that the remaining gap stems from missing structure-factor coverage rather than normalization math. |
   254	
   255	### Phase L3 — Normalization Fix Implementation
   256	Goal: Patch the PyTorch scaling pipeline so every factor (omega, polarization, capture_fraction, r_e², fluence, steps) matches the C implementation within 1e-6 relative error.
   257	Prereqs: L2 comparison summary pointing to the exact divergent factor; relevant C references documented; regression tests identified.
   258	Exit Criteria: PyTorch source changes with inline C-code docstring references are merged, targeted regression tests cover the corrected scaling semantics, and new artifacts demonstrate matching intermediate values. docs/fix_plan.md records the fix attempt and resulting metrics.
   259	
   260	| ID | Task Description | State | How/Why & Guidance |
   261	| --- | --- | --- | --- |
   262	| L3a | Verify structure-factor coverage for supervisor pixel | [D] | ✅ 2025-11-17 Attempt #77: `reports/2025-10-cli-flags/phase_l/structure_factor/probe.py` recorded `probe_20251117.log` showing scaled.hkl returns `F_cell=190.270004` for hkl=(-7,-1,-14). Keep the log + timestamped copies alongside a brief summary in `analysis.md`, then proceed to L3c to thread the same attachment pattern through the harness/CLI path. |
   263	| L3b | Mirror probe attachment in harness | [D] | ✅ 2025-11-17 Attempt #78: `trace_harness.py` now assigns both `hkl_data` and `hkl_metadata` before simulator construction (see `trace_py_scaling_20251117.log`, `harness_hkl_state_20251117.txt`). Keeps harness behavior aligned with probe results and removes F_cell=0 divergence. |
   264	| L3c | Audit CLI HKL loading path | [D] | ✅ 2025-10-18 Attempt #80: Refreshed `cli_hkl_audit.md` with precise line refs (line 1073) showing dtype-only transfer; confirmed probe artifacts and logged device gap blocking CUDA parity. |
   265	| L3d | Add targeted regression tests | [D] | ✅ Attempt #81 (2025-11-18): Added `TestHKLDevice::test_hkl_tensor_respects_device` covering CPU/CUDA × float32/float64; ensures HKL tensors honor requested device/dtype and lookups return F≈190.27 for (-7,-1,-14). |
   266	| L3e | Refresh per-phi scaling validation | [D] | ✅ Attempt #86 (2025-10-07 timestamp, replayed 2025-11-19 artifacts): Harness now captures 10 `TRACE_PY_PHI` lines plus JSON, reruns `compare_scaling_traces.py`, and stores outputs under `reports/2025-10-cli-flags/phase_l/{per_phi,scaling_validation}/`. Remaining delta isolated to `k_frac`/`F_latt_b` at phi=0. |
   267	| L3f | Rotation-vector audit (new) | [D] | ✅ Attempts #86/#88 (2025-11-18/19) produced `rot_vector_comparison.md`, `invariant_probe.md`, and per-φ JSON showing φ=0 real vectors drifting in Y while reciprocal vectors remain aligned ≤1e-9. Evidence archived under `reports/2025-10-cli-flags/phase_l/rot_vector/`. |
   268	| L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
   269	| L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
[2025-10-07T12:04:55] tokens used: 115,020
[2025-10-07T12:04:55] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:04:58] thinking

**Verifying documentation updates**
[2025-10-07T12:04:59] exec bash -lc "sed -n '450,520p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:04:59] bash -lc "sed -n '450,520p' docs/fix_plan.md" succeeded in 707ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A–H complete; K3a/K3b/K3d landed via Attempts #43–44, pending per-φ evidence + normalization closure)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
- Next Actions (2025-11-20 refresh → updated by galph):
 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
- Attempts History:
  * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
    Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
    Artifacts:
      - `src/nanobrag_torch/simulator.py:1313-1322` - Spindle instrumentation (emit raw/normalized/magnitude)
      - `reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_rot_vector.log` - Refreshed φ=0 trace with spindle data
[2025-10-07T12:04:59] tokens used: 117,664
[2025-10-07T12:04:59] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:05:10] thinking

**Preparing detailed input.md content**

I'll gather all the necessary document references and structure detailed sections like Summary, Focus, Branch, Mapped Tests, Artifacts, and more to produce a comprehensive input.md file around 100–200 lines long, carefully balancing thoroughness with conciseness.
[2025-10-07T12:05:29] exec bash -lc "cat <<'EOF' > input.md
Summary: Capture parity evidence updates for φ-rotation gap before any simulator edits.
Mode: Parity
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md; reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md; docs/fix_plan.md; plans/active/cli-noise-pix0/plan.md; reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md
Do Now: CLI-FLAGS-003 Phase L3j.1–L3j.2 — pytest --collect-only -q
If Blocked: Capture a short note in reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md and stage "'`trace_harness.py` stdout/stderr for review; mention the blocker in docs/fix_plan.md Attempts.
Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:255 keeps L3j gating future implementation; completing memo+checklist unblocks simulator changes.
- docs/fix_plan.md:450 requires Next Actions alignment so automation has an authoritative checklist.
- specs/spec-a-cli.md:1 documents CLI semantics; citing it in the memo ensures spec linkage for -pix0_vector_mm.
- docs/architecture/detector.md:35 captures pix0 geometry formulas; reference them while writing the checklist tolerances.
- docs/development/c_to_pytorch_config_map.md:1 enforces pivot and unit parity; align φ-rotation guidance with its mapping notes.
- docs/development/testing_strategy.md:1 (Tier 1/Tier 2) details targeted pytest selectors; reuse its commands in the checklist instructions.
How-To Map:
- Update reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md with Attempt #93 findings; highlight H5/H6/H7 statuses and quote key lines from c_trace_mosflm.log and trace_py_rot_vector.log.
- Author reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md with a table: ID, Requirement, Owner, Artifact Path, Threshold/Notes; include entries for per-φ harness rerun, pytest selector, and nb-compare ROI command (`nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`).
- After docs are written, run `pytest --collect-only -q` (env KMP_DUPLICATE_LIB_OK=TRUE) from repo root to ensure collection unaffected, then save the log under reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log.
- Update docs/fix_plan.md CLI-FLAGS-003 Attempts with a new entry summarizing L3j memo/checklist completion (reference artifact paths and collection log).
- Refresh plans/active/cli-noise-pix0/plan.md L3j rows if adjustments arise while drafting the checklist (keep table format intact).
- Stage updated docs and reports only after confirming they contain spec citations and explicit tolerances; leave production code untouched.
Pitfalls To Avoid:
- Do not modify src/ files or simulator logic during this loop; evidence only.
- Keep Protected Assets intact (docs/index.md references); avoid renaming or deleting referenced files.
- Ensure all new doc references use meters/Å units consistent with specs; no ad-hoc conversions.
- Avoid introducing `.cpu()`/`.cuda()` guidance in docs; maintain device-neutral messaging.
- Do not run full pytest; stick to `--collect-only` per supervisor mode.
- Keep nb-compare command documented but not executed yet; checklist only.
- Preserve existing TRACE naming conventions (TRACE_PY/TRACE_C) when quoting logs.
- Avoid duplicating plan tables; update existing rows in place.
- No new directories outside reports/2025-10-cli-flags/phase_l/rot_vector/ without plan discussion.
- Include SHA or git describe references when citing artifacts in docs/fix_plan.md.
Pointers:
- specs/spec-a-cli.md:1 — CLI normative requirements for -nonoise and pix0 flags.
- docs/architecture/detector.md:35 — pix0_vector formulas for BEAM/SAMPLE pivots.
- docs/development/c_to_pytorch_config_map.md:1 — detector pivot and unit mapping.
- docs/development/testing_strategy.md:120 — targeted pytest usage expectations.
- plans/active/cli-noise-pix0/plan.md:260 — Phase L3 task table with L3j.1–L3j.3 definitions.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 — latest H5/H6/H7 hypothesis ranking to cite in memo.
- reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log:63 — C-side φ=0 vector baseline for comparisons.
- reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_rot_vector.log:16 — PyTorch φ=0 vector output to cross-reference in memo.
- docs/fix_plan.md:450 — CLI-FLAGS-003 entry to update.
- prompts/supervisor.md:1 — authoritative supervisor command flags for nb-compare listing.
Next Up: 1) Once checklist exists, plan Phase L3 implementation loop to instrument φ rotation fix; 2) Alternatively pivot to VECTOR-TRICUBIC-001 Phase C1 if CLI evidence wraps quickly.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:05:29] bash -lc "cat <<'EOF' > input.md
Summary: Capture parity evidence updates for φ-rotation gap before any simulator edits.
Mode: Parity
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md; reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md; docs/fix_plan.md; plans/active/cli-noise-pix0/plan.md; reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md
Do Now: CLI-FLAGS-003 Phase L3j.1–L3j.2 — pytest --collect-only -q
If Blocked: Capture a short note in reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md and stage "'`trace_harness.py` stdout/stderr for review; mention the blocker in docs/fix_plan.md Attempts.
Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:255 keeps L3j gating future implementation; completing memo+checklist unblocks simulator changes.
- docs/fix_plan.md:450 requires Next Actions alignment so automation has an authoritative checklist.
- specs/spec-a-cli.md:1 documents CLI semantics; citing it in the memo ensures spec linkage for -pix0_vector_mm.
- docs/architecture/detector.md:35 captures pix0 geometry formulas; reference them while writing the checklist tolerances.
- docs/development/c_to_pytorch_config_map.md:1 enforces pivot and unit parity; align φ-rotation guidance with its mapping notes.
- docs/development/testing_strategy.md:1 (Tier 1/Tier 2) details targeted pytest selectors; reuse its commands in the checklist instructions.
How-To Map:
- Update reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md with Attempt #93 findings; highlight H5/H6/H7 statuses and quote key lines from c_trace_mosflm.log and trace_py_rot_vector.log.
- Author reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md with a table: ID, Requirement, Owner, Artifact Path, Threshold/Notes; include entries for per-φ harness rerun, pytest selector, and nb-compare ROI command (`nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`).
- After docs are written, run `pytest --collect-only -q` (env KMP_DUPLICATE_LIB_OK=TRUE) from repo root to ensure collection unaffected, then save the log under reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log.
- Update docs/fix_plan.md CLI-FLAGS-003 Attempts with a new entry summarizing L3j memo/checklist completion (reference artifact paths and collection log).
- Refresh plans/active/cli-noise-pix0/plan.md L3j rows if adjustments arise while drafting the checklist (keep table format intact).
- Stage updated docs and reports only after confirming they contain spec citations and explicit tolerances; leave production code untouched.
Pitfalls To Avoid:
- Do not modify src/ files or simulator logic during this loop; evidence only.
- Keep Protected Assets intact (docs/index.md references); avoid renaming or deleting referenced files.
- Ensure all new doc references use meters/Å units consistent with specs; no ad-hoc conversions.
- Avoid introducing `.cpu()`/`.cuda()` guidance in docs; maintain device-neutral messaging.
- Do not run full pytest; stick to `--collect-only` per supervisor mode.
- Keep nb-compare command documented but not executed yet; checklist only.
- Preserve existing TRACE naming conventions (TRACE_PY/TRACE_C) when quoting logs.
- Avoid duplicating plan tables; update existing rows in place.
- No new directories outside reports/2025-10-cli-flags/phase_l/rot_vector/ without plan discussion.
- Include SHA or git describe references when citing artifacts in docs/fix_plan.md.
Pointers:
- specs/spec-a-cli.md:1 — CLI normative requirements for -nonoise and pix0 flags.
- docs/architecture/detector.md:35 — pix0_vector formulas for BEAM/SAMPLE pivots.
- docs/development/c_to_pytorch_config_map.md:1 — detector pivot and unit mapping.
- docs/development/testing_strategy.md:120 — targeted pytest usage expectations.
- plans/active/cli-noise-pix0/plan.md:260 — Phase L3 task table with L3j.1–L3j.3 definitions.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 — latest H5/H6/H7 hypothesis ranking to cite in memo.
- reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log:63 — C-side φ=0 vector baseline for comparisons.
- reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_rot_vector.log:16 — PyTorch φ=0 vector output to cross-reference in memo.
- docs/fix_plan.md:450 — CLI-FLAGS-003 entry to update.
- prompts/supervisor.md:1 — authoritative supervisor command flags for nb-compare listing.
Next Up: 1) Once checklist exists, plan Phase L3 implementation loop to instrument φ rotation fix; 2) Alternatively pivot to VECTOR-TRICUBIC-001 Phase C1 if CLI evidence wraps quickly.
EOF
' succeeded in 863ms:

[2025-10-07T12:05:29] tokens used: 122,391
[2025-10-07T12:05:29] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:05:36] thinking

**Planning input.md expansion**
[2025-10-07T12:05:59] exec bash -lc "cat <<'EOF' > input.md
Summary: Document φ-rotation parity evidence so future simulator fixes have a locked checklist.
Mode: Parity
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md; reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md; docs/fix_plan.md; plans/active/cli-noise-pix0/plan.md; reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md; reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log
Do Now: CLI-FLAGS-003 Phase L3j.1–L3j.2 — pytest --collect-only -q
If Blocked: Capture a short narrative in reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md, stash any harness stdout under the same folder, and note the blocker plus file paths in docs/fix_plan.md Attempts.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:260 keeps Phase L3 sequencing; finishing the memo/checklist flips L3j rows to [D] so code edits can proceed without rework.
- docs/fix_plan.md:450 needs Next Actions aligned to L3j.1–L3j.3 ensuring repo status and automation commands stay in sync.
- specs/spec-a-cli.md:1 enumerates CLI semantics; referencing §3.3 prevents documentation drift when summarising pix0 overrides and noise toggles.
- docs/architecture/detector.md:35 supplies the BEAM/SAMPLE formulas; quoting them in the checklist anchors tolerances to the geometry spec.
- docs/development/c_to_pytorch_config_map.md:1 documents implicit pivot/unit rules; the memo must cite it to explain why φ rotation is the last unmatched stage.
- docs/development/testing_strategy.md:120 standardises targeted pytest usage; the checklist needs explicit selectors drawn from this guidance.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 tracks current hypothesis ordering (H5 primary); memo must echo this to avoid duplicate analysis loops.
- reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log:63 and trace_py_rot_vector.log:16 form the evidence pair; include numeric deltas to justify thresholds.
- prompts/supervisor.md:1 houses the authoritative CLI command; the checklist should reference it verbatim for nb-compare reproduction.
- plans/active/vectorization.md:31 is non-blocking but stays queued; documenting CLI parity progress clarifies when we can pivot to tricubic work.

How-To Map:
- Re-read Attempt #93 artifacts (c_trace_mosflm.log, mosflm_matrix_diff.md) and extend mosflm_matrix_correction.md with a section titled “Post-L3i Findings” that explicitly states H3 is ruled out and H5 (φ rotation) remains; cite golden_suite_generator/nanoBragg.c:2050-2199 and src/nanobrag_torch/models/crystal.py:568-780.
- Summarise the quantitative deltas: note b_Y diff 1.35e-07 Å, k_frac delta ≈0.018, and link them to φ=0 instrumentation; include trace line numbers to make review quick.
- Outline the φ sampling requirements (0°, 0.05°, 0.1°) and explain why these cover the supervisor command (phisteps=10, osc=0.1) so future runs stay consistent.
- Draft fix_checklist.md with a markdown table containing columns "'`[ID | Requirement | Owner | Artifact Path | Threshold / Notes]`; include separate entries for per-φ harness rerun, targeted pytest (`env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI command (`nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`).
- For each checklist row, add guidance referencing the relevant doc (specs/spec-a-cli.md §3.3 for CLI, docs/development/testing_strategy.md §2 for tests, docs/debugging/debugging.md §Parallel Trace for harness rerun) so future implementer knows the source of truth.
- After updating docs, run `KMP_DUPLICATE_LIB_OK=TRUE pytest --collect-only -q` from repo root, capture the terminal output into reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log, and mention it in fix_plan Attempt.
- Update docs/fix_plan.md CLI-FLAGS-003 Attempts with a new entry “Attempt #94 (documentation loop)” summarising memo changes, checklist creation, and the collect-only log; ensure Observations mention H5 promotion and Next Actions point to implementation.
- Reflect any minor wording adjustments back into plans/active/cli-noise-pix0/plan.md L3j cells if the checklist adds new thresholds or artifact names not already documented.
- Leave traces, harness scripts, and code untouched; commit only doc/report updates once reviewed.
- Optional: if referencing new artifacts (e.g., nb-compare command text files), keep them under the existing rot_vector folder to respect Protected Assets guidance.

Pitfalls To Avoid:
- Do not modify src/ or scripts/ code paths; this loop is documentation only.
- Avoid regenerating large traces; reuse existing logs to quote numbers unless a blocker requires new runs.
- Keep all new doc references unit-consistent (meters for geometry, Å for physics) to avoid confusing downstream readers.
- Do not collapse plan tables; maintain the existing ID/Task/State/Guidance formatting.
- Skip running nb-compare or the supervisor command; checklist should document commands without executing them.
- Guard against losing trace precision when copying values—carry full significant digits from logs.
- Ensure Protected Assets referenced in docs/index.md remain untouched; no renames or deletions.
- Avoid editing prompts/main.md or automation scripts; not part of this focus.
- Never downgrade tolerances; keep ≤1e-6 relative thresholds unless the spec demands tighter numbers.
- Refrain from adding TODOs without context; every addition should reference plan IDs or spec clauses.

Pointers:
- specs/spec-a-cli.md:1 — Normative CLI rules for -nonoise and pix0 overrides.
- specs/spec-a-core.md:400 — Lattice factor equations and acceptance tests to cite for F_latt thresholds.
- docs/architecture/detector.md:35 — pix0_vector derivation (BEAM/SAMPLE formulas) used in memo/checklist.
- docs/development/c_to_pytorch_config_map.md:42 — Detector pivot/unit mapping tied to φ rotation.
- docs/development/testing_strategy.md:120 — Targeted pytest workflow (Tier 1 parity guidance).
- docs/debugging/debugging.md:24 — Parallel trace SOP to quote in the checklist instructions.
- plans/active/cli-noise-pix0/plan.md:271 — Detailed definition of L3j.1–L3j.3 tasks.
- docs/fix_plan.md:450 — CLI-FLAGS-003 ledger section to update with Attempt #94.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 — Current hypothesis status (H5 primary, H6/H7 secondary).
- reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_diff.md:40 — Component-level delta summary to cite in the memo.
- reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_env.json:1 — Environment snapshot for reproducibility metadata.
- prompts/supervisor.md:18 — Exact supervisor command used for parity runs.
- reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md:22 — Context for k_frac divergence to restate in memo.
- history/ — Additional archival references if prior attempts need cross-linking (optional).

Next Up: 1) Once L3j checklist is in place, schedule the implementation loop targeting φ rotation parity per plan Phase L3; 2) If time remains, gather outstanding evidence for VECTOR-TRICUBIC-001 Phase C1 (gather fallback semantics) without touching production code.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:06:00] bash -lc "cat <<'EOF' > input.md
Summary: Document φ-rotation parity evidence so future simulator fixes have a locked checklist.
Mode: Parity
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md; reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md; docs/fix_plan.md; plans/active/cli-noise-pix0/plan.md; reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md; reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log
Do Now: CLI-FLAGS-003 Phase L3j.1–L3j.2 — pytest --collect-only -q
If Blocked: Capture a short narrative in reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md, stash any harness stdout under the same folder, and note the blocker plus file paths in docs/fix_plan.md Attempts.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:260 keeps Phase L3 sequencing; finishing the memo/checklist flips L3j rows to [D] so code edits can proceed without rework.
- docs/fix_plan.md:450 needs Next Actions aligned to L3j.1–L3j.3 ensuring repo status and automation commands stay in sync.
- specs/spec-a-cli.md:1 enumerates CLI semantics; referencing §3.3 prevents documentation drift when summarising pix0 overrides and noise toggles.
- docs/architecture/detector.md:35 supplies the BEAM/SAMPLE formulas; quoting them in the checklist anchors tolerances to the geometry spec.
- docs/development/c_to_pytorch_config_map.md:1 documents implicit pivot/unit rules; the memo must cite it to explain why φ rotation is the last unmatched stage.
- docs/development/testing_strategy.md:120 standardises targeted pytest usage; the checklist needs explicit selectors drawn from this guidance.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 tracks current hypothesis ordering (H5 primary); memo must echo this to avoid duplicate analysis loops.
- reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log:63 and trace_py_rot_vector.log:16 form the evidence pair; include numeric deltas to justify thresholds.
- prompts/supervisor.md:1 houses the authoritative CLI command; the checklist should reference it verbatim for nb-compare reproduction.
- plans/active/vectorization.md:31 is non-blocking but stays queued; documenting CLI parity progress clarifies when we can pivot to tricubic work.

How-To Map:
- Re-read Attempt #93 artifacts (c_trace_mosflm.log, mosflm_matrix_diff.md) and extend mosflm_matrix_correction.md with a section titled “Post-L3i Findings” that explicitly states H3 is ruled out and H5 (φ rotation) remains; cite golden_suite_generator/nanoBragg.c:2050-2199 and src/nanobrag_torch/models/crystal.py:568-780.
- Summarise the quantitative deltas: note b_Y diff 1.35e-07 Å, k_frac delta ≈0.018, and link them to φ=0 instrumentation; include trace line numbers to make review quick.
- Outline the φ sampling requirements (0°, 0.05°, 0.1°) and explain why these cover the supervisor command (phisteps=10, osc=0.1) so future runs stay consistent.
- Draft fix_checklist.md with a markdown table containing columns "'`[ID | Requirement | Owner | Artifact Path | Threshold / Notes]`; include separate entries for per-φ harness rerun, targeted pytest (`env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI command (`nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`).
- For each checklist row, add guidance referencing the relevant doc (specs/spec-a-cli.md §3.3 for CLI, docs/development/testing_strategy.md §2 for tests, docs/debugging/debugging.md §Parallel Trace for harness rerun) so future implementer knows the source of truth.
- After updating docs, run `KMP_DUPLICATE_LIB_OK=TRUE pytest --collect-only -q` from repo root, capture the terminal output into reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log, and mention it in fix_plan Attempt.
- Update docs/fix_plan.md CLI-FLAGS-003 Attempts with a new entry “Attempt #94 (documentation loop)” summarising memo changes, checklist creation, and the collect-only log; ensure Observations mention H5 promotion and Next Actions point to implementation.
- Reflect any minor wording adjustments back into plans/active/cli-noise-pix0/plan.md L3j cells if the checklist adds new thresholds or artifact names not already documented.
- Leave traces, harness scripts, and code untouched; commit only doc/report updates once reviewed.
- Optional: if referencing new artifacts (e.g., nb-compare command text files), keep them under the existing rot_vector folder to respect Protected Assets guidance.

Pitfalls To Avoid:
- Do not modify src/ or scripts/ code paths; this loop is documentation only.
- Avoid regenerating large traces; reuse existing logs to quote numbers unless a blocker requires new runs.
- Keep all new doc references unit-consistent (meters for geometry, Å for physics) to avoid confusing downstream readers.
- Do not collapse plan tables; maintain the existing ID/Task/State/Guidance formatting.
- Skip running nb-compare or the supervisor command; checklist should document commands without executing them.
- Guard against losing trace precision when copying values—carry full significant digits from logs.
- Ensure Protected Assets referenced in docs/index.md remain untouched; no renames or deletions.
- Avoid editing prompts/main.md or automation scripts; not part of this focus.
- Never downgrade tolerances; keep ≤1e-6 relative thresholds unless the spec demands tighter numbers.
- Refrain from adding TODOs without context; every addition should reference plan IDs or spec clauses.

Pointers:
- specs/spec-a-cli.md:1 — Normative CLI rules for -nonoise and pix0 overrides.
- specs/spec-a-core.md:400 — Lattice factor equations and acceptance tests to cite for F_latt thresholds.
- docs/architecture/detector.md:35 — pix0_vector derivation (BEAM/SAMPLE formulas) used in memo/checklist.
- docs/development/c_to_pytorch_config_map.md:42 — Detector pivot/unit mapping tied to φ rotation.
- docs/development/testing_strategy.md:120 — Targeted pytest workflow (Tier 1 parity guidance).
- docs/debugging/debugging.md:24 — Parallel trace SOP to quote in the checklist instructions.
- plans/active/cli-noise-pix0/plan.md:271 — Detailed definition of L3j.1–L3j.3 tasks.
- docs/fix_plan.md:450 — CLI-FLAGS-003 ledger section to update with Attempt #94.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 — Current hypothesis status (H5 primary, H6/H7 secondary).
- reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_diff.md:40 — Component-level delta summary to cite in the memo.
- reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_env.json:1 — Environment snapshot for reproducibility metadata.
- prompts/supervisor.md:18 — Exact supervisor command used for parity runs.
- reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md:22 — Context for k_frac divergence to restate in memo.
- history/ — Additional archival references if prior attempts need cross-linking (optional).

Next Up: 1) Once L3j checklist is in place, schedule the implementation loop targeting φ rotation parity per plan Phase L3; 2) If time remains, gather outstanding evidence for VECTOR-TRICUBIC-001 Phase C1 (gather fallback semantics) without touching production code.
EOF
' succeeded in 895ms:

[2025-10-07T12:06:00] tokens used: 126,121
[2025-10-07T12:06:00] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:06:04] thinking

**Checking input file length**
[2025-10-07T12:06:05] exec bash -lc 'wc -l input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:06:05] bash -lc 'wc -l input.md' succeeded in 702ms:
      62 input.md
[2025-10-07T12:06:05] tokens used: 128,897
[2025-10-07T12:06:05] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:06:13] thinking

**Planning to expand file content**
[2025-10-07T12:06:50] exec bash -lc "cat <<'EOF' > input.md
Summary: Document φ-rotation parity evidence so future simulator fixes have a locked checklist and spec citations.
Mode: Parity
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md; reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md; docs/fix_plan.md; plans/active/cli-noise-pix0/plan.md; reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md; reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log; reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md
Do Now: CLI-FLAGS-003 Phase L3j.1–L3j.2 — pytest --collect-only -q
If Blocked: Capture a short narrative in reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md, stash any harness stdout under the same folder, and note the blocker plus file paths in docs/fix_plan.md Attempts for traceability.

Context Recap:
- Attempt #93 proved MOSFLM base vectors align within float32 precision and shifted suspicion to φ rotation (H5) per reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md.
- L3a–L3i tasks are ✅; per-φ traces and spindle audits exist, but no implementation checklist yet guards the upcoming fix.
- The supervisor command relies on phisteps=10, osc=0.1, so φ sampling at 0°, 0.05°, 0.1° captures the full motion envelope.
- docs/fix_plan.md Next Actions still reference L3i instrumentation; updating them prevents future loops from repeating now-complete evidence tasks.
- Long-term Goal #1 (run C vs PyTorch parity command) is blocked until φ rotation parity is restored, making this documentation loop a prerequisite.
- Vectorization backlog is paused; documenting CLI progress clarifies when resources can return to VECTOR-TRICUBIC-001.
- Protected Assets rule demands we leave docs/index.md references untouched; all new content must live in allowed directories (plans/, docs/, reports/).
- Mode Parity forbids running full pytest; only collect-only validation is expected after doc edits.
- Prior evidence loops already generated heavy traces; reuse them, avoid generating new large logs unless absolutely necessary.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:260 keeps Phase L3 sequencing; finishing memo/checklist flips L3j rows to [D], signalling readiness for code changes.
  Tie the memo content directly to the plan so future readers map doc artifacts to plan IDs without guessing.
- docs/fix_plan.md:450 needs Next Actions aligned to L3j.1–L3j.3; without this, automation scripts may queue stale instrumentation tasks.
  When updating fix_plan, cite artifact paths explicitly to maintain reproducibility.
- specs/spec-a-cli.md:1 enumerates CLI semantics; referencing §3.3 prevents documentation drift when summarising pix0 overrides and noise suppression expectations.
  Connect -nonoise behavior with the existing plan to remind reviewers the flag already works at CLI level.
- docs/architecture/detector.md:35 supplies BEAM/SAMPLE formulas; quoting them in the checklist anchors tolerances to the geometry spec and clarifies which components are meter-based.
  Include note about how these formulas interact with CUSTOM convention when pix0 overrides are present.
- docs/development/c_to_pytorch_config_map.md:42 documents implicit pivot/unit rules; the memo must cite it to explain why φ rotation is the remaining unmatched stage and to avoid re-litigating pivot logic.
  Highlight the pivot implications (twotheta implies SAMPLE) so checklist readers recall the default.
- docs/development/testing_strategy.md:120 standardises targeted pytest usage; the checklist needs explicit selectors drawn from this guidance to stay in compliance with testing SOP.
  Mention Tier 1 parity context to tie the collect-only run to spec-driven expectations.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 tracks current hypothesis ordering (H5 primary, H6/H7 secondary); memo must echo this so later loops continue where we left off.
  Carry over the quantitative deltas (e.g., k_frac mismatch, F_latt sign flip) into the new memo section.
- reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log:63 and trace_py_rot_vector.log:16 form the evidence pair; quote them in the memo to justify threshold choices.
  Keep raw precision (up to 1e-12) when transcribing values.
- prompts/supervisor.md:18 houses the authoritative CLI command; the checklist should reference it verbatim for nb-compare reproduction to avoid parameter drift.
  Clarify environment variables (NB_C_BIN, KMP_DUPLICATE_LIB_OK) alongside the command.
- plans/active/vectorization.md:31 is non-blocking but stays queued; documenting CLI parity progress clarifies when we can pivot to tricubic work without mixing initiatives.
  Mention this in memo conclusions for cross-team visibility.

How-To Map:
- Re-read Attempt #93 artifacts (c_trace_mosflm.log, mosflm_matrix_diff.md) and extend mosflm_matrix_correction.md with a \"Post-L3i Findings\" section stating H3 is ruled out, H5 remains primary, H6/H7 secondary.
  Cite golden_suite_generator/nanoBragg.c:2050-2199 for C reference and src/nanobrag_torch/models/crystal.py:568-780 for PyTorch behavior.
- Summarise quantitative deltas: include b_Y delta 1.35e-07 Å, k_frac shift ≈0.018, F_latt sign flip, linking each to trace line numbers.
  Explain how these deltas propagate into intensity mismatches (I_before_scaling ~7.13e5 vs 9.44e5) referencing scaling logs.
- Outline φ sampling requirements (0°, 0.05°, 0.1°) and relate them to phisteps, osc, and beamsize to justify coverage.
  Note that per-φ JSON already exists; instruct checklist users to regenerate it only after applying code changes.
- Draft fix_checklist.md with table "'`[ID | Requirement | Owner | Artifact Path | Threshold / Notes]` containing at least three rows: per-φ harness rerun, targeted pytest, nb-compare ROI.
  For each row, list spec/doc references (specs/spec-a-cli.md §3.3, docs/debugging/debugging.md §Parallel Trace, docs/development/testing_strategy.md §1.5) and required thresholds (≤1e-6 relative, correlation ≥0.9995, etc.).
- Include an entry reminding future implementers to update docs/index.md references only if new artifacts become canonical, respecting Protected Assets Rule.
- After doc edits, run `KMP_DUPLICATE_LIB_OK=TRUE pytest --collect-only -q` from repo root, capture output into reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log, and mention it in fix_plan Attempt.
  Do not upgrade to full pytest; collect-only suffices for import validation in this planning loop.
- Update docs/fix_plan.md CLI-FLAGS-003 Attempts with a new entry (“Attempt #94 — documentation loop”) summarising memo updates, checklist creation, and collect-only log.
  In Observations, reiterate H5 dominance and note that implementation is blocked pending checklist completion; list artifact paths in Artifacts subsection.
- Adjust plans/active/cli-noise-pix0/plan.md L3j guidance if the checklist adds new thresholds or artifact directories; maintain table formatting and state `[D]` only after verifying docs exist.
  Keep plan references to spec and doc paths aligned with actual file names.
- Commit only doc/report changes; leave src/ untouched. Prepare for future implementation loop by mentioning the new artifacts in galph_memory once done.

Pitfalls To Avoid:
- Do not modify src/ or scripts/ code; this is strictly a planning/documentation turn.
- Avoid regenerating large traces; reuse existing logs to quote values unless a blocker demands reruns.
- Keep all new doc references unit-consistent (meters for geometry, Å for physics) to avoid confusion.
- Do not collapse plan tables or reorder completed tasks; append notes if necessary.
- Skip running nb-compare or the supervisor command; checklist should document commands without executing them this loop.
- Guard against losing precision when transcribing values; use full numeric strings from logs.
- Respect Protected Assets (docs/index.md references); do not rename or delete listed files.
- Avoid editing prompts/main.md or automation harness scripts; not part of this scope.
- Do not relax tolerances below spec thresholds; maintain ≤1e-6 relative for scaling factors.
- Refrain from adding TODO markers without context; reference plan IDs or spec clauses when noting follow-ups.
- Ensure collect-only command runs with KMP_DUPLICATE_LIB_OK=TRUE to avoid MKL crashes; mention env var in logs.
- When editing markdown, keep ASCII characters only; follow repository editing constraints.

Pointers:
- specs/spec-a-cli.md:1 — Normative CLI rules for -nonoise and pix0 overrides.
- specs/spec-a-core.md:400 — Lattice factor equations and acceptance criteria to cite for F_latt thresholds.
- docs/architecture/detector.md:35 — pix0_vector derivation (BEAM/SAMPLE formulas) referenced in memo/checklist.
- docs/development/c_to_pytorch_config_map.md:42 — Detector pivot/unit mapping tied to φ rotation decisions.
- docs/development/testing_strategy.md:120 — Targeted pytest workflow (Tier 1 parity guidance) for checklist selectors.
- docs/debugging/debugging.md:24 — Parallel trace SOP; cite when directing per-φ harness reruns.
- plans/active/cli-noise-pix0/plan.md:271 — Detailed definitions of L3j.1–L3j.3 tasks to mirror in doc updates.
- docs/fix_plan.md:450 — CLI-FLAGS-003 ledger entry awaiting Attempt #94 documentation.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 — Current hypothesis ranking (H5 primary).
- reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_diff.md:40 — Component-level deltas backing the memo.
- reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_env.json:1 — Environment snapshot for reproducibility metadata.
- prompts/supervisor.md:18 — Exact supervisor command parameters; include in checklist.
- reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md:22 — Context for k_frac divergence to restate.
- reports/2025-10-cli-flags/phase_l/rot_vector/spindle_audit.log:5 — Evidence ruling out spindle normalization; mention in memo recap.
- reports/2025-10-cli-flags/phase_l/rot_vector/per_phi/trace_py_scaling_20251119_per_phi.json:1 — JSON structure to reference in checklist instructions.
- history/2025-10/cli-flags/README.md:1 — Prior archival summary if cross-links help orient reviewers (optional).

Next Up: 1) Once L3j checklist is in place, schedule the implementation loop targeting φ rotation parity per plan Phase L3; 2) If time remains, gather outstanding evidence for VECTOR-TRICUBIC-001 Phase C1 (gather fallback semantics) without touching production code.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:06:51] bash -lc "cat <<'EOF' > input.md
Summary: Document φ-rotation parity evidence so future simulator fixes have a locked checklist and spec citations.
Mode: Parity
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: pytest --collect-only -q
Artifacts: reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md; reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md; docs/fix_plan.md; plans/active/cli-noise-pix0/plan.md; reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md; reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log; reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md
Do Now: CLI-FLAGS-003 Phase L3j.1–L3j.2 — pytest --collect-only -q
If Blocked: Capture a short narrative in reports/2025-10-cli-flags/phase_l/rot_vector/attempt_notes.md, stash any harness stdout under the same folder, and note the blocker plus file paths in docs/fix_plan.md Attempts for traceability.

Context Recap:
- Attempt #93 proved MOSFLM base vectors align within float32 precision and shifted suspicion to φ rotation (H5) per reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md.
- L3a–L3i tasks are ✅; per-φ traces and spindle audits exist, but no implementation checklist yet guards the upcoming fix.
- The supervisor command relies on phisteps=10, osc=0.1, so φ sampling at 0°, 0.05°, 0.1° captures the full motion envelope.
- docs/fix_plan.md Next Actions still reference L3i instrumentation; updating them prevents future loops from repeating now-complete evidence tasks.
- Long-term Goal #1 (run C vs PyTorch parity command) is blocked until φ rotation parity is restored, making this documentation loop a prerequisite.
- Vectorization backlog is paused; documenting CLI progress clarifies when resources can return to VECTOR-TRICUBIC-001.
- Protected Assets rule demands we leave docs/index.md references untouched; all new content must live in allowed directories (plans/, docs/, reports/).
- Mode Parity forbids running full pytest; only collect-only validation is expected after doc edits.
- Prior evidence loops already generated heavy traces; reuse them, avoid generating new large logs unless absolutely necessary.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md:260 keeps Phase L3 sequencing; finishing memo/checklist flips L3j rows to [D], signalling readiness for code changes.
  Tie the memo content directly to the plan so future readers map doc artifacts to plan IDs without guessing.
- docs/fix_plan.md:450 needs Next Actions aligned to L3j.1–L3j.3; without this, automation scripts may queue stale instrumentation tasks.
  When updating fix_plan, cite artifact paths explicitly to maintain reproducibility.
- specs/spec-a-cli.md:1 enumerates CLI semantics; referencing §3.3 prevents documentation drift when summarising pix0 overrides and noise suppression expectations.
  Connect -nonoise behavior with the existing plan to remind reviewers the flag already works at CLI level.
- docs/architecture/detector.md:35 supplies BEAM/SAMPLE formulas; quoting them in the checklist anchors tolerances to the geometry spec and clarifies which components are meter-based.
  Include note about how these formulas interact with CUSTOM convention when pix0 overrides are present.
- docs/development/c_to_pytorch_config_map.md:42 documents implicit pivot/unit rules; the memo must cite it to explain why φ rotation is the remaining unmatched stage and to avoid re-litigating pivot logic.
  Highlight the pivot implications (twotheta implies SAMPLE) so checklist readers recall the default.
- docs/development/testing_strategy.md:120 standardises targeted pytest usage; the checklist needs explicit selectors drawn from this guidance to stay in compliance with testing SOP.
  Mention Tier 1 parity context to tie the collect-only run to spec-driven expectations.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 tracks current hypothesis ordering (H5 primary, H6/H7 secondary); memo must echo this so later loops continue where we left off.
  Carry over the quantitative deltas (e.g., k_frac mismatch, F_latt sign flip) into the new memo section.
- reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log:63 and trace_py_rot_vector.log:16 form the evidence pair; quote them in the memo to justify threshold choices.
  Keep raw precision (up to 1e-12) when transcribing values.
- prompts/supervisor.md:18 houses the authoritative CLI command; the checklist should reference it verbatim for nb-compare reproduction to avoid parameter drift.
  Clarify environment variables (NB_C_BIN, KMP_DUPLICATE_LIB_OK) alongside the command.
- plans/active/vectorization.md:31 is non-blocking but stays queued; documenting CLI parity progress clarifies when we can pivot to tricubic work without mixing initiatives.
  Mention this in memo conclusions for cross-team visibility.

How-To Map:
- Re-read Attempt #93 artifacts (c_trace_mosflm.log, mosflm_matrix_diff.md) and extend mosflm_matrix_correction.md with a \"Post-L3i Findings\" section stating H3 is ruled out, H5 remains primary, H6/H7 secondary.
  Cite golden_suite_generator/nanoBragg.c:2050-2199 for C reference and src/nanobrag_torch/models/crystal.py:568-780 for PyTorch behavior.
- Summarise quantitative deltas: include b_Y delta 1.35e-07 Å, k_frac shift ≈0.018, F_latt sign flip, linking each to trace line numbers.
  Explain how these deltas propagate into intensity mismatches (I_before_scaling ~7.13e5 vs 9.44e5) referencing scaling logs.
- Outline φ sampling requirements (0°, 0.05°, 0.1°) and relate them to phisteps, osc, and beamsize to justify coverage.
  Note that per-φ JSON already exists; instruct checklist users to regenerate it only after applying code changes.
- Draft fix_checklist.md with table "'`[ID | Requirement | Owner | Artifact Path | Threshold / Notes]` containing at least three rows: per-φ harness rerun, targeted pytest, nb-compare ROI.
  For each row, list spec/doc references (specs/spec-a-cli.md §3.3, docs/debugging/debugging.md §Parallel Trace, docs/development/testing_strategy.md §1.5) and required thresholds (≤1e-6 relative, correlation ≥0.9995, etc.).
- Include an entry reminding future implementers to update docs/index.md references only if new artifacts become canonical, respecting Protected Assets Rule.
- After doc edits, run `KMP_DUPLICATE_LIB_OK=TRUE pytest --collect-only -q` from repo root, capture output into reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log, and mention it in fix_plan Attempt.
  Do not upgrade to full pytest; collect-only suffices for import validation in this planning loop.
- Update docs/fix_plan.md CLI-FLAGS-003 Attempts with a new entry (“Attempt #94 — documentation loop”) summarising memo updates, checklist creation, and collect-only log.
  In Observations, reiterate H5 dominance and note that implementation is blocked pending checklist completion; list artifact paths in Artifacts subsection.
- Adjust plans/active/cli-noise-pix0/plan.md L3j guidance if the checklist adds new thresholds or artifact directories; maintain table formatting and state `[D]` only after verifying docs exist.
  Keep plan references to spec and doc paths aligned with actual file names.
- Commit only doc/report changes; leave src/ untouched. Prepare for future implementation loop by mentioning the new artifacts in galph_memory once done.

Pitfalls To Avoid:
- Do not modify src/ or scripts/ code; this is strictly a planning/documentation turn.
- Avoid regenerating large traces; reuse existing logs to quote values unless a blocker demands reruns.
- Keep all new doc references unit-consistent (meters for geometry, Å for physics) to avoid confusion.
- Do not collapse plan tables or reorder completed tasks; append notes if necessary.
- Skip running nb-compare or the supervisor command; checklist should document commands without executing them this loop.
- Guard against losing precision when transcribing values; use full numeric strings from logs.
- Respect Protected Assets (docs/index.md references); do not rename or delete listed files.
- Avoid editing prompts/main.md or automation harness scripts; not part of this scope.
- Do not relax tolerances below spec thresholds; maintain ≤1e-6 relative for scaling factors.
- Refrain from adding TODO markers without context; reference plan IDs or spec clauses when noting follow-ups.
- Ensure collect-only command runs with KMP_DUPLICATE_LIB_OK=TRUE to avoid MKL crashes; mention env var in logs.
- When editing markdown, keep ASCII characters only; follow repository editing constraints.

Pointers:
- specs/spec-a-cli.md:1 — Normative CLI rules for -nonoise and pix0 overrides.
- specs/spec-a-core.md:400 — Lattice factor equations and acceptance criteria to cite for F_latt thresholds.
- docs/architecture/detector.md:35 — pix0_vector derivation (BEAM/SAMPLE formulas) referenced in memo/checklist.
- docs/development/c_to_pytorch_config_map.md:42 — Detector pivot/unit mapping tied to φ rotation decisions.
- docs/development/testing_strategy.md:120 — Targeted pytest workflow (Tier 1 parity guidance) for checklist selectors.
- docs/debugging/debugging.md:24 — Parallel trace SOP; cite when directing per-φ harness reruns.
- plans/active/cli-noise-pix0/plan.md:271 — Detailed definitions of L3j.1–L3j.3 tasks to mirror in doc updates.
- docs/fix_plan.md:450 — CLI-FLAGS-003 ledger entry awaiting Attempt #94 documentation.
- reports/2025-10-cli-flags/phase_l/rot_vector/analysis.md:12 — Current hypothesis ranking (H5 primary).
- reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_diff.md:40 — Component-level deltas backing the memo.
- reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_env.json:1 — Environment snapshot for reproducibility metadata.
- prompts/supervisor.md:18 — Exact supervisor command parameters; include in checklist.
- reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md:22 — Context for k_frac divergence to restate.
- reports/2025-10-cli-flags/phase_l/rot_vector/spindle_audit.log:5 — Evidence ruling out spindle normalization; mention in memo recap.
- reports/2025-10-cli-flags/phase_l/rot_vector/per_phi/trace_py_scaling_20251119_per_phi.json:1 — JSON structure to reference in checklist instructions.
- history/2025-10/cli-flags/README.md:1 — Prior archival summary if cross-links help orient reviewers (optional).

Next Up: 1) Once L3j checklist is in place, schedule the implementation loop targeting φ rotation parity per plan Phase L3; 2) If time remains, gather outstanding evidence for VECTOR-TRICUBIC-001 Phase C1 (gather fallback semantics) without touching production code.
EOF
' succeeded in 919ms:

[2025-10-07T12:06:51] tokens used: 131,870
[2025-10-07T12:06:51] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:06:53] thinking

**Checking line count**
[2025-10-07T12:06:53] exec bash -lc 'wc -l input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:06:54] bash -lc 'wc -l input.md' succeeded in 707ms:
      93 input.md
[2025-10-07T12:06:54] tokens used: 135,610
[2025-10-07T12:06:54] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:06:59] thinking

**Planning to extend content length**
[2025-10-07T12:07:03] exec bash -lc "cat <<'EOF' >> input.md

Evidence Reminders:
- Keep numeric precision consistent (≥12 significant digits) when quoting trace outputs; mismatched rounding complicates parity comparisons later.
- When saving collect-only log, prepend timestamp and git SHA at top for reproducibility (see reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_template.txt if helpful).
- Cross-link new memo sections with galph_memory entry once committed so future supervisor loops pick up the context without rereading whole plan.
- Ensure nb-compare command in checklist mentions expected output directory and correlation thresholds (≥0.9995) so implementer knows pass criteria before running it.
- If you identify any missing documentation references while drafting, note them inline with TODO[doc] markers tied to plan IDs for easy follow-up.
EOF
" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:07:03] bash -lc "cat <<'EOF' >> input.md

Evidence Reminders:
- Keep numeric precision consistent (≥12 significant digits) when quoting trace outputs; mismatched rounding complicates parity comparisons later.
- When saving collect-only log, prepend timestamp and git SHA at top for reproducibility (see reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_template.txt if helpful).
- Cross-link new memo sections with galph_memory entry once committed so future supervisor loops pick up the context without rereading whole plan.
- Ensure nb-compare command in checklist mentions expected output directory and correlation thresholds (≥0.9995) so implementer knows pass criteria before running it.
- If you identify any missing documentation references while drafting, note them inline with TODO[doc] markers tied to plan IDs for easy follow-up.
EOF
" succeeded in 679ms:

[2025-10-07T12:07:03] tokens used: 136,069
[2025-10-07T12:07:03] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.

[2025-10-07T12:07:06] exec bash -lc 'wc -l input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:07:07] bash -lc 'wc -l input.md' succeeded in 684ms:
     100 input.md
[2025-10-07T12:07:07] tokens used: 136,994
[2025-10-07T12:07:07] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:07:16] thinking

**Preparing to enforce git hygiene**
[2025-10-07T12:07:17] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:07:18] bash -lc 'git status --short' succeeded in 924ms:
 M docs/fix_plan.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-07T12:07:18] tokens used: 137,233
[2025-10-07T12:07:18] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:07:24] thinking

**Reviewing code changes**
[2025-10-07T12:07:26] exec bash -lc 'git diff' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:07:27] bash -lc 'git diff' succeeded in 709ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04..5588fad 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/input.md b/input.md
index 4643c20..52d906b 100644
--- a/input.md
[2025-10-07T12:07:27] tokens used: 137,485
[2025-10-07T12:07:27] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:07:37] thinking

**Preparing update for galph_memory.md**
[2025-10-07T12:07:37] tokens used: 141,226
[2025-10-07T12:07:37] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:07:40] thinking

**Appending new entry to galph_memory.md**
[2025-10-07T12:07:41] exec bash -lc 'tail -n 40 galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:07:42] bash -lc 'tail -n 40 galph_memory.md' succeeded in 852ms:
## 2025-11-19 (galph loop — CLI rotation audit setup)
- Updated CLI-FLAGS-003 next actions + plan Phase L3 to reflect Attempt #86 per-phi evidence and new phi=0 rotation mismatch; L3e marked done, new tasks L3f (rot-vector comparison) and L3g (hypothesis framing) added.
- Input.md now directs Ralph to capture rotation vectors via trace_harness, build `rot_vector_comparison.md`, and log hypotheses before touching simulator code.
- Key observation logged: PyTorch rot_b at phi=0 uses k_frac ≈ -0.589 vs C -0.607, flipping F_latt_b sign; rotation-vector audit required before normalization changes.


## 2025-11-19 (galph loop — CLI L3g invariants setup)
- Refreshed input.md (Parity) to drive Phase L3g evidence: rerun φ=0 harness, generate `rot_vector/invariant_probe.md`, and capture pytest collect.
- Parsed new rot_vector artifacts: real-space vectors drift O(1e-2 Å) while reciprocal vectors align ≈1e-9 Å⁻¹; computed volumes (C 24682.25663 Å³ vs Py 24682.25998 Å³) and dot products (C deviates ≤4.4e-4, Py ≈1.0) to focus on reciprocal→real reconstruction.
- Directed Ralph to update `analysis.md` plus fix_plan Attempt #88 with invariant metrics and to keep snippets under reports/rot_vector/ before any simulator edits.
- Next follow-up: after invariants are logged, decide whether Crystal.get_real_from_reciprocal needs instrumentation or spindle-axis normalization fixes before code changes.

## 2025-11-20 (galph loop — Vectorization Phase C kickoff)
- `git pull --rebase` clean; no new conflicts encountered.
- Reviewed long-term goals: CLI parity remains in Phase L3f (rotation vectors outstanding), while vectorization backlog stalled at Phase C. Determined VECTOR-TRICUBIC-001 needs refreshed guidance before Ralph can implement C1.
- Updated `plans/active/vectorization.md` (lines 1-120) with 2025-11-20 gap snapshot plus explicit artifact paths and pytest/benchmark commands for Phase C1–C3. Mirrored instructions in `docs/fix_plan.md:1796-1810` so Next Actions now reference gather_notes.md, diff_snapshot.json, and new test selectors.
- Authored `input.md` (Perf mode, 101 lines) directing Ralph to tackle Phase C1: collect-only run, implement batched `(S,F,4,4,4)` gather, capture diff/runtime artifacts, rerun targeted tricubic tests (including fallback + gradient smoke), and log results under `reports/2025-10-vectorization/phase_c/` before staging.
- Follow-up expectations: Ralph executes Do Now, populates gather_notes + Attempt entry, and leaves polynomial work for later phases. Next supervisor loop should verify new artifacts, ensure docs/fix_plan Attempt logged, and then pivot to CLI L3f or Phase C2 depending on progress.

## 2025-11-20 (galph loop — CLI L3g spindle audit prep)
[2025-10-07T12:07:42] tokens used: 142,329
[2025-10-07T12:07:42] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:07:45] thinking

**Appending new entry with patch**
[2025-10-07T12:07:50] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/galph_memory.md
@@ -1608 +1608,6 @@
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
[2025-10-07T12:07:50] apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M galph_memory.md
[2025-10-07T12:07:50] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.

[2025-10-07T12:07:50] tokens used: 144,400
[2025-10-07T12:07:50] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:07:53] thinking

**Staging and committing changes**
[2025-10-07T12:07:55] exec bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:07:55] bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' succeeded in 882ms:

[2025-10-07T12:07:55] tokens used: 145,453
[2025-10-07T12:07:55] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:07:58] thinking

**Committing with descriptive message**
[2025-10-07T12:07:59] exec bash -lc 'git commit -m "SUPERVISOR: CLI L3j planning - tests: not run"' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:08:00] bash -lc 'git commit -m "SUPERVISOR: CLI L3j planning - tests: not run"' succeeded in 688ms:
[feature/spec-based-2 e8a2559] SUPERVISOR: CLI L3j planning - tests: not run
 4 files changed, 104 insertions(+), 96 deletions(-)
[2025-10-07T12:08:00] tokens used: 145,624
[2025-10-07T12:08:00] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:08:04] thinking

**Pushing committed changes**
[2025-10-07T12:08:04] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:08:07] bash -lc 'git push' succeeded in 2.13s:
To github.com:hoidn/nanoBragg.git
   acde53e..e8a2559  feature/spec-based-2 -> feature/spec-based-2
[2025-10-07T12:08:07] tokens used: 145,806
[2025-10-07T12:08:07] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:08:13] thinking

**Preparing final summary and references**
[2025-10-07T12:08:14] exec bash -lc "nl -ba docs/fix_plan.md | sed -n '450,470p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:08:15] bash -lc "nl -ba docs/fix_plan.md | sed -n '450,470p'" succeeded in 733ms:
   450	## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
   451	- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
   452	- Priority: High
   453	- Status: in_progress (Phases A–H complete; K3a/K3b/K3d landed via Attempts #43–44, pending per-φ evidence + normalization closure)
   454	- Owner/Date: ralph/2025-10-05
   455	- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
   456	- Reproduction (C & PyTorch):
   457	  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   458	  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
   459	- First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
   460	- Next Actions (2025-11-20 refresh → updated by galph):
   461	 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
   462	 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
   463	 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
   464	- Attempts History:
   465	  * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
   466	    Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
   467	    Artifacts:
   468	      - `src/nanobrag_torch/simulator.py:1313-1322` - Spindle instrumentation (emit raw/normalized/magnitude)
   469	      - `reports/2025-10-cli-flags/phase_l/rot_vector/trace_py_rot_vector.log` - Refreshed φ=0 trace with spindle data
[2025-10-07T12:08:15] tokens used: 146,256
[2025-10-07T12:08:15] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:08:17] thinking

**Confirming plan line numbers**
[2025-10-07T12:08:18] exec bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '268,282p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:08:19] bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '268,282p'" succeeded in 688ms:
   268	| L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
   269	| L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
   270	| L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
   271	| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
   272	| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
   273	| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
   274	
   275	### Phase L4 — Supervisor Command Parity Rerun
   276	Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.
   277	Prereqs: L3 validation artifacts show ≤1e-6 deltas for scaling factors; regression tests green.
   278	Exit Criteria: nb-compare metrics meet thresholds, artifacts stored under `reports/2025-10-cli-flags/phase_l/supervisor_command_rerun/`, docs/fix_plan.md Attempt #56 documents the pass, and this plan is ready for archival.
   279	
   280	| ID | Task Description | State | How/Why & Guidance |
   281	| --- | --- | --- | --- |
   282	| L4a | Rerun supervisor command parity | [ ] | Execute the authoritative command from `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md`, writing outputs to a new timestamped directory. Capture `summary.json`, stdout/stderr, and SHA256 hashes. |
[2025-10-07T12:08:19] tokens used: 147,962
[2025-10-07T12:08:19] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:08:21] thinking

**Checking galph_memory.md line numbers**
[2025-10-07T12:08:23] exec bash -lc 'nl -ba galph_memory.md | tail -n 30' in /Users/ollie/Documents/nanoBragg3
[2025-10-07T12:08:23] bash -lc 'nl -ba galph_memory.md | tail -n 30' succeeded in 701ms:
  1584	- Updated `plans/active/vectorization.md` (lines 1-120) with 2025-11-20 gap snapshot plus explicit artifact paths and pytest/benchmark commands for Phase C1–C3. Mirrored instructions in `docs/fix_plan.md:1796-1810` so Next Actions now reference gather_notes.md, diff_snapshot.json, and new test selectors.
  1585	- Authored `input.md` (Perf mode, 101 lines) directing Ralph to tackle Phase C1: collect-only run, implement batched `(S,F,4,4,4)` gather, capture diff/runtime artifacts, rerun targeted tricubic tests (including fallback + gradient smoke), and log results under `reports/2025-10-vectorization/phase_c/` before staging.
  1586	- Follow-up expectations: Ralph executes Do Now, populates gather_notes + Attempt entry, and leaves polynomial work for later phases. Next supervisor loop should verify new artifacts, ensure docs/fix_plan Attempt logged, and then pivot to CLI L3f or Phase C2 depending on progress.
  1587	
  1588	## 2025-11-20 (galph loop — CLI L3g spindle audit prep)
  1589	- Reviewed CLI-FLAGS-003 status: Phase L3f/L3g remain open despite prior rot_vector artifacts; residual k_frac drift traced to Y-component deltas and potential spindle/volume mismatch.
  1590	- Captured current artifacts (rot_vector_comparison.md, invariant_probe.md) and confirmed trace_harness.py emits full TRACE_PY data; next evidence must log spindle-axis norm + V_formula/V_actual for PyTorch vs C.
  1591	- Authored input.md (Parity mode) directing Ralph to refresh the trace, build spindle_probe + volume_probe outputs under reports/2025-10-cli-flags/phase_l/rot_vector/, rerun collect-only pytest, and update docs/fix_plan.md Attempt with quantified deltas.
  1592	- No plan rewrites needed yet; expect Ralph to append new evidence then adjust plan L3 items if hypotheses shift.
  1593	
  1594	## 2025-11-20 (galph loop — CLI spindle instrumentation setup)
  1595	- Recorded new context line in `plans/active/cli-noise-pix0/plan.md` for Attempt #89 (spindle + volume probe). Marked L3f ✅, kept L3g `[P]` with explicit instruction to surface `TRACE_PY: spindle_axis` before simulator edits; L3h now depends on that evidence.
  1596	- Updated `docs/fix_plan.md` Next Actions (CLI-FLAGS-003) to focus on spindle-axis instrumentation → doc/plan sync → eventual nb-compare rerun. input.md refreshed accordingly.
  1597	- Expect Ralph to extend `trace_harness.py` (or TRACE_PY hooks) with raw/normalized spindle logging, rerun the φ=0 trace, append results to `spindle_audit.log`, and update fix_plan/plan entries before shifting to implementation.
  1598	## 2025-11-20 (galph loop — CLI-FLAGS MOSFLM probe setup)
  1599	- Updated `plans/active/cli-noise-pix0/plan.md` Phase L3 with new tasks L3h–L3j covering MOSFLM matrix probe, corrective memo, and implementation checklist; prior L3a–L3g remain [D].
  1600	- Adjusted `docs/fix_plan.md` Next Actions for CLI-FLAGS-003 to align with the new Phase L3h–L3j workflow (probe → memo → checklist).
  1601	- Authored `input.md` (Parity mode, 100 lines) directing Ralph to capture `mosflm_matrix_probe.log/md`, log env metadata, and prepare outlines for `mosflm_matrix_correction.md` + `fix_checklist.md` before any code edits.
  1602	- Expectation for Ralph: run the harness with MOSFLM vector dumps, document the deltas, update fix_plan Attempt history, and leave code untouched until the memo/checklist exist.
  1603	- No production code changes made; commit 3232549 contains plan/fix_plan/input refresh (tests: not run).
[2025-10-07T12:08:23] tokens used: 149,373
[2025-10-07T12:08:23] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.


[2025-10-07T12:08:30] thinking

**Preparing final summary message**

I'll create a friendly, bullet-pointed summary highlighting the updated files and next steps for Ralph, while noting that no tests were run since the changes are documentation-only.
[2025-10-07T12:08:31] codex

**Updates**
- docs/fix_plan.md:450 now points CLI-FLAGS-003 to Phase L3j.1–L3j.3 (memo refresh, checklist authoring, fix_plan sync) so stale L3i instrumentation is cleared before the next loop.
- plans/active/cli-noise-pix0/plan.md:271 splits L3j into explicit tasks covering the correction memo, verification checklist, and coordination step, tying each to required artifacts and tolerances.
- input.md:1 replaced with a 100-line Parity brief directing Ralph to update mosflm_matrix_correction.md, draft fix_checklist.md, run collect-only pytest, and log outputs under rot_vector/.
- galph_memory.md:1609 records this alignment for future supervisor turns and notes that no production code changed this cycle.

**Next Steps**
- Ralph should execute CLI-FLAGS-003 Phase L3j.1–L3j.3: update the correction memo, create the checklist, run `KMP_DUPLICATE_LIB_OK=TRUE pytest --collect-only -q`, and log Attempt #94 with the new artifacts. Tests: not run (doc-only loop).
[2025-10-07T12:08:35] tokens used: 151,311
[2025-10-07T12:08:35] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 32fdb04877e9978271831066664e95f680a60d08..5588fadb62eabfac0a0e12b0a11924721a91f00f
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -458,9 +458,9 @@
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase L2c comparison shows all scaling factors (ω, polarization, r_e², fluence, steps) match C within 0.2%, but `I_before_scaling` diverges because PyTorch reports `F_cell=0` at hkl≈(−7,−1,−14) while C's trace records `F_cell=190.27`. **Phase L3b (Attempt #76) proved the data exists (scaled.hkl contains F=190.27 for this reflection); root cause is configuration/loading, NOT missing coverage.**
 - Next Actions (2025-11-20 refresh → updated by galph):
-  1. Phase L3i.a — Instrument `nanoBragg.c` around lines 2050-2169 to emit `TRACE_C` logs for the MOSFLM cross products, `V_cell`, and real-space vectors; stash the run at `reports/2025-10-cli-flags/phase_l/rot_vector/c_trace_mosflm.log`.
-  2. Phase L3i.b — Extend `trace_harness.py` to capture the raw numpy MOSFLM vectors and the tensor views before/after `Crystal.compute_cell_tensors`; produce `rot_vector/mosflm_matrix_diff.md` aligning PyTorch vs C per-component deltas.
-  3. Phase L3j — Author `rot_vector/fix_checklist.md` (tests + tolerances) once the diff isolates the fault, then queue the implementation loop to restore lattice-vector parity prior to rerunning nb-compare.
+ 1. Phase L3j.1 — Update `mosflm_matrix_correction.md` with Attempt #93 evidence (H3 ruled out, H5–H7 promoted) and cite the relevant trace line numbers plus φ sampling requirements.
+ 2. Phase L3j.2 — Draft `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` listing per-φ trace, targeted pytest (`tests/test_cli_scaling.py -k lattice -v`), and nb-compare ROI commands with ≤1e-6 tolerances and artifact paths.
+ 3. Phase L3j.3 — Refresh docs/fix_plan.md Attempt history once the checklist exists and log the evidence paths before scheduling simulator code changes.
 - Attempts History:
   * [2025-10-07] Attempt #91 (ralph loop i=91) — Result: **SUCCESS** (Phase L3g spindle instrumentation COMPLETE). **H1 (spindle normalization) RULED OUT as root cause of Y-drift.**
     Metrics: Spindle Δ(magnitude)=0.0 (tolerance ≤5e-4); trace captured 43 TRACE_PY lines (was 40, +3 spindle lines); test collection 4/4 passed.
diff --git a/galph_memory.md b/galph_memory.md
index e87e3d4534e595f9a2569a3ed91f64a3285c23da..a586570704caee44369406b2b31016b6ec33bd16
--- a/galph_memory.md
+++ b/galph_memory.md
@@ -1606,3 +1606,8 @@
 - Updated `docs/fix_plan.md` Next Actions to focus on C TRACE_C taps, Py harness dumps, and diff memo before implementation; input.md now directs Ralph to capture those traces and document deltas.
 - Expect Ralph to instrument `golden_suite_generator/nanoBragg.c`, run the supervisor command to generate `c_trace_mosflm.log`, extend the Py harness for raw/tensor dumps, and produce `mosflm_matrix_diff.md` prior to touching simulator code.
 
+## 2025-11-20 (galph loop — CLI L3j checklist alignment)
+- Extended `plans/active/cli-noise-pix0/plan.md` Phase L3 with sub-tasks L3j.1–L3j.3 (memo refresh, fix checklist, plan/fix_plan sync) so implementation has explicit gates.
+- Updated `docs/fix_plan.md` Next Actions to point at the new L3j workflow; removed stale L3i instrumentation steps.
+- Authored `input.md` (Parity mode, 100 lines) instructing Ralph to update mosflm_matrix_correction.md, draft `fix_checklist.md`, run pytest --collect-only, and log artifacts under rot_vector/ before touching code.
+- No production code changes performed; expect Ralph’s Attempt #94 to document memo/checklist completion plus collect-only log before proceeding to φ-rotation implementation.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 89b2ddfb16886aef39aa5388d895cb160405b274..0754341c5fbf8aa4a6e0e5559ac645ab985008c5
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -28,6 +28,7 @@
 - Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
 - Gap snapshot refresh (2025-11-19): Latest scaling audit (`reports/2025-10-cli-flags/phase_l/scaling_validation/analysis_20251119.md`) shows `F_cell` parity restored while per-phi instrumentation (Attempt #86) now emits the expected `TRACE_PY_PHI` entries. The refreshed log exposes a residual phi=0 mismatch (`k_frac` -0.589 in PyTorch vs -0.607 in C) that flips `F_latt_b`’s sign, so Phase L3 needs a dedicated rotation-vector audit before touching normalization again.
 - Gap snapshot refresh (2025-11-20): Attempt #89 (ralph loop i=90) completed the Phase L3g spindle/volume probe. `spindle_audit.log` and `volume_probe.md` confirm reciprocal vectors retain ≤1e-9 alignment while real-space Y components drift (b_y +6.8%). Hypothesis H2 (V_formula vs V_actual) is ruled out; remaining blocker is capturing `TRACE_PY: spindle_axis` output so spindle normalization can be proven (or disproven) before code edits.
+- Gap snapshot update (2025-11-20 evening): Attempt #93 diff confirmed MOSFLM base vectors align ≤1e-7 Å, promoting **H5 (φ rotation application)** as the primary suspect. Before implementation, Phase L3j must lock verification gates (per-φ trace, targeted pytest, nb-compare ROI) so the eventual fix can be validated against specs/spec-a-cli.md §3.3 and CLAUDE Rules 12/13.
 - Diagnostic note (2025-11-08 galph audit): `scripts/trace_per_phi.py` currently subtracts `pix0_vector` from `detector.get_pixel_coords()`, yielding plane-relative vectors instead of sample-to-pixel paths. Fix this double subtraction in the Phase K3f PyTorch harness before recording new parity traces.
 - Gap confirmation (2025-11-08 trace diff): Phase K3f base-lattice traces show PyTorch keeps the placeholder unit cell volume (`V≈1 Å^3`) when MOSFLM vectors are supplied, so `Crystal.compute_cell_tensors` fails to rescale the real vectors. C multiplies `b*×c*` by `V_cell≈2.4682×10^4 Å^3` before converting to meters, yielding |a|≈26.75 Å; PyTorch leaves |a|≈5.8×10^3 Å, which in turn inflates h/k/l by ≈6 units. Fix requires mirroring the MOSFLM derivation pipeline in `Crystal.compute_cell_tensors` (see `specs/spec-a-core.md` Geometry + `golden_suite_generator/nanoBragg.c` 3135-3210).
 - Gap snapshot update (2025-11-08 evening): Commit 46ba36b implements the MOSFLM rescale path and new regression test `TestMOSFLMCellVectors::test_mosflm_cell_vectors` passes (see `reports/2025-10-cli-flags/phase_k/base_lattice/post_fix/cell_tensors_py.txt`). Base-lattice summary now records the fix; remaining blocker is Phase K3g3 to rerun scaling evidence and refresh nb-compare/pytest artifacts.
@@ -267,7 +268,9 @@
 | L3g | Fractional Miller alignment plan | [D] | ✅ 2025-10-07 Attempt #91: Instrumented simulator.py:1313-1322 to emit `spindle_axis_raw/normalized/magnitude`, reran φ=0 trace (43 TRACE_PY lines), confirmed Δ(magnitude)=0.0 (tolerance ≤5e-4). H1 **RULED OUT**: spindle is exact unit vector [-1,0,0], normalization is no-op. H3 (MOSFLM matrix semantics) promoted to primary suspect. Artifacts: `rot_vector/spindle_audit.log`, `analysis.md` (updated with H3 ranking). |
 | L3h | MOSFLM matrix probe & diff | [D] | ✅ Attempt #92 (2025-10-07, ralph evidence loop i=92): Created `trace_harness.py` in rot_vector/, captured 12 MOSFLM probe lines (post-misset reciprocals, reconstructed reals, re-derived reciprocals), proved V_formula ≈ V_actual (Δ=1.5e-11 Å³), **ruled out Hypothesis H2**. Reciprocal re-derivation exact to 15 digits. Artifacts: `mosflm_matrix_probe.md` (primary doc), `mosflm_matrix_probe_output.log`, `trace_harness.py`, `harness_run.log`. pytest: 579 tests collected. Next: Phase L3i C instrumentation to complete C vs PyTorch diff. |
 | L3i | C instrumentation & diff | [D] | ✅ Attempt #93 (2025-10-07, ralph loop i=93): Captured full C MOSFLM pipeline trace (291 lines) via instrumented `golden_suite_generator/nanoBragg.c:2050-2199`, executed supervisor command, performed component-level diff. **H3 (MOSFLM transpose) RULED OUT** — real-space b_Y matches to O(1e-7) Å. Artifacts: `c_trace_mosflm.log`, `c_trace_extract.txt`, `mosflm_matrix_diff.md`, `analysis.md` (updated with H5-H7 hypotheses). pytest: 652 tests collected. Next: L3j fix checklist focusing on H5 (phi rotation) verification. |
-| L3j | Implementation readiness checklist | [ ] | Before touching simulator/crystal code, author `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating tests (trace harness, `pytest tests/test_cli_scaling.py -k lattice`, nb-compare ROI) and verification thresholds (≤1e-6 relative). Ensure doc references (specs/spec-a-core.md §4, CLAUDE rules 12/13) are cited so the subsequent implementation loop has an actionable checklist. |
+| L3j.1 | Refresh correction memo | [ ] | Extend `reports/2025-10-cli-flags/phase_l/rot_vector/mosflm_matrix_correction.md` with Attempt #93 findings: cite `golden_suite_generator/nanoBragg.c:2050-2199` and `src/nanobrag_torch/models/crystal.py:568-780`, mark H3 **ruled out**, promote H5–H7 with supporting trace line numbers, and spell out the φ samples (0°, 0.05°, 0.1°) needed for verification. |
+| L3j.2 | Author fix checklist | [ ] | Create `reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md` enumerating verification gates: (a) rerun `trace_harness.py` with per-φ outputs under `per_phi/` enforcing ≤1e-6 relative thresholds; (b) `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_scaling.py -k lattice -v`; (c) `nb-compare --roi 100 156 100 156 --resample --outdir reports/2025-10-cli-flags/phase_l/nb_compare_phi0/ -- [supervisor flags]`. Provide status columns (Owner, Artifact Path, Notes) so implementation loop can tick off each gate. |
+| L3j.3 | Sync plan + fix_plan | [ ] | Update this plan and `docs/fix_plan.md` (CLI-FLAGS-003) Attempt history/Next Actions to point at the checklist, including artifact locations and tolerance thresholds, then log the evidence as Attempt #94 before authorizing code changes. |
 
 ### Phase L4 — Supervisor Command Parity Rerun
 Goal: Demonstrate end-to-end parity for the supervisor command (correlation ≥ 0.9995, sum_ratio 0.99–1.01, mean_peak_distance ≤ 1 px) and close CLI-FLAGS-003.

Reading prompt from stdin...
To github.com:hoidn/nanoBragg.git
   e8a2559..837c6bd  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=94...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=94
Updating 837c6bd..99805d5
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   837c6bd..99805d5  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=94
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 99805d5..f7bc759
Fast-forward
 docs/fix_plan.md                                   |  49 ++
 plans/active/cli-noise-pix0/plan.md                |   6 +-
 .../phase_l/rot_vector/fix_checklist.md            | 260 ++++++++
 .../phase_l/rot_vector/mosflm_matrix_correction.md | 159 ++++-
 .../phase_l/rot_vector/test_collect_L3j.log        | 664 +++++++++++++++++++++
 5 files changed, 1132 insertions(+), 6 deletions(-)
 create mode 100644 reports/2025-10-cli-flags/phase_l/rot_vector/fix_checklist.md
 create mode 100644 reports/2025-10-cli-flags/phase_l/rot_vector/test_collect_L3j.log
From github.com:hoidn/nanoBragg
   99805d5..f7bc759  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating f7bc759..783bfde
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   f7bc759..783bfde  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=95
Ralph completed iteration 94; proceeding to 95
