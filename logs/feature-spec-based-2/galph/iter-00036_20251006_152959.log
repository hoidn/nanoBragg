Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=36
To github.com:hoidn/nanoBragg.git
   a26af92..64471dd  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T15:30:04] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T15:30:04] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md ‚Äî C‚ÜîPy config parity and implicit rules
-- docs/debugging/debugging.md ‚Äî Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‚Äëdo; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‚Äëspecific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 


Debugging Items ‚Äî Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1‚Äì3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1‚Äì3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‚Äëline rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase‚Äôs intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  ‚Ä¢ Include reproduction commands, owners (if known), and decision rules in the guidance column.
  ‚Ä¢ Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  ‚Ä¢ Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A ‚Äî <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for this turn.
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor‚Üíengineer steering memo). Overwrite the entire file every invocation. Keep length ~100‚Äì200 lines. Include these sections in order:
Header:
- Summary: <one‚Äësentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none ‚Äî evidence‚Äëonly>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write ‚ÄúDo Now: delegate‚Äù and provide decision guidance below.
  - Note: When the Phase is Evidence, you must not execute tests; any pytest command included here is provided for Ralph‚Äôs subsequent loop.
<Do Now guidelines>
Phase Gate (Evidence): If the active plan phase is Evidence, do not run pytest at all (including collection). Limit evidence gathering to non-test probes and command‚Äëline tooling (e.g., scripts/validation/*, minimal parity CLIs). Do not include runnable tests in this loop.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3‚Äì6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5‚Äì10 crisp do/don‚Äôt reminders (device/dtype neutrality, vectorization, Protected Assets, two‚Äëmessage loop policy, no ad‚Äëhoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1‚Äì2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md‚Äôs Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‚Äëonly loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions‚Äîespecially for docs/fix_plan.md‚Äîin galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T15:30:10] thinking

**Preparing to run git pull with rebase**
[2025-10-06T15:30:12] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:14] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.34s:
Already up to date.
[2025-10-06T15:30:14] tokens used: 12,949

[2025-10-06T15:30:16] thinking

**Preparing to read galph_memory.md**
[2025-10-06T15:30:18] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:19] bash -lc 'cat galph_memory.md' succeeded in 675ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (œÄ/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A‚ÄìE).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ‚â•200√ó slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop ‚Äî AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ‚â•95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr‚âà1.0 (perfect physics) ‚úÖ
  * Parity matrix test: PASSES perfectly ‚úÖ (live C‚ÜîPy comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7√ó more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20√ó20 ROI) has 91 unique values; PyTorch has 331 (3.6√ó fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) ‚Üí perfect correlation but incompatible plateau structure.
[2025-10-06T15:30:19] tokens used: 13,183

[2025-10-06T15:30:24] thinking

**Preparing to review key documents**
[2025-10-06T15:30:25] exec bash -lc "sed -n '1,160p' docs/index.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:26] bash -lc "sed -n '1,160p' docs/index.md" succeeded in 857ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## üèõÔ∏è Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** ‚Äì quick do/don‚Äôt list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** ‚Äì detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy ¬ß1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** ‚Äì required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T15:30:26] tokens used: 16,290

[2025-10-06T15:30:28] thinking

**Opening spec file spec-a.md**
[2025-10-06T15:30:30] exec bash -lc "sed -n '1,160p' specs/spec-a.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:31] bash -lc "sed -n '1,160p' specs/spec-a.md" succeeded in 781ms:
# nanoBragg Spec A ‚Äî Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T15:30:31] tokens used: 33,903

[2025-10-06T15:30:32] thinking

**Checking arch.md file**
[2025-10-06T15:30:34] exec bash -lc "sed -n '1,160p' arch.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:35] bash -lc "sed -n '1,160p' arch.md" succeeded in 835ms:
# nanoBragg PyTorch ‚Äî Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T15:30:35] tokens used: 35,864

[2025-10-06T15:30:44] thinking

**Reviewing PyTorch config map documentation**
[2025-10-06T15:30:46] exec bash -lc "sed -n '1,160p' docs/development/c_to_pytorch_config_map.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:47] bash -lc "sed -n '1,160p' docs/development/c_to_pytorch_config_map.md" succeeded in 691ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | √Ö and degrees ‚Üí radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T15:30:47] tokens used: 56,442

[2025-10-06T15:30:49] thinking

**Accessing debugging documentation**
[2025-10-06T15:30:50] exec bash -lc "sed -n '1,160p' docs/debugging/debugging.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:50] bash -lc "sed -n '1,160p' docs/debugging/debugging.md" succeeded in 695ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T15:30:50] tokens used: 58,350

[2025-10-06T15:30:53] thinking

**Opening initial portion of fix_plan.md**
[2025-10-06T15:30:54] exec bash -lc "sed -n '1,200p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:55] bash -lc "sed -n '1,200p' docs/fix_plan.md" succeeded in 1.09s:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A‚ÄìC) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2‚ÄìB4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1‚ÄìA3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ‚úÖ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
| [CLI-DTYPE-002](#cli-dtype-002-cli-dtype-parity) | CLI dtype parity | High | in_progress |
[2025-10-06T15:30:55] tokens used: 60,339

[2025-10-06T15:30:57] thinking

**Switching to testing strategy document**
[2025-10-06T15:30:58] exec bash -lc "sed -n '1,160p' docs/development/testing_strategy.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:30:59] bash -lc "sed -n '1,160p' docs/development/testing_strategy.md" succeeded in 743ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T15:30:59] tokens used: 63,367

[2025-10-06T15:31:02] thinking

**Preparing to analyze plan and CLI flags**
[2025-10-06T15:31:02] exec bash -lc 'ls plans/active' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:03] bash -lc 'ls plans/active' succeeded in 731ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T15:31:03] tokens used: 75,634

[2025-10-06T15:31:05] thinking

**Checking CLI flags plan**
[2025-10-06T15:31:07] exec bash -lc "sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:08] bash -lc "sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" succeeded in 775ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md ¬ß¬ß3.2‚Äì3.4, docs/architecture/detector.md ¬ß5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720‚Äì1040 & 1730‚Äì1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md ¬ß2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.

### Phase A ‚Äî Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
Prereqs: Ability to run instrumented C binary via `NB_C_BIN` and collect traces.
Exit Criteria: Documented parity notes under `reports/2025-10-cli-flags/phase_a/` with explicit decisions on unit conversions and noise toggle ordering.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Extract C reference for `-nonoise` | [D] | ‚úÖ 2025-10-05: Supervisor command captured with/without `-nonoise`; logs stored under `reports/2025-10-cli-flags/phase_a/`. |
| A2 | Capture pix0 vector ground truth | [D] | ‚úÖ 2025-10-05: Instrumented C trace recorded pix0 vector values; confirms outputs remain in meters even for `_mm` flag. |
| A3 | Update findings memo | [D] | ‚úÖ 2025-10-05: Phase A summary authored in `reports/2025-10-cli-flags/phase_a/README.md` documenting semantics and CUSTOM convention side effects. |
[2025-10-06T15:31:08] tokens used: 79,066

[2025-10-06T15:31:11] thinking

**Considering vectorization planning**
[2025-10-06T15:31:13] exec bash -lc "sed -n '1,200p' plans/active/vectorization.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:14] bash -lc "sed -n '1,200p' plans/active/vectorization.md" succeeded in 734ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md ¬ß4 (Structure factors), specs/spec-a-parallel.md ¬ß2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md ¬ß¬ß2.2‚Äì2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md ¬ß¬ß2‚Äì4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604‚Äì3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A ‚Äî Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ‚áí save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B ‚Äî Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T15:31:14] tokens used: 81,948

[2025-10-06T15:31:20] thinking

**Preparing for in-depth code analysis**
[2025-10-06T15:31:20] exec bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:21] bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' succeeded in 852ms:
21:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
448:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
507:    Next Actions: Execute Phase I3 final parity sweep by running the supervisor command end-to-end (PyTorch CLI + C reference), stash logs under `reports/2025-10-cli-flags/phase_i/supervisor_command/`, document polarization metrics in Attempt #27, then close CLI-FLAGS-003.
[2025-10-06T15:31:21] tokens used: 87,634

[2025-10-06T15:31:23] thinking

**Checking specific code lines**
[2025-10-06T15:31:25] exec bash -lc "sed -n '448,620p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:26] bash -lc "sed -n '448,620p' docs/fix_plan.md" succeeded in 846ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md ¬ß5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720‚Äì1040 & 1730‚Äì1860
- Priority: High
- Status: in_progress (Phases A-H complete; polarization Phase I pending)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase C2 parity run exposed a 2.58e2√ó intensity scaling mismatch (PyTorch max_I‚âà1.15e5 vs C max_I‚âà4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14‚ÄØmm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ‚âà0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
- Next Actions (2025-10-22): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
  1. Refresh C precedence evidence (H5a): rerun the supervisor command with and without `-pix0_vector_mm`, stash logs under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`, and update `phase_h5/c_precedence.md` to document that C recomputes `Fbeam/Sbeam` when the override is supplied alongside custom vectors.
  2. Capture PyTorch traces with the reinstated override (H5c): extend/execute the Phase H trace harness so it logs `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Archive outputs to `reports/2025-10-cli-flags/phase_h5/py_traces/` and append the C vs PyTorch deltas to `phase_h5/parity_summary.md`.
  3. Once geometry parity is verified, log the follow-up attempt in this entry (H5d) and then transition to Phase K normalization tasks.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) ‚Äî Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538√ó sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000√ó discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/summary.json` - Complete parity metrics (correlation, RMSE, sums, peak distances)
[2025-10-06T15:31:26] tokens used: 91,650

[2025-10-06T15:31:35] thinking

**Formulating initial debugging hypotheses**
[2025-10-06T15:31:36] exec bash -lc 'rg "VECTOR-TRICUBIC-001" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:37] bash -lc 'rg "VECTOR-TRICUBIC-001" -n docs/fix_plan.md' succeeded in 759ms:
19:| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
1040:## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
[2025-10-06T15:31:37] tokens used: 94,834

[2025-10-06T15:31:39] thinking

**Scrolling to line 1040**
[2025-10-06T15:31:41] exec bash -lc "sed -n '1040,1220p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:42] bash -lc "sed -n '1040,1220p' docs/fix_plan.md" succeeded in 762ms:
## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
- Spec/AT: specs/spec-a-core.md ¬ß4 (structure factor sampling), specs/spec-a-parallel.md ¬ß2.3 (tricubic acceptance tests), docs/architecture/pytorch_design.md ¬ß¬ß2.2‚Äì2.4 (vectorization strategy), docs/development/testing_strategy.md ¬ß¬ß2‚Äì4, docs/development/pytorch_runtime_checklist.md, nanoBragg.c lines 2604‚Äì3278 (polin3/polin2/polint) and 3375‚Äì3450 (detector absorption loop).
- Priority: High
- Status: in_planning (Phase A evidence outstanding)
- Owner/Date: galph/2025-10-17
- Plan Reference: `plans/active/vectorization.md`
- Reproduction (C & PyTorch):
  * PyTorch baseline tests: `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py tests/test_at_abs_001.py -v`
  * Optional microbenchmarks (to be created per plan Phase A): `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/sample_tricubic_baseline.py`
  * Shapes/ROI: 256¬≤ & 512¬≤ detectors for microbench; oversample 1; structure-factor grid enabling tricubic.
- First Divergence (if known): Current tricubic path drops to nearest-neighbour fallback for batched pixel grids, emitting warnings and forfeiting accuracy/performance; detector absorption still loops over `thicksteps`, preventing full vectorization and creating hotspots in profiler traces (see reports/benchmarks/20250930-165726-compile-cache/analysis.md).
- Next Actions:
  1. Execute plan Phase A tasks A1‚ÄìA3: author the reusable `scripts/benchmarks/tricubic_baseline.py` and `absorption_baseline.py` harnesses, capture pytest + timing artifacts under `reports/2025-10-vectorization/phase_a/`, and record Attempt #1 in this entry.
  2. Complete Phase B design memo (tensor shapes, broadcasting, gradients) before editing code; update this item with design references (`phase_b/design_notes.md`).
  3. Prioritise Phase C/D implementation work on tricubic interpolation, followed by Phase E parity/perf validation. Detector absorption vectorization (Phase F) follows once tricubic work is stable.
- Attempts History:
  * (pending) ‚Äî Capture Phase A baseline artifacts and update this log.
- Risks/Assumptions: Must maintain differentiability (no `.item()`, no `torch.linspace` with tensor bounds), preserve device/dtype neutrality (CPU/CUDA parity), and obey Protected Assets rule (all new scripts under `scripts/benchmarks/`). Large tensor indexing may increase memory pressure; ensure ROI caching still works.
- Exit Criteria (quote thresholds from spec):
  * specs/spec-a-parallel.md ¬ß2.3 tricubic acceptance tests run without warnings and match C parity within documented tolerances (corr‚â•0.9995, ‚â§1e-12 structural duality where applicable).
[2025-10-06T15:31:42] tokens used: 95,111

[2025-10-06T15:31:47] thinking

**Preparing multi-step plan**
[2025-10-06T15:31:50] exec bash -lc 'echo planning tool placeholder' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:31:51] bash -lc 'echo planning tool placeholder' succeeded in 830ms:
planning tool placeholder
[2025-10-06T15:31:51] tokens used: 97,032

[2025-10-06T15:31:57] thinking

**Contemplating plan tool usage**
[2025-10-06T15:31:59] exec bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:00] bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" succeeded in 707ms:
heads
[2025-10-06T15:32:00] tokens used: 97,441

[2025-10-06T15:32:03] thinking

**Checking recent commit history**
[2025-10-06T15:32:05] exec bash -lc 'git log --oneline -n 15' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:06] bash -lc 'git log --oneline -n 15' succeeded in 695ms:
64471dd [SYNC i=36] actor=galph status=running
a26af92 [SYNC i=36] actor=ralph ‚Üí next=galph status=ok ralph_commit=052307f
052307f CLI-FLAGS-003 H5a: Fresh C traces re-confirm override ignored with custom vectors
857c075 [SYNC i=35] actor=ralph status=running
b911412 [SYNC i=35] actor=galph ‚Üí next=ralph status=ok galph_commit=9081bfc
9081bfc SUPERVISOR: CLI-FLAGS-003 H5a evidence prep - tests: not run
d88228f SUPERVISOR AUTO: doc/meta hygiene ‚Äî tests: not run
5210d33 SUPERVISOR: CLI-FLAGS-003 Phase H5 guidance refresh - tests: not run
ac073ae [SYNC i=35] actor=galph status=running
92791b3 [SYNC i=35] actor=ralph ‚Üí next=galph status=ok ralph_commit=5878f16
5878f16 [CLI-FLAGS-003] Phase H5a evidence complete - override ignored with custom vectors
e4b3238 [SYNC i=34] actor=ralph status=running
5837770 [SYNC i=34] actor=galph ‚Üí next=ralph status=ok galph_commit=9b3dbd2
9b3dbd2 SUPERVISOR: Phase H5 evidence setup - tests not run
a53a97f [SYNC i=34] actor=galph status=running
[2025-10-06T15:32:06] tokens used: 97,568

[2025-10-06T15:32:08] thinking

**Reviewing recent commits by Ralph**
[2025-10-06T15:32:09] exec bash -lc 'git log --author=ralph -n 10' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:10] bash -lc 'git log --author=ralph -n 10' succeeded in 739ms:

[2025-10-06T15:32:10] tokens used: 98,051

[2025-10-06T15:32:14] thinking

**Investigating commit author details**
[2025-10-06T15:32:15] exec bash -lc 'git show --stat 052307f' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:15] bash -lc 'git show --stat 052307f' succeeded in 837ms:
commit 052307f0ac5a85ef8496e27a59403cfa26cafca7
Author: ollie <ohoidn>
Date:   Mon Oct 6 08:29:11 2025 -0700

    CLI-FLAGS-003 H5a: Fresh C traces re-confirm override ignored with custom vectors
    
    Evidence-only loop. Captured 2025-10-22 C traces with supervisor command:
    - WITH -pix0_vector_mm: pix0=[-0.216476,0.216343,-0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m
    - WITHOUT -pix0_vector_mm: IDENTICAL geometry values
    
    Result: Override is IGNORED when custom detector vectors present.
    Dot-product derivation proves expected projection values (-0.217596/-0.212772)
    do not match actual C output (0.217889/0.215043).
    
    PyTorch Phase H3b2 (commit d6f158c) correctly skips override in custom-vector path.
    The 1.14mm pix0 delta must originate from different source (Phase K normalization).
    
    Artifacts:
    - reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/{with,without}_override.log
    - reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/diff.log
[2025-10-06T15:32:15] tokens used: 98,338

[2025-10-06T15:32:20] thinking

**Reviewing recent commit logs**
[2025-10-06T15:32:21] exec bash -lc 'git show --stat 5878f16' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:22] bash -lc 'git show --stat 5878f16' succeeded in 888ms:
commit 5878f165b9a0f70f607dd46f6e929d1a000fa813
Author: ollie <ohoidn>
Date:   Mon Oct 6 03:59:19 2025 -0700

    [CLI-FLAGS-003] Phase H5a evidence complete - override ignored with custom vectors
    
    Evidence-only loop. Ran supervisor command with/without -pix0_vector_mm flag.
    
    Key finding: C code produces IDENTICAL pix0/Fbeam/Sbeam with and without
    override when custom detector vectors are present (override silently ignored).
    
    Metrics: WITH override: pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m
            WITHOUT override: pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m
            Difference: 0.0 (geometry identical)
    
    Artifacts:
    - reports/2025-10-cli-flags/phase_h5/c_traces/with_override.log
    - reports/2025-10-cli-flags/phase_h5/c_traces/without_override.log
    - reports/2025-10-cli-flags/phase_h5/c_traces/diff.log
    - reports/2025-10-cli-flags/phase_h5/c_precedence.md (full analysis)
[2025-10-06T15:32:22] tokens used: 140,731

[2025-10-06T15:32:33] thinking

**Analyzing override behavior and logging inconsistencies**

I'm trying to untangle possible contradictions between Ralph's conclusion that override is ignored with custom vectors and earlier indications that it should apply. There‚Äôs a need to sift through logs, detect duplicates, and re-examine documentation and test plans to clarify whether the override logic in component C is functioning as intended or if instrumentation or commands are misleading. I'll also look at relevant commit history and report contents to better understand progress and potential regressions.
[2025-10-06T15:32:34] exec bash -lc 'ls reports/2025-10-cli-flags/phase_h5' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:35] bash -lc 'ls reports/2025-10-cli-flags/phase_h5' succeeded in 759ms:
PHASE_H5A_COMPLETE.md
c_precedence.md
c_precedence_2025-10-22.md
c_traces
implementation_notes.md
parity_summary.md
pytest_h5b.log
pytest_regression.log
[2025-10-06T15:32:35] tokens used: 142,503

[2025-10-06T15:32:41] thinking

**Assessing debugging and hypothesis planning**
[2025-10-06T15:32:46] exec bash -lc "sed -n '1,200p' input.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:47] bash -lc "sed -n '1,200p' input.md" succeeded in 964ms:
Summary: Capture fresh C traces to prove pix0 override precedence before touching PyTorch scaling.
Phase: Evidence
Focus: CLI-FLAGS-003 / -nonoise & -pix0_vector_mm parity
Branch: feature/spec-based-2
Mapped tests: none ‚Äî evidence-only
Artifacts: reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/, reports/2025-10-cli-flags/phase_h5/c_precedence.md
Artifacts note: store raw stdout with TRACE_C lines intact; do not trim progress banners or warnings.
Artifacts note: ensure the precedence memo records timestamp, git SHA, and NB_C_BIN path for reproducibility.
Artifacts note: attach a brief summary of observed deltas (pix0, Fbeam, Sbeam) at the top of the memo for quick reference.
Do Now: CLI-FLAGS-003 H5a ‚Äî run `NB_C_BIN=./golden_suite_generator/nanoBragg` with the supervisor command (first WITH, then WITHOUT `-pix0_vector_mm`) and tee stdout to `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/{with_override,without_override}.log`; refresh `c_precedence.md` with the new dot-product derivation.
Do Now note: after both runs, jot down immediate observations (match vs mismatch) before diving into diff analysis.
Do Now note: keep terminal scrollback until logs are verified on disk in case tee fails.
If Blocked: Capture at least the WITH-override run to `reports/.../c_traces/2025-10-22/with_override_attempt.log`, log the failure cause plus environment in c_precedence.md under a new "Attempts" heading, and stop.
If Blocked note: mention whether the failure occurred before or after command launch (e.g., missing NB_C_BIN vs runtime crash).
If Blocked note: record stdout tail (~20 lines) in the memo so the supervisor can triage remotely.

Priorities & Rationale:
- docs/fix_plan.md:508-570 ‚Äî Next actions demand H5a evidence before Phase K resumes.
  Reasserts that normalization work is paused until pix0 override parity is proven with new traces.
- plans/active/cli-noise-pix0/plan.md:1-35 ‚Äî Plan context flags the 1.14 mm pix0 delta blocking normalization.
[2025-10-06T15:32:47] tokens used: 142,915

[2025-10-06T15:32:54] thinking

**Examining recent commits and fix_plan entries**
[2025-10-06T15:32:55] exec bash -lc "sed -n '570,680p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:32:55] bash -lc "sed -n '570,680p' docs/fix_plan.md" succeeded in 699ms:
    Artifacts:
      - `tests/test_cli_flags.py` - 293 lines, 18 comprehensive test cases
      - `reports/2025-10-cli-flags/phase_c/pytest/test_cli_flags.log` - pytest output log
    Test Coverage:
      - ‚úÖ pix0_vector meters alias parsing and config storage
      - ‚úÖ pix0_vector_mm millimeters alias parsing with conversion to meters (mm * 0.001)
      - ‚úÖ Equivalence of meters and millimeters aliases (tolerance: 1e-12)
      - ‚úÖ Mutual exclusivity enforcement (ValueError on dual-flag usage)
      - ‚úÖ Signed combination parametrization (3 scenarios including negatives, zero, small values)
      - ‚úÖ Detector override persistence through cache invalidation (CPU)
      - ‚úÖ Detector override persistence through cache invalidation (CUDA, device check)
      - ‚úÖ Detector override dtype preservation (float32, float64)
      - ‚úÖ r_factor=1.0 and close_distance consistency when override provided
      - ‚úÖ -nonoise suppresses noisefile generation (suppress_noise=True)
      - ‚úÖ -nonoise doesn't mutate adc default (40.0) or seed handling
      - ‚úÖ -noisefile without -nonoise enables noise generation (suppress_noise=False)
      - ‚úÖ -nonoise valid without -noisefile (no-op but accepted)
      - ‚úÖ pix0 override doesn't mutate custom_beam_vector
      - ‚úÖ pix0 override triggers CUSTOM convention
      - ‚úÖ ROI remains unaffected by new flags
[2025-10-06T15:32:55] tokens used: 145,820

[2025-10-06T15:32:58] thinking

**Continuing to review attempts**
[2025-10-06T15:33:00] exec bash -lc "sed -n '680,860p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:33:01] bash -lc "sed -n '680,860p' docs/fix_plan.md" succeeded in 735ms:
    Observations/Hypotheses: CLI parser stores `custom_beam_vector`, but `Detector` and the divergence/dispersion harness select hard-coded convention defaults, so the supervisor command never threads its custom beam direction through. This invalidates assumptions from the earlier trace that incident_vec matched C‚Äîthe alignment was coincidental because downstream code normalised geometry using `[0,0,1]`.
  * [2025-10-05] Attempt #11 (ralph) ‚Äî Result: success. **Phase F1 complete: `_calculate_pix0_vector()` now honors `custom_beam_vector` from CLI.**
    Metrics: Beam vector exact match (delta < 1e-12): C = `[0.00051387949, 0.0, -0.99999986]`, PyTorch = `[0.00051387949, 0.0, -0.99999986]`. Pix0 vector Y-axis discrepancy reduced but still ~0.84mm (was 1.14mm): C = `[-0.216475836, 0.216343050, -0.230192414]`, PyTorch = `[-0.216336293, 0.215205512, -0.230200866]`.
    Artifacts:
      - `src/nanobrag_torch/models/detector.py:438-440` - Replaced hardcoded beam vector with `self.beam_vector` property call
      - `src/nanobrag_torch/models/detector.py:519-521` - Removed redundant beam vector instantiation in BEAM pivot branch
      - `reports/2025-10-cli-flags/phase_f/beam_vector_after_fix.txt` - Validation artifact showing custom beam vector now used
      - `reports/2025-10-cli-flags/phase_f/pix0_vector_after_fix.txt` - Validation artifact showing current pix0 state
      - `reports/2025-10-cli-flags/phase_f/beam_vector_check.md` - Complete verification report with deltas
    Observations/Hypotheses:
      - Root cause: `_calculate_pix0_vector()` instantiated convention-default beam vectors at lines 439-450 and 530-548, bypassing `self.beam_vector` property that honors CUSTOM overrides
      - Fix: Two edits‚Äî(1) r-factor calculation now uses `self.beam_vector` directly; (2) BEAM pivot branch reuses same `beam_vector` variable instead of re-instantiating
      - Beam vector fix complete (CLI `-beam_vector` now drives r-factor and pix0 calculations)
      - Remaining pix0 discrepancy (~0.84mm Y) indicates Phase F2 (CUSTOM pix0 transform) still needed per plan
    Next Actions: Execute plan Phase F2 (port CUSTOM pix0 transform from nanoBragg.c:1730-1860), then Phase F3 parity rerun. After F2 complete, pix0 should match C within ‚â§1e-12 and geometry correlation should exceed 0.999.
    Next Actions: Update plan Phase E guidance to document beam-vector evidence (done) and prioritize implementation work that (1) threads `custom_beam_vector` into Detector/BeamConfig while preserving differentiability and device/dtype neutrality, and (2) re-runs Phase E traces to confirm both pix0 and beam vectors match before reattempting parity.
  * [2025-10-16] Attempt #7 (ralph) ‚Äî Result: Phase E0 complete (evidence captured). Beam-vector divergence confirmed.
    Metrics: PyTorch beam_vector = `tensor([0., 0., 1.], dtype=torch.float64)` (CUSTOM/XDS default); C log reports user-supplied `-beam_vector 0.00051387949 0.0 -0.99999986`. Confirms CLI parser stores but does not thread `custom_beam_vector` through to detector instantiation.
    Artifacts: `reports/2025-10-cli-flags/phase_e/beam_vector_check.txt` (1 line: PyTorch beam_vector output).
    Observations/Hypotheses: CLI successfully parsed all flags including `-beam_vector`, `-pix0_vector_mm`, `-convention CUSTOM` inputs, but `Detector.__init__` ignores `custom_beam_vector` from config and falls back to convention defaults. This is the second geometry gap alongside the pix0 transform issue documented in Attempt #5 (Phase E). Running the evidence harness also created a duplicate copy of the structure-factor file (`scaled.hkl.1`, identical to `scaled.hkl`) in the repo root; treat it as an artefact that needs removal during the upcoming implementation pass so repo hygiene stays intact.
[2025-10-06T15:33:01] tokens used: 147,311

[2025-10-06T15:33:06] thinking

**Reviewing recent loop commits**
[2025-10-06T15:33:08] exec bash -lc 'rg "Attempt #30" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:33:09] bash -lc 'rg "Attempt #30" -n docs/fix_plan.md' succeeded in 850ms:
257:  * [2025-10-01] Attempt #30 (loop BK) ‚Äî Result: Phase B tasks B1-B2 COMPLETE. Added profiling instrumentation to `benchmark_detailed.py` and captured 4096¬≤ CPU warm trace.
523:    Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
525:  * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
[2025-10-06T15:33:09] tokens used: 150,408

[2025-10-06T15:33:16] thinking

**Reevaluating override behavior**
[2025-10-06T15:33:16] exec bash -lc 'rg "pix0" -n specs/spec-a-cli.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:33:17] bash -lc 'rg "pix0" -n specs/spec-a-cli.md' succeeded in 779ms:
60:    - -pix0_vector x y z: Detector origin offset vector (meters) from sample to the first (min fast,
143:- Custom basis vectors or -pix0_vector set convention to CUSTOM and use provided vectors where
[2025-10-06T15:33:17] tokens used: 150,838

[2025-10-06T15:33:20] thinking

**Reviewing code segment**
[2025-10-06T15:33:22] exec bash -lc "sed -n '120,200p' specs/spec-a-cli.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:33:23] bash -lc "sed -n '120,200p' specs/spec-a-cli.md" succeeded in 732ms:
- Misc:
    - -printout: Verbose pixel prints (for debugging).
    - -printout_pixel f s: Limit prints to specified pixel.
    - -trace_pixel s f: Instrument trace for a pixel.
    - -noprogress / -progress: Toggle progress meter.
    - -seed <int>: Noise RNG seed (negative used internally), defaults to negative time.
    - -mosaic_seed <int>, -misset_seed <int>: Seeds for mosaic domain rotations and random misset.
    - -misset 10 20 30: Apply misset angles (deg). -misset random: Use a random orientation.
    - -stol <file>, -4stol <file>, -Q <file>, -stolout <file>: Auxiliary S(Q) support is read but
not used further in this version.

Unsupported flags in examples:

- -dispstep (example shows this; not recognized). The supported control is -dispsteps (count).
- -hdiv and -vdiv (examples show these; not recognized). Supported are -hdivrange and -vdivrange.

Precedence and overrides (Normative)

- If both -img and -mask headers are read, the last one read wins for shared header-initialized
quantities.
[2025-10-06T15:33:23] tokens used: 151,063

[2025-10-06T15:33:39] thinking

**Analyzing intensity scaling discrepancies**

I‚Äôm examining hypotheses around the F_latt intensity difference, focusing on whether custom pix0_vector overrides are being ignored as expected and how that impacts scattering vector orientation. There‚Äôs a complex interplay between lattice shape factors, pixel-to-lab mappings, and vectorization that may explain the 463x discrepancy. I plan to cross-check the detector code and relevant logs to clarify if PyTorch and underlying code paths align on ignoring overrides and consider if spindle_axis defaults or unstarted vectorization plan tasks contribute. I‚Äôll next inspect detailed reports from the CLI flags parity phase for further clues.
[2025-10-06T15:33:44] exec bash -lc "sed -n '1,200p' reports/2025-10-cli-flags/phase_j/scaling_chain.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:33:45] bash -lc "sed -n '1,200p' reports/2025-10-cli-flags/phase_j/scaling_chain.md" succeeded in 669ms:
# Scaling Chain Analysis: C vs PyTorch

**Pixel:** (slow=1039, fast=685)

## Key Findings

**First Divergence:** `I_before_scaling`
- C value: 1.480792010454e+15
- PyTorch value: 5.344373483470e+08
- Ratio (Py/C): 3.609132e-07

**Final Intensity Ratio (Py/C):** 1.053e-05

## Full Factor Comparison

| Factor | C Value | PyTorch Value | Ratio (Py/C) | Match? |
|--------|---------|---------------|--------------|--------|
| I_before_scaling | 1.480792e+15 | 5.344373e+08 | 3.609132e-07 | ‚ùå |
| steps | 1.000000e+01 | 1.000000e+01 | 1.000000e+00 | ‚úÖ |
| r_e_sqr | 7.940792e-30 | 7.940792e-30 | 1.000000e+00 | ‚úÖ |
[2025-10-06T15:33:45] tokens used: 153,893

[2025-10-06T15:33:51] thinking

**Investigating lattice factor discrepancies**
[2025-10-06T15:33:53] exec bash -lc 'rg "F_latt" -n src' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:33:53] bash -lc 'rg "F_latt" -n src' succeeded in 721ms:
src/nanobrag_torch/config.py:148:    shape: CrystalShape = CrystalShape.SQUARE  # Crystal shape model for F_latt calculation
src/nanobrag_torch/simulator.py:219:        F_latt_a = sincg(torch.pi * (h - h0), Na)
src/nanobrag_torch/simulator.py:220:        F_latt_b = sincg(torch.pi * (k - k0), Nb)
src/nanobrag_torch/simulator.py:221:        F_latt_c = sincg(torch.pi * (l - l0), Nc)
src/nanobrag_torch/simulator.py:222:        F_latt = F_latt_a * F_latt_b * F_latt_c
src/nanobrag_torch/simulator.py:232:        F_latt = Na * Nb * Nc * 0.723601254558268 * sinc3(
src/nanobrag_torch/simulator.py:251:        F_latt = Na * Nb * Nc * torch.exp(-(rad_star_sqr / 0.63) * fudge)
src/nanobrag_torch/simulator.py:269:        F_latt = torch.where(inside_cutoff,
src/nanobrag_torch/simulator.py:276:    F_total = F_cell * F_latt
src/nanobrag_torch/simulator.py:694:                                    /* ... F_cell and F_latt calculation ... */
src/nanobrag_torch/simulator.py:697:                                    I += F_cell*F_cell*F_latt*F_latt;
src/nanobrag_torch/simulator.py:1258:                    # Calculate F_latt components (SQUARE shape assumed)
src/nanobrag_torch/simulator.py:1264:                    F_latt_a = sincg(torch.pi * torch.tensor(h - h0), Na).item()
src/nanobrag_torch/simulator.py:1265:                    F_latt_b = sincg(torch.pi * torch.tensor(k - k0), Nb).item()
src/nanobrag_torch/simulator.py:1266:                    F_latt_c = sincg(torch.pi * torch.tensor(l - l0), Nc).item()
src/nanobrag_torch/simulator.py:1267:                    F_latt = F_latt_a * F_latt_b * F_latt_c
src/nanobrag_torch/simulator.py:1269:                    print(f"TRACE_PY: F_latt_a {F_latt_a:.15g}")
src/nanobrag_torch/simulator.py:1270:                    print(f"TRACE_PY: F_latt_b {F_latt_b:.15g}")
src/nanobrag_torch/simulator.py:1271:                    print(f"TRACE_PY: F_latt_c {F_latt_c:.15g}")
src/nanobrag_torch/simulator.py:1272:                    print(f"TRACE_PY: F_latt {F_latt:.15g}")
[2025-10-06T15:33:53] tokens used: 154,690

[2025-10-06T15:34:01] thinking

**Examining code near lattice calculations**
[2025-10-06T15:34:03] exec bash -lc "sed -n '180,260p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:34:04] bash -lc "sed -n '180,260p' src/nanobrag_torch/simulator.py" succeeded in 792ms:
            rot_c_broadcast = rot_c.unsqueeze(0).unsqueeze(0)
        else:
            # (S, F) case: add 3 leading dims
            rot_a_broadcast = rot_a.unsqueeze(0).unsqueeze(0).unsqueeze(0)
            rot_b_broadcast = rot_b.unsqueeze(0).unsqueeze(0).unsqueeze(0)
            rot_c_broadcast = rot_c.unsqueeze(0).unsqueeze(0).unsqueeze(0)
    else:
        # Single source: (S, F, 3) -> (S, F, 1, 1, 3) or (batch, 3) -> (batch, 1, 1, 3)
        scattering_broadcast = scattering_vector.unsqueeze(-2).unsqueeze(-2)
        # rot vectors: (N_phi, N_mos, 3) -> (1, 1, N_phi, N_mos, 3)
        rot_a_broadcast = rot_a.unsqueeze(0).unsqueeze(0)
        rot_b_broadcast = rot_b.unsqueeze(0).unsqueeze(0)
        rot_c_broadcast = rot_c.unsqueeze(0).unsqueeze(0)

    h = dot_product(scattering_broadcast, rot_a_broadcast)
    k = dot_product(scattering_broadcast, rot_b_broadcast)
    l = dot_product(scattering_broadcast, rot_c_broadcast)  # noqa: E741

    # Find nearest integer Miller indices
    h0 = torch.round(h)
[2025-10-06T15:34:04] tokens used: 155,706

[2025-10-06T15:34:11] thinking

**Investigating F_latt discrepancies**
[2025-10-06T15:34:12] exec bash -lc 'rg "TRACE_PY: h " -n reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:34:12] bash -lc 'rg "TRACE_PY: h " -n reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' exited 1 in 731ms:

[2025-10-06T15:34:12] tokens used: 157,402

[2025-10-06T15:34:15] thinking

**Checking log naming convention**
[2025-10-06T15:34:19] exec bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_py_scaling.log" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:34:20] bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_py_scaling.log" succeeded in 714ms:
# Tracing pixel (slow=1039, fast=685)
# Trace complete
TRACE_PY: pix0_vector_meters -0.21645536097285 0.21520668107301 -0.23019804092515
TRACE_PY: fdet_vec 0.999982 -0.005998 -0.000118
TRACE_PY: sdet_vec -0.005998 -0.99997 -0.004913
TRACE_PY: pixel_pos_meters -0.09962388969285 0.03571084470501 -0.23109036875515
TRACE_PY: R_distance_meters 0.254171088754149
TRACE_PY: omega_pixel_sr 4.16678627260442e-07
TRACE_PY: close_distance_meters 0.231271852251217
TRACE_PY: obliquity_factor 0.909906210752861
TRACE_PY: diffracted_vec -0.391956025294492 0.140499239626549 -0.909192189748518
TRACE_PY: incident_vec 0.00051387949 0 -0.99999986
TRACE_PY: lambda_meters 9.768e-11
TRACE_PY: lambda_angstroms 0.9768
TRACE_PY: scattering_vec_A_inv -4017914668.14591 1438362404.03919 929644453.844001
TRACE_PY: rot_a_angstroms -14.3562690335399 -21.8717928453817 -5.58202083498661
TRACE_PY: rot_b_angstroms -11.4986968432508 0.717320030990266 -29.1132147806318
TRACE_PY: rot_c_angstroms 21.0699500320179 -24.3892962470766 -9.75265166505327
TRACE_PY: rot_a_star_A_inv -0.0290510954135954 -0.0293958845208845 0.0107498771498771
TRACE_PY: rot_b_star_A_inv -0.0031263923013923 0.0104376433251433 -0.0328566748566749
[2025-10-06T15:34:20] tokens used: 158,458

[2025-10-06T15:34:25] thinking

**Comparing lattice parameter with trace data**
[2025-10-06T15:34:27] exec bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_c_scaling.log" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:34:28] bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_c_scaling.log" succeeded in 693ms:
WARNING: auto-generating odet_vector
nanoBragg nanocrystal diffraction simulator - James Holton and Ken Frankel 5-17-17
custom convention selected.
pivoting detector around sample
DETECTOR_FAST_AXIS 0.999982004873912 -0.00599800002923425 -0.000118000000575132
DETECTOR_SLOW_AXIS -0.0059979996566955 -0.999969942765222 -0.0049129997187971
DETECTOR_NORMAL_AXIS -8.85282813644494e-05 0.00491361907271126 -0.999987924182263
DETECTOR_PIX0_VECTOR -0.216475836204836 0.216343050492215 -0.230192414300537
XDS incident beam: 0.00063187 0.00490992 0.999988
reading A.mat
TRACE: Raw matrix values from file:
TRACE:   a_star (raw) = [-0.0283771, -0.0287139, 0.0105005]
TRACE:   b_star (raw) = [-0.00305386, 0.0101955, -0.0320944]
TRACE:   c_star (raw) = [0.0253582, -0.0140005, -0.0103605]
TRACE:   lambda0 = 0.9768 Angstroms
TRACE:   scaling factor = 1e-10/lambda0 = 1.02375
TRACE: After wavelength correction:
TRACE:   a_star = [-0.0290511, -0.0293959, 0.0107499] |a_star| = 0.0427041
TRACE:   b_star = [-0.00312639, 0.0104376, -0.0328567] |b_star| = 0.0346162
TRACE:   c_star = [0.0259604, -0.014333, -0.0106066] |c_star| = 0.0314941
[2025-10-06T15:34:28] tokens used: 174,427

[2025-10-06T15:34:35] thinking

**Searching for TRACE_C definition**
[2025-10-06T15:34:37] exec bash -lc 'rg "TRACE_C: F_latt" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:34:38] bash -lc 'rg "TRACE_C: F_latt" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 708ms:
185:TRACE_C: F_latt_a 35.8890618450812
186:TRACE_C: F_latt_b 38.6324938361129
187:TRACE_C: F_latt_c 25.7024842831081
188:TRACE_C: F_latt 35636.0822038919
[2025-10-06T15:34:38] tokens used: 178,509

[2025-10-06T15:34:53] thinking

**Analyzing significant F_latt discrepancy**
[2025-10-06T15:34:56] exec bash -lc "sed -n '1,200p' src/nanobrag_torch/utils/physics.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:34:57] bash -lc "sed -n '1,200p' src/nanobrag_torch/utils/physics.py" succeeded in 878ms:
"""
Vectorized physics utilities for nanoBragg PyTorch implementation.

This module contains PyTorch implementations of physical models and
calculations from the original C code.
"""

import torch


# Use different compile modes for CPU vs GPU to avoid CUDA graph issues
# On GPU, "max-autotune" avoids the nested compilation CUDA graph problem
# On CPU, "reduce-overhead" is faster
def _get_compile_decorator():
    """Get appropriate compile decorator based on available hardware."""
    import os
    disable_compile = os.environ.get("NANOBRAGG_DISABLE_COMPILE", "0") == "1"

    if disable_compile:
        # Return identity decorator when compilation is disabled (for gradient testing)
[2025-10-06T15:34:57] tokens used: 179,046

[2025-10-06T15:35:01] thinking

**Verifying data types for N_cells variables**
[2025-10-06T15:35:04] exec bash -lc 'rg "N_cells" -n src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:35:05] bash -lc 'rg "N_cells" -n src/nanobrag_torch/simulator.py' succeeded in 739ms:
37:    N_cells_a: int = 0,
38:    N_cells_b: int = 0,
39:    N_cells_c: int = 0,
87:        N_cells_a/b/c: Number of unit cells in each direction
212:    Na = N_cells_a
213:    Nb = N_cells_b
214:    Nc = N_cells_c
636:            N_cells_a=self.crystal.N_cells_a,
637:            N_cells_b=self.crystal.N_cells_b,
638:            N_cells_c=self.crystal.N_cells_c,
728:                abs(self.crystal.config.cell_a * 1e-10 * self.crystal.config.N_cells[0]),  # a*Na in meters
729:                abs(self.crystal.config.cell_b * 1e-10 * self.crystal.config.N_cells[1]),  # b*Nb in meters
730:                abs(self.crystal.config.cell_c * 1e-10 * self.crystal.config.N_cells[2])   # c*Nc in meters
1259:                    Na = self.crystal.N_cells_a
1260:                    Nb = self.crystal.N_cells_b
1261:                    Nc = self.crystal.N_cells_c
[2025-10-06T15:35:05] tokens used: 181,323

[2025-10-06T15:35:08] thinking

**Analyzing data types for tensors**
[2025-10-06T15:35:10] exec bash -lc 'rg "N_cells_a" -n src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:35:11] bash -lc 'rg "N_cells_a" -n src/nanobrag_torch/models/crystal.py' succeeded in 721ms:
92:        self.N_cells_a = torch.as_tensor(
115:            self.N_cells_a.item(),
135:        self.N_cells_a = self.N_cells_a.to(device=self.device, dtype=self.dtype)
[2025-10-06T15:35:11] tokens used: 181,870

[2025-10-06T15:35:13] thinking

**Inspecting code lines**
[2025-10-06T15:35:14] exec bash -lc "sed -n '60,160p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:35:15] bash -lc "sed -n '60,160p' src/nanobrag_torch/models/crystal.py" succeeded in 713ms:
        # Store configuration
        self.config = config if config is not None else CrystalConfig()

        # Apply sample clipping if beam config provided (AT-FLU-001)
        if beam_config is not None and beam_config.beamsize_mm > 0:
            self._apply_sample_clipping(beam_config)

        # Initialize cell parameters from config with validation
        # These are the fundamental parameters that can be differentiable
        self.cell_a = torch.as_tensor(
            self.config.cell_a, device=self.device, dtype=self.dtype
        )
        self.cell_b = torch.as_tensor(
            self.config.cell_b, device=self.device, dtype=self.dtype
        )
        self.cell_c = torch.as_tensor(
            self.config.cell_c, device=self.device, dtype=self.dtype
        )
        self.cell_alpha = torch.as_tensor(
            self.config.cell_alpha, device=self.device, dtype=self.dtype
[2025-10-06T15:35:15] tokens used: 182,058

[2025-10-06T15:35:22] thinking

**Verifying shape factor calculation**
[2025-10-06T15:35:23] exec bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
sincg=math.sin(Na*nu)/math.sin(u)
print('Expected F_latt_a',sincg)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:35:24] bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
sincg=math.sin(Na*nu)/math.sin(u)
print('Expected F_latt_a',sincg)
PY" exited 1 in 1.08s:
Traceback (most recent call last):
  File "<stdin>", line 5, in <module>
NameError: name 'nu' is not defined. Did you mean: 'u'?
[2025-10-06T15:35:24] tokens used: 183,458

[2025-10-06T15:35:27] thinking

**Correcting variable mistake**
[2025-10-06T15:35:30] exec bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
F_latt_a=math.sin(Na*nu)/math.sin(u)
print('Expected F_latt_a',F_latt_a)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:35:31] bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
F_latt_a=math.sin(Na*nu)/math.sin(u)
print('Expected F_latt_a',F_latt_a)
PY" exited 1 in 734ms:
Traceback (most recent call last):
  File "<stdin>", line 5, in <module>
NameError: name 'nu' is not defined. Did you mean: 'u'?
[2025-10-06T15:35:31] tokens used: 183,759

[2025-10-06T15:35:47] thinking

**Correcting variable reference**
[2025-10-06T15:35:49] exec bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
F_latt_a=math.sin(Na*nu)/math.sin(u)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:35:49] bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
F_latt_a=math.sin(Na*nu)/math.sin(u)
PY" exited 1 in 912ms:
Traceback (most recent call last):
  File "<stdin>", line 5, in <module>
NameError: name 'nu' is not defined. Did you mean: 'u'?
[2025-10-06T15:35:49] tokens used: 184,097

[2025-10-06T15:35:53] thinking

**Correcting variable naming consistency**
[2025-10-06T15:35:54] exec bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
F_latt_a=math.sin(Na*nu)/math.sin(nu)
print(F_latt_a)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:35:55] bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
u=math.pi*h_diff
Na=36
F_latt_a=math.sin(Na*nu)/math.sin(nu)
print(F_latt_a)
PY" exited 1 in 711ms:
Traceback (most recent call last):
  File "<stdin>", line 5, in <module>
NameError: name 'nu' is not defined. Did you mean: 'u'?
[2025-10-06T15:35:55] tokens used: 184,372

[2025-10-06T15:36:02] thinking

**Investigating NameError on variable**
[2025-10-06T15:36:05] exec bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
nu=math.pi*h_diff
print('nu',nu)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:06] bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
nu=math.pi*h_diff
print('nu',nu)
PY" succeeded in 852ms:
nu 0.3246536555558682
[2025-10-06T15:36:06] tokens used: 216,338

[2025-10-06T15:36:11] thinking

**Debugging variable definition errors**
[2025-10-06T15:36:13] exec bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
nu=math.pi*h_diff
Na=36
result=math.sin(Na*nu)/math.sin(nu)
print(result)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:14] bash -lc "python - <<'PY'
import math
h_diff=0.10334046814914
nu=math.pi*h_diff
Na=36
result=math.sin(Na*nu)/math.sin(nu)
print(result)
PY" succeeded in 733ms:
-2.4139359866745087
[2025-10-06T15:36:14] tokens used: 217,843

[2025-10-06T15:36:21] thinking

**Investigating sincg function differences**
[2025-10-06T15:36:21] exec bash -lc 'rg "sincg(" -n golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:22] bash -lc 'rg "sincg(" -n golden_suite_generator/nanoBragg.c' exited 2 in 759ms:
rg: regex parse error:
    (?:sincg()
    ^
error: unclosed group
[2025-10-06T15:36:22] tokens used: 218,605

[2025-10-06T15:36:27] thinking

**Considering parentheses escaping**
[2025-10-06T15:36:27] exec bash -lc 'rg -F "sincg" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:28] bash -lc 'rg -F "sincg" golden_suite_generator/nanoBragg.c' succeeded in 802ms:
double sincg(double x, double N);
                /* use sincg */
                                            F_latt_a = sincg(M_PI*h,Na);
                                            F_latt_b = sincg(M_PI*k,Nb);
                                            F_latt_c = sincg(M_PI*l,Nc);
double sincg(double x,double N) {
[2025-10-06T15:36:28] tokens used: 218,876

[2025-10-06T15:36:31] thinking

**Requesting missing definition**
[2025-10-06T15:36:33] exec bash -lc "sed -n '2400,2460p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:33] bash -lc "sed -n '2400,2460p' golden_suite_generator/nanoBragg.c" succeeded in 733ms:
//                  }
//                  printf("%d %d %d = %f\n",h0,k0,l0,F_cell);
//              }
//          }
//      }

        /* make dump file */
        outfile = fopen(dumpfilename,"wb");
        if(outfile == NULL)
        {
            printf("WARNING: unable to open dump file: %s\n",dumpfilename);
        }
        else
        {
            printf("writing dump file for next time: %s\n",dumpfilename);
            fprintf(outfile,"%d %d %d %d %d %d\n\f",h_min,h_max,k_min,k_max,l_min,l_max);
            for (h0=0; h0<=h_range;h0++) {
                for (k0=0; k0<=k_range;k0++) {
                        fwrite(*(*(Fhkl +h0)+k0),sizeof(double),l_range+1,outfile);
                }
[2025-10-06T15:36:33] tokens used: 219,079

[2025-10-06T15:36:38] thinking

**Searching for `double sincg` definition**
[2025-10-06T15:36:38] exec bash -lc "sed -n '3250,3330p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:39] bash -lc "sed -n '3250,3330p' golden_suite_generator/nanoBragg.c" succeeded in 701ms:
                                            /* just take nearest-neighbor */
                                            F_cell = Fhkl[h0-h_min][k0-k_min][l0-l_min];
                                        }
                                        else
                                        {
                                            F_cell = default_F;  // usually zero
                                        }
                                    }

                                    /* now we have the structure factor for this pixel */
                                    if(fpixel==trace_fpixel && spixel==trace_spixel && source==0 && mos_tic==0 && phi_tic==0) {
                                        printf("TRACE_C: F_cell %.15g\n", F_cell);
                                    }

                                    /* convert amplitudes into intensity (photons per steradian) */
                                    I += F_cell*F_cell*F_latt*F_latt;

                                    /* only do this if we need to */
                                    if(oversample_thick) I *= capture_fraction;
                                    if(oversample_polar) I *= polar;
[2025-10-06T15:36:39] tokens used: 220,832

[2025-10-06T15:36:42] thinking

**Searching for sincg definition**
[2025-10-06T15:36:43] exec bash -lc "sed -n '3500,3600p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:43] bash -lc "sed -n '3500,3600p' golden_suite_generator/nanoBragg.c" succeeded in 690ms:
    }

    /* simulate Poisson noise */
    imgidx = 0;
    sum = 0.0;
    overloads = 0;
    for(spixel=0;spixel<spixels;++spixel)
    {
        for(fpixel=0;fpixel<fpixels;++fpixel)
        {
            if(fpixel < roi_xmin || fpixel > roi_xmax || spixel < roi_ymin || spixel > roi_ymax)
            {
                ++imgidx; continue;
            }
            test = poidev( floatimage[imgidx], &seed );
            sum += test;
            test += adc_offset;
            if(test > 65535.0)
            {
                test = 65535.0;
[2025-10-06T15:36:43] tokens used: 222,694

[2025-10-06T15:36:48] thinking

**Investigating sincg function usage**
[2025-10-06T15:36:49] exec bash -lc "sed -n '3000,3100p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:36:50] bash -lc "sed -n '3000,3100p' golden_suite_generator/nanoBragg.c" succeeded in 693ms:
                                /* enumerate mosaic domains */
                                for(mos_tic=0;mos_tic<mosaic_domains;++mos_tic)
                                {
                                    /* apply mosaic rotation after phi rotation */
                                    if( mosaic_spread > 0.0 )
                                    {
                                        if(fpixel==512 && spixel==512 && source==0 && phi_tic==0 && mos_tic==0) {
                                            printf("TRACE: Mosaic rotation (domain %d):\n", mos_tic);
                                            printf("TRACE:   Mosaic umat = [%g %g %g; %g %g %g; %g %g %g]\n",
                                                mosaic_umats[mos_tic*9], mosaic_umats[mos_tic*9+1], mosaic_umats[mos_tic*9+2],
                                                mosaic_umats[mos_tic*9+3], mosaic_umats[mos_tic*9+4], mosaic_umats[mos_tic*9+5],
                                                mosaic_umats[mos_tic*9+6], mosaic_umats[mos_tic*9+7], mosaic_umats[mos_tic*9+8]);
                                            printf("TRACE:   Before mosaic rotation:\n");
                                            printf("TRACE:     ap = [%g, %g, %g] |ap| = %g\n", ap[1], ap[2], ap[3], ap[0]);
                                            printf("TRACE:     bp = [%g, %g, %g] |bp| = %g\n", bp[1], bp[2], bp[3], bp[0]);
                                            printf("TRACE:     cp = [%g, %g, %g] |cp| = %g\n", cp[1], cp[2], cp[3], cp[0]);
                                        }
                                        
                                        rotate_umat(ap,a,&mosaic_umats[mos_tic*9]);
                                        rotate_umat(bp,b,&mosaic_umats[mos_tic*9]);
[2025-10-06T15:36:50] tokens used: 224,222

[2025-10-06T15:37:01] thinking

**Analyzing sinc function argument discrepancy**
[2025-10-06T15:37:03] exec bash -lc "python - <<'PY'
import math
h=2.10334046814914
Na=36
val=math.sin(math.pi*Na*h)/math.sin(math.pi*h)
print(val)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:04] bash -lc "python - <<'PY'
import math
h=2.10334046814914
Na=36
val=math.sin(math.pi*Na*h)/math.sin(math.pi*h)
print(val)
PY" succeeded in 923ms:
-2.413935986674528
[2025-10-06T15:37:04] tokens used: 226,846

[2025-10-06T15:37:10] thinking

**Investigating discrepancy in lattice factor calculation**
[2025-10-06T15:37:12] exec bash -lc "sed -n '3100,3200p' golden_suite_generator/nanoBragg.c" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:13] bash -lc "sed -n '3100,3200p' golden_suite_generator/nanoBragg.c" succeeded in 742ms:
                                       /* radius in hkl space, squared */
                                        hrad_sqr = (h-h0)*(h-h0)*Na*Na + (k-k0)*(k-k0)*Nb*Nb + (l-l0)*(l-l0)*Nc*Nc ;

                                         /* use sinc3 for elliptical xtal shape,
                                           correcting for sqrt of volume ratio between cube and sphere */
                                        F_latt = Na*Nb*Nc*0.723601254558268*sinc3(M_PI*sqrt( hrad_sqr * fudge ) );
                                    }
                                    if(xtal_shape == GAUSS)
                                    {
                                        /* fudge the radius so that volume and FWHM are similar to square_xtal spots */
                                        F_latt = Na*Nb*Nc*exp(-( rad_star_sqr / 0.63 * fudge ));
                                    }
                                    if(xtal_shape == TOPHAT)
                                    {
                                        /* make a flat-top spot of same height and volume as square_xtal spots */
                                        F_latt = Na*Nb*Nc*(rad_star_sqr*fudge < 0.3969 );
                                    }
                                    /* no need to go further if result will be zero? */
                                    if(F_latt == 0.0 && water_size == 0.0) continue;

[2025-10-06T15:37:13] tokens used: 227,952

[2025-10-06T15:37:19] thinking

**Analyzing variable usage and transformations**
[2025-10-06T15:37:20] exec bash -lc 'rg "h -=" -n golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:21] bash -lc 'rg "h -=" -n golden_suite_generator/nanoBragg.c' exited 1 in 725ms:

[2025-10-06T15:37:21] tokens used: 230,580

[2025-10-06T15:37:24] thinking

**Searching for h-h0 patterns**
[2025-10-06T15:37:25] exec bash -lc 'rg "h-h0" -n golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:25] bash -lc 'rg "h-h0" -n golden_suite_generator/nanoBragg.c' succeeded in 711ms:
3092:                                        double dx_star = (h-h0)*a_star[1] + (k-k0)*b_star[1] + (l-l0)*c_star[1];
3093:                                        double dy_star = (h-h0)*a_star[2] + (k-k0)*b_star[2] + (l-l0)*c_star[2];
3094:                                        double dz_star = (h-h0)*a_star[3] + (k-k0)*b_star[3] + (l-l0)*c_star[3];
3101:                                        hrad_sqr = (h-h0)*(h-h0)*Na*Na + (k-k0)*(k-k0)*Nb*Nb + (l-l0)*(l-l0)*Nc*Nc ;
[2025-10-06T15:37:25] tokens used: 231,269

[2025-10-06T15:37:29] thinking

**Evaluating constant variable use**
[2025-10-06T15:37:32] exec bash -lc "python - <<'PY'
import math
def sincg(x, N):
    if x == 0:
        return N
    return math.sin(x*N)/math.sin(x)

h = 2.10334046814914
Na = 36
print('Na',Na,'h',h)
print('x =', math.pi*h)
print('result', sincg(math.pi*h, Na))
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:32] bash -lc "python - <<'PY'
import math
def sincg(x, N):
    if x == 0:
        return N
    return math.sin(x*N)/math.sin(x)

h = 2.10334046814914
Na = 36
print('Na',Na,'h',h)
print('x =', math.pi*h)
print('result', sincg(math.pi*h, Na))
PY" succeeded in 680ms:
Na 36 h 2.10334046814914
x = 6.607838962735455
result -2.413935986674471
[2025-10-06T15:37:32] tokens used: 232,391

[2025-10-06T15:37:36] thinking

**Investigating calculation discrepancy**
[2025-10-06T15:37:39] exec bash -lc "python - <<'PY'
import math
h = 2.10334046814914
h0 = round(h)
frac = h - h0
Na = 36
import numpy as np
print('frac',frac)
print('sin', math.sin(math.pi*Na*frac)/math.sin(math.pi*frac))
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:40] bash -lc "python - <<'PY'
import math
h = 2.10334046814914
h0 = round(h)
frac = h - h0
Na = 36
import numpy as np
print('frac',frac)
print('sin', math.sin(math.pi*Na*frac)/math.sin(math.pi*frac))
PY" succeeded in 803ms:
frac 0.10334046814914011
sin -2.4139359866744816
[2025-10-06T15:37:40] tokens used: 233,755

[2025-10-06T15:37:46] thinking

**Investigating rounding and variable adjustments**
[2025-10-06T15:37:47] exec bash -lc 'rg "h -=" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:48] bash -lc 'rg "h -=" golden_suite_generator/nanoBragg.c' exited 1 in 710ms:

[2025-10-06T15:37:48] tokens used: 234,260

[2025-10-06T15:37:50] thinking

**Checking for compact subtraction syntax**
[2025-10-06T15:37:51] exec bash -lc 'rg "h-=" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:52] bash -lc 'rg "h-=" golden_suite_generator/nanoBragg.c' exited 1 in 688ms:

[2025-10-06T15:37:52] tokens used: 234,490

[2025-10-06T15:37:55] thinking

**Checking variable assignment styles**
[2025-10-06T15:37:59] exec bash -lc 'rg "h = h" golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:37:59] bash -lc 'rg "h = h" golden_suite_generator/nanoBragg.c' exited 1 in 690ms:

[2025-10-06T15:37:59] tokens used: 234,695

[2025-10-06T15:38:05] thinking

**Analyzing sinc function input and values**
[2025-10-06T15:38:08] exec bash -lc "python - <<'PY'
import math
h = 2.10334046814914
print('sin denominator', math.sin(math.pi*h))
print('sin numerator', math.sin(math.pi*36*h))
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:38:09] bash -lc "python - <<'PY'
import math
h = 2.10334046814914
print('sin denominator', math.sin(math.pi*h))
print('sin numerator', math.sin(math.pi*36*h))
PY" succeeded in 736ms:
sin denominator 0.31898055314823326
sin numerator -0.7699986362938671
[2025-10-06T15:38:09] tokens used: 235,041

[2025-10-06T15:38:28] thinking

**Investigating lattice factor discrepancy**

I'm examining why the ratio for `F_latt_a` differs greatly between computed values and the C instrumentation output, suspecting it could be due to how `h` is normalized or fractionalized in the calculations. I want to confirm if macros or code around `h` adjust it before computing the lattice factor, and I'll search the instrumentation traces to clarify how `F_latt_a` is actually derived.
[2025-10-06T15:38:30] exec bash -lc 'rg "TRACE_C: F_latt_a" -n golden_suite_generator/nanoBragg.c' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:38:31] bash -lc 'rg "TRACE_C: F_latt_a" -n golden_suite_generator/nanoBragg.c' succeeded in 721ms:
3083:                                            printf("TRACE_C: F_latt_a %.15g\n", F_latt_a);
[2025-10-06T15:38:31] tokens used: 236,107

[2025-10-06T15:38:34] thinking

**Searching for TRACE_C: Na**
[2025-10-06T15:38:37] exec bash -lc 'rg "TRACE_C: Na" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:38:38] bash -lc 'rg "TRACE_C: Na" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' exited 1 in 767ms:

[2025-10-06T15:38:38] tokens used: 237,194

[2025-10-06T15:38:43] thinking

**Analyzing lattice parameter calculations**
[2025-10-06T15:38:44] exec bash -lc "python - <<'PY'
import math
h=2.10334046814914
Na=36
x=math.pi*h/Na
print(math.sin(Na*x)/math.sin(x))
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:38:45] bash -lc "python - <<'PY'
import math
h=2.10334046814914
Na=36
x=math.pi*h/Na
print(math.sin(Na*x)/math.sin(x))
PY" succeeded in 723ms:
1.747626564928127
[2025-10-06T15:38:45] tokens used: 237,523

[2025-10-06T15:38:49] thinking

**Considering alternative sine formula**
[2025-10-06T15:38:52] exec bash -lc "python - <<'PY'
import math
h=2.10334046814914
h0=2
Na=36
x=math.pi*(h-h0)
res=math.sin(Na*x)/math.sin(x)
print(res)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:38:53] bash -lc "python - <<'PY'
import math
h=2.10334046814914
h0=2
Na=36
x=math.pi*(h-h0)
res=math.sin(Na*x)/math.sin(x)
print(res)
PY" succeeded in 698ms:
-2.4139359866744816
[2025-10-06T15:38:53] tokens used: 238,019

[2025-10-06T15:38:58] thinking

**Considering sine expression variations**
[2025-10-06T15:39:00] exec bash -lc "python - <<'PY'
import math
h=2.10334046814914
h0=2
Na=36
x=h-h0
res=math.sin(Na*x)/math.sin(x)
print(res)
PY" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:39:00] bash -lc "python - <<'PY'
import math
h=2.10334046814914
h0=2
Na=36
x=h-h0
res=math.sin(Na*x)/math.sin(x)
print(res)
PY" succeeded in 738ms:
-5.301705613387682
[2025-10-06T15:39:00] tokens used: 238,672

[2025-10-06T15:39:10] thinking

**Questioning unit differences and function use**
[2025-10-06T15:39:11] exec bash -lc 'rg "TRACE_C: hkl_frac" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:39:12] bash -lc 'rg "TRACE_C: hkl_frac" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 959ms:
183:TRACE_C: hkl_frac 2.00120331912649 1.99279793937568 -12.9907668789699
[2025-10-06T15:39:12] tokens used: 239,217

[2025-10-06T15:39:28] thinking

**Analyzing pix0_vector discrepancies**
[2025-10-06T15:39:29] exec bash -lc 'rg "_calculate_pix0_vector" -n src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:39:30] bash -lc 'rg "_calculate_pix0_vector" -n src/nanobrag_torch/models/detector.py' succeeded in 949ms:
135:        self._calculate_pix0_vector()
147:        # These will be set properly in _calculate_pix0_vector
238:        self._calculate_pix0_vector()
326:    def _calculate_pix0_vector(self):
979:            self._calculate_pix0_vector()
999:            self._calculate_pix0_vector()
[2025-10-06T15:39:30] tokens used: 240,195

[2025-10-06T15:39:32] thinking

**Inspecting method**
[2025-10-06T15:39:33] exec bash -lc "sed -n '326,460p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:39:33] bash -lc "sed -n '326,460p' src/nanobrag_torch/models/detector.py" succeeded in 691ms:
    def _calculate_pix0_vector(self):
        """
        Calculate the position of the first pixel (0,0) in 3D space.

        This follows the C-code convention where pix0_vector represents the
        3D position of pixel (0,0), taking into account the beam center offset
        and detector positioning.

        The calculation depends on:
        1. detector_pivot mode (BEAM vs SAMPLE)
        2. detector convention (MOSFLM vs CUSTOM)
        3. r-factor distance correction (AT-GEO-003)

        CRITICAL: C code switches to CUSTOM convention when twotheta_axis is
        explicitly specified and differs from MOSFLM default [0,0,-1].
        CUSTOM convention removes the +0.5 pixel offset that MOSFLM adds.

        - BEAM pivot: pix0_vector = -Fbeam*fdet_vec - Sbeam*sdet_vec + distance*beam_vec
        - SAMPLE pivot: Calculate pix0_vector BEFORE rotations, then rotate it

[2025-10-06T15:39:33] tokens used: 241,358

[2025-10-06T15:39:36] thinking

**Checking for overrides**
[2025-10-06T15:39:38] exec bash -lc "sed -n '460,640p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:39:38] bash -lc "sed -n '460,640p' src/nanobrag_torch/models/detector.py" succeeded in 691ms:
                ratio
            )

            # Update distance based on r-factor
            # If close_distance is specified, use it; otherwise calculate from nominal distance
            if hasattr(self.config, 'close_distance_mm') and self.config.close_distance_mm is not None:
                close_distance = self.config.close_distance_mm / 1000.0  # Convert mm to meters
            else:
                close_distance = abs(ratio * self.distance)  # Default from C code

            # Update the actual distance using r-factor (implements AT-GEO-003)
            self.distance_corrected = close_distance / ratio

            # CRITICAL: Update the stored close_distance for obliquity calculations
            # This is needed when detector is rotated (e.g., with twotheta)
            self.close_distance = close_distance

        # Store r-factor for later verification
        # Ensure it's a tensor with correct dtype
        if isinstance(ratio, torch.Tensor):
[2025-10-06T15:39:38] tokens used: 243,345

[2025-10-06T15:39:50] thinking

**Inspecting conditional block logic**
[2025-10-06T15:39:51] exec bash -lc "sed -n '520,600p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:39:52] bash -lc "sed -n '520,600p' src/nanobrag_torch/models/detector.py" succeeded in 903ms:
            # C code DOES honor -pix0_vector_mm even when custom detector vectors are present.
            # The override is applied by deriving Fbeam/Sbeam from the pix0_override value.
            #
            # pix0_override application workflow:
            # 1. Subtract beam term to get detector offset: pix0_delta = pix0_override - distance*beam
            # 2. Project onto detector axes to get Fbeam_override, Sbeam_override
            #    Fbeam = -dot(pix0_delta, fdet); Sbeam = -dot(pix0_delta, sdet)
            # 3. Update beam_center_f/s tensors for header consistency
            # 4. Apply standard BEAM formula with derived Fbeam/Sbeam
            #
            # This ensures that -pix0_vector_mm overrides the beam center calculation
            # regardless of whether custom detector vectors are present.

            # CLI-FLAGS-003 Phase H5b: Apply pix0 override even with custom vectors
            # Evidence from Phase J traces (2025-10-21) shows C code DOES recompute
            # Fbeam/Sbeam from pix0_override even when custom detector vectors are present.
            # The override precedence is: pix0_override transforms into Fbeam/Sbeam which
            # then feed into the standard BEAM pivot formula.
            if pix0_override_tensor is not None:
                # Ensure all tensors on same device/dtype
[2025-10-06T15:39:52] tokens used: 246,751

[2025-10-06T15:40:02] thinking

**Analyzing override logic and plan consistency**
[2025-10-06T15:40:03] exec bash -lc 'rg "H5" -n plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:40:04] bash -lc 'rg "H5" -n plans/active/cli-noise-pix0/plan.md' succeeded in 829ms:
7:- Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
8:- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
113:### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
120:| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
121:| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
122:| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
123:| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
[2025-10-06T15:40:04] tokens used: 248,729

[2025-10-06T15:40:13] thinking

**Reevaluating plan based on new evidence**

I‚Äôm sorting through conflicting info on override handling‚Äîlogs suggest override is ignored with custom vectors, which challenges previous assumptions. I‚Äôll verify this with specs and tests, then update the plan accordingly before recommending any reversion or further changes.
[2025-10-06T15:40:15] exec bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/diff.log' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:40:16] bash -lc 'head -n 40 reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/diff.log' succeeded in 857ms:
--- reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/with_override.log	2025-10-06 08:27:05.860759781 -0700
+++ reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/without_override.log	2025-10-06 08:27:23.933882863 -0700
@@ -258,7 +258,7 @@
 2% done
 
 solid angle subtended by detector = 0.192259 steradian ( 1.52995% sphere)
-writing img.bin as 6224001 4-byte floats
+writing img_no_override.bin as 6224001 4-byte floats
 max_I = 446.254  at 0.117906 0.178794
 mean= 0.00104287 rms= 0.334386 rmsd= 0.334384
 intfile_scale = 123.248
[2025-10-06T15:40:16] tokens used: 249,740

[2025-10-06T15:40:42] thinking

**Analyzing override inconsistency and planning update**

I'll assess how current code incorrectly applies the override despite evidence that it should be ignored when custom vectors exist, causing lattice differences. There‚Äôs a plan mismatch to fix by revising phases H5b-H5d in the noise-pix0 plan and adjusting related docs to align with new findings. Next steps include specifying revisions to ensure the plan and code stay consistent with updated evidence.
[2025-10-06T15:40:46] exec bash -lc "sed -n '520,560p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:40:47] bash -lc "sed -n '520,560p' docs/fix_plan.md" succeeded in 966ms:
      - **Implies precedence:** `if (custom_vectors) { compute_from_custom_vectors(); ignore_override(); } else if (override) { apply_override(); } else { use_convention(); }`
      - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
    Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
    Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
  * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
    Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
    Artifacts:
      - `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/with_override.log` - 267 lines, C run WITH -pix0_vector_mm flag
      - `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/without_override.log` - 267 lines, C run WITHOUT -pix0_vector_mm flag
      - `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/diff.log` - 11 lines, only filename difference
      - `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` - Authoritative evidence report with dot-product derivation
    Observations/Hypotheses:
      - **Re-confirms 2025-10-06 evidence:** C ignores `-pix0_vector_mm` when custom detector vectors are supplied
      - **Dot-product derivation performed:** If override (-0.216336, 0.215206, -0.230201) were projected onto fdet/sdet, expected Fbeam‚âà-0.217596 m, Sbeam‚âà-0.212772 m. Actual C values: Fbeam=0.217889 m, Sbeam=0.215043 m. **Mismatch proves override not applied.**
      - **Precedence logic:** `if(custom_vectors) {compute_from_xbeam_ybeam(); ignore_override();} else if(override) {apply_override();} else {use_convention();}`
      - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
      - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
    Next Actions:
      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
[2025-10-06T15:40:47] tokens used: 250,884

[2025-10-06T15:41:05] thinking

**Revising plan to revert override**

I'll update the `cli-noise-pix0` plan to reflect the new directive to revert the override behavior, revising task statuses in Phase H5 and adjusting related documentation to align with the updated approach and recent evidence. I'll reference key docs like the CLI spec and detector architecture to ensure the plan‚Äôs context is solid.
[2025-10-06T15:41:29] tokens used: 276,347

[2025-10-06T15:41:33] thinking

**Diagnosing patch failure**
[2025-10-06T15:41:35] exec bash -lc "sed -n '100,160p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:41:36] bash -lc "sed -n '100,160p' plans/active/cli-noise-pix0/plan.md" succeeded in 882ms:

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| H1 | Refresh trace evidence post-orientation | [D] | ‚úÖ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
| H2 | Fix incident beam propagation from CLI | [D] | ‚úÖ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
| H3a | Diagnose residual lattice mismatch | [D] | ‚úÖ 2025-10-17 Attempt #21 (ralph). `trace_py_after_H3_refresh.log`, `pix0_reproduction.md`, and `implementation_notes.md` quantify the ~1.14‚ÄØmm pix0 delta and show the cascade into scattering vector and `F_latt` disparities; `attempt_log.txt` restored with evidence summary. |
| H3b1 | Capture C vs PyTorch pix0/F/S references (override on/off) | [D] | ‚úÖ 2025-10-17 Attempt #23: Stored paired C traces (`reports/2025-10-cli-flags/phase_h/implementation/c_trace_with_override.log` / `_without_override.log`), PyTorch traces, and `pix0_mapping_analysis.md`; evidence proves C geometry is identical with or without `-pix0_vector_mm` when custom vectors are supplied. |
| H3b2 | Implement pix0 precedence (custom vectors > override) | [D] | ‚úÖ 2025-10-06 Attempt #24 (commit d6f158c). `Detector._calculate_pix0_vector` now skips overrides when any custom detector vector is supplied; override logic only executes in the no-custom-vectors path. Validation: `tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot` (CPU) and evidence log `reports/2025-10-cli-flags/phase_h/implementation/pix0_override_validation.md`. Residual pix0 Y-delta (‚âà3.9‚ÄØmm) traced to missing post-rotation `Fbeam/Sbeam` recomputation and deferred to H4. |
| H3b3 | Repair CLI regression + artifacts for precedence | [D] | ‚úÖ 2025-10-06 Attempt #24. Regression test now covers BOTH precedence cases (custom vectors ignored, standard path applies override) and records expected C pix0 vector in `pix0_expected.json`. CUDA parametrisation remains skipped until parity fix lands; tolerance temporarily relaxed to 5‚ÄØmm pending H4 geometry alignment. |
| H4a | Port post-rotation beam-centre recomputation | [D] | ‚úÖ 2025-10-17 Attempt #25: Ported nanoBragg.c lines 1846-1860 into `Detector._calculate_pix0_vector`; see `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/implementation.md`. |
| H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
| H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |

### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
[2025-10-06T15:41:36] tokens used: 281,137

[2025-10-06T15:41:41] thinking

**Preparing targeted patch**
[2025-10-06T15:41:57] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/./plans/active/cli-noise-pix0/plan.md
@@ -112,5 +112,5 @@
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
@@ -119,6 +119,6 @@
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
[2025-10-06T15:41:57] apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T15:41:57] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..38277577564ef6d2cef706a001db7eefdfd4bad9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.

[2025-10-06T15:41:58] tokens used: 285,674
[2025-10-06T15:41:58] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..38277577564ef6d2cef706a001db7eefdfd4bad9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:42:01] thinking

**Updating reference bullet points**
[2025-10-06T15:42:05] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/./plans/active/cli-noise-pix0/plan.md
@@ -7,3 +7,3 @@
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
[2025-10-06T15:42:05] apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T15:42:05] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.

[2025-10-06T15:42:05] tokens used: 287,802
[2025-10-06T15:42:05] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:42:16] thinking

**Updating fix_plan documentation**

I‚Äôm updating the Next Actions in docs/fix_plan.md around lines 500-540 to reflect the revised plan, including reverting override (#29), capturing PyTorch traces (H5c), and updating attempt logs. I‚Äôll ensure consistency between Next Actions and attempt entry descriptions, noting regressions and actions needed.
[2025-10-06T15:42:27] tokens used: 290,189
[2025-10-06T15:42:27] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:42:32] thinking

**Examining patch failure details**
[2025-10-06T15:42:34] exec bash -lc "sed -n '500,560p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:42:35] bash -lc "sed -n '500,560p' docs/fix_plan.md" succeeded in 969ms:
      - `src/nanobrag_torch/config.py:483-487` - Updated polarization_factor default from 0.0 to 1.0 with C reference citation
      - `tests/test_cli_flags.py:591-675` - Added TestCLIPolarization class with 3 tests (default parity, -nopolar flag, -polar override)
    Observations/Hypotheses:
      - **Root Cause Fixed:** PyTorch was defaulting to polarization_factor=0.0 instead of matching C's polar=1.0
      - **C Reference:** golden_suite_generator/nanoBragg.c:308-309 sets polar=1.0, polarization=0.0, nopolar=0
      - **Test Coverage:** Validates default matches C (1.0), -nopolar flag behavior, and -polar <value> override
      - **Phase I Tasks:** I1 (audit) ‚úÖ, I2 (implement) ‚úÖ; I3 (final parity sweep) remains pending
    Next Actions: Execute Phase I3 final parity sweep by running the supervisor command end-to-end (PyTorch CLI + C reference), stash logs under `reports/2025-10-cli-flags/phase_i/supervisor_command/`, document polarization metrics in Attempt #27, then close CLI-FLAGS-003.
  * [2025-10-06] Attempt #29 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE-ONLY COMPLETE. **C-code pix0 override behavior with custom vectors documented.**
    Metrics: Evidence-only loop. Two C runs executed: WITH override (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). Identical geometry values confirm override is ignored when custom vectors are present.
    Artifacts:
      - `reports/2025-10-cli-flags/phase_h5/c_traces/with_override.log` - C run WITH -pix0_vector_mm flag
      - `reports/2025-10-cli-flags/phase_h5/c_traces/without_override.log` - C run WITHOUT -pix0_vector_mm flag
      - `reports/2025-10-cli-flags/phase_h5/c_traces/diff.log` - Diff showing only filename difference
      - `reports/2025-10-cli-flags/phase_h5/c_precedence.md` - Complete evidence report with precedence analysis
    Observations/Hypotheses:
      - **Critical finding:** When custom detector vectors (`-odet_vector`, `-sdet_vector`, `-fdet_vector`) are supplied, C code computes pix0 from Xbeam/Ybeam and IGNORES `-pix0_vector_mm` override
      - **Geometry identical:** pix0_vector, Fbeam, Sbeam all match exactly between WITH/WITHOUT override runs
      - **Only diff:** Output filename (img.bin vs img_no_override.bin)
      - **Contradicts Attempt #23 (Phase H3b1):** Prior evidence suggested different Fbeam/Sbeam values; current evidence shows identical values
[2025-10-06T15:42:35] tokens used: 291,922
[2025-10-06T15:42:35] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:42:41] thinking

**Updating Next Actions section**
[2025-10-06T15:42:46] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/./docs/fix_plan.md
@@ -538,5 +538,5 @@
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
[2025-10-06T15:42:46] apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T15:42:46] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..eb9e30e36b42f3aa29b1f2b1f72f64ba1d4fbc17
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.

[2025-10-06T15:42:46] tokens used: 295,305
[2025-10-06T15:42:46] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..eb9e30e36b42f3aa29b1f2b1f72f64ba1d4fbc17
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:42:51] thinking

**Updating task descriptions**
[2025-10-06T15:42:55] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/./docs/fix_plan.md
@@ -523,3 +523,3 @@
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
[2025-10-06T15:42:55] apply_patch(auto_approved=true) exited 0 in 28ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T15:42:55] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.

[2025-10-06T15:42:55] tokens used: 296,203
[2025-10-06T15:42:55] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:43:10] thinking

**Preparing detailed update for input.md**

I'm getting ready to write a new `input.md` with around 100-200 lines to guide Ralph on reverting the override in the detector code. I'll carefully include sections like Do Now, Phases, Artifacts, and testing commands‚Äîmaking sure to confirm exact test names by inspecting the test file before finalizing instructions. The focus will tie closely to the fix_plan ID and ensure thorough documentation cross-references.
[2025-10-06T15:43:14] exec bash -lc 'rg "class TestCLIPix0Override" -n tests/test_cli_flags.py' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:43:15] bash -lc 'rg "class TestCLIPix0Override" -n tests/test_cli_flags.py' succeeded in 897ms:
375:class TestCLIPix0Override:
[2025-10-06T15:43:15] tokens used: 297,943
[2025-10-06T15:43:15] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:43:17] thinking

**Checking class for test function names**
[2025-10-06T15:43:19] exec bash -lc "sed -n '375,460p' tests/test_cli_flags.py" in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:43:19] bash -lc "sed -n '375,460p' tests/test_cli_flags.py" succeeded in 708ms:
class TestCLIPix0Override:
    """
    Regression tests for CLI-FLAGS-003 Phase H3b.

    Test the BEAM-pivot pix0 transformation when -pix0_vector_mm override is provided.
    Reference: plans/active/cli-noise-pix0/plan.md Phase H3b
    Evidence: reports/2025-10-cli-flags/phase_h/pix0_reproduction.md
    """

    @pytest.mark.parametrize("device,dtype", [
        ("cpu", torch.float32),
        pytest.param("cuda", torch.float32, marks=pytest.mark.skipif(
            not torch.cuda.is_available(), reason="CUDA not available"
        ))
    ])
    def test_pix0_override_beam_pivot_transform(self, device, dtype):
        """
        Verify pix0 override IS APPLIED when NO custom vectors are present (BEAM pivot).

        Phase H3b2 Update: Per Phase H3b1 evidence, pix0_override is ONLY ignored when
[2025-10-06T15:43:19] tokens used: 298,759
[2025-10-06T15:43:19] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:43:28] thinking

**Preparing detailed input.md contents**
[2025-10-06T15:43:47] exec bash -lc "cat <<'EOF' > input.md
Summary: Restore pix0 precedence with custom detector vectors so F_latt matches C.
Phase: Implementation
Focus: CLI-FLAGS-003 / Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: tests/test_cli_flags.py::TestCLIPix0Override
Artifacts: reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log, reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/, reports/2025-10-cli-flags/phase_h5/parity_summary.md
Do Now: CLI-FLAGS-003 H5b ‚Äî revert custom-vector pix0 override ("'`env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v`)
If Blocked: Pause after reverting the code; capture the failure cause and current pix0 deltas in `reports/2025-10-cli-flags/phase_h5/attempt_h5b_blocked.md`, then stop.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md ¬ßPhase H5 ‚Äî Newly updated tasks demand undoing the override for custom vectors before Phase K.
- docs/fix_plan.md:503-550 ‚Äî Next actions call for reverting Attempt #29 and recapturing PyTorch traces (<5e-5‚ÄØm pix0, <1e-3 `F_latt` ratio).
- reports/2025-10-cli-flags/phase_j/scaling_chain.md ‚Äî Shows F_latt ratio 3.6e-7 caused by pix0 mismatch; fixing precedence should eliminate this gap.
- specs/spec-a-cli.md ¬ßPrecedence ‚Äî Custom vectors define geometry; overrides apply only when vectors absent.
- docs/architecture/detector.md ¬ß5 ‚Äî Details BEAM pivot equations and override projection math that must stay intact after the revert.

How-To Map:
1. Edit `src/nanobrag_torch/models/detector.py` so the pix0 override projection is skipped when any custom f/s/o vectors are configured; keep device/dtype neutrality and update inline comments accordingly.
2. Run `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v | tee reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` to prove both precedence scenarios still pass.
3. Execute the supervisor command via the Phase H trace harness (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/trace_py.log`) and diff against `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/with_override.log`.
4. Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with pix0/Fbeam/Sbeam deltas (<5e-5‚ÄØm) and `F_latt` ratio, then add Attempt #31 notes to docs/fix_plan.md.

Pitfalls To Avoid:
- Do not touch C evidence files under reports/2025-10-cli-flags/phase_h5/c_traces/; they are the reference set.
- Preserve runtime guardrails: no `.cpu()`/`.item()` inserts, and keep the override logic differentiable.
- Ensure the revert keeps MOSFLM defaults intact‚Äîonly guard the override when custom vectors are present.
- Avoid introducing ad-hoc scripts; reuse `reports/2025-10-cli-flags/phase_h/trace_harness.py` for traces.
- Keep logs under the 2025-10-22 directory to avoid clobbering prior evidence.
- Run the targeted pytest exactly once; no full suite this loop.
- Retain device/dtype parity checks in existing tests; update expected tolerances only if necessary and document why.
- Do not delete prior Attempt #29 artifacts; add new summaries instead.
- Maintain Protected Assets‚Äîreview docs/index.md before modifying tracked tooling or scripts.
- Capture git diff before committing to ensure only intended files changed.

Pointers:
- plans/active/cli-noise-pix0/plan.md:96-140 ‚Äî Phase H5 checklist and success criteria.
- docs/fix_plan.md:506-551 ‚Äî Attempt #29/#30 narrative and required follow-up.
- reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md ‚Äî C evidence you must mirror.
- docs/architecture/detector.md ¬ß5.3 ‚Äî Pix0 computation formulas and custom vector rules.
- docs/development/testing_strategy.md ¬ß1.5 ‚Äî Targeted pytest cadence expectations.

Next Up: Phase H5c trace capture (complete diff vs C) once the revert lands.
EOF
' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:43:48] bash -lc "cat <<'EOF' > input.md
Summary: Restore pix0 precedence with custom detector vectors so F_latt matches C.
Phase: Implementation
Focus: CLI-FLAGS-003 / Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: tests/test_cli_flags.py::TestCLIPix0Override
Artifacts: reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log, reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/, reports/2025-10-cli-flags/phase_h5/parity_summary.md
Do Now: CLI-FLAGS-003 H5b ‚Äî revert custom-vector pix0 override ("'`env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v`)
If Blocked: Pause after reverting the code; capture the failure cause and current pix0 deltas in `reports/2025-10-cli-flags/phase_h5/attempt_h5b_blocked.md`, then stop.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md ¬ßPhase H5 ‚Äî Newly updated tasks demand undoing the override for custom vectors before Phase K.
- docs/fix_plan.md:503-550 ‚Äî Next actions call for reverting Attempt #29 and recapturing PyTorch traces (<5e-5‚ÄØm pix0, <1e-3 `F_latt` ratio).
- reports/2025-10-cli-flags/phase_j/scaling_chain.md ‚Äî Shows F_latt ratio 3.6e-7 caused by pix0 mismatch; fixing precedence should eliminate this gap.
- specs/spec-a-cli.md ¬ßPrecedence ‚Äî Custom vectors define geometry; overrides apply only when vectors absent.
- docs/architecture/detector.md ¬ß5 ‚Äî Details BEAM pivot equations and override projection math that must stay intact after the revert.

How-To Map:
1. Edit `src/nanobrag_torch/models/detector.py` so the pix0 override projection is skipped when any custom f/s/o vectors are configured; keep device/dtype neutrality and update inline comments accordingly.
2. Run `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v | tee reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` to prove both precedence scenarios still pass.
3. Execute the supervisor command via the Phase H trace harness (`PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/trace_py.log`) and diff against `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/with_override.log`.
4. Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with pix0/Fbeam/Sbeam deltas (<5e-5‚ÄØm) and `F_latt` ratio, then add Attempt #31 notes to docs/fix_plan.md.

Pitfalls To Avoid:
- Do not touch C evidence files under reports/2025-10-cli-flags/phase_h5/c_traces/; they are the reference set.
- Preserve runtime guardrails: no `.cpu()`/`.item()` inserts, and keep the override logic differentiable.
- Ensure the revert keeps MOSFLM defaults intact‚Äîonly guard the override when custom vectors are present.
- Avoid introducing ad-hoc scripts; reuse `reports/2025-10-cli-flags/phase_h/trace_harness.py` for traces.
- Keep logs under the 2025-10-22 directory to avoid clobbering prior evidence.
- Run the targeted pytest exactly once; no full suite this loop.
- Retain device/dtype parity checks in existing tests; update expected tolerances only if necessary and document why.
- Do not delete prior Attempt #29 artifacts; add new summaries instead.
- Maintain Protected Assets‚Äîreview docs/index.md before modifying tracked tooling or scripts.
- Capture git diff before committing to ensure only intended files changed.

Pointers:
- plans/active/cli-noise-pix0/plan.md:96-140 ‚Äî Phase H5 checklist and success criteria.
- docs/fix_plan.md:506-551 ‚Äî Attempt #29/#30 narrative and required follow-up.
- reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md ‚Äî C evidence you must mirror.
- docs/architecture/detector.md ¬ß5.3 ‚Äî Pix0 computation formulas and custom vector rules.
- docs/development/testing_strategy.md ¬ß1.5 ‚Äî Targeted pytest cadence expectations.

Next Up: Phase H5c trace capture (complete diff vs C) once the revert lands.
EOF
' succeeded in 952ms:

[2025-10-06T15:43:48] tokens used: 301,365
[2025-10-06T15:43:48] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:43:55] thinking

**Planning to expand input.md length**

I see that the current `input.md` is only about 40 lines, which is shorter than the desired 100‚Äì200 lines. I‚Äôll rewrite it to add more detail, extra bullet points, notes like "Do Now," and additional guidelines to bring the length up to around 120 lines while keeping the content meaningful.
[2025-10-06T15:44:28] exec bash -lc "cat <<'EOF' > input.md
Summary: Restore pix0 precedence with custom detector vectors so PyTorch reproduces C "'`F_latt` for the supervisor command.
Phase: Implementation
Focus: CLI-FLAGS-003 / Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: tests/test_cli_flags.py::TestCLIPix0Override
Artifacts: reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log, reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/, reports/2025-10-cli-flags/phase_h5/parity_summary.md, docs/fix_plan.md (Attempt #31 entry)
Do Now: CLI-FLAGS-003 H5b ‚Äî revert custom-vector pix0 override (`env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v`)
Do Now note: Commit d6f158c kept overrides disabled; Attempt #29 reintroduced them. Restore the pre-Attempt-29 behavior while preserving new r-factor math.
Do Now note: Annotate code comments referencing `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` so future readers know why overrides are skipped with custom vectors.
If Blocked: Halt after editing the detector; log the failure cause, git diff, and current pix0 deltas in `reports/2025-10-cli-flags/phase_h5/attempt_h5b_blocked.md`, then wait for supervisor guidance.
If Blocked note: Include command output (tail 20 lines) and environment details (device availability, torch version).
If Blocked note: Mention whether pytest or trace harness failed; do not attempt ad-hoc fixes.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md ¬ßPhase H5 ‚Äî Newly revised tasks require undoing the override for custom vectors before Phase K normalization.
- docs/fix_plan.md:506-551 ‚Äî Next actions and Attempt #30 observations explicitly call for the revert + fresh PyTorch traces.
- reports/2025-10-cli-flags/phase_j/scaling_chain.md ‚Äî Shows the 3.6e-7 `F_latt` ratio driven by the 1.14‚ÄØmm pix0 delta; reverting restores geometry parity.
- specs/spec-a-cli.md ¬ß¬ßPrecedence ‚Äî Custom vectors supersede pix0 overrides; implementation must follow the normative spec.
- docs/architecture/detector.md ¬ß5.3 ‚Äî Contains BEAM pivot formulas and projection math that must remain intact after the revert.
- docs/debugging/detector_geometry_checklist.md ‚Äî Provides mandatory unit/orientation checks when validating the updated traces.
- AUTHORITATIVE_CMDS_DOC=docs/development/testing_strategy.md ‚Äî Confirms targeted pytest cadence and CPU/CUDA smoke expectations.

How-To Map:
1. Code change
   - Open `src/nanobrag_torch/models/detector.py`.
   - Locate the pix0 override block inside `_calculate_pix0_vector`.
   - Guard the override projection with `if pix0_override_tensor is not None and not self.has_custom_vectors():` (or equivalent helper).
   - Keep device/dtype coercion and comments; cite `c_precedence_2025-10-22.md` when explaining the guard.
   - Ensure CUSTOM path still updates `beam_center_{f,s}` when overrides apply in the no-custom case.
2. Targeted tests
   - Run `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v | tee reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`.
   - Confirm CPU and CUDA parametrisations respect the new guard (CUDA will auto-skip if unavailable).
   - If assertions change, adjust expectations but keep tolerances ‚â§5e-5‚ÄØm.
3. PyTorch traces
   - Reuse the Phase H harness: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/trace_py.log`.
   - Diff against `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/with_override.log` (expect identical pix0/F/S, h/k/l, `F_latt`).
   - Record deltas in `parity_summary.md` (<5e-5‚ÄØm pix0, <1e-3 relative `F_latt`).
4. Documentation updates
   - Append a new Attempt (#31) in `docs/fix_plan.md` summarising the revert, pytest results, and trace metrics.
   - Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with a table of old vs new values.
   - Note any test changes in `reports/2025-10-cli-flags/phase_h5/implementation_notes.md`.

Pitfalls To Avoid:
- Do not edit reference logs under `reports/2025-10-cli-flags/phase_h5/c_traces/`; they are protected evidence.
- Avoid reintroducing `.cpu()`, `.detach()`, or `.item()` inside `_calculate_pix0_vector`; differentiability must remain intact.
- Keep MOSFLM/XDS behavior untouched; only guard the override when custom vectors are explicitly provided.
- No ad-hoc scripts‚Äîreuse existing harnesses and pytest selectors per testing_strategy.md.
- Maintain Protected Assets; consult docs/index.md before moving or deleting tooling.
- Run the targeted pytest exactly once; no full suite this loop.
- Preserve device/dtype neutrality in regression tests; adjust tolerances only with justification logged in parity_summary.md.
- When updating docs/fix_plan.md, keep Attempt chronology intact and cite plan cross-references.
- Ensure new logs land under `reports/2025-10-cli-flags/phase_h5/` with the 2025-10-22 stamp to prevent clobbering earlier attempts.
- Capture git diff prior to commit; only include detector.py, parity docs, reports, and fix_plan updates.

Pointers:
- plans/active/cli-noise-pix0/plan.md:95-146 ‚Äî Phase H5 checklist, exit criteria, and reporting expectations.
- docs/fix_plan.md:506-551 ‚Äî Attempt #29/#30 narrative + updated Next Actions.
- reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md ‚Äî Authoritative C precedence evidence.
- reports/2025-10-cli-flags/phase_j/scaling_chain.md ‚Äî Quantifies the current F_latt gap you are closing.
- docs/architecture/detector.md ¬ß5 ‚Äî Pix0 computation details and convention nuances.
- docs/development/testing_strategy.md ¬ß1.5 ‚Äî Targeted pytest requirements and logging conventions.
- docs/debugging/detector_geometry_checklist.md ‚Äî Mandatory validation steps before claiming detector parity.
- reports/2025-10-cli-flags/phase_h/trace_harness.py ‚Äî Reusable script for PyTorch trace capture.
- tests/test_cli_flags.py:375-452 ‚Äî Regression tests covering override precedence scenarios.
- plans/active/vectorization.md ‚Äî Leave untouched; vectorization remains pending until CLI parity is restored.

Next Up: Phase H5c PyTorch trace verification and docs/fix_plan Attempt #31 closure once override parity is restored.
Next Up note: After traces align, you can pivot to Phase K normalization tasks per plan (steps ordering + scaling fix).
EOF
' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:44:29] bash -lc "cat <<'EOF' > input.md
Summary: Restore pix0 precedence with custom detector vectors so PyTorch reproduces C "'`F_latt` for the supervisor command.
Phase: Implementation
Focus: CLI-FLAGS-003 / Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: tests/test_cli_flags.py::TestCLIPix0Override
Artifacts: reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log, reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/, reports/2025-10-cli-flags/phase_h5/parity_summary.md, docs/fix_plan.md (Attempt #31 entry)
Do Now: CLI-FLAGS-003 H5b ‚Äî revert custom-vector pix0 override (`env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v`)
Do Now note: Commit d6f158c kept overrides disabled; Attempt #29 reintroduced them. Restore the pre-Attempt-29 behavior while preserving new r-factor math.
Do Now note: Annotate code comments referencing `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` so future readers know why overrides are skipped with custom vectors.
If Blocked: Halt after editing the detector; log the failure cause, git diff, and current pix0 deltas in `reports/2025-10-cli-flags/phase_h5/attempt_h5b_blocked.md`, then wait for supervisor guidance.
If Blocked note: Include command output (tail 20 lines) and environment details (device availability, torch version).
If Blocked note: Mention whether pytest or trace harness failed; do not attempt ad-hoc fixes.

Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md ¬ßPhase H5 ‚Äî Newly revised tasks require undoing the override for custom vectors before Phase K normalization.
- docs/fix_plan.md:506-551 ‚Äî Next actions and Attempt #30 observations explicitly call for the revert + fresh PyTorch traces.
- reports/2025-10-cli-flags/phase_j/scaling_chain.md ‚Äî Shows the 3.6e-7 `F_latt` ratio driven by the 1.14‚ÄØmm pix0 delta; reverting restores geometry parity.
- specs/spec-a-cli.md ¬ß¬ßPrecedence ‚Äî Custom vectors supersede pix0 overrides; implementation must follow the normative spec.
- docs/architecture/detector.md ¬ß5.3 ‚Äî Contains BEAM pivot formulas and projection math that must remain intact after the revert.
- docs/debugging/detector_geometry_checklist.md ‚Äî Provides mandatory unit/orientation checks when validating the updated traces.
- AUTHORITATIVE_CMDS_DOC=docs/development/testing_strategy.md ‚Äî Confirms targeted pytest cadence and CPU/CUDA smoke expectations.

How-To Map:
1. Code change
   - Open `src/nanobrag_torch/models/detector.py`.
   - Locate the pix0 override block inside `_calculate_pix0_vector`.
   - Guard the override projection with `if pix0_override_tensor is not None and not self.has_custom_vectors():` (or equivalent helper).
   - Keep device/dtype coercion and comments; cite `c_precedence_2025-10-22.md` when explaining the guard.
   - Ensure CUSTOM path still updates `beam_center_{f,s}` when overrides apply in the no-custom case.
2. Targeted tests
   - Run `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override -v | tee reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`.
   - Confirm CPU and CUDA parametrisations respect the new guard (CUDA will auto-skip if unavailable).
   - If assertions change, adjust expectations but keep tolerances ‚â§5e-5‚ÄØm.
3. PyTorch traces
   - Reuse the Phase H harness: `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_h/trace_harness.py --out reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/trace_py.log`.
   - Diff against `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/with_override.log` (expect identical pix0/F/S, h/k/l, `F_latt`).
   - Record deltas in `parity_summary.md` (<5e-5‚ÄØm pix0, <1e-3 relative `F_latt`).
4. Documentation updates
   - Append a new Attempt (#31) in `docs/fix_plan.md` summarising the revert, pytest results, and trace metrics.
   - Update `reports/2025-10-cli-flags/phase_h5/parity_summary.md` with a table of old vs new values.
   - Note any test changes in `reports/2025-10-cli-flags/phase_h5/implementation_notes.md`.

Pitfalls To Avoid:
- Do not edit reference logs under `reports/2025-10-cli-flags/phase_h5/c_traces/`; they are protected evidence.
- Avoid reintroducing `.cpu()`, `.detach()`, or `.item()` inside `_calculate_pix0_vector`; differentiability must remain intact.
- Keep MOSFLM/XDS behavior untouched; only guard the override when custom vectors are explicitly provided.
- No ad-hoc scripts‚Äîreuse existing harnesses and pytest selectors per testing_strategy.md.
- Maintain Protected Assets; consult docs/index.md before moving or deleting tooling.
- Run the targeted pytest exactly once; no full suite this loop.
- Preserve device/dtype neutrality in regression tests; adjust tolerances only with justification logged in parity_summary.md.
- When updating docs/fix_plan.md, keep Attempt chronology intact and cite plan cross-references.
- Ensure new logs land under `reports/2025-10-cli-flags/phase_h5/` with the 2025-10-22 stamp to prevent clobbering earlier attempts.
- Capture git diff prior to commit; only include detector.py, parity docs, reports, and fix_plan updates.

Pointers:
- plans/active/cli-noise-pix0/plan.md:95-146 ‚Äî Phase H5 checklist, exit criteria, and reporting expectations.
- docs/fix_plan.md:506-551 ‚Äî Attempt #29/#30 narrative + updated Next Actions.
- reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md ‚Äî Authoritative C precedence evidence.
- reports/2025-10-cli-flags/phase_j/scaling_chain.md ‚Äî Quantifies the current F_latt gap you are closing.
- docs/architecture/detector.md ¬ß5 ‚Äî Pix0 computation details and convention nuances.
- docs/development/testing_strategy.md ¬ß1.5 ‚Äî Targeted pytest requirements and logging conventions.
- docs/debugging/detector_geometry_checklist.md ‚Äî Mandatory validation steps before claiming detector parity.
- reports/2025-10-cli-flags/phase_h/trace_harness.py ‚Äî Reusable script for PyTorch trace capture.
- tests/test_cli_flags.py:375-452 ‚Äî Regression tests covering override precedence scenarios.
- plans/active/vectorization.md ‚Äî Leave untouched; vectorization remains pending until CLI parity is restored.

Next Up: Phase H5c PyTorch trace verification and docs/fix_plan Attempt #31 closure once override parity is restored.
Next Up note: After traces align, you can pivot to Phase K normalization tasks per plan (steps ordering + scaling fix).
EOF
' succeeded in 851ms:

[2025-10-06T15:44:29] tokens used: 304,652
[2025-10-06T15:44:29] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:44:31] thinking

**Checking file length**
[2025-10-06T15:44:34] exec bash -lc 'wc -l input.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:44:34] bash -lc 'wc -l input.md' succeeded in 731ms:
      68 input.md
[2025-10-06T15:44:34] tokens used: 306,863
[2025-10-06T15:44:34] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:44:41] thinking

**Planning to expand file content**
[2025-10-06T15:45:02] exec bash -lc "cat <<'EOF' >> input.md

Verification Checklist:
- Confirm "'`Detector.has_custom_vectors()` (or equivalent) accurately reflects CLI inputs (custom f/s/o or None).
- Print temporary debug (guarded by `if __debug__`) only if needed; remove before commit to keep traces clean.
- Validate that `self.beam_center_f/s` remain tensors post-revert; avoid silent Python floats.
- Double-check `distance_corrected` and `close_distance` invariants via trace harness output.
- Ensure new Attempt entry references plan lines and artifacts explicitly (dates, commands, metrics).

Metrics To Capture:
- Pix0 delta (PyTorch - C) in meters for each component (target <5e-5).
- `F_latt` ratio Py/C (target 0.999‚Äì1.001) reported in parity_summary.md.
- `h`, `k`, `l` fractional offsets compared to C trace (should match within 1e-6).
- pytest duration and device coverage recorded in pytest log header.
- Git SHA in parity_summary.md for reproducibility.

Reporting Notes:
- Update `phase_h5/parity_summary.md` intro paragraph to mention Attempt #31 and cite new artifacts.
- Cross-link `phase_h5/implementation_notes.md` with the exact detector.py lines changed.
- When editing docs/fix_plan.md, keep markdown bullet indentation consistent (two spaces before hyphen inside Attempts).
- Record command invocations verbatim in the relevant report to aid future reproductions.
- Tag parity summary tables with "after Attempt #31" so later archives distinguish versions.

Command Log Expectations:
- `pytest_h5b_revert.log` should include command header, environment variables, and summary lines.
- Trace harness output should preserve `TRACE_PY` ordering; no manual edits to log lines.
- Diff commands (e.g., `diff -u .../trace_c .../trace_py`) may go into `parity_summary.md` as fenced code for clarity.
- If additional sanity checks are run (e.g., quick smoke ROI), document them separately under `reports/2025-10-cli-flags/phase_h5/sanity/`.
- Document wall-clock timing for trace harness to monitor any regressions.

Fallback Plan:
- If revert causes broader regressions, capture `git diff` output into `reports/.../attempt_h5b_blocked.md` and ping supervisor with summary + hypothesis.
- Should tests reveal stale fixtures, update them in a separate patch queued after parity is restored.
- If CUDA skips unexpectedly, note availability status and driver version in the report.
- Maintain clean workspace; stash unrelated files before proceeding.
- Escalate if evidence suggests C actually honors overrides‚Äîinclude new C traces before any PyTorch edits.

Coding Reminders:
- Respect Core Rule #16 (device/dtype neutrality) when modifying helper methods.
- Use small helper (e.g., `_has_custom_vectors`) if readability improves; include docstring referencing C behavior.
- Keep magnet for gradient flow by reusing existing tensors where possible (no fresh tensor creation on every call).
- Re-run static type checks if available (optional) to ensure signature parity.
- Update docstrings/comments to clarify precedence decisions for future maintainers.

Documentation Touchpoints:
- Mention revert rationale in `docs/development/pytorch_runtime_checklist.md` if override rules affect guardrails.
- Consider adding a short FAQ note in `README_PYTORCH.md` under CLI flags about custom vectors vs pix0 overrides (optional, only if time).
- Ensure `plans/active/cli-noise-pix0/plan.md` Phase H5 table state transitions ([ ], [D]) are accurate after work.
- Archive any superseded parity summaries under `reports/archive/` if file size balloons.
- Keep Attempt numbering monotonic; if Attempt #31 already used externally, bump to next free number.

Coordination Notes:
- Log progress in Attempts History within docs/fix_plan.md even if partial (e.g., revert complete, traces pending).
- If time remains, outline next steps for Phase K in a short note for supervisor review.
- Avoid overlapping plan phases (no Phase K edits until H5 marked complete).
- Mention in parity_summary.md whether override revert changed runtime metrics (if measurable).
- Maintain chronological ordering in `reports/2025-10-cli-flags/phase_h5/` directories (YYYY-MM-DD).

Housekeeping:
- Verify `input.md` is not touched by Ralph; only supervisor writes to it.
- Keep repo clean: remove temporary diff files after use.
- Run `git status` before finishing to ensure only intended files changed.
- Prepare commit message referencing "CLI-FLAGS-003 H5b revert" and list tests run.
- Push branch after commit; supervisor expects remote sync for next loop.
EOF
' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:45:03] bash -lc "cat <<'EOF' >> input.md

Verification Checklist:
- Confirm "'`Detector.has_custom_vectors()` (or equivalent) accurately reflects CLI inputs (custom f/s/o or None).
- Print temporary debug (guarded by `if __debug__`) only if needed; remove before commit to keep traces clean.
- Validate that `self.beam_center_f/s` remain tensors post-revert; avoid silent Python floats.
- Double-check `distance_corrected` and `close_distance` invariants via trace harness output.
- Ensure new Attempt entry references plan lines and artifacts explicitly (dates, commands, metrics).

Metrics To Capture:
- Pix0 delta (PyTorch - C) in meters for each component (target <5e-5).
- `F_latt` ratio Py/C (target 0.999‚Äì1.001) reported in parity_summary.md.
- `h`, `k`, `l` fractional offsets compared to C trace (should match within 1e-6).
- pytest duration and device coverage recorded in pytest log header.
- Git SHA in parity_summary.md for reproducibility.

Reporting Notes:
- Update `phase_h5/parity_summary.md` intro paragraph to mention Attempt #31 and cite new artifacts.
- Cross-link `phase_h5/implementation_notes.md` with the exact detector.py lines changed.
- When editing docs/fix_plan.md, keep markdown bullet indentation consistent (two spaces before hyphen inside Attempts).
- Record command invocations verbatim in the relevant report to aid future reproductions.
- Tag parity summary tables with "after Attempt #31" so later archives distinguish versions.

Command Log Expectations:
- `pytest_h5b_revert.log` should include command header, environment variables, and summary lines.
- Trace harness output should preserve `TRACE_PY` ordering; no manual edits to log lines.
- Diff commands (e.g., `diff -u .../trace_c .../trace_py`) may go into `parity_summary.md` as fenced code for clarity.
- If additional sanity checks are run (e.g., quick smoke ROI), document them separately under `reports/2025-10-cli-flags/phase_h5/sanity/`.
- Document wall-clock timing for trace harness to monitor any regressions.

Fallback Plan:
- If revert causes broader regressions, capture `git diff` output into `reports/.../attempt_h5b_blocked.md` and ping supervisor with summary + hypothesis.
- Should tests reveal stale fixtures, update them in a separate patch queued after parity is restored.
- If CUDA skips unexpectedly, note availability status and driver version in the report.
- Maintain clean workspace; stash unrelated files before proceeding.
- Escalate if evidence suggests C actually honors overrides‚Äîinclude new C traces before any PyTorch edits.

Coding Reminders:
- Respect Core Rule #16 (device/dtype neutrality) when modifying helper methods.
- Use small helper (e.g., `_has_custom_vectors`) if readability improves; include docstring referencing C behavior.
- Keep magnet for gradient flow by reusing existing tensors where possible (no fresh tensor creation on every call).
- Re-run static type checks if available (optional) to ensure signature parity.
- Update docstrings/comments to clarify precedence decisions for future maintainers.

Documentation Touchpoints:
- Mention revert rationale in `docs/development/pytorch_runtime_checklist.md` if override rules affect guardrails.
- Consider adding a short FAQ note in `README_PYTORCH.md` under CLI flags about custom vectors vs pix0 overrides (optional, only if time).
- Ensure `plans/active/cli-noise-pix0/plan.md` Phase H5 table state transitions ([ ], [D]) are accurate after work.
- Archive any superseded parity summaries under `reports/archive/` if file size balloons.
- Keep Attempt numbering monotonic; if Attempt #31 already used externally, bump to next free number.

Coordination Notes:
- Log progress in Attempts History within docs/fix_plan.md even if partial (e.g., revert complete, traces pending).
- If time remains, outline next steps for Phase K in a short note for supervisor review.
- Avoid overlapping plan phases (no Phase K edits until H5 marked complete).
- Mention in parity_summary.md whether override revert changed runtime metrics (if measurable).
- Maintain chronological ordering in `reports/2025-10-cli-flags/phase_h5/` directories (YYYY-MM-DD).

Housekeeping:
- Verify `input.md` is not touched by Ralph; only supervisor writes to it.
- Keep repo clean: remove temporary diff files after use.
- Run `git status` before finishing to ensure only intended files changed.
- Prepare commit message referencing "CLI-FLAGS-003 H5b revert" and list tests run.
- Push branch after commit; supervisor expects remote sync for next loop.
EOF
' succeeded in 967ms:

[2025-10-06T15:45:03] tokens used: 308,164
[2025-10-06T15:45:03] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:45:09] thinking

**Checking line count**
[2025-10-06T15:45:10] exec bash -lc 'wc -l input.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:45:11] bash -lc 'wc -l input.md' succeeded in 777ms:
     131 input.md
[2025-10-06T15:45:11] tokens used: 309,702
[2025-10-06T15:45:11] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:45:16] thinking

**Preparing to update galph_memory.md**
[2025-10-06T15:45:17] exec bash -lc 'tail -n 40 galph_memory.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:45:18] bash -lc 'tail -n 40 galph_memory.md' succeeded in 695ms:
- Long-term goal sweep: CLI parity stalled only on Phase I3; vectorization plan Phases A‚ÄìF untouched pending parity evidence. `_tricubic_interpolation` still falls back to nearest-neighbour for batched tensors, reinforcing urgency once CLI closes.
- Hypotheses for Phase I3 parity gap (triage): (1) Polarization factor may still diverge if CLI path misses Kahn defaults despite BeamConfig fix‚Äîconfirm by running nb-compare; (2) -nonoise might still emit noiseimage if simulator flag regressed; (3) pix0 override suppression with custom vectors must match C‚Äîverify stdout pix0 to ensure parity. Highest-confidence risk is #1; next step is the nb-compare command recorded in input.md (correlation + polarization metrics).
- No new plan drafted‚Äî`plans/active/cli-noise-pix0/plan.md` remains authoritative. Updated docs/fix_plan.md next actions to focus on Attempt #27 parity run and deepened I3 guidance.
- Regenerated input.md (143 lines, Validation phase) instructing Ralph to run nb-compare with the supervisor command, archive artifacts under `reports/2025-10-cli-flags/phase_i/supervisor_command/`, execute targeted pytest, and document Attempt #27 metrics.
- Follow-ups for Ralph: execute Do Now nb-compare command, capture stdout/stderr + summary.json, run targeted pytest + collect-only, update README + docs/fix_plan Attempt #27, leave code untouched.
## 2025-10-19 (galph loop ‚Äî Phase J directive)
- `git pull --rebase` was clean; reviewed CLAUDE guardrails, spec shards, arch.md, config map, debugging + testing strategy, fix_plan, and active plans before action.
- Deep-dive confirmed Goal #1 is now blocked solely by a 1.24538e5√ó intensity gap even after polarization parity; Goal #2 (vectorization) remains paused until CLI parity lands (Phase A evidence still outstanding).
- Reviewed Ralph‚Äôs recent commits (`e8146c2`, `beadffc`): polarization default fix + new tests look solid; nb-compare tooling patch captured parity failure evidence without regressions. No course correction needed, but scaling issue persists.
- Updated `plans/active/cli-noise-pix0/plan.md` with new Phases J‚ÄìL covering scaling evidence ‚Üí normalization implementation ‚Üí final parity; marked I3 as blocked and refreshed context to emphasise the scaling gap.
- Synced `docs/fix_plan.md` Next Actions with the Phase J checklist and noted that Attempt #27 directives are superseded; Phase K work now gated on Attempt #28 evidence.
- Regenerated `input.md` (Evidence phase) instructing Ralph to capture C/Py scaling traces, build `scaling_chain.md`, and log Attempt #28 before any simulator edits.
- Follow-ups for Ralph: deliver plan tasks J1‚ÄìJ3 (logs + analysis + fix_plan update) under `reports/2025-10-cli-flags/phase_j/`, then pause for supervisor review before touching normalization code.

## 2025-10-21 (galph loop ‚Äî Phase H5 reopen)
- Phase J scaling traces revealed C honours `-pix0_vector_mm` even with custom detector vectors; PyTorch still skips override in that path ‚Üí 1.14‚ÄØmm pix0 delta, h/k/l drift, F_latt collapse.
- Updated `plans/active/cli-noise-pix0/plan.md` with Phase H5 (C evidence, override reinstatement, trace verification, fix_plan logging) and corrected the prior note that C ignored overrides.
- Synced `docs/fix_plan.md` Next Actions to require H5a‚ÄìH5c before Phase K; Attempt #28 observations now document the confirmed driver (missing override in custom-vector path).
- Regenerated `input.md` (Implementation phase) directing Ralph to execute Phase H5b with fresh C/PyTorch traces and targeted pytest.
- Follow-up: Expect Attempt #29 after override fix; pause Phase K normalization work until H5 parity evidence lands.
[2025-10-06T15:45:18] tokens used: 310,044
[2025-10-06T15:45:18] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:45:24] thinking

**Appending new changelog entry**
[2025-10-06T15:45:32] exec bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-24 (galph loop ‚Äî Phase H5 revert directive)
- "'`git pull --rebase` clean; re-read docs/index.md, spec shards, arch.md, config map, debugging + testing strategy, fix_plan, and active plans before proceeding.
- Deep analysis vs long-term goals: parity still blocked by pix0 mismatch (PyTorch applies override while C ignores with custom vectors); vectorization plan untouched until CLI parity closes.
- Reviewed Ralph‚Äôs latest loops (5878f16, 052307f): evidence solidly shows nanoBragg ignores `-pix0_vector_mm` when custom detector vectors supplied, but repo still carries Attempt #29 override change ‚Üí root cause of 3.6e-7 `F_latt` ratio. Direction needed to undo that change.
- Updated `plans/active/cli-noise-pix0/plan.md` Phase H5: marked H5a [D], replaced H5b with "revert override when custom vectors supplied", refreshed H5c/H5d guidance, and revised context to cite 2025-10-22 C evidence.
- Synced `docs/fix_plan.md` Next Actions with new H5b/H5c tasks, emphasized Attempt #29 now needs a revert, and kept Attempt #30 observations as canonical precedence proof.
- Reissued `input.md` (131 lines, Implementation phase) directing Ralph to remove the override for custom vectors, rerun targeted pytest + trace harness, update parity_summary.md, and log Attempt #31 before touching Phase K.
- Hypotheses for remaining intensity gap now hinge on normalization once geometry parity returns; no new plan beyond existing Phase K tasks.
- Follow-ups for Ralph: execute Do Now revert + tests, capture PyTorch traces under `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`, update parity_summary.md and docs/fix_plan Attempt history, then pause for supervisor review before Phase K work.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T15:45:33] bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-24 (galph loop ‚Äî Phase H5 revert directive)
- "'`git pull --rebase` clean; re-read docs/index.md, spec shards, arch.md, config map, debugging + testing strategy, fix_plan, and active plans before proceeding.
- Deep analysis vs long-term goals: parity still blocked by pix0 mismatch (PyTorch applies override while C ignores with custom vectors); vectorization plan untouched until CLI parity closes.
- Reviewed Ralph‚Äôs latest loops (5878f16, 052307f): evidence solidly shows nanoBragg ignores `-pix0_vector_mm` when custom detector vectors supplied, but repo still carries Attempt #29 override change ‚Üí root cause of 3.6e-7 `F_latt` ratio. Direction needed to undo that change.
- Updated `plans/active/cli-noise-pix0/plan.md` Phase H5: marked H5a [D], replaced H5b with "revert override when custom vectors supplied", refreshed H5c/H5d guidance, and revised context to cite 2025-10-22 C evidence.
- Synced `docs/fix_plan.md` Next Actions with new H5b/H5c tasks, emphasized Attempt #29 now needs a revert, and kept Attempt #30 observations as canonical precedence proof.
- Reissued `input.md` (131 lines, Implementation phase) directing Ralph to remove the override for custom vectors, rerun targeted pytest + trace harness, update parity_summary.md, and log Attempt #31 before touching Phase K.
- Hypotheses for remaining intensity gap now hinge on normalization once geometry parity returns; no new plan beyond existing Phase K tasks.
- Follow-ups for Ralph: execute Do Now revert + tests, capture PyTorch traces under `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`, update parity_summary.md and docs/fix_plan Attempt history, then pause for supervisor review before Phase K work.
EOF
' succeeded in 883ms:

[2025-10-06T15:45:33] tokens used: 363,369
[2025-10-06T15:45:33] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:45:45] thinking

**Checking git status**
[2025-10-06T15:45:46] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:45:47] bash -lc 'git status --short' succeeded in 880ms:
 M docs/fix_plan.md
 M galph_memory.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T15:45:47] tokens used: 365,814
[2025-10-06T15:45:47] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:45:54] thinking

**Reviewing diffs for correctness**
[2025-10-06T15:45:57] exec bash -lc 'git diff plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:45:58] bash -lc 'git diff plans/active/cli-noise-pix0/plan.md' succeeded in 828ms:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07..5c3e5b4 100644
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@ Update 2025-10-17: Attempt #22 proved the projection-based override mapping push
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
[2025-10-06T15:45:58] tokens used: 366,077
[2025-10-06T15:45:58] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:46:01] thinking

**Reviewing docs/fix_plan changes**
[2025-10-06T15:46:01] exec bash -lc 'git diff docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:46:02] bash -lc 'git diff docs/fix_plan.md' succeeded in 711ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f267..8fba8c8 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
[2025-10-06T15:46:02] tokens used: 368,237
[2025-10-06T15:46:02] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:46:15] thinking

**Preparing commit with tests note**
[2025-10-06T15:46:16] exec bash -lc 'git add -A' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:46:17] bash -lc 'git add -A' succeeded in 749ms:

[2025-10-06T15:46:17] tokens used: 369,729
[2025-10-06T15:46:17] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:46:20] thinking

**Committing revert directive changes**
[2025-10-06T15:46:21] exec bash -lc 'git commit -m "SUPERVISOR: CLI-FLAGS-003 H5 revert directive - tests: not run"' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:46:22] bash -lc 'git commit -m "SUPERVISOR: CLI-FLAGS-003 H5 revert directive - tests: not run"' succeeded in 702ms:
[feature/spec-based-2 6687255] SUPERVISOR: CLI-FLAGS-003 H5 revert directive - tests: not run
 4 files changed, 143 insertions(+), 102 deletions(-)
[2025-10-06T15:46:22] tokens used: 369,915
[2025-10-06T15:46:22] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:46:24] thinking

**Pushing changes to repository**
[2025-10-06T15:46:25] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3/.
[2025-10-06T15:46:28] bash -lc 'git push' succeeded in 2.41s:
To github.com:hoidn/nanoBragg.git
   64471dd..6687255  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T15:46:28] tokens used: 370,759
[2025-10-06T15:46:28] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.


[2025-10-06T15:46:43] thinking

**Preparing final summary message**
[2025-10-06T15:46:43] codex

**Loop Update**
- Reset H5 context to match fresh C evidence: `plans/active/cli-noise-pix0/plan.md` now treats override-with-custom-vectors as disabled and adds revert/trace tasks; docs/fix_plan.md carries the same directive.
- Reissued `input.md` (Implementation phase, 131 lines) instructing Ralph to remove the custom-vector override, rerun the targeted CLI tests, recapture PyTorch traces, and log Attempt #31 before touching normalization work.
- Ralph‚Äôs last two loops (5878f16, 052307f) captured excellent C evidence but left Attempt #29‚Äôs override change in place; the repo therefore still applies the override and causes the 1.14‚ÄØmm pix0 delta‚Äîtoday‚Äôs instructions course-correct that regression.
- Vectorization initiative remains paused; no updates to `plans/active/vectorization.md` until CLI parity lands.

**Hypotheses**
- H1 (high): PyTorch applying the override when custom detector vectors are present drives the 3.6e-7 `F_latt` ratio (logs: `reports/2025-10-cli-flags/phase_j/trace_py_scaling.log`, `trace_c_scaling.log`); confirming step is to revert the override (H5b) and rerun the trace harness.
- H2 (medium): Once geometry matches, remaining intensity gap may stem from normalization order (Phase K tasks); confirming step is to rerun scaling_chain.md after H5 completes.
- H3 (low): Residual polarization discrepancies after revert; confirming step is the existing Phase I3 nb-compare once H5/K close.

Next up for Ralph: execute the Do Now revert/test/trace workflow from `input.md`, update parity_summary.md and docs/fix_plan Attempt log, then pause for review before normalization work resumes.
[2025-10-06T15:46:51] tokens used: 372,570
[2025-10-06T15:46:51] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 1c3f2677a541366d570c26c93d160992859b6e21..8fba8c855d5ba825f766a73a8d4f71f721a3cc40
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -521,7 +521,7 @@
       - **PyTorch status (2025-10-06 snapshot):** Implementation skipped override in the custom-vector path, matching this interpretation.
     Update 2025-10-21: superseded by refreshed C traces showing the override DOES apply with custom vectors; the 2025-10-06 instrumentation reused the derived Fbeam/Sbeam so the runs appeared identical. See Attempt #29 (2025-10-21) for corrected evidence.
     Update 2025-10-22: Fresh evidence collection (Attempt #30) **re-confirms 2025-10-06 finding**. WITH and WITHOUT override runs produce IDENTICAL geometry (pix0=-0.216476 m, Fbeam=0.217889 m, Sbeam=0.215043 m). The 2025-10-21 claim is not supported by fresh C traces. See `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md` for authoritative dot-product derivation proving override is ignored when custom vectors are present.
-  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. Pending: refresh C traces (H5a) and PyTorch parity logs (H5c) to confirm `Fbeam/Sbeam`, h/k/l, and `F_latt` alignment before closing this attempt.
+  * [2025-10-21] Attempt #29 (ralph) ‚Äî Result: **PARTIAL** (Phase H5b implementation). `Detector._calculate_pix0_vector` now projects `pix0_override_tensor` onto f/s axes even when custom vectors are supplied; regression suite (`reports/2025-10-cli-flags/phase_h5/pytest_regression.log`) green and parity memo logged at `reports/2025-10-cli-flags/phase_h5/parity_summary.md`. **Superseded by Attempt #30 evidence ‚Äî this override path must now be reverted so PyTorch matches C precedence when custom vectors are present.** Pending: apply the revert, capture new PyTorch traces (H5c), and log the follow-up attempt.
   * [2025-10-22] Attempt #30 (ralph loop) ‚Äî Result: Phase H5a EVIDENCE RE-CAPTURE COMPLETE. **C-code behavior re-confirmed: override ignored when custom vectors present.**
     Metrics: Evidence-only loop. Fresh C traces captured 2025-10-22. Two C runs executed: WITH override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m) and WITHOUT override (pix0 = [-0.216476, 0.216343, -0.230192] m, Fbeam=0.217889 m, Sbeam=0.215043 m). Geometry IDENTICAL to 15 significant figures.
     Artifacts:
@@ -536,9 +536,9 @@
       - **PyTorch parity status:** Phase H3b2 (commit d6f158c) correctly skips override when custom vectors present, **matching C behavior exactly**
       - **1.14 mm pix0 delta root cause:** Not due to override precedence (that logic is correct). Must trace to different issue in Phase K normalization or Phase L parity sweep.
     Next Actions:
-      - REVERSE Attempt #29 (2025-10-21) Phase H5b implementation that applied override with custom vectors (this contradicts C evidence)
-      - Skip Phase H5c (PyTorch trace) since parity is already correct per Phase H3b2
-      - Proceed to Phase K (normalization fix) to resolve the 1.14 mm delta via a different root cause
+      - Revert Attempt #29 (Phase H5b) so pix0 overrides are ignored whenever custom detector vectors are supplied, restoring C precedence (logs to `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log`).
+      - After the revert, capture new PyTorch traces (`reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/`) and update `phase_h5/parity_summary.md` with pix0/F_latt deltas (<5e-5‚ÄØm, <1e-3 relative error).
+      - Record the follow-up attempt in this entry and then resume Phase K normalization work once geometry parity is confirmed.
   * [2025-10-17] Attempt #25 (ralph) ‚Äî Result: success (Phase H4a-c complete). **Post-rotation beam-centre recomputation implemented and verified.**
     Metrics: pix0_vector parity achieved - C vs PyTorch deltas < 2e-8 m (well within 5e-5 m tolerance). Test suite: test_cli_flags.py 23/23 passed, test_detector_geometry.py 12/12 passed, test_crystal_geometry.py 19/19 passed (54 total).
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index b4edf07ccf3e33ad97e24a393c581ecc68dc1256..5c3e5b436b2e22134def6a137eddb13ef4089daa
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -5,7 +5,7 @@
 - Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
 - Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5√ó intensity scaling mismatch despite polarization fix; Phases J‚ÄìL track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
 - Gap snapshot refresh (2025-10-21): Phase H5b implementation reinstated the pix0 override for custom detector vectors (`reports/2025-10-cli-flags/phase_h5/parity_summary.md`); pending work is to refresh C precedence traces (H5a) and capture PyTorch parity logs (H5c) before resuming Phase K normalization tasks.
-- Gap correction (2025-10-22): Phase J traces still show PyTorch pix0 Y offset ~1.14 mm and `F_latt` ~7.69e1 vs C 3.56e4 because the 2025-10-06 precedence run captured stale geometry. H5a/H5c must refresh C/PyTorch traces to confirm override projection before entering Phase K.
+- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because H5b applied the override unconditionally, yielding a 1.14‚ÄØmm pix0 delta and the 3.6e-7 `F_latt` ratio. Revert the override in the custom-vector path and reconfirm parity before entering Phase K.
 - Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
 
 ### Phase A ‚Äî Requirements & Trace Alignment
@@ -110,17 +110,17 @@
 | H4b | Refresh traces and parity evidence | [D] | ‚úÖ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ‚â§1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ‚úÖ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
-### Phase H5 ‚Äî Custom Vector Pix0 Override Reinstatement
-Goal: Reconcile the newly observed 1.14‚ÄØmm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C‚Äôs override precedence.
-Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+### Phase H5 ‚Äî Custom Vector Pix0 Override Parity
+Goal: Bring PyTorch pix0 precedence back in line with C when custom detector vectors accompany `-pix0_vector_mm`, eliminating the 1.14‚ÄØmm delta driving the `F_latt` mismatch.
+Prereqs: Phase H4 artifacts available; C precedence proof in `reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`.
 Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5‚ÄØm, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
-| H5a | Verify C precedence with explicit derivation | [P] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing fresh C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-21/`. Update `phase_h5/c_precedence.md` to replace the 2025-10-06 conclusion (which stated the override was ignored) and document the dot-product derivation that now shows C recomputes `Fbeam/Sbeam` from the override with custom vectors. |
-| H5b | Restore pix0 override application in PyTorch custom-vector path | [D] | ‚úÖ 2025-10-21 Attempt #29 (ralph). `Detector._calculate_pix0_vector` applies the override before projecting onto detector axes regardless of custom vectors; see `reports/2025-10-cli-flags/phase_h5/parity_summary.md` and regression log `pytest_regression.log` (57 passed). |
-| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, derived `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components with the new override path. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and append deltas (C vs PyTorch) to `phase_h5/parity_summary.md`; explicitly confirm `F_latt` converges to the C value (~3.5636e4) and pix0 deltas fall <5e-5 m before unlocking Phase K. |
-| H5d | Update fix_plan Attempt log | [ ] | After H5a/H5c align within 5e-5‚ÄØm and 1e-3 relative error, record Attempt #29 closure in `docs/fix_plan.md` summarising restored override precedence and remaining Phase K normalization gaps. |
+| H5a | Verify C precedence with explicit derivation | [D] | ‚úÖ 2025-10-22 Attempt #30. C traces stored under `reports/2025-10-cli-flags/phase_h5/c_traces/2025-10-22/` prove geometry is identical with or without `-pix0_vector_mm` when custom vectors are present. `c_precedence_2025-10-22.md` carries the dot-product derivation. |
+| H5b | Revert PyTorch override when custom vectors supplied | [ ] | Undo the unconditional override path introduced in Attempt #29. In `Detector._calculate_pix0_vector`, gate the pix0_override projection so it runs only when **no** custom detector vectors are provided. Preserve device/dtype neutrality and keep regression coverage by updating `tests/test_cli_flags.py::TestCLIPix0Override` if expectations change. Capture targeted pytest output in `reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log` and summarise the implementation in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | After reverting, rerun the Phase H trace harness so `reports/2025-10-cli-flags/phase_h5/py_traces/2025-10-22/` contains TRACE_PY logs for pix0, F/S beams, h/k/l, and `F_latt`. Update `phase_h5/parity_summary.md` with C vs PyTorch deltas; require `|Œîpix0| < 5e-5 m` and `F_latt` ratio within 1e-3 before Phase K resumes. |
+| H5d | Update fix_plan Attempt log | [ ] | Log the revert and trace parity metrics in `docs/fix_plan.md` (new attempt), explicitly noting how the change restores `F_latt` agreement and unblocks Phase K normalization work. |
 
 ### Phase I ‚Äî Polarization Alignment (follow-up)
 Goal: Match C‚Äôs Kahn polarization factor once lattice geometry aligns.

Reading prompt from stdin...
Already up to date.
To github.com:hoidn/nanoBragg.git
   6687255..135c8cb  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=36...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=36
Updating 135c8cb..b2a520f
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   135c8cb..b2a520f  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=36
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating b2a520f..831b670
Fast-forward
 docs/fix_plan.md                                   |  18 +++
 .../phase_h5/implementation_notes.md               | 153 +++++++++++++--------
 .../phase_h5/pytest_h5b_revert.log                 |  13 ++
 src/nanobrag_torch/models/detector.py              |  27 ++--
 4 files changed, 141 insertions(+), 70 deletions(-)
 create mode 100644 reports/2025-10-cli-flags/phase_h5/pytest_h5b_revert.log
From github.com:hoidn/nanoBragg
   b2a520f..831b670  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating 831b670..8d2a47c
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   831b670..8d2a47c  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=37
Ralph completed iteration 36; proceeding to 37
