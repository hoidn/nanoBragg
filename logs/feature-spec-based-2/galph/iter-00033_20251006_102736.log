Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=33
To github.com:hoidn/nanoBragg.git
   eadee8c..e357e8f  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T10:27:41] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T10:27:41] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 


Debugging Items — Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‑line rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for this turn.
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
Header:
- Summary: <one‑sentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
  - Note: When the Phase is Evidence, you must not execute tests; any pytest command included here is provided for Ralph’s subsequent loop.
<Do Now guidelines>
Phase Gate (Evidence): If the active plan phase is Evidence, do not run pytest at all (including collection). Limit evidence gathering to non-test probes and command‑line tooling (e.g., scripts/validation/*, minimal parity CLIs). Do not include runnable tests in this loop.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T10:27:48] thinking

**Clarifying scope and initial setup**
[2025-10-06T10:27:48] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:27:50] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.25s:
Already up to date.
[2025-10-06T10:27:50] tokens used: 13,017

[2025-10-06T10:27:52] thinking

**Preparing to review galph_memory.md**
[2025-10-06T10:27:53] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:27:53] bash -lc 'cat galph_memory.md' succeeded in 717ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-06T10:27:53] tokens used: 13,185

[2025-10-06T10:27:58] thinking

**Planning to review key documentation files**
[2025-10-06T10:27:58] exec bash -lc "sed -n '1,160p' docs/index.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:27:59] bash -lc "sed -n '1,160p' docs/index.md" succeeded in 679ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T10:27:59] tokens used: 16,083

[2025-10-06T10:28:00] thinking

**Reviewing specification sections**
[2025-10-06T10:28:01] exec bash -lc "sed -n '1,160p' specs/spec-a.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:02] bash -lc "sed -n '1,160p' specs/spec-a.md" succeeded in 673ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T10:28:02] tokens used: 17,770

[2025-10-06T10:28:03] thinking

**Considering reading shards**
[2025-10-06T10:28:03] exec bash -lc "sed -n '1,160p' arch.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:04] bash -lc "sed -n '1,160p' arch.md" succeeded in 668ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T10:28:04] tokens used: 18,032

[2025-10-06T10:28:05] thinking

**Reading configuration mapping file**
[2025-10-06T10:28:06] exec bash -lc "sed -n '1,160p' docs/development/c_to_pytorch_config_map.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:06] bash -lc "sed -n '1,160p' docs/development/c_to_pytorch_config_map.md" succeeded in 692ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T10:28:06] tokens used: 20,815

[2025-10-06T10:28:09] thinking

**Checking for debugging documentation**
[2025-10-06T10:28:11] exec bash -lc "sed -n '1,160p' docs/debugging/debugging.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:11] bash -lc "sed -n '1,160p' docs/debugging/debugging.md" succeeded in 684ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T10:28:11] tokens used: 22,717

[2025-10-06T10:28:13] thinking

**Starting to review fix_plan.md**
[2025-10-06T10:28:14] exec bash -lc "sed -n '1,200p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:14] bash -lc "sed -n '1,200p' docs/fix_plan.md" succeeded in 682ms:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A–C) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2–B4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1–A3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ✅ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
| [CLI-DTYPE-002](#cli-dtype-002-cli-dtype-parity) | CLI dtype parity | High | in_progress |
[2025-10-06T10:28:14] tokens used: 24,703

[2025-10-06T10:28:16] thinking

**Prioritizing relevant sections and docs**
[2025-10-06T10:28:17] exec bash -lc "sed -n '1,160p' docs/development/testing_strategy.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:18] bash -lc "sed -n '1,160p' docs/development/testing_strategy.md" succeeded in 680ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T10:28:18] tokens used: 27,696

[2025-10-06T10:28:20] thinking

**Checking active plans directory**
[2025-10-06T10:28:21] exec bash -lc 'ls plans/active' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:22] bash -lc 'ls plans/active' succeeded in 700ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T10:28:22] tokens used: 30,280

[2025-10-06T10:28:25] thinking

**Reviewing CLI flags plan**
[2025-10-06T10:28:26] exec bash -lc "sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:27] bash -lc "sed -n '1,200p' plans/active/cli-noise-pix0/plan.md" succeeded in 698ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.

### Phase A — Requirements & Trace Alignment
Goal: Confirm the authoritative semantics for both flags and capture the C reference behavior (including unit expectations) before touching implementation.
Prereqs: Ability to run instrumented C binary via `NB_C_BIN` and collect traces.
Exit Criteria: Documented parity notes under `reports/2025-10-cli-flags/phase_a/` with explicit decisions on unit conversions and noise toggle ordering.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Extract C reference for `-nonoise` | [D] | ✅ 2025-10-05: Supervisor command captured with/without `-nonoise`; logs stored under `reports/2025-10-cli-flags/phase_a/`. |
| A2 | Capture pix0 vector ground truth | [D] | ✅ 2025-10-05: Instrumented C trace recorded pix0 vector values; confirms outputs remain in meters even for `_mm` flag. |
| A3 | Update findings memo | [D] | ✅ 2025-10-05: Phase A summary authored in `reports/2025-10-cli-flags/phase_a/README.md` documenting semantics and CUSTOM convention side effects. |

### Phase B — CLI & Config Wiring
[2025-10-06T10:28:27] tokens used: 30,538

[2025-10-06T10:28:28] thinking

**Preparing to review vectorization plan**
[2025-10-06T10:28:28] exec bash -lc "sed -n '1,200p' plans/active/vectorization.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:29] bash -lc "sed -n '1,200p' plans/active/vectorization.md" succeeded in 714ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B — Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T10:28:29] tokens used: 32,951

[2025-10-06T10:28:34] thinking

**Preparing for deep codebase analysis**
[2025-10-06T10:28:34] exec bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:35] bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' succeeded in 746ms:
21:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
448:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
507:    Next Actions: Execute Phase I3 final parity sweep by running the supervisor command end-to-end (PyTorch CLI + C reference), stash logs under `reports/2025-10-cli-flags/phase_i/supervisor_command/`, document polarization metrics in Attempt #27, then close CLI-FLAGS-003.
[2025-10-06T10:28:35] tokens used: 35,723

[2025-10-06T10:28:37] thinking

**Checking specific code section**
[2025-10-06T10:28:38] exec bash -lc "sed -n '448,620p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:39] bash -lc "sed -n '448,620p' docs/fix_plan.md" succeeded in 693ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A-H complete; polarization Phase I pending)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/summary.json` - Complete parity metrics (correlation, RMSE, sums, peak distances)
[2025-10-06T10:28:39] tokens used: 36,063

[2025-10-06T10:28:42] thinking

**Analyzing debugging and vectorization plans**
[2025-10-06T10:28:43] exec bash -lc 'rg "VECTOR-TRICUBIC-001" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:44] bash -lc 'rg "VECTOR-TRICUBIC-001" -n docs/fix_plan.md' succeeded in 680ms:
19:| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
1006:## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
[2025-10-06T10:28:44] tokens used: 39,217
[2025-10-06T10:28:46] exec bash -lc "sed -n '1006,1180p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:47] bash -lc "sed -n '1006,1180p' docs/fix_plan.md" succeeded in 668ms:
## [VECTOR-TRICUBIC-001] Vectorize tricubic interpolation and detector absorption
- Spec/AT: specs/spec-a-core.md §4 (structure factor sampling), specs/spec-a-parallel.md §2.3 (tricubic acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4 (vectorization strategy), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, nanoBragg.c lines 2604–3278 (polin3/polin2/polint) and 3375–3450 (detector absorption loop).
- Priority: High
- Status: in_planning (Phase A evidence outstanding)
- Owner/Date: galph/2025-10-17
- Plan Reference: `plans/active/vectorization.md`
- Reproduction (C & PyTorch):
  * PyTorch baseline tests: `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py tests/test_at_abs_001.py -v`
  * Optional microbenchmarks (to be created per plan Phase A): `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/sample_tricubic_baseline.py`
  * Shapes/ROI: 256² & 512² detectors for microbench; oversample 1; structure-factor grid enabling tricubic.
- First Divergence (if known): Current tricubic path drops to nearest-neighbour fallback for batched pixel grids, emitting warnings and forfeiting accuracy/performance; detector absorption still loops over `thicksteps`, preventing full vectorization and creating hotspots in profiler traces (see reports/benchmarks/20250930-165726-compile-cache/analysis.md).
- Next Actions:
  1. Execute plan Phase A tasks A1–A3: author the reusable `scripts/benchmarks/tricubic_baseline.py` and `absorption_baseline.py` harnesses, capture pytest + timing artifacts under `reports/2025-10-vectorization/phase_a/`, and record Attempt #1 in this entry.
  2. Complete Phase B design memo (tensor shapes, broadcasting, gradients) before editing code; update this item with design references (`phase_b/design_notes.md`).
  3. Prioritise Phase C/D implementation work on tricubic interpolation, followed by Phase E parity/perf validation. Detector absorption vectorization (Phase F) follows once tricubic work is stable.
- Attempts History:
  * (pending) — Capture Phase A baseline artifacts and update this log.
- Risks/Assumptions: Must maintain differentiability (no `.item()`, no `torch.linspace` with tensor bounds), preserve device/dtype neutrality (CPU/CUDA parity), and obey Protected Assets rule (all new scripts under `scripts/benchmarks/`). Large tensor indexing may increase memory pressure; ensure ROI caching still works.
- Exit Criteria (quote thresholds from spec):
  * specs/spec-a-parallel.md §2.3 tricubic acceptance tests run without warnings and match C parity within documented tolerances (corr≥0.9995, ≤1e-12 structural duality where applicable).
[2025-10-06T10:28:47] tokens used: 39,493

[2025-10-06T10:28:49] thinking

**Preparing to run coin toss script**
[2025-10-06T10:28:49] exec bash -lc "python - <<'PY'
import random
print('heads' if random.random() < 0.5 else 'tails')
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:50] bash -lc "python - <<'PY'
import random
print('heads' if random.random() < 0.5 else 'tails')
PY" succeeded in 718ms:
tails
[2025-10-06T10:28:50] tokens used: 41,239

[2025-10-06T10:28:57] thinking

**Evaluating need for plan update**
[2025-10-06T10:28:58] exec bash -lc 'git log --oneline -5' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:28:59] bash -lc 'git log --oneline -5' succeeded in 750ms:
e357e8f [SYNC i=33] actor=galph status=running
eadee8c [SYNC i=33] actor=ralph → next=galph status=ok ralph_commit=288a28b
288a28b [CLI-FLAGS-003] Phase J: Evidence - Identify first scaling divergence (I_before_scaling)
df979dc [SYNC i=32] actor=ralph status=running
a64029a [SYNC i=32] actor=galph → next=ralph status=ok galph_commit=6791be4
[2025-10-06T10:28:59] tokens used: 41,627

[2025-10-06T10:29:05] thinking

**Reviewing and evaluating vectorization plan**

I'm analyzing whether the existing vectorization plan in plans/active/vectorization.md is complete and up-to-date, especially since phase K tasks remain undone. I’m considering inspecting the code around F_latt, like in src/nanobrag_torch/utils/physics.py, to better understand its role in the intensity mismatch and decide if new tasks or plan updates are needed.
[2025-10-06T10:29:06] exec bash -lc "rg \"F_latt\" -n src -g'*.py'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:07] bash -lc "rg \"F_latt\" -n src -g'*.py'" succeeded in 721ms:
src/nanobrag_torch/config.py:148:    shape: CrystalShape = CrystalShape.SQUARE  # Crystal shape model for F_latt calculation
src/nanobrag_torch/simulator.py:219:        F_latt_a = sincg(torch.pi * (h - h0), Na)
src/nanobrag_torch/simulator.py:220:        F_latt_b = sincg(torch.pi * (k - k0), Nb)
src/nanobrag_torch/simulator.py:221:        F_latt_c = sincg(torch.pi * (l - l0), Nc)
src/nanobrag_torch/simulator.py:222:        F_latt = F_latt_a * F_latt_b * F_latt_c
src/nanobrag_torch/simulator.py:232:        F_latt = Na * Nb * Nc * 0.723601254558268 * sinc3(
src/nanobrag_torch/simulator.py:251:        F_latt = Na * Nb * Nc * torch.exp(-(rad_star_sqr / 0.63) * fudge)
src/nanobrag_torch/simulator.py:269:        F_latt = torch.where(inside_cutoff,
src/nanobrag_torch/simulator.py:276:    F_total = F_cell * F_latt
src/nanobrag_torch/simulator.py:694:                                    /* ... F_cell and F_latt calculation ... */
src/nanobrag_torch/simulator.py:697:                                    I += F_cell*F_cell*F_latt*F_latt;
src/nanobrag_torch/simulator.py:1258:                    # Calculate F_latt components (SQUARE shape assumed)
src/nanobrag_torch/simulator.py:1264:                    F_latt_a = sincg(torch.pi * torch.tensor(h - h0), Na).item()
src/nanobrag_torch/simulator.py:1265:                    F_latt_b = sincg(torch.pi * torch.tensor(k - k0), Nb).item()
src/nanobrag_torch/simulator.py:1266:                    F_latt_c = sincg(torch.pi * torch.tensor(l - l0), Nc).item()
src/nanobrag_torch/simulator.py:1267:                    F_latt = F_latt_a * F_latt_b * F_latt_c
src/nanobrag_torch/simulator.py:1269:                    print(f"TRACE_PY: F_latt_a {F_latt_a:.15g}")
src/nanobrag_torch/simulator.py:1270:                    print(f"TRACE_PY: F_latt_b {F_latt_b:.15g}")
src/nanobrag_torch/simulator.py:1271:                    print(f"TRACE_PY: F_latt_c {F_latt_c:.15g}")
src/nanobrag_torch/simulator.py:1272:                    print(f"TRACE_PY: F_latt {F_latt:.15g}")
[2025-10-06T10:29:07] tokens used: 42,239

[2025-10-06T10:29:14] thinking

**Assessing plan update necessity**
[2025-10-06T10:29:15] exec bash -lc 'git show 288a28b --stat' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:15] bash -lc 'git show 288a28b --stat' succeeded in 734ms:
commit 288a28b68d1225d396578cfdd0a263060090877b
Author: ollie <ohoidn>
Date:   Mon Oct 6 03:26:17 2025 -0700

    [CLI-FLAGS-003] Phase J: Evidence - Identify first scaling divergence (I_before_scaling)
    
    Phase J Tasks Complete:
    - J1: Captured C and PyTorch scaling traces for pixel (1039,685)
    - J2: Created analyze_scaling.py to compute factor-by-factor ratios
    - J3: Updated docs/fix_plan.md Attempt #28 with findings
    
    Key Findings (Attempt #28):
    - First divergence: I_before_scaling (C=1.48e15, PyTorch=5.34e8, ratio=3.6e-7)
    - Root cause: F_latt calculation error
      * C: F_latt_a=35.9, F_latt_b=38.6, F_latt_c=25.7 → F_latt=35636
      * PyTorch: F_latt_a=-2.4, F_latt_b=11.8, F_latt_c=-2.7 → F_latt=76.9
      * 463× F_latt error squares to ~2e5× intensity gap
    - Secondary issues: polarization (C=0.9126 vs Py=1.0), omega minor delta
    - Steps, r_e², fluence all match exactly (normalization infrastructure correct)
    
[2025-10-06T10:29:15] tokens used: 43,724

[2025-10-06T10:29:26] thinking

**Reviewing and updating fix_plan for Phase K**

I'm checking the current plan phase and realizing we're ready to move from Phase J to Phase K, which involves implementing the F_latt fix. I need to verify and likely update the docs/fix_plan to reflect this shift in next actions, ensuring the instructions align with the new implementation focus. To do that, I'm gathering more details on the relevant code and how the F_latt mismatch is tied to the `sincg` evaluation using `torch.tensor.item()`.
[2025-10-06T10:29:28] exec bash -lc "sed -n '200,340p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:29] bash -lc "sed -n '200,340p' src/nanobrag_torch/simulator.py" succeeded in 744ms:
    k0 = torch.round(k)
    l0 = torch.round(l)

    # Look up structure factors
    F_cell = crystal_get_structure_factor(h0, k0, l0)

    # Ensure F_cell is on the same device as h (device-neutral implementation per Core Rule #16)
    # The crystal.get_structure_factor may return CPU tensors even when h0/k0/l0 are on CUDA
    if F_cell.device != h.device:
        F_cell = F_cell.to(device=h.device)

    # Calculate lattice structure factor
    Na = N_cells_a
    Nb = N_cells_b
    Nc = N_cells_c
    shape = crystal_shape
    fudge = crystal_fudge

    if shape == CrystalShape.SQUARE:
        F_latt_a = sincg(torch.pi * (h - h0), Na)
[2025-10-06T10:29:29] tokens used: 45,041

[2025-10-06T10:29:32] thinking

**Investigating variable definitions and shape issues**
[2025-10-06T10:29:33] exec bash -lc "sed -n '120,220p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:34] bash -lc "sed -n '120,220p' src/nanobrag_torch/simulator.py" succeeded in 716ms:
    if is_multi_source:
        # Multi-source case: broadcast over sources
        # diffracted_beam_unit: (S, F, 3) or (batch, 3)
        # incident_beam_direction: (n_sources, 3)
        # Need to add source dimension to diffracted_beam_unit

        # Add source dimension: (S, F, 3) -> (1, S, F, 3) or (batch, 3) -> (1, batch, 3)
        diffracted_expanded = diffracted_beam_unit.unsqueeze(0)

        # Handle both 2D (batch, 3) and 3D (S, F, 3) cases for incident beam expansion
        if original_n_dims == 2:
            # (batch, 3) case: expand incident to (n_sources, 1, 3)
            incident_expanded = incident_beam_direction.view(n_sources, 1, 3)
        else:
            # (S, F, 3) case: expand incident to (n_sources, 1, 1, 3)
            incident_expanded = incident_beam_direction.view(n_sources, 1, 1, 3)

        # Expand to match diffracted shape
        incident_beam_unit = incident_expanded.expand(n_sources, *diffracted_beam_unit.shape)
        diffracted_beam_unit = diffracted_expanded.expand_as(incident_beam_unit)
[2025-10-06T10:29:34] tokens used: 47,338

[2025-10-06T10:29:35] thinking

**Investigating sincg function difference**
[2025-10-06T10:29:36] exec bash -lc "sed -n '1,200p' src/nanobrag_torch/utils/physics.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:37] bash -lc "sed -n '1,200p' src/nanobrag_torch/utils/physics.py" succeeded in 698ms:
"""
Vectorized physics utilities for nanoBragg PyTorch implementation.

This module contains PyTorch implementations of physical models and
calculations from the original C code.
"""

import torch


# Use different compile modes for CPU vs GPU to avoid CUDA graph issues
# On GPU, "max-autotune" avoids the nested compilation CUDA graph problem
# On CPU, "reduce-overhead" is faster
def _get_compile_decorator():
    """Get appropriate compile decorator based on available hardware."""
    import os
    disable_compile = os.environ.get("NANOBRAGG_DISABLE_COMPILE", "0") == "1"

    if disable_compile:
        # Return identity decorator when compilation is disabled (for gradient testing)
[2025-10-06T10:29:37] tokens used: 49,049

[2025-10-06T10:29:43] thinking

**Analyzing lattice factor discrepancy hypotheses**
[2025-10-06T10:29:44] exec bash -lc "sed -n '1,160p' reports/2025-10-cli-flags/phase_j/scaling_chain.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:45] bash -lc "sed -n '1,160p' reports/2025-10-cli-flags/phase_j/scaling_chain.md" succeeded in 711ms:
# Scaling Chain Analysis: C vs PyTorch

**Pixel:** (slow=1039, fast=685)

## Key Findings

**First Divergence:** `I_before_scaling`
- C value: 1.480792010454e+15
- PyTorch value: 5.344373483470e+08
- Ratio (Py/C): 3.609132e-07

**Final Intensity Ratio (Py/C):** 1.053e-05

## Full Factor Comparison

| Factor | C Value | PyTorch Value | Ratio (Py/C) | Match? |
|--------|---------|---------------|--------------|--------|
| I_before_scaling | 1.480792e+15 | 5.344373e+08 | 3.609132e-07 | ❌ |
| steps | 1.000000e+01 | 1.000000e+01 | 1.000000e+00 | ✅ |
| r_e_sqr | 7.940792e-30 | 7.940792e-30 | 1.000000e+00 | ✅ |
[2025-10-06T10:29:45] tokens used: 51,648

[2025-10-06T10:29:47] thinking

**Generating hypotheses based on divergence**
[2025-10-06T10:29:48] exec bash -lc 'rg "F_latt" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:49] bash -lc 'rg "F_latt" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' succeeded in 726ms:
TRACE_PY: F_latt_a -2.41393606891084
TRACE_PY: F_latt_b 11.7501279643604
TRACE_PY: F_latt_c -2.71156462742556
TRACE_PY: F_latt 76.9109755698808
[2025-10-06T10:29:49] tokens used: 52,331
[2025-10-06T10:29:51] exec bash -lc 'rg "F_latt" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:52] bash -lc 'rg "F_latt" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 669ms:
TRACE_C: F_latt_a 35.8890618450812
TRACE_C: F_latt_b 38.6324938361129
TRACE_C: F_latt_c 25.7024842831081
TRACE_C: F_latt 35636.0822038919
[2025-10-06T10:29:52] tokens used: 52,667

[2025-10-06T10:29:56] thinking

**Analyzing discrepancies in `sincg` arguments**
[2025-10-06T10:29:57] exec bash -lc 'rg "TRACE_PY: h " -n reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:29:57] bash -lc 'rg "TRACE_PY: h " -n reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' exited 1 in 684ms:

[2025-10-06T10:29:57] tokens used: 53,030

[2025-10-06T10:29:59] thinking

**Checking trace logs for variable 'h'**
[2025-10-06T10:29:59] exec bash -lc 'rg "TRACE_C: h" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:00] bash -lc 'rg "TRACE_C: h" -n reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 679ms:
183:TRACE_C: hkl_frac 2.00120331912649 1.99279793937568 -12.9907668789699
184:TRACE_C: hkl_rounded 2 2 -13
[2025-10-06T10:30:00] tokens used: 53,284

[2025-10-06T10:30:02] thinking

**Checking for 'hkl_' in pyro logs**
[2025-10-06T10:30:02] exec bash -lc 'rg "TRACE_PY: hkl" -n reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:03] bash -lc 'rg "TRACE_PY: hkl" -n reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' succeeded in 678ms:
22:TRACE_PY: hkl_frac 2.10334046814914 2.01676102209174 -12.8804406604205
23:TRACE_PY: hkl_rounded 2 2 -13
[2025-10-06T10:30:03] tokens used: 53,575

[2025-10-06T10:30:07] thinking

**Analyzing fractional h discrepancies**
[2025-10-06T10:30:08] exec bash -lc 'rg "rot_a_star" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:09] bash -lc 'rg "rot_a_star" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' succeeded in 680ms:
TRACE_PY: rot_a_star_A_inv -0.0290510954135954 -0.0293958845208845 0.0107498771498771
[2025-10-06T10:30:09] tokens used: 53,972

[2025-10-06T10:30:11] thinking

**Checking C trace**
[2025-10-06T10:30:12] exec bash -lc 'rg "rot_a_star" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:12] bash -lc 'rg "rot_a_star" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 700ms:
TRACE_C: rot_a_star_A_inv -0.0290510954135954 -0.0293958845208845 0.0107498771498771
[2025-10-06T10:30:12] tokens used: 54,253

[2025-10-06T10:30:15] thinking

**Checking scattering vector in logs**
[2025-10-06T10:30:16] exec bash -lc 'rg "scattering_vector" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:16] bash -lc 'rg "scattering_vector" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' exited 1 in 689ms:

[2025-10-06T10:30:16] tokens used: 54,542

[2025-10-06T10:30:19] thinking

**Checking for S_vec usage in logs**
[2025-10-06T10:30:19] exec bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_py_scaling.log" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:20] bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_py_scaling.log" succeeded in 824ms:
# Tracing pixel (slow=1039, fast=685)
# Trace complete
TRACE_PY: pix0_vector_meters -0.21645536097285 0.21520668107301 -0.23019804092515
TRACE_PY: fdet_vec 0.999982 -0.005998 -0.000118
TRACE_PY: sdet_vec -0.005998 -0.99997 -0.004913
TRACE_PY: pixel_pos_meters -0.09962388969285 0.03571084470501 -0.23109036875515
TRACE_PY: R_distance_meters 0.254171088754149
TRACE_PY: omega_pixel_sr 4.16678627260442e-07
TRACE_PY: close_distance_meters 0.231271852251217
TRACE_PY: obliquity_factor 0.909906210752861
TRACE_PY: diffracted_vec -0.391956025294492 0.140499239626549 -0.909192189748518
TRACE_PY: incident_vec 0.00051387949 0 -0.99999986
TRACE_PY: lambda_meters 9.768e-11
TRACE_PY: lambda_angstroms 0.9768
TRACE_PY: scattering_vec_A_inv -4017914668.14591 1438362404.03919 929644453.844001
TRACE_PY: rot_a_angstroms -14.3562690335399 -21.8717928453817 -5.58202083498661
TRACE_PY: rot_b_angstroms -11.4986968432508 0.717320030990266 -29.1132147806318
TRACE_PY: rot_c_angstroms 21.0699500320179 -24.3892962470766 -9.75265166505327
TRACE_PY: rot_a_star_A_inv -0.0290510954135954 -0.0293958845208845 0.0107498771498771
TRACE_PY: rot_b_star_A_inv -0.0031263923013923 0.0104376433251433 -0.0328566748566749
[2025-10-06T10:30:20] tokens used: 54,701

[2025-10-06T10:30:22] thinking

**Comparing log for variable h**
[2025-10-06T10:30:22] exec bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_c_scaling.log" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:23] bash -lc "sed -n '1,120p' reports/2025-10-cli-flags/phase_j/trace_c_scaling.log" succeeded in 718ms:
WARNING: auto-generating odet_vector
nanoBragg nanocrystal diffraction simulator - James Holton and Ken Frankel 5-17-17
custom convention selected.
pivoting detector around sample
DETECTOR_FAST_AXIS 0.999982004873912 -0.00599800002923425 -0.000118000000575132
DETECTOR_SLOW_AXIS -0.0059979996566955 -0.999969942765222 -0.0049129997187971
DETECTOR_NORMAL_AXIS -8.85282813644494e-05 0.00491361907271126 -0.999987924182263
DETECTOR_PIX0_VECTOR -0.216475836204836 0.216343050492215 -0.230192414300537
XDS incident beam: 0.00063187 0.00490992 0.999988
reading A.mat
TRACE: Raw matrix values from file:
TRACE:   a_star (raw) = [-0.0283771, -0.0287139, 0.0105005]
TRACE:   b_star (raw) = [-0.00305386, 0.0101955, -0.0320944]
TRACE:   c_star (raw) = [0.0253582, -0.0140005, -0.0103605]
TRACE:   lambda0 = 0.9768 Angstroms
TRACE:   scaling factor = 1e-10/lambda0 = 1.02375
TRACE: After wavelength correction:
TRACE:   a_star = [-0.0290511, -0.0293959, 0.0107499] |a_star| = 0.0427041
TRACE:   b_star = [-0.00312639, 0.0104376, -0.0328567] |b_star| = 0.0346162
TRACE:   c_star = [0.0259604, -0.014333, -0.0106066] |c_star| = 0.0314941
[2025-10-06T10:30:23] tokens used: 55,959

[2025-10-06T10:30:29] thinking

**Examining differences in scattering vectors**
[2025-10-06T10:30:30] exec bash -lc 'rg "diffracted" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:31] bash -lc 'rg "diffracted" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 703ms:
TRACE_C: diffracted_vec -0.391782158179886 0.14487608188769 -0.908580024779756
[2025-10-06T10:30:31] tokens used: 59,078

[2025-10-06T10:30:33] thinking

**Comparing scattering vectors**
[2025-10-06T10:30:34] exec bash -lc 'rg "scattering" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:35] bash -lc 'rg "scattering" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 712ms:
TRACE_C: scattering_vec_A_inv -4016134701.82206 1483170371.49559 935911580.509501
[2025-10-06T10:30:35] tokens used: 59,335

[2025-10-06T10:30:40] thinking

**Investigating scattering vector discrepancies**
[2025-10-06T10:30:41] exec bash -lc 'rg "pixel_pos_meters" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:30:42] bash -lc 'rg "pixel_pos_meters" reports/2025-10-cli-flags/phase_j/trace_c_scaling.log' succeeded in 687ms:
TRACE_C: pixel_pos_meters -0.0996443642887915 0.0368472243540029 -0.231084742080328
[2025-10-06T10:30:42] tokens used: 59,843

[2025-10-06T10:30:58] thinking

**Analyzing pixel position discrepancies**

I'm comparing pixel position vectors between PyTorch and C implementations and noticing a significant 1.1 mm difference in the Y component, which is much larger than expected from the pix0 vector differences alone. This suggests additional factors like pixel indexing conventions or missing 0.5 offsets might contribute, despite previous plans indicating parity within nanometers. I want to verify Pyro logs for beam parameters to understand what's causing these residual discrepancies.
[2025-10-06T10:31:00] exec bash -lc 'rg "Fbeam" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:31:01] bash -lc 'rg "Fbeam" reports/2025-10-cli-flags/phase_j/trace_py_scaling.log' exited 1 in 957ms:

[2025-10-06T10:31:01] tokens used: 61,188

[2025-10-06T10:31:07] thinking

**Investigating pyro pixel vector calculation**
[2025-10-06T10:31:08] exec bash -lc 'rg "pix0_vector" -n src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:31:08] bash -lc 'rg "pix0_vector" -n src/nanobrag_torch/models/detector.py' succeeded in 781ms:
134:        # Calculate and cache pix0_vector (position of first pixel)
135:        self._calculate_pix0_vector()
144:        self._cached_pix0_vector = self.pix0_vector.clone()
147:        # These will be set properly in _calculate_pix0_vector
152:        if not hasattr(self, 'pix0_vector'):
153:            self.pix0_vector: Optional[torch.Tensor] = None
237:        # Recalculate pix0_vector when geometry changes
238:        self._calculate_pix0_vector()
250:            tuple: (beam_f_m, beam_s_m) in meters for use in pix0_vector calculation
326:    def _calculate_pix0_vector(self):
330:        This follows the C-code convention where pix0_vector represents the
343:        - BEAM pivot: pix0_vector = -Fbeam*fdet_vec - Sbeam*sdet_vec + distance*beam_vec
344:        - SAMPLE pivot: Calculate pix0_vector BEFORE rotations, then rotate it
362:            pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
363:            pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
364:            pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
367:            rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
368:            rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
375:            pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
376:            pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
[2025-10-06T10:31:08] tokens used: 61,503

[2025-10-06T10:31:10] thinking

**Reviewing vector branch code near line 520**
[2025-10-06T10:31:11] exec bash -lc "sed -n '520,640p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:31:12] bash -lc "sed -n '520,640p' src/nanobrag_torch/models/detector.py" succeeded in 676ms:
            # When custom detector vectors are present, C code IGNORES -pix0_vector_mm entirely.
            # The custom vectors already define the detector geometry completely.
            # Only apply pix0_override when NO custom vectors are provided.
            #
            # When pix0_override IS applied (no custom vectors case), derive Fbeam/Sbeam from it by:
            # 1. Subtract beam term to get detector offset
            # 2. Project onto detector axes to get Fbeam_override, Sbeam_override
            # 3. Update beam_center_f/s tensors for header consistency
            # 4. Apply standard BEAM formula
            #
            # C-code pattern (inferred from trace evidence):
            # pix0_delta = pix0_override - distance*beam
            # Fbeam_override = -dot(pix0_delta, fdet)
            # Sbeam_override = -dot(pix0_delta, sdet)

            # Check if custom detector vectors are present - if so, ignore pix0_override
            has_custom_vectors = (
                self.config.custom_fdet_vector is not None or
                self.config.custom_sdet_vector is not None or
                self.config.custom_odet_vector is not None
[2025-10-06T10:31:12] tokens used: 63,216

[2025-10-06T10:31:19] thinking

**Verifying pix0 vector handling differences**
[2025-10-06T10:31:20] exec bash -lc "python - <<'PY'
import numpy as np
Fbeam = 0.217889
Sbeam = 0.215043
fdet = np.array([0.999982, -0.005998, -0.000118])
sdet = np.array([-0.005998, -0.99997, -0.004913])
beam = np.array([0.00051387949, 0.0, -0.99999986])
distance = 0.231274660
pix0 = -Fbeam*fdet - Sbeam*sdet + distance*beam
print(pix0)
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:31:21] bash -lc "python - <<'PY'
import numpy as np
Fbeam = 0.217889
Sbeam = 0.215043
fdet = np.array([0.999982, -0.005998, -0.000118])
sdet = np.array([-0.005998, -0.99997, -0.004913])
beam = np.array([0.00051387949, 0.0, -0.99999986])
distance = 0.231274660
pix0 = -Fbeam*fdet - Sbeam*sdet + distance*beam
print(pix0)
PY" succeeded in 788ms:
[-0.2164764   0.21634345 -0.23019241]
[2025-10-06T10:31:21] tokens used: 65,770

[2025-10-06T10:31:27] thinking

**Analyzing beam center calculation details**
[2025-10-06T10:31:28] exec bash -lc "python - <<'PY'
Ybeam = 213.907080
Xbeam = 217.742295
pixel = 0.000172
Fbeam = (Ybeam + 0.5) * pixel
Sbeam = (Xbeam + 0.5) * pixel
print(Fbeam, Sbeam)
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:31:29] bash -lc "python - <<'PY'
Ybeam = 213.907080
Xbeam = 217.742295
pixel = 0.000172
Fbeam = (Ybeam + 0.5) * pixel
Sbeam = (Xbeam + 0.5) * pixel
print(Fbeam, Sbeam)
PY" succeeded in 696ms:
0.03687801776 0.037537674740000006
[2025-10-06T10:31:29] tokens used: 66,618

[2025-10-06T10:31:38] thinking

**Analyzing pix0 override impact on Fbeam and plan adjustments**

I'm seeing that the code labeled C uses the pix0 override for Fbeam calculation even when custom vectors are present, contrary to pyro's assumption. This causes a major difference in Fbeam values and explains pixel position discrepancies. The root cause appears to be incorrect precedence of the `-pix0_vector_mm` override in pyro when custom vectors exist. I'll need to revisit the existing plan, possibly reopening or extending Phase H, to address this overlooked scenario so our fixes fully align with C's behavior. Let's dig into the plan details to confirm if tasks for customizing with pix0 were comprehensive or need enhancement.
[2025-10-06T10:31:42] exec bash -lc 'rg "Phase H" -n plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:31:43] bash -lc 'rg "Phase H" -n plans/active/cli-noise-pix0/plan.md' succeeded in 929ms:
5:- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
7:- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
90:| G3 | Trace verification + parity rerun | [D] | ✅ 2025-10-06 Attempt #18 (ralph). Fixed MOSFLM matrix transpose bug (`src/nanobrag_torch/io/mosflm.py:88`). Reciprocal vectors now match C exactly (9/9 components to 16 decimals). Miller indices match: (2,2,-13). F_cell perfect match: 300.58. Real vectors within 0.05Å (<0.2% error). Artifacts: `reports/2025-10-cli-flags/phase_g/trace_summary_orientation_fixed.md`, `traces/trace_c.log`, `traces/trace_py_fixed.log`. Intensity parity still divergent (deferred to Phase H polarization). |
92:### Phase H — Lattice Structure Factor Alignment
97:Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
102:| H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
[2025-10-06T10:31:43] tokens used: 67,423

[2025-10-06T10:31:48] thinking

**Analyzing C code's handling of pix0 override and custom vectors**
[2025-10-06T10:31:53] exec bash -lc "python - <<'PY'
import numpy as np
pix0_override_mm = np.array([-216.336293, 215.205512, -230.200866])
pix0_override = pix0_override_mm * 1e-3
fdet = np.array([0.999982, -0.005998, -0.000118])
sdet = np.array([-0.005998, -0.99997, -0.004913])
beam = np.array([0.00051387949, 0.0, -0.99999986])
distance = 0.231274660
# Derive Fbeam and Sbeam from override per logic in code
beam_term = distance * beam
pix0_delta = pix0_override - beam_term
Fbeam = -np.dot(pix0_delta, fdet)
Sbeam = -np.dot(pix0_delta, sdet)
print('Fbeam', Fbeam, 'Sbeam', Sbeam)
print('pix0 derived', -Fbeam*fdet - Sbeam*sdet + distance*beam)
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:31:54] bash -lc "python - <<'PY'
import numpy as np
pix0_override_mm = np.array([-216.336293, 215.205512, -230.200866])
pix0_override = pix0_override_mm * 1e-3
fdet = np.array([0.999982, -0.005998, -0.000118])
sdet = np.array([-0.005998, -0.99997, -0.004913])
beam = np.array([0.00051387949, 0.0, -0.99999986])
distance = 0.231274660
# Derive Fbeam and Sbeam from override per logic in code
beam_term = distance * beam
pix0_delta = pix0_override - beam_term
Fbeam = -np.dot(pix0_delta, fdet)
Sbeam = -np.dot(pix0_delta, sdet)
print('Fbeam', Fbeam, 'Sbeam', Sbeam)
print('pix0 derived', -Fbeam*fdet - Sbeam*sdet + distance*beam)
PY" succeeded in 827ms:
Fbeam 0.21774217347665262 Sbeam 0.2139060332939413
pix0 derived [-0.2163364   0.21520563 -0.23019801]
[2025-10-06T10:31:54] tokens used: 68,707

[2025-10-06T10:32:30] thinking

**Updating plan for pix0 override precedence**
[2025-10-06T10:32:32] exec bash -lc "sed -n '120,240p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:32:33] bash -lc "sed -n '120,240p' plans/active/cli-noise-pix0/plan.md" succeeded in 941ms:
| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |

### Phase J — Intensity Scaling Evidence
Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
Prereqs: Phase I2 complete; beam/pix0/orientation traces from Phases F–H archived.
Exit Criteria: Report under `reports/2025-10-cli-flags/phase_j/scaling_chain.md` documenting C vs PyTorch values for `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, `fluence`, and the resulting per-pixel intensities, with the first mismatched quantity identified and logged in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| J1 | Capture single-pixel scaling traces | [D] | ✅ 2025-10-19: C trace (`trace_c_scaling.log`) and PyTorch trace (`trace_py_scaling.log`) captured for pixel (1039,685) with full scaling chain (`steps`, `I_before_scaling`, `r_e²`, `fluence`, `polar`, `omega`). |
| J2 | Compute factor-by-factor ratios | [D] | ✅ 2025-10-19: `analyze_scaling.py` created and executed; identifies first divergence as `I_before_scaling` with Py/C ratio=3.6e-7. Root cause: F_latt components differ by ~463× (C: 35636 vs PyTorch: 76.9). Markdown report at `scaling_chain.md`. |
| J3 | Update fix_plan Attempt log | [D] | ✅ 2025-10-19: Attempt #28 logged in `docs/fix_plan.md` with complete metrics, artifacts, and hypothesis (F_latt calculation error in sincg lattice shape factor). Phase I3 remains blocked pending Phase K F_latt fix. |

### Phase K — Normalization Implementation
Goal: Align PyTorch normalization logic with C based on Phase J evidence (steps division, fluence, r_e², omega/polarization application order).
Prereqs: Phase J report pinpoints the mismatched factor; existing regression suite green.
Exit Criteria: Code changes merged with targeted tests covering the corrected scaling, and docs/fix_plan.md records Attempt #29 metrics before moving to Phase L.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
[2025-10-06T10:32:33] tokens used: 71,095

[2025-10-06T10:32:36] thinking

**Identifying insertion point for new phase**
[2025-10-06T10:32:38] exec bash -lc "sed -n '80,160p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:32:38] bash -lc "sed -n '80,160p' plans/active/cli-noise-pix0/plan.md" succeeded in 691ms:

### Phase G — MOSFLM Matrix Orientation Support
Goal: Preserve full crystal orientation from `-mat` files so PyTorch matches C lattice vectors and downstream physics.
Prereqs: Detector parity (Phase F) achieved or at least traced; clarity on orientation data flow.
Exit Criteria: Crystal trace (rotated a/b/c vectors) aligns with C for the supervisor command; CLI accepts orientation without manual overrides.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| G1 | Extend CLI config to retain A* vectors | [D] | ✅ Commit 28fc584 stores MOSFLM reciprocal vectors from `-mat` in `parse_and_validate_args` and threads them into `CrystalConfig`; 26-case CLI regression sweep captured in Attempt #15 notes. |
| G2 | Teach `Crystal` to ingest orientation | [D] | ✅ 2025-10-17 Attempt #17 (ralph). Modified `Crystal.compute_cell_tensors()` (lines 545-603) to detect MOSFLM orientation in config, convert to tensors with proper device/dtype, and integrate with Core Rules 12-13 pipeline. Tests: 26/26 passed (CLI), 35/35 passed (crystal). Metric duality perfect. Artifacts: `reports/2025-10-cli-flags/phase_g/README.md`. |
| G3 | Trace verification + parity rerun | [D] | ✅ 2025-10-06 Attempt #18 (ralph). Fixed MOSFLM matrix transpose bug (`src/nanobrag_torch/io/mosflm.py:88`). Reciprocal vectors now match C exactly (9/9 components to 16 decimals). Miller indices match: (2,2,-13). F_cell perfect match: 300.58. Real vectors within 0.05Å (<0.2% error). Artifacts: `reports/2025-10-cli-flags/phase_g/trace_summary_orientation_fixed.md`, `traces/trace_c.log`, `traces/trace_py_fixed.log`. Intensity parity still divergent (deferred to Phase H polarization). |

### Phase H — Lattice Structure Factor Alignment
Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulator and bring scattering/lattice parity back in line before polarization work.
Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).

Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).

| ID | Task Description | State | How/Why & Guidance |
[2025-10-06T10:32:38] tokens used: 72,405

[2025-10-06T10:32:46] thinking

**Revising update notes and plan phases**
[2025-10-06T10:32:56] tokens used: 75,279

[2025-10-06T10:32:58] thinking

**Diagnosing patch failure**
[2025-10-06T10:32:59] exec bash -lc "sed -n '112,190p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:32:59] bash -lc "sed -n '112,190p' plans/active/cli-noise-pix0/plan.md" succeeded in 861ms:
Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
Prereqs: Phases F–H complete; traces show `F_latt` parity.
Exit Criteria: Polarization entries in C/PyTorch traces agree (≈0.9126 for supervisor command) and parity smoke stays green.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| I1 | Audit polarization inputs | [D] | ✅ Completed 2025-10-17. C defaults polar=1.0/polarization=0.0/nopolar=0 verified at nanoBragg.c:308-309. PyTorch BeamConfig.polarization_factor was defaulting to 0.0 instead of 1.0. |
| I2 | Implement polarization parity | [D] | ✅ Completed 2025-10-17. Updated BeamConfig.polarization_factor default to 1.0 (config.py:483-487). Added TestCLIPolarization with 3 tests (test_cli_flags.py:591-675). Tests verify default=1.0, -nopolar flag, and -polar override. |
| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; blocked until Phase J evidence resolves normalization divergence. |

### Phase J — Intensity Scaling Evidence
Goal: Isolate the first divergence in the normalization chain (steps, ω, r_e², fluence) responsible for the 1.2×10⁵ intensity mismatch.
Prereqs: Phase I2 complete; beam/pix0/orientation traces from Phases F–H archived.
Exit Criteria: Report under `reports/2025-10-cli-flags/phase_j/scaling_chain.md` documenting C vs PyTorch values for `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, `fluence`, and the resulting per-pixel intensities, with the first mismatched quantity identified and logged in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| J1 | Capture single-pixel scaling traces | [D] | ✅ 2025-10-19: C trace (`trace_c_scaling.log`) and PyTorch trace (`trace_py_scaling.log`) captured for pixel (1039,685) with full scaling chain (`steps`, `I_before_scaling`, `r_e²`, `fluence`, `polar`, `omega`). |
| J2 | Compute factor-by-factor ratios | [D] | ✅ 2025-10-19: `analyze_scaling.py` created and executed; identifies first divergence as `I_before_scaling` with Py/C ratio=3.6e-7. Root cause: F_latt components differ by ~463× (C: 35636 vs PyTorch: 76.9). Markdown report at `scaling_chain.md`. |
| J3 | Update fix_plan Attempt log | [D] | ✅ 2025-10-19: Attempt #28 logged in `docs/fix_plan.md` with complete metrics, artifacts, and hypothesis (F_latt calculation error in sincg lattice shape factor). Phase I3 remains blocked pending Phase K F_latt fix. |
[2025-10-06T10:32:59] tokens used: 76,588

[2025-10-06T10:33:02] thinking

**Verifying Phase H code segment**
[2025-10-06T10:33:02] exec bash -lc "sed -n '96,148p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:33:03] bash -lc "sed -n '96,148p' plans/active/cli-noise-pix0/plan.md" succeeded in 677ms:

Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| H1 | Refresh trace evidence post-orientation | [D] | ✅ 2025-10-17: `reports/2025-10-cli-flags/phase_h/trace_harness.py` + `trace_comparison.md` captured the no-override trace and logged Attempt #19 (beam vector divergence documented). |
| H2 | Fix incident beam propagation from CLI | [D] | ✅ 2025-10-17 Attempt #20 (ralph). Simulator now clones `detector.beam_vector` (commit 8c1583d); regression covered by `tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates`. Pending: rerun `phase_h/trace_harness.py` to confirm `incident_vec` parity before Phase H3. |
| H3a | Diagnose residual lattice mismatch | [D] | ✅ 2025-10-17 Attempt #21 (ralph). `trace_py_after_H3_refresh.log`, `pix0_reproduction.md`, and `implementation_notes.md` quantify the ~1.14 mm pix0 delta and show the cascade into scattering vector and `F_latt` disparities; `attempt_log.txt` restored with evidence summary. |
| H3b1 | Capture C vs PyTorch pix0/F/S references (override on/off) | [D] | ✅ 2025-10-17 Attempt #23: Stored paired C traces (`reports/2025-10-cli-flags/phase_h/implementation/c_trace_with_override.log` / `_without_override.log`), PyTorch traces, and `pix0_mapping_analysis.md`; evidence proves C geometry is identical with or without `-pix0_vector_mm` when custom vectors are supplied. |
| H3b2 | Implement pix0 precedence (custom vectors > override) | [D] | ✅ 2025-10-06 Attempt #24 (commit d6f158c). `Detector._calculate_pix0_vector` now skips overrides when any custom detector vector is supplied; override logic only executes in the no-custom-vectors path. Validation: `tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot` (CPU) and evidence log `reports/2025-10-cli-flags/phase_h/implementation/pix0_override_validation.md`. Residual pix0 Y-delta (≈3.9 mm) traced to missing post-rotation `Fbeam/Sbeam` recomputation and deferred to H4. |
| H3b3 | Repair CLI regression + artifacts for precedence | [D] | ✅ 2025-10-06 Attempt #24. Regression test now covers BOTH precedence cases (custom vectors ignored, standard path applies override) and records expected C pix0 vector in `pix0_expected.json`. CUDA parametrisation remains skipped until parity fix lands; tolerance temporarily relaxed to 5 mm pending H4 geometry alignment. |
| H4a | Port post-rotation beam-centre recomputation | [D] | ✅ 2025-10-17 Attempt #25: Ported nanoBragg.c lines 1846-1860 into `Detector._calculate_pix0_vector`; see `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/implementation.md`. |
| H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
| H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |

### Phase I — Polarization Alignment (follow-up)
Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
Prereqs: Phases F–H complete; traces show `F_latt` parity.
Exit Criteria: Polarization entries in C/PyTorch traces agree (≈0.9126 for supervisor command) and parity smoke stays green.

[2025-10-06T10:33:03] tokens used: 78,158

[2025-10-06T10:33:09] thinking

**Preparing patch updates**
[2025-10-06T10:33:12] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -96,3 +96,3 @@
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
[2025-10-06T10:33:12] apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T10:33:12] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..7555f73d024b5129879ff0dbe7d3b1cd9a342c4a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |

[2025-10-06T10:33:12] tokens used: 80,802
[2025-10-06T10:33:12] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..7555f73d024b5129879ff0dbe7d3b1cd9a342c4a
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |


[2025-10-06T10:33:14] thinking

**Inserting new Phase H5 block**
[2025-10-06T10:33:19] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -110,2 +110,14 @@
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
[2025-10-06T10:33:19] apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T10:33:19] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.

[2025-10-06T10:33:19] tokens used: 81,967
[2025-10-06T10:33:19] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:33:26] thinking

**Updating docs/fix_plan.md sections**
[2025-10-06T10:33:29] exec bash -lc "sed -n '448,520p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:33:30] bash -lc "sed -n '448,520p' docs/fix_plan.md" succeeded in 932ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A-H complete; polarization Phase I pending)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/summary.json` - Complete parity metrics (correlation, RMSE, sums, peak distances)
[2025-10-06T10:33:30] tokens used: 82,964
[2025-10-06T10:33:30] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:33:36] thinking

**Updating Next Actions and Observations**

I'm updating the Next Actions list to reflect today's date and new priorities, focusing on Phase H5 tasks before Phase K. I also plan to revise Observations for Attempt #28 to note the new evidence about the pix0 override being skipped, making the record clearer and more accurate. I'll locate and replace the existing Next Actions bullet block accordingly.
[2025-10-06T10:33:42] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -457,6 +457,6 @@
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
[2025-10-06T10:33:42] apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T10:33:42] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..a1744f6c8c55c4081201be375fd098086dad1f24
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.

[2025-10-06T10:33:42] tokens used: 86,603
[2025-10-06T10:33:42] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..a1744f6c8c55c4081201be375fd098086dad1f24
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:33:46] thinking

**Adding new observation detail**
[2025-10-06T10:34:00] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -494,4 +494,4 @@
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
[2025-10-06T10:34:00] apply_patch(auto_approved=true) exited 0 in 27ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T10:34:00] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.

[2025-10-06T10:34:00] tokens used: 87,594
[2025-10-06T10:34:00] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:34:06] thinking

**Preparing input.md for next steps**
[2025-10-06T10:34:07] exec bash -lc 'git branch --show-current' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:34:08] bash -lc 'git branch --show-current' succeeded in 890ms:
feature/spec-based-2
[2025-10-06T10:34:08] tokens used: 88,498
[2025-10-06T10:34:08] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:34:42] thinking

**Outlining detailed input.md structure**
[2025-10-06T10:35:05] exec bash -lc "cat <<'EOF' > input.md
Summary: Restore pix0 override precedence with custom detector vectors so F_latt parity recovers before normalization fixes.
Phase: Implementation
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot -q
Artifacts: reports/2025-10-cli-flags/phase_h5/
Do Now: CLI-FLAGS-003 H5b — Restore pix0 override in custom-vector path; env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot -q
If Blocked: If override logic still fails parity, capture fresh C/PyTorch traces into reports/2025-10-cli-flags/phase_h5/debug_attempt/ and log the issue in docs/fix_plan.md Attempts History before pausing.
Priorities & Rationale:
- reports/2025-10-cli-flags/phase_j/scaling_chain.md shows pix0-driven F_latt mismatch causing the 3.6e-7 intensity ratio; resolving override precedence is prerequisite to Phase K.
- plans/active/cli-noise-pix0/plan.md Phase H5 lays out the required evidence, implementation, and documentation steps; stay inside that checklist this loop.
- docs/architecture/detector.md §5 documents the BEAM pivot formula "'`pix0 = -Fbeam*fdet - Sbeam*sdet + distance*beam_vector`; restored override must follow it exactly.
- specs/spec-a-cli.md mandates CLI parity for `-pix0_vector_mm` even with custom detector vectors; no shortcuts allowed.
- docs/development/c_to_pytorch_config_map.md clarifies MOSFLM beam-center mappings used to derive Fbeam/Sbeam from overrides; double-check before adjusting tests.
How-To Map:
- Reproduce C behavior: `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 120 $NB_C_BIN -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0` (store stdout under `reports/2025-10-cli-flags/phase_h5/c_traces/with_override.log`). Repeat without `-pix0_vector_mm` for comparison.
- After patching Detector, rerun the PyTorch CLI: `KMP_DUPLICATE_LIB_OK=TRUE python -m nanobrag_torch -mat A.mat -floatfile torch_img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0` and pipe trace output to `reports/2025-10-cli-flags/phase_h5/py_traces/with_override.log` via the existing trace harness.
- Use the harness at `reports/2025-10-cli-flags/phase_h/trace_harness.py` (extend if needed) to extract `pix0_vector`, `Fbeam`, `Sbeam`, fractional h/k/l, and `F_latt` components into `phase_h5/parity_summary.md`.
- Run `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot -q` to confirm regression coverage, then update docs/fix_plan.md with Attempt #29 summary.
Pitfalls To Avoid:
- Do not drop `KMP_DUPLICATE_LIB_OK=TRUE`; every PyTorch CLI/test run must set it.
- Keep Detector changes vectorized and device/dtype neutral—no `.cpu()` casts or tensor detaches.
- Preserve Protected Assets (`loop.sh`, `input.md`, entries listed in docs/index.md); never rename or delete them.
- Avoid editing plan status markers unless evidence is captured and cross-referenced in reports/.
- Ensure trace logs differentiate "with" vs "without" override; ambiguous filenames slow parity review.
- Do not rerun full pytest; stick to targeted nodes unless you finish implementation changes.
- Retain existing pix0 tests; update tolerances only if parity artifacts justify the change.
- No ad-hoc scripts outside `scripts/`—extend existing harnesses instead.
- Keep commits clean; include rationale and tests in message per supervisor SOP.
Pointers:
- plans/active/cli-noise-pix0/plan.md
- docs/fix_plan.md#cli-flags-003-handle-nonoise-and-pix0_vector_mm
- docs/architecture/detector.md
- specs/spec-a-cli.md
- reports/2025-10-cli-flags/phase_j/scaling_chain.md
Next Up: Phase H5c trace comparison & Attempt #29 logging (if code lands cleanly).
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:06] bash -lc "cat <<'EOF' > input.md
Summary: Restore pix0 override precedence with custom detector vectors so F_latt parity recovers before normalization fixes.
Phase: Implementation
Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
Branch: feature/spec-based-2
Mapped tests: env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot -q
Artifacts: reports/2025-10-cli-flags/phase_h5/
Do Now: CLI-FLAGS-003 H5b — Restore pix0 override in custom-vector path; env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot -q
If Blocked: If override logic still fails parity, capture fresh C/PyTorch traces into reports/2025-10-cli-flags/phase_h5/debug_attempt/ and log the issue in docs/fix_plan.md Attempts History before pausing.
Priorities & Rationale:
- reports/2025-10-cli-flags/phase_j/scaling_chain.md shows pix0-driven F_latt mismatch causing the 3.6e-7 intensity ratio; resolving override precedence is prerequisite to Phase K.
- plans/active/cli-noise-pix0/plan.md Phase H5 lays out the required evidence, implementation, and documentation steps; stay inside that checklist this loop.
- docs/architecture/detector.md §5 documents the BEAM pivot formula "'`pix0 = -Fbeam*fdet - Sbeam*sdet + distance*beam_vector`; restored override must follow it exactly.
- specs/spec-a-cli.md mandates CLI parity for `-pix0_vector_mm` even with custom detector vectors; no shortcuts allowed.
- docs/development/c_to_pytorch_config_map.md clarifies MOSFLM beam-center mappings used to derive Fbeam/Sbeam from overrides; double-check before adjusting tests.
How-To Map:
- Reproduce C behavior: `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 120 $NB_C_BIN -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0` (store stdout under `reports/2025-10-cli-flags/phase_h5/c_traces/with_override.log`). Repeat without `-pix0_vector_mm` for comparison.
- After patching Detector, rerun the PyTorch CLI: `KMP_DUPLICATE_LIB_OK=TRUE python -m nanobrag_torch -mat A.mat -floatfile torch_img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0` and pipe trace output to `reports/2025-10-cli-flags/phase_h5/py_traces/with_override.log` via the existing trace harness.
- Use the harness at `reports/2025-10-cli-flags/phase_h/trace_harness.py` (extend if needed) to extract `pix0_vector`, `Fbeam`, `Sbeam`, fractional h/k/l, and `F_latt` components into `phase_h5/parity_summary.md`.
- Run `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot -q` to confirm regression coverage, then update docs/fix_plan.md with Attempt #29 summary.
Pitfalls To Avoid:
- Do not drop `KMP_DUPLICATE_LIB_OK=TRUE`; every PyTorch CLI/test run must set it.
- Keep Detector changes vectorized and device/dtype neutral—no `.cpu()` casts or tensor detaches.
- Preserve Protected Assets (`loop.sh`, `input.md`, entries listed in docs/index.md); never rename or delete them.
- Avoid editing plan status markers unless evidence is captured and cross-referenced in reports/.
- Ensure trace logs differentiate "with" vs "without" override; ambiguous filenames slow parity review.
- Do not rerun full pytest; stick to targeted nodes unless you finish implementation changes.
- Retain existing pix0 tests; update tolerances only if parity artifacts justify the change.
- No ad-hoc scripts outside `scripts/`—extend existing harnesses instead.
- Keep commits clean; include rationale and tests in message per supervisor SOP.
Pointers:
- plans/active/cli-noise-pix0/plan.md
- docs/fix_plan.md#cli-flags-003-handle-nonoise-and-pix0_vector_mm
- docs/architecture/detector.md
- specs/spec-a-cli.md
- reports/2025-10-cli-flags/phase_j/scaling_chain.md
Next Up: Phase H5c trace comparison & Attempt #29 logging (if code lands cleanly).
EOF
' succeeded in 952ms:

[2025-10-06T10:35:06] tokens used: 92,328
[2025-10-06T10:35:06] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:11] thinking

**Preparing to list hypotheses and track changes**
[2025-10-06T10:35:11] exec bash -lc 'git status --short' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:12] bash -lc 'git status --short' succeeded in 727ms:
 M docs/fix_plan.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T10:35:12] tokens used: 94,126
[2025-10-06T10:35:12] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:14] thinking

**Preparing documentation and memory update**
[2025-10-06T10:35:17] exec bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-21 (galph loop — Phase H5 reopen)
- Phase J scaling traces revealed C honours "'`-pix0_vector_mm` even with custom detector vectors; PyTorch still skips override in that path → 1.14 mm pix0 delta, h/k/l drift, F_latt collapse.
- Updated `plans/active/cli-noise-pix0/plan.md` with Phase H5 (C evidence, override reinstatement, trace verification, fix_plan logging) and corrected the prior note that C ignored overrides.
- Synced `docs/fix_plan.md` Next Actions to require H5a–H5c before Phase K; Attempt #28 observations now document the confirmed driver (missing override in custom-vector path).
- Regenerated `input.md` (Implementation phase) directing Ralph to execute Phase H5b with fresh C/PyTorch traces and targeted pytest.
- Follow-up: Expect Attempt #29 after override fix; pause Phase K normalization work until H5 parity evidence lands.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:18] bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-10-21 (galph loop — Phase H5 reopen)
- Phase J scaling traces revealed C honours "'`-pix0_vector_mm` even with custom detector vectors; PyTorch still skips override in that path → 1.14 mm pix0 delta, h/k/l drift, F_latt collapse.
- Updated `plans/active/cli-noise-pix0/plan.md` with Phase H5 (C evidence, override reinstatement, trace verification, fix_plan logging) and corrected the prior note that C ignored overrides.
- Synced `docs/fix_plan.md` Next Actions to require H5a–H5c before Phase K; Attempt #28 observations now document the confirmed driver (missing override in custom-vector path).
- Regenerated `input.md` (Implementation phase) directing Ralph to execute Phase H5b with fresh C/PyTorch traces and targeted pytest.
- Follow-up: Expect Attempt #29 after override fix; pause Phase K normalization work until H5 parity evidence lands.
EOF
' succeeded in 693ms:

[2025-10-06T10:35:18] tokens used: 94,562
[2025-10-06T10:35:18] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:19] thinking

**Reviewing changes before commit**
[2025-10-06T10:35:20] exec bash -lc 'git diff plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:21] bash -lc 'git diff plans/active/cli-noise-pix0/plan.md' succeeded in 726ms:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e28..1c8cc82 100644
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@ Goal: Ensure the CLI-provided beam vector propagates through Detector→Simulato
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@ Update 2025-10-17: Attempt #22 proved the projection-based override mapping push
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
[2025-10-06T10:35:21] tokens used: 94,959
[2025-10-06T10:35:21] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:22] thinking

**Reviewing docs/fix_plan diff**
[2025-10-06T10:35:23] exec bash -lc 'git diff docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:24] bash -lc 'git diff docs/fix_plan.md' succeeded in 681ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e80978..72177f6 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
[2025-10-06T10:35:24] tokens used: 96,386
[2025-10-06T10:35:24] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:26] thinking

**Reviewing diff for input.md**
[2025-10-06T10:35:27] exec bash -lc 'git diff input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:28] bash -lc 'git diff input.md' succeeded in 702ms:
diff --git a/input.md b/input.md
index 4e08e48..1eb9d72 100644
--- a/input.md
+++ b/input.md
@@ -1,103 +1,36 @@
-Summary: Capture C vs PyTorch scaling diagnostics for the supervisor command before touching simulator code. Establish the first mismatched factor in the normalization chain so we can plan fixes confidently.
-Phase: Evidence
-Focus: [CLI-FLAGS-003] Phase J — Intensity Scaling Evidence
+Summary: Restore pix0 override precedence with custom detector vectors so F_latt parity recovers before normalization fixes.
+Phase: Implementation
+Focus: CLI-FLAGS-003 Handle -nonoise and -pix0_vector_mm
 Branch: feature/spec-based-2
-Mapped tests: none — evidence-only
-Artifacts:
-- reports/2025-10-cli-flags/phase_j/trace_c_scaling.log
-- reports/2025-10-cli-flags/phase_j/trace_py_scaling.log
-- reports/2025-10-cli-flags/phase_j/scaling_chain.md
-- reports/2025-10-cli-flags/phase_j/analyze_scaling.py
-- reports/2025-10-cli-flags/phase_j/attempted_scaling_notes.md (only if fallback path required)
-Do Now: CLI-FLAGS-003 Phase J1 — extend the existing trace harness to emit the full normalization chain, then run the C and PyTorch scaling traces for pixel (slow=1039, fast=685) and stash the raw logs in phase_j before editing any simulator code or tests.
[2025-10-06T10:35:28] tokens used: 97,937
[2025-10-06T10:35:28] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:31] thinking

**Preparing to stage and commit**
[2025-10-06T10:35:32] exec bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:32] bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md galph_memory.md' succeeded in 717ms:

[2025-10-06T10:35:32] tokens used: 100,074
[2025-10-06T10:35:32] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:38] thinking

**Preparing commit message**
[2025-10-06T10:35:39] exec bash -lc 'git commit -m "SUPERVISOR: Phase H5 pix0 override - tests not run"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:40] bash -lc 'git commit -m "SUPERVISOR: Phase H5 pix0 override - tests not run"' succeeded in 720ms:
[feature/spec-based-2 a85e83d] SUPERVISOR: Phase H5 pix0 override - tests not run
 4 files changed, 57 insertions(+), 105 deletions(-)
[2025-10-06T10:35:40] tokens used: 100,265
[2025-10-06T10:35:40] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:44] thinking

**Pushing changes to repository**
[2025-10-06T10:35:45] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T10:35:47] bash -lc 'git push' succeeded in 2.09s:
To github.com:hoidn/nanoBragg.git
   e357e8f..a85e83d  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T10:35:47] tokens used: 100,478
[2025-10-06T10:35:47] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.


[2025-10-06T10:35:56] thinking

**Preparing final summary and plan message**

I'll craft a clear, concise final response with sections for key points, hypotheses on the observed F_latt mismatch, updated plans including vectorization, references to relevant files like `reports/2025-10-cli-flags/phase_j/trace_c_scaling.log`, and next steps. I'll keep it friendly and structured for easy understanding.
[2025-10-06T10:35:57] codex

**Key Points**
- Phase J scaling traces (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) show the 3.6e-07 intensity ratio stems from a 1.14 mm pix0 delta: PyTorch skips `-pix0_vector_mm` when custom detector vectors are present, leaving `Fbeam/Sbeam` ≈0.0369 m instead of the C value ≈0.2179 m and collapsing `F_latt` (see `trace_py_scaling.log` vs `trace_c_scaling.log`).
- This overrides the earlier assumption in `plans/active/cli-noise-pix0/plan.md` Phase H that C ignored the pix0 override; the evidence demonstrates the override is applied even with custom vectors.
- Long-term Goal 2 remains on hold: `plans/active/vectorization.md` is ready, but Phase A baselines still depend on resolving CLI parity first.

**Hypotheses (ranked)**
- `Detector._calculate_pix0_vector` must honour `pix0_override_tensor` even when custom vectors are provided; restoring that branch should collapse the pix0/F_latt gap. Confidence: high. Confirm by re-running the supervisor command and comparing traces after the patch.
- Residual differences in the normalization chain (ω, polarization) could persist after pix0 parity; once H5 succeeds, re-evaluate Phase K metrics. Confidence: medium. Confirm with a rerun of `reports/2025-10-cli-flags/phase_j/scaling_chain.md`.
- If small deltas survive, revisit beam/pivot mappings per `docs/architecture/detector.md` and `specs/spec-a-cli.md`, but current data points to override precedence. Confidence: low.

**Actions**
- Updated `plans/active/cli-noise-pix0/plan.md` with Phase H5 (C evidence, override reinstatement, trace verification, fix_plan logging) and corrected the outdated note about C ignoring the override.
- Synced `docs/fix_plan.md#cli-flags-003-handle-nonoise-and-pix0_vector_mm` to require H5a–H5c before Phase K and logged the confirmed driver of Attempt #28.
- Regenerated `input.md` (Implementation phase) directing Ralph to execute Phase H5b, capture fresh C/PyTorch traces, run the targeted pix0 pytest node, and archive artifacts under `reports/2025-10-cli-flags/phase_h5/`.

**Next Steps**
- Ralph should follow `input.md`, starting with H5a evidence and H5b override restoration, then update docs/fix_plan.md with Attempt #29 once parity is demonstrated.
- After H5 closes, re-run the normalization ratio check to decide whether Phase K still needs code changes or if the pix0 fix resolves the discrepancy.
[2025-10-06T10:36:02] tokens used: 101,763
[2025-10-06T10:36:02] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 2e809781b20071dd8107d51b993b781f5e8b1973..72177f653bbe3677846c5d9e7e21e4d24fc18c04
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase C2 parity run exposed a 2.58e2× intensity scaling mismatch (PyTorch max_I≈1.15e5 vs C max_I≈4.46e2). Phase D3/E diagnostics (2025-10-16) confirm three blocking geometry gaps: (a) PyTorch applies the raw `-pix0_vector_mm` override without the CUSTOM transform used in C (1.14 mm Y error); (b) CLI ignores `-beam_vector`, leaving the incident ray at the convention default `[0,0,1]`; (c) `-mat A.mat` handling discards the MOSFLM orientation, so Crystal falls back to canonical upper-triangular vectors while C uses the supplied A*. Traces also show a polarization delta (C Kahn factor ≈0.9126 vs PyTorch 1.0) to revisit after geometry fixes.
-- Next Actions (2025-10-19): Follow `plans/active/cli-noise-pix0/plan.md` Phase J before any implementation:
-  1. Capture C/PyTorch scaling traces for pixel (1039,685) logging `steps`, `I_before_scaling`, `omega`, `polarization`, `r_e²`, and `fluence` (artifact: `reports/2025-10-cli-flags/phase_j/trace_*_scaling.log`).
-  2. Produce `reports/2025-10-cli-flags/phase_j/scaling_chain.md` with ratio analysis pinpointing the first mismatched factor; raise Attempt #28 once published.
-  3. Only after Phase J evidence, proceed to Phase K implementation tasks (normalization fix, regression tests, doc updates) and rerun Phase L parity command to retire Attempt #27 failure.
+- Next Actions (2025-10-21): Execute `plans/active/cli-noise-pix0/plan.md` Phase H5 before resuming normalization work:
+  1. Re-run the supervisor command with/without `-pix0_vector_mm`, capturing C traces (`reports/2025-10-cli-flags/phase_h5/c_traces/`) that prove the override updates `Fbeam/Sbeam` even with custom vectors.
+  2. Restore the pix0 override path inside `Detector._calculate_pix0_vector` for custom vectors, ensuring device/dtype neutrality, and document rationale in `phase_h5/implementation_notes.md`.
+  3. Regenerate PyTorch traces (store under `reports/2025-10-cli-flags/phase_h5/py_traces/`), compare against C to confirm pix0/Fbeam/Sbeam/hkl/`F_latt` parity, then log Attempt #29 in this entry before advancing to Phase K normalization tasks.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
@@ -492,8 +492,8 @@
       - **Secondary issues (non-blocking):** Polarization C=0.9126 vs PyTorch=1.0 (9.6% discrepancy), omega C=4.16e-7 vs PyTorch=4.17e-7 (0.2% difference, within tolerance)
       - **Steps, r_e², fluence all match exactly:** Confirms normalization infrastructure is correct; issue is in physics computation upstream
       - **F_cell matches perfectly (300.58):** Structure factor lookup/interpolation working correctly
-      - **Hypothesis:** F_latt calculation (sincg lattice shape factor) may have sign errors, incorrect fractional Miller index handling, or wrong lattice vector magnitudes
-    Next Actions: Phase K implementation per plan - investigate F_latt calculation in PyTorch simulator (likely `_compute_physics_for_position` lattice shape factor section), compare against C nanoBragg.c sincg implementation, fix discrepancy, add targeted regression test for F_latt components, then rerun Phase L parity command.
+      - **Confirmed driver:** Pix0 override is skipped in the custom-vector branch, leaving PyTorch `Fbeam/Sbeam` near 0.0369 m vs C ≈0.2179 m and producing 1.14 mm pixel-position error that cascades into h/k/l and `F_latt`.
+    Next Actions: Phase H5 (new) reinstates the override precedence, then Phase K will address any residual normalization deltas once lattice parity is restored.
   * [2025-10-17] Attempt #26 (ralph) — Result: success (Phase I polarization defaults complete). **BeamConfig.polarization_factor default aligned with C polar=1.0.**
     Metrics: CLI polarization tests 3/3 passed. Core tests: cli_flags 26/26, detector_geometry 12/12, crystal_geometry 19/19 (57 passed, 1 warning). Test collection: 632 tests collected.
     Artifacts:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index c202e286d046c98c5751d65910a4b32a5deea64e..1c8cc8218667f97587a54b868e0890e9875c5db9
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -94,7 +94,7 @@
 Prereqs: Phases F and G complete; orientation traces captured (Phase G3 artifacts in place).
 Exit Criteria: Trace comparison shows `pix0_vector` components matching C within 5e-5 m, `h`, `k`, `l` fractional components within 1e-3, `F_latt_a/b/c` within 0.5% (signed), and a parity rerun demonstrates ≥0.95 correlation improvement attributable to lattice fixes (polarization still disabled).
 
-Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 shows the C code ignores `-pix0_vector_mm` when custom detector vectors are present, so Phase H3b2 must enforce the precedence (custom vectors > pix0 override > standard calculation).
+Update 2025-10-17: Attempt #22 proved the projection-based override mapping pushes pix0 off by 2.16e-1 m; Attempt #23 (now superseded) inferred the C code ignored `-pix0_vector_mm` when custom detector vectors are present. Phase J traces captured on 2025-10-21 demonstrate the override IS honoured (C recomputes `Fbeam/Sbeam` ≈0.2179/0.2139 m), so PyTorch must re-apply overrides even in the custom-vector path.
 
 | ID | Task Description | State | How/Why & Guidance |
 | --- | --- | --- | --- |
@@ -108,6 +108,18 @@
 | H4b | Refresh traces and parity evidence | [D] | ✅ 2025-10-17 Attempt #25: Stored C/PyTorch traces in `reports/2025-10-cli-flags/phase_h/parity_after_lattice_fix/trace_c.log` and `trace_py.log`; `summary.md` records pix0 deltas ≤1.3e-8 m and `F_latt` agreement <0.2%. |
 | H4c | Tighten regression test + targeted pytest | [D] | ✅ 2025-10-17 Attempt #25: Updated regression tolerance to 5e-5 m (CPU and CUDA parametrised) and captured `pytest_h4c.log`; Attempt #25 logged in docs/fix_plan.md. |
 
+### Phase H5 — Custom Vector Pix0 Override Reinstatement
+Goal: Reconcile the newly observed 1.14 mm pix0 delta when both custom detector vectors and `-pix0_vector_mm` are supplied so PyTorch mirrors C’s override precedence.
+Prereqs: Phase H4 artifacts available; Phase J scaling report (`reports/2025-10-cli-flags/phase_j/scaling_chain.md`) pinpointing the divergence.
+Exit Criteria: Detector traces with custom vectors show `pix0_vector`, `Fbeam`, and `Sbeam` matching C within 5e-5 m, and fractional h/k/l plus `F_latt_a/b/c` align within 1e-3 relative difference before resuming normalization work.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| H5a | Verify C precedence with explicit derivation | [ ] | Re-run the supervisor command twice (with and without `-pix0_vector_mm`) capturing C traces under `reports/2025-10-cli-flags/phase_h5/c_traces/`. Confirm C recomputes `Fbeam/Sbeam` from the override even with custom vectors and document the dot-product derivation in `phase_h5/c_precedence.md`. |
+| H5b | Restore pix0 override application in PyTorch custom-vector path | [ ] | Update `Detector._calculate_pix0_vector` so custom vectors still honour `pix0_override_tensor`, keeping device/dtype neutrality and vectorization. Reuse the existing projection logic; capture rationale + code references in `phase_h5/implementation_notes.md`. |
+| H5c | Capture updated PyTorch traces & compare | [ ] | Extend `phase_h/trace_harness.py` for Phase H5 to log `pix0_vector`, `Fbeam/Sbeam`, fractional h/k/l, and `F_latt` components. Store outputs in `reports/2025-10-cli-flags/phase_h5/py_traces/` and summarise deltas in `phase_h5/parity_summary.md`. |
+| H5d | Update fix_plan Attempt log | [ ] | Record Attempt #29 in `docs/fix_plan.md` once traces align, noting restored override precedence and residual normalization gaps feeding Phase K. |
+
 ### Phase I — Polarization Alignment (follow-up)
 Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
 Prereqs: Phases F–H complete; traces show `F_latt` parity.

Reading prompt from stdin...
Already up to date.
To github.com:hoidn/nanoBragg.git
   a85e83d..2303646  HEAD -> feature/spec-based-2
Waiting for Ralph to complete i=33...
Already up to date.
[sync] state: actor=ralph status=waiting-ralph iter=33
Updating 2303646..fe1103e
Fast-forward
 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
From github.com:hoidn/nanoBragg
   2303646..fe1103e  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=ralph status=running-ralph iter=33
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Already up to date.
Updating fe1103e..c0be084
Fast-forward
 docs/fix_plan.md                                   | 14 ++++
 .../phase_h5/implementation_notes.md               | 67 ++++++++++++++++++
 .../2025-10-cli-flags/phase_h5/parity_summary.md   | 79 ++++++++++++++++++++++
 reports/2025-10-cli-flags/phase_h5/pytest_h5b.log  | 11 +++
 .../phase_h5/pytest_regression.log                 | 73 ++++++++++++++++++++
 src/nanobrag_torch/models/detector.py              | 38 +++++------
 6 files changed, 261 insertions(+), 21 deletions(-)
 create mode 100644 reports/2025-10-cli-flags/phase_h5/implementation_notes.md
 create mode 100644 reports/2025-10-cli-flags/phase_h5/parity_summary.md
 create mode 100644 reports/2025-10-cli-flags/phase_h5/pytest_h5b.log
 create mode 100644 reports/2025-10-cli-flags/phase_h5/pytest_regression.log
From github.com:hoidn/nanoBragg
   fe1103e..c0be084  feature/spec-based-2 -> origin/feature/spec-based-2
Already up to date.
Already up to date.
Already up to date.
Updating c0be084..9b69ba4
Fast-forward
 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)
From github.com:hoidn/nanoBragg
   c0be084..9b69ba4  feature/spec-based-2 -> origin/feature/spec-based-2
[sync] state: actor=galph status=complete iter=34
Ralph completed iteration 33; proceeding to 34
