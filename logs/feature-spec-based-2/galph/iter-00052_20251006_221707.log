Already up to date.
Waiting for expected_actor=galph...
Already up to date.
[sync] state: actor=galph status=complete iter=52
To github.com:hoidn/nanoBragg.git
   82bbc42..06363bc  HEAD -> feature/spec-based-2
$ codex exec -m gpt-5-codex -c model_reasoning_effort=high --dangerously-bypass-approvals-and-sandbox
[2025-10-06T22:17:12] OpenAI Codex v0.38.0 (research preview)
--------
workdir: /Users/ollie/Documents/nanoBragg3
model: gpt-5-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
--------
[2025-10-06T22:17:12] User instructions:
<role>
planning, review and analysis. do not make code changes.
</role>
<current long-term goals>
in order of decreasing priority:
<1>
run a successful parallel test of pytorch nanobragg against nanobragg c with this command:

nanoBragg  -mat A.mat -floatfile img.bin -hkl scaled.hkl  -nonoise  -nointerpolate -oversample 1  -exposure 1  -flux 1e18 -beamsize 1.0  -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080  -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866  -beam_vector 0.00051387949 0.0 -0.99999986  -Na 36  -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0

this will require first adding support for the following cli params to pytorch nanobragg:
-nonoise
-pix0_vector_mm

</1>
<2>
review and firm up if needed plans/active/vectorization.md. then implement it (or rather, delegate its implementation to ralph), starting with the tricubic interpolation vectorization 
</2>
</current long-term goals>
</past long term goals>
(just for archival / reference purposes):
- error-correcting the engineer agent 
- profiling pytorch nanobragg to find performance bottlenecks. analyzing to understand the CRITICAL slowness of the pytorch implementation compared to reference C, which persists after our recent improvement attempts
- finding performance issues in the PyTorch reimplementation of nanobragg (originally a C code) and speeding it up. It should be efficiently vectorized and faster than C nanobragg, but currently it's slower 
- ensuring that the pytorch implementation uses fp32 (not fp64) by default 
- understanding why pytorch is slower than C in the warm condition at 4096x4096 resolution and fixing the underlying performance issue, if one is found. THIS IS A CRITICAL PERFORMANCE ISSUE.
- once all the above are taken care of: building a user-facing showcase of autodiff-based parameter refinement, with plots / visuals

</past long-term goals>
<task>
You are galph, a planner / supervisor agent. you are overseeing the work of an agent (ralph) that is running prompts/main.md in a loop, using docs/fix_plan.md as its instruction set and long term memory. 

You will get invoked repeatedly. Use galph_memory.md to communicate with your future self. You'll plans under plans/, when needed, to help steer multi-turn efforts by the coder agent (ralph). Those plans will be cross referenced from docs/fix_plan.md so that ralph can find / read them. 

At the start of every invocation:
- Run `timeout 30 git pull --rebase` with a hard 30-second timeout  to sync with origin before reviewing context. If the command times out, immediately abort any partial rebase (`git rebase --abort`) and fall back to a normal merge via `git pull --no-rebase`. Whatever path you take, resolve resulting conflicts (docs/fix_plan.md is a frequent hotspot) and document key decisions in galph_memory.md. If the pull reports conflicts:
  * Run `git status --short` to list conflicted files.
  * Fix each file (remove conflict markers, keep the intended content) and stage it with `git add`.
  * When the index is clean, resume with `timeout 30 git rebase --continue --no-edit`. IMPORTANT: NEVER RUN THIS COMMAND WITHOUT TIMEOUT
- After resolving any conflicts, read the latest galph_memory.md entry (and any linked plan files) so you do not lose past context.
- Prune or summarize older entries when they become stale or redundant.

Before concluding each invocation:
- Append a concise update to galph_memory.md capturing key findings, decisions, and open questions (reference file paths or plan names).
- Note any follow-up actions you expect Ralph to take.
- If no substantial update is needed, explicitly log that fact so future runs know context was reviewed.
</task>

<instructions>
<0>
READ the following files:
- Index of project documentation: `./docs/index.md`
- $SPECS: `./specs/spec-a.md`
- $ARCH: `./arch.md` (ADR-backed implementation architecture; reconcile design with spec, surface conflicts)
- docs/development/c_to_pytorch_config_map.md — C↔Py config parity and implicit rules
-- docs/debugging/debugging.md — Parallel trace-driven debugging SOP
- $PLAN: `./fix_plan.md` (living, prioritized to‑do; keep it up to date)
- $TESTS: `./docs/development/testing_strategy.md` (testing philosophy, tiers, seeds/tolerances, commands)
- Set `AUTHORITATIVE_CMDS_DOC=./docs/development/testing_strategy.md` (or project‑specific path) and consult it for authoritative reference commands and test discovery.
<0>
<1>
do a deep analysis of the codebase in light of the <current long term goals>. What are some current issues / gaps and possible approaches to resolving them? Review docs/fix_plan.md and plans/active/, as previous iterations of you may have already done some legwork.
 


Debugging Items — Hypothesis + Triage (initial pass):
- Only when the selected item is a debugging or parity analysis task, formulate 1–3 plausible hypotheses for the observed gap/issue.
- Triage each with checks appropriate to scope using existing artifacts or quick, documented reproductions; this triage may constitute the primary work for the iteration. Record outcomes succinctly in the evidence.
- For the top hypothesis, state confidence and the single confirming step to run next. Deliver 1–3 ranked hypotheses with supporting evidence, artifact paths, and the next confirming step.
</1>
<2>
flip a coin using python. if it comes up <heads>:
review ralph's work over the last N (~10 but can be more or less - you decide) iterations. Check the commit history. Has the work been productive? Have there been regressions? Do we need to provide any feedback / course-correction?
</heads>
if it comes up <tails>: proceed to step <3>
</2>
<3>
Given your findings in <1> and <2>, think about whether there's any need for a multi-turn planning effort -- i.e. ralph can't see the forest for the trees and may struggle with major refactorings and multi-turn implementation efforts unless they are coordinated by you. Is there a need for such planning *right now*? If such a plan is already spoken for (plans/active/ or wherever else past galph might have saved to), does that plan require updates or is it up to date / high quality and simply pending? IFF you determine the need for a new plan or modification of an existing one:
<yes case>
- we will be calling the plan topic the <focus issue> of this turn.
- based on which long term <goal> and sub-goal is that effort / plan? 
- Which existing docs/fix_plan.md items does it (i.e. the <focus issue>) relate to? 
- Documentation review for <focus issue>: Using `docs/index.md` as the map, identify and read the specific documents relevant to the chosen <focus issue> (e.g., component contracts, architecture ADRs, parity/testing strategy). List the file paths you will rely on (with a one‑line rationale each) before drafting or updating the plan.
- think deeply. draft / redraft the plan and save it to a .md under plans/active/. Structure the write-up as a phased implementation document (see `plans/archive/general-detector-geometry/implementation.md` for tone/shape): begin with context + phase overviews, then outline each phase’s intent, prerequisites, and exit criteria. When a phase benefits from explicit tracking, embed a checklist table using the `ID | Task Description | State | How/Why & Guidance` format (with `[ ]`, `[P]`, `[D]` markers) inside that phase section.
  • Include reproduction commands, owners (if known), and decision rules in the guidance column.
  • Favor narrative flow first; layer checklists only where they clarify verification steps or deliverables.
  • Mini-template to crib when drafting:
    ```md
    ## Context
    - Initiative: <initiative>
    - Phase Goal: <outcome>
    - Dependencies: <docs/tests>

    ### Phase A — <short title>
    Goal: <what this phase proves or delivers>
    Prereqs: <artifacts or measurements required before starting>
    Exit Criteria: <verifiable completion signal>

    | ID | Task Description | State | How/Why & Guidance |
    | --- | --- | --- | --- |
    | A1 | <Key diagnostic or implementation step> | [ ] | Run `<command>`; capture results under `reports/<date>/...`. |
    | A2 | <Follow-up validation> | [ ] | Compare against `<artifact>`; stop if deviation > threshold. |
    ```
- When refreshing an existing plan, retrofit it to this phased format before adding or editing tasks.
- review docs/fix_plan.md. edit if needed. cross reference the new plans .md so that ralph can find it.
</yes case>
</no case>
- Since you decided there's no need for planning, you will instead focus on review / housekeeping. 
- Once the above is done (or deemed unneeded): review and evaluate ralph's work. Scrutinize the commit history. Look at the diffs. 
- Are the docs/fix_plan.md contents and priorities sane? things to consider:
  - if docs/fix_plan.md is longer than 1000 lines it should be housecleaned. If it's disorganized and / or internally inconsistent, consider how this could be addressed. 
- after considering the above, you have enough information to choose a <focus issue> for this turn. do so. Consider the nature of the <focus issue>:
    - Documentation review for <focus issue>: From `docs/index.md`, enumerate and read the documents that are most relevant to the chosen <focus issue>`; note the key file paths you will rely on for this turn.
    - Do we need a new docs/fix_plan item to put ralph back on course, fix one of his mistakes, or instruct him to do something that he overlooked? If so, draft it and add it to docs/fix_plans
    - does the <focus issue> involve identified issues in docs/fix_plan.md? If so, fix them. If you decide to shorten docs/fix_plan.md, the least relevant portions should be moved to archive/fix_plan_archive.md (with summary + archive cross reference if appropriate)
</no case>
</3>
<3.5>
Render and write ./input.md (supervisor→engineer steering memo). Overwrite the entire file every invocation. Keep length ~100–200 lines. Include these sections in order:
Header:
- Summary: <one‑sentence goal for this loop>
- Phase: <Evidence | Implementation | Validation>
- Focus: <plan item ID/title from docs/fix_plan.md>
- Branch: <expected branch>
- Mapped tests: <validated list | none — evidence‑only>
- Artifacts: <key paths to produce under reports/>
- Do Now: 1 line naming the exact docs/fix_plan.md item (ID and title) to execute this loop, plus the exact pytest command/env to reproduce it (only when an authoritative mapping exists). If no such test exists, the Do Now MUST be to author the minimal targeted test first and then run it. If you intend to delegate the choice, write “Do Now: delegate” and provide decision guidance below.
  - Note: When the Phase is Evidence, you must not execute tests; any pytest command included here is provided for Ralph’s subsequent loop.
<Do Now guidelines>
Phase Gate (Evidence): If the active plan phase is Evidence, do not run pytest at all (including collection). Limit evidence gathering to non-test probes and command‑line tooling (e.g., scripts/validation/*, minimal parity CLIs). Do not include runnable tests in this loop.
Command Sourcing (tests): Only include an exact pytest command in Do Now when sourced from an authoritative mapping (e.g., docs/development/testing_strategy.md) or an existing, known test file/identifier. If no authoritative mapping exists, set the Do Now task to author the minimal targeted test first; do not guess at a pytest selector here.
</Do Now guidelines>
- If Blocked: fallback action (what to run/capture, how to record it in Attempts History).
- Priorities & Rationale: 3–6 bullets with file pointers (specs/arch/tests/plan) justifying the Do Now.
- How-To Map: exact commands (pytest, nb-compare), env vars, ROI/thresholds, and where to store artifacts; prefer using `scripts/validation/*` when available.
- Pitfalls To Avoid: 5–10 crisp do/don’t reminders (device/dtype neutrality, vectorization, Protected Assets, two‑message loop policy, no ad‑hoc scripts).
- Pointers: file paths with line anchors to the most relevant spec/arch/testing_strategy/fix_plan entries for this loop.
- Next Up (optional): 1–2 candidates Ralph may choose next loop if he finishes early (still one thing per loop).

 Rules:
 - Ralph must not edit input.md. You (galph) are the single writer.
 - If input.md’s Do Now conflicts with an existing in_progress selection in fix_plan.md, Ralph is allowed to switch; he must record the change in Attempts History.
- Do not instruct Ralph to run the full test suite more than once per turn. Require targeted tests first; run the full suite once at the end only if code changed. For prompt/docs‑only loops, require `pytest --collect-only -q` instead.
- Prefer referencing reusable scripts under `scripts/validation/` from Do Now when available.
- Commit input.md each run as part of step <4> (commit only if the content changed).
</3.5>
<4>
Before finishing the loop, enforce git hygiene:
- Run `git status --short` to inspect new or modified files that appeared during this invocation.
- Review diffs for each change; revert only if you created it this loop and it was accidental.
- Stage intentional updates with `git add -A` and commit via `git commit -m "SUPERVISOR: <scope> - <tests or rationale>"`, noting any tests run (use `tests: not run` when you skip them).
- After committing, run `git push` to share the updates. If the push is rejected, `timeout 30 git pull --rebase`, resolve conflicts (capture decisions—especially for docs/fix_plan.md—in galph_memory.md), then push again.
- If you deliberately leave the tree dirty, document the rationale in galph_memory.md so the next invocation knows why.
</4>
</instructions>
<notes>
- ignore 'routing violations'. these are out of scope.
- ignore AT parallel 012-related items for now
</notes>
Now carefully and exhaustively follow your <instructions>.


[2025-10-06T22:17:16] thinking

**Preparing to run git pull with rebase**
[2025-10-06T22:17:17] exec bash -lc 'timeout 30 git pull --rebase' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:20] bash -lc 'timeout 30 git pull --rebase' succeeded in 2.46s:
Already up to date.
[2025-10-06T22:17:20] tokens used: 10,841

[2025-10-06T22:17:22] thinking

**Preparing to read galph_memory.md**
[2025-10-06T22:17:22] exec bash -lc 'cat galph_memory.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:23] bash -lc 'cat galph_memory.md' succeeded in 706ms:
## 2025-09-30 (loops 1-4 summary)
- Established parity backlog: AT-020/021/022/024 failing; created first supervisor plan for AT-021 and enforced prompts/debug.md routing.
- Diagnosed AT-024 random misset cap mismatch (π/2 vs 90 radians) and opened dedicated plan; insisted Ralph stop verification-only loops.
- Flagged torch.compile warm-up overhead (per-instance compilation, inline tensor factories) and opened AT-012 rotation parity plan (Phases A–E).
- Documented performance hotspots (`_compute_physics_for_position` guard tensors, `Crystal.compute_cell_tensors` clamps) and chronic dirty worktree artifacts blocking `git pull --rebase`.

## 2025-09-30 (loops 5-10 summary)
- Authored repo hygiene checklist (REPO-HYGIENE-002) to undo accidental `golden_suite_generator/nanoBragg.c` churn and purge stray reports.
- Created PERF-PYTORCH-004 plan to hoist constants, introduce compile caching, and remove Dynamo graph breaks; reiterated need for prompts/debug.md while parity fails.
- Repeatedly documented routing violations from Ralph and emphasized restoring Core Rule #13 metric duality after WIP commit 058986f swapped `V_actual` for formula volume.
- Noted that `_compute_physics_for_position` still recompiles each Simulator and that benchmarks in `reports/benchmarks/20250930-004916/` show ≥200× slowdown vs C for small detectors.

## 2025-09-30 (ralph debugging loop — AT-012 float32 regression)
- **Context**: AT-PARALLEL-012 test_simple_cubic_correlation failing (43/50 peaks matched, need ≥95%) after DTYPE-DEFAULT-001 (commit 8c2ceb4) switched simulator to native float32.
- **Investigation**:
  * Reproduced: 43/50 peaks matched (86%), corr≈1.0 (perfect physics) ✅
  * Parity matrix test: PASSES perfectly ✅ (live C↔Py comparison with current float32)
  * **Root cause identified**: PyTorch float32 produces 7× more unique values (4901 vs C's 669) in hot pixels, fragmenting intensity plateaus. Peak detection algorithm (scipy.ndimage.maximum_filter) is sensitive to plateau structure.
  * Parallel comparison: C float32 beam center (20×20 ROI) has 91 unique values; PyTorch has 331 (3.6× fragmentation). Max absolute diff tiny (0.0017).
  * **First Divergence**: Numerical accumulation patterns differ (likely FMA, compiler opts, vectorized accumulation order, or torch.compile kernel fusion) → perfect correlation but incompatible plateau structure.
[2025-10-06T22:17:23] tokens used: 11,057

[2025-10-06T22:17:25] thinking

**Planning to read documentation files**
[2025-10-06T22:17:26] exec bash -lc 'cat docs/index.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:27] bash -lc 'cat docs/index.md' succeeded in 687ms:
# Project Documentation Index

Welcome to the central index for all `nanoBragg-PyTorch` project documentation. This guide provides a map to the key technical specifications, development processes, and historical records that define the project.

---

## 🏛️ Permanent Documentation

These are the core, living documents that guide the project.

### Core Project Guides
### PyTorch Guardrails
* **[PyTorch Runtime Checklist](./development/pytorch_runtime_checklist.md)** – quick do/don’t list for vectorization and device placement. Always review before editing simulator code.
* **[PyTorch Design](./architecture/pytorch_design.md#vectorization-strategy)** – detailed explanation of the required broadcast shapes and batched flows.
* **[Testing Strategy §1.4](./development/testing_strategy.md#14-pytorch-device--dtype-discipline)** – required CPU/GPU smoke tests and compile checks.

* **[CLAUDE.md](../CLAUDE.md)** - The primary instruction set for the AI agent.
* **[README.md](../README.md)** - The main project entry point.
* **[README_PYTORCH.md](../README_PYTORCH.md)** - Comprehensive user guide for the PyTorch implementation, including CLI usage, parallel comparison tools, and visualization.
* **[PROJECT_STATUS.md](../PROJECT_STATUS.md)** - Tracks the current active development initiative.
[2025-10-06T22:17:27] tokens used: 14,014

[2025-10-06T22:17:28] thinking

**Opening specs/spec-a.md**
[2025-10-06T22:17:28] exec bash -lc 'cat specs/spec-a.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:29] bash -lc 'cat specs/spec-a.md' succeeded in 712ms:
# nanoBragg Spec A — Sharded Specification

Spec A is now organized across multiple shards. Read them together for the full normative contract.

- [spec-a-core.md](spec-a-core.md): Core physics, geometry, sampling, data, and associated acceptance tests.
- [spec-a-cli.md](spec-a-cli.md): CLI surface area, precedence rules, and CLI-focused acceptance tests.
- [spec-a-parallel.md](spec-a-parallel.md): Conformance profiles, parallel validation suites, and developer tooling requirements.

Each shard cross-references the others; updates must keep them consistent.
[2025-10-06T22:17:29] tokens used: 15,662

[2025-10-06T22:17:33] thinking

**Considering shard reading approach**
[2025-10-06T22:17:34] exec bash -lc 'cat arch.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:34] bash -lc 'cat arch.md' succeeded in 691ms:
# nanoBragg PyTorch — Implementation Architecture

Document version: 1.0 (aligned with specs/spec-a.md)
Target spec: specs/spec-a.md (single-file normative spec)
Implementation target: Python (>=3.11) + PyTorch (float32 default). Type blocks may use TypeScript-style for clarity; implement with Python dataclasses and torch tensors.

## Running The CLI

- Install (recommended):
  - `pip install -e .` from repo root (provides `nanoBragg` console script).
- Run (installed):
  - `nanoBragg -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Run (without install):
  - `PYTHONPATH=src python -m nanobrag_torch -hkl P1.hkl -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -floatfile out.bin`
- Minimal quick test (no HKL):
  - `nanoBragg -default_F 1 -cell 100 100 100 90 90 90 -lambda 1.0 -distance 100 -detpixels 128 -pgmfile test.pgm`

Notes
- Entry point: `src/nanobrag_torch/__main__.py` (module runner `python -m nanobrag_torch`).
- Required inputs: provide `-hkl` (or existing `Fdump.bin`) or set `-default_F > 0`, and either `-mat` (MOSFLM A*) or `-cell`.
[2025-10-06T22:17:34] tokens used: 15,981

[2025-10-06T22:17:36] thinking

**Checking PyTorch config map docs**
[2025-10-06T22:17:36] exec bash -lc 'cat docs/development/c_to_pytorch_config_map.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:37] bash -lc 'cat docs/development/c_to_pytorch_config_map.md' succeeded in 676ms:
# C-CLI to PyTorch Configuration Map

## Critical Importance Notice

**This document is the authoritative source of truth for configuration parity between nanoBragg.c and the PyTorch implementation.**

Before writing any test or implementation that involves C-code validation, you **MUST** consult this document. Failure to ensure 1:1 configuration parity is the most common source of bugs, particularly with:
- Implicit pivot mode logic
- Convention-dependent beam center calculations
- Rotation axis defaults
- Unit conversions

## Quick Reference Table

### Crystal Parameters

| C-CLI Flag | PyTorch Config Field | C Variable | Units/Convention | Critical Notes |
|------------|---------------------|------------|------------------|----------------|
| `-cell a b c al be ga` | `CrystalConfig.cell_a/b/c/alpha/beta/gamma` | `a[0], b[0], c[0], alpha, beta, gamma` | Å and degrees → radians | Must convert degrees to radians internally |
| `-N <val>` | `CrystalConfig.N_cells` | `Na, Nb, Nc` | Number of unit cells | Sets all three axes to same value |
[2025-10-06T22:17:37] tokens used: 18,711

[2025-10-06T22:17:38] thinking

**Opening debugging documentation**
[2025-10-06T22:17:40] exec bash -lc 'cat docs/debugging/debugging.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:40] bash -lc 'cat docs/debugging/debugging.md' succeeded in 681ms:
# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.
[2025-10-06T22:17:40] tokens used: 20,551

[2025-10-06T22:17:42] thinking

**Checking fix_plan instructions**
[2025-10-06T22:17:42] exec bash -lc 'cat docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:43] bash -lc 'cat docs/fix_plan.md' succeeded in 685ms:
# Fix Plan Ledger

**Last Updated:** 2025-10-17 (galph loop)
**Active Focus:**
- ROUTING: Close the reopened guard plan by capturing a fresh regression audit referencing commit `c49e3be` and re-confirming the guarded `loop.sh` flow (`plans/active/routing-loop-guard/plan.md` Phases A–C) before automation resumes.
- ROUTING-SUPERVISOR: Launch Phase A of `plans/active/supervisor-loop-guard/plan.md`, then drive Phase B guard work (B2–B4) and new task B5 to add `supervisor.sh` to docs/index.md so Protected-Asset policy covers the script before automation runs again.
- AT-012: Plan archived (`plans/archive/at-parallel-012-plateau-regression/plan.md`); monitor for regressions using `reports/2025-10-AT012-regression/phase_c_validation/` artifacts and re-open only if peak matches drop below spec.
- GRADIENT: Execute `plans/active/gradcheck-tier2-completion/plan.md` Phase A (A1–A3 baseline audit + env alignment) before adding misset/beam gradchecks from Phases B/C; once pass logs exist, close `[AT-TIER2-GRADCHECK]` with Phase D documentation updates.
- DTYPE: ✅ Complete. Plan archived to `plans/archive/dtype-default-fp32/`. All phases (A-D) finished; float32 defaults documented in arch.md, pytorch_runtime_checklist.md, CLAUDE.md, prompts/debug.md.
- PERF: Land plan task B7 (benchmark env toggle fix), rerun Phase B6 ten-process reproducibility with the new compile metadata, capture the weighted-source parity memo feeding C5, then execute Phase C diagnostics (C1/C2 plus C8/C9 pixel-grid & rotated-vector cost probes, and new C10 mosaic RNG timing) ahead of Phase D caching work (D5/D6/D7) and detector-scalar hoisting (D8).

## Index
| ID | Title | Priority | Status |
| --- | --- | --- | --- |
| [PROTECTED-ASSETS-001](#protected-assets-001-docsindexmd-safeguard) | Protect docs/index.md assets | Medium | in_progress |
| [REPO-HYGIENE-002](#repo-hygiene-002-restore-canonical-nanobraggc) | Restore canonical nanoBragg.c | Medium | in_progress |
| [PERF-PYTORCH-004](#perf-pytorch-004-fuse-physics-kernels) | Fuse physics kernels | High | in_progress |
| [AT-TIER2-GRADCHECK](#at-tier2-gradcheck-implement-tier-2-gradient-correctness-tests) | Implement Tier 2 gradient correctness tests | High | in_progress |
| [VECTOR-TRICUBIC-001](#vector-tricubic-001-vectorize-tricubic-interpolation-and-detector-absorption) | Vectorize tricubic interpolation and detector absorption | High | in_planning |
| [CLI-DTYPE-002](#cli-dtype-002-cli-dtype-parity) | CLI dtype parity | High | in_progress |
[2025-10-06T22:17:43] tokens used: 43,039

[2025-10-06T22:17:45] thinking

**Identifying key document sections**
[2025-10-06T22:17:45] exec bash -lc 'cat docs/development/testing_strategy.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:46] bash -lc 'cat docs/development/testing_strategy.md' succeeded in 716ms:
# nanoBragg PyTorch Testing Strategy

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** [Your Name/Team]

## 1. Introduction & Philosophy

This document outlines the comprehensive testing strategy for the PyTorch implementation of nanoBragg. The primary goal is to ensure that the new application is a correct, verifiable, and trustworthy scientific tool.
Our testing philosophy is a three-tiered hybrid approach, designed to build confidence layer by layer:

1. **Tier 1: Translation Correctness:** We first prove that the PyTorch code is a faithful, numerically precise reimplementation of the original C code's physical model. The C code is treated as the "ground truth" specification.
2. **Tier 2: Gradient Correctness:** We then prove that the new differentiable capabilities are mathematically sound.
3. **Tier 3: Scientific Validation:** Finally, we validate the model against objective physical principles.

All tests will be implemented using the PyTest framework.

### 1.4 PyTorch Device & Dtype Discipline

- **Device-neutral code:** Every PyTorch path MUST operate correctly on both CPU and CUDA tensors and across supported dtypes. Do not hard-code `.cpu()`/`.cuda()` calls, create CPU-only constants, or assume float64 execution when the caller may supply float32/half tensors.
[2025-10-06T22:17:46] tokens used: 45,908

[2025-10-06T22:17:49] thinking

**Preparing for deep analysis**
[2025-10-06T22:17:49] exec bash -lc 'ls plans' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:50] bash -lc 'ls plans' succeeded in 708ms:
active
archive
cellparams
rotation
[2025-10-06T22:17:50] tokens used: 48,544

[2025-10-06T22:17:51] thinking

**Listing active items**
[2025-10-06T22:17:52] exec bash -lc 'ls plans/active' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:53] bash -lc 'ls plans/active' succeeded in 684ms:
cli-noise-pix0
gradcheck-tier2-completion
perf-pytorch-compile-refactor
routing-loop-guard
supervisor-loop-guard
unification.md
vectorization.md
[2025-10-06T22:17:53] tokens used: 48,746

[2025-10-06T22:17:57] thinking

**Starting analysis of vectorization plan**
[2025-10-06T22:17:58] exec bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:17:59] bash -lc 'rg "CLI-FLAGS-003" -n docs/fix_plan.md' succeeded in 695ms:
21:| [CLI-FLAGS-003](#cli-flags-003-handle-nonoise-and-pix0_vector_mm) | Handle -nonoise and -pix0_vector_mm | High | in_progress |
448:## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
[2025-10-06T22:17:59] tokens used: 49,461

[2025-10-06T22:18:00] thinking

**Preparing to read specific section**
[2025-10-06T22:18:01] exec bash -lc "sed -n '448,620p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:02] bash -lc "sed -n '448,620p' docs/fix_plan.md" succeeded in 751ms:
## [CLI-FLAGS-003] Handle -nonoise and -pix0_vector_mm
- Spec/AT: specs/spec-a-cli.md flag catalogue, docs/architecture/detector.md §5 (pix0 workflow), docs/development/c_to_pytorch_config_map.md (pivot rules), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860
- Priority: High
- Status: in_progress (Phases A–H complete; K3a/K3b/K3d landed via Attempts #43–44, pending per-φ evidence + normalization closure)
- Owner/Date: ralph/2025-10-05
- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
- Reproduction (C & PyTorch):
  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
- Next Actions (2025-10-06 refresh):
  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/summary.json` - Complete parity metrics (correlation, RMSE, sums, peak distances)
[2025-10-06T22:18:02] tokens used: 50,330

[2025-10-06T22:18:04] thinking

**Reviewing CLI support plan**
[2025-10-06T22:18:04] exec bash -lc 'cat plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:05] bash -lc 'cat plans/active/cli-noise-pix0/plan.md' succeeded in 741ms:
## Context
- Initiative: CLI Parity for nanoBragg PyTorch vs C (supports long-term goal in prompts/supervisor.md)
- Phase Goal: Accept `-nonoise` and `-pix0_vector_mm` flags with C-equivalent semantics so the parallel comparison command in prompts/supervisor.md executes end-to-end.
- Dependencies: specs/spec-a-cli.md §§3.2–3.4, docs/architecture/detector.md §5, docs/development/c_to_pytorch_config_map.md (detector pivot + noise), golden_suite_generator/nanoBragg.c lines 720–1040 & 1730–1860 (flag behavior), docs/debugging/detector_geometry_checklist.md (pix0 validation), docs/development/testing_strategy.md §2 (CLI parity tests).
- Current gap snapshot (2025-10-18 refresh): Phase H4 parity landed (Attempt #25) with pix0 deltas < 2e-8 m and regression tolerances tightened; the remaining blocker before executing the supervisor command end-to-end is Phase I polarization alignment.
- Gap snapshot update (2025-10-19): Attempt #27 parity run reveals 1.24538e5× intensity scaling mismatch despite polarization fix; Phases J–L track the normalization diagnosis, fix, and closure required before long-term Goal #1 completes.
- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
- Gap snapshot update (2025-10-24): Attempt #35 reran the PyTorch trace harness post-unit-fix; metrics still show |Δpix0| ≈ 1.145 mm, so a fresh diagnostics phase is required before resuming normalization work.
- Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
- Gap insight (2025-10-31): Scaling evidence shows MOSFLM matrix runs still rescale real vectors using formula lengths; C skips that step unless `-cell` is provided, so PyTorch must gate the `vector_rescale` analogue when `mosflm_a_star` is set. The same trace confirms the polarization Kahn factor should default to 0.0 (C’s `polarization`), not 1.0, so BeamConfig defaults need to be realigned before Phase L.
- Gap correction (2025-10-22): Fresh C evidence (`reports/2025-10-cli-flags/phase_h5/c_precedence_2025-10-22.md`) proves nanoBragg ignores `-pix0_vector_mm` whenever custom detector vectors are present. PyTorch now deviates because the lattice factor uses fractional indices (h−h0); fix required before normalization parity.
- Gap recap (2025-11-05): Manual inspection of `src/nanobrag_torch/models/crystal.py` shows the cross-product rescale still runs even when MOSFLM reciprocal vectors are supplied (lines 681-705), and `BeamConfig.polarization_factor` defaults to 1.0, so scaling remains off despite SAMPLE pivot parity.
- Gap snapshot update (2025-11-06): Traces (`reports/2025-10-cli-flags/phase_k/f_latt_fix/trace_py_after.log`) show the SAMPLE pivot fix leaves residual close-distance deltas (~2.8 µm), which push the fractional Miller index from 2.0012 (C) to 1.9993 (PyTorch). Those 0.002 shifts around integer values amplify sincg results (F_latt_b ≈ +21.6%). Need dtype diagnostics to confirm float32 rounding vs geometry formula drift before coding a fix.
- Gap snapshot refresh (2025-11-07): dtype sweep (`reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/`) rules out precision and exposes a φ-grid mismatch—PyTorch logs `k≈1.9997` (φ=0°) while C logs `k≈1.9928` (φ=0.09°). Next action: capture per-φ traces to align sampling before rerunning normalization tests.
- Evidence status: Phase E artifacts (`reports/2025-10-cli-flags/phase_e/`) hold C/PyTorch traces, diffs, and beam-vector checks. Phase H3b1 also stashes WITH/without override traces under `reports/2025-10-cli-flags/phase_h/implementation/` for reference.
- Documentation anchors for this focus:
  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
  * `golden_suite_generator/nanoBragg.c` (≈2993-3151) — definitive implementation of the sincg calls and rounding logic.
  * `docs/architecture/pytorch_design.md` — simulator reference; docstring currently claims full-h usage and must be updated post-fix.
[2025-10-06T22:18:05] tokens used: 53,473

[2025-10-06T22:18:08] thinking

**Analyzing plan tasks and next steps**
[2025-10-06T22:18:09] exec bash -lc 'cat plans/active/vectorization.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:10] bash -lc 'cat plans/active/vectorization.md' succeeded in 738ms:
## Context
- Initiative: PERF-PYTORCH-004 vectorization backlog; supports long-term goal "Parallel parity + performance" from docs/fix_plan.md
- Phase Goal: Deliver a production-ready, fully vectorized tricubic interpolation pipeline (gather + polynomial evaluation) and follow with detector absorption vectorization without regressing physics, gradients, or device neutrality.
- Dependencies: specs/spec-a-core.md §4 (Structure factors), specs/spec-a-parallel.md §2.3 (Interpolation acceptance tests), docs/architecture/pytorch_design.md §§2.2–2.4, docs/architecture/c_code_overview.md (tricubic routines), docs/development/testing_strategy.md §§2–4, docs/development/pytorch_runtime_checklist.md, `nanoBragg.c` lines 2604–3278 (polin3/polin2/polint + detector absorption), `tests/test_at_str_002.py`, `tests/test_at_abs_001.py`, `reports/benchmarks/20250930-165726-compile-cache/` (current performance references). No dedicated tricubic/absorption microbenchmarks exist yet; Phase A will author reusable harnesses under `scripts/benchmarks/` so future loops can rerun baselines without ad-hoc snippets.

### Phase A — Evidence & Baseline Capture
Goal: Document the current (non-vectorized) behavior, warnings, and performance so we can prove the impact of the refactor.
Prereqs: Editable install (`pip install -e .`), C binary available for parity (when needed), environment variable `KMP_DUPLICATE_LIB_OK=TRUE`.
Exit Criteria: Baseline pytest log, timing snippet results, and notes stored under `reports/2025-10-vectorization/phase_a/` with references in docs/fix_plan.md Attempt history.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| A1 | Re-run tricubic acceptance tests | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_str_002.py -v` ⇒ save log to `reports/2025-10-vectorization/phase_a/test_at_str_002.log`; confirm nearest-neighbour fallback warning message appears for batched inputs. |
| A2 | Measure current tricubic runtime | [ ] | Author `scripts/benchmarks/tricubic_baseline.py` (device/dtype neutral, honours `KMP_DUPLICATE_LIB_OK=TRUE`) and run `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/tricubic_baseline.py --sizes 256 512 --repeats 5`. Capture CPU timings (and CUDA when available) in `phase_a/tricubic_baseline.md` plus raw JSON/CSV under `phase_a/tricubic_baseline_results.json`. |
| A3 | Record detector absorption baseline | [ ] | Create `scripts/benchmarks/absorption_baseline.py` mirroring A2's interface; execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/benchmarks/absorption_baseline.py --sizes 256 512 --repeats 5` alongside `env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_at_abs_001.py -v`. Store logs in `phase_a/absorption_baseline.md` and metrics in `phase_a/absorption_baseline_results.json`. |

### Phase B — Tricubic Vectorization Design
Goal: Lock the tensor-shape design, broadcasting plan, and gradient checks before code changes.
Prereqs: Phase A artifacts uploaded and referenced in docs/fix_plan.md.
Exit Criteria: Design memo (`reports/2025-10-vectorization/phase_b/design_notes.md`) describing target shapes, indexing strategy, gradient expectations, and failure modes; docs/fix_plan.md updated with summary and link.
[2025-10-06T22:18:10] tokens used: 56,516

[2025-10-06T22:18:14] thinking

**Outlining detailed analysis and next steps**

I’m setting up a plan to deeply analyze the codebase while focusing on long-term goals, especially the blockers mentioned around lattice mismatches and CLI flags. I’ll inspect relevant code files like `crystal.py` to understand the current state before moving to later steps like debugging hypotheses, planning, and committing.
[2025-10-06T22:18:15] exec bash -lc "sed -n '1,200p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:16] bash -lc "sed -n '1,200p' src/nanobrag_torch/models/crystal.py" succeeded in 679ms:
"""
Crystal model for nanoBragg PyTorch implementation.

This module defines the Crystal class responsible for managing unit cell,
orientation, and structure factor data.

NOTE: The default parameters in this file are configured to match the 'simple_cubic'
golden test case, which uses a 10 Å unit cell and a 500×500×500 cell crystal size.
"""

from typing import Optional, Tuple

import math
import torch

from ..config import CrystalConfig, BeamConfig
from ..utils.geometry import angles_to_rotation_matrix
from ..io.hkl import read_hkl_file, try_load_hkl_or_fdump


[2025-10-06T22:18:16] tokens used: 59,312

[2025-10-06T22:18:17] thinking

**Searching relevant functions**
[2025-10-06T22:18:18] exec bash -lc 'rg "compute_cell_tensors" -n src/nanobrag_torch/models/crystal.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:18] bash -lc 'rg "compute_cell_tensors" -n src/nanobrag_torch/models/crystal.py' succeeded in 734ms:
412:    def compute_cell_tensors(self) -> dict:
762:    def _compute_cell_tensors_cached(self):
764:        Cached version of compute_cell_tensors to avoid redundant calculations.
772:        return self.compute_cell_tensors()
777:        return self._compute_cell_tensors_cached()["a"]
782:        return self._compute_cell_tensors_cached()["b"]
787:        return self._compute_cell_tensors_cached()["c"]
792:        return self._compute_cell_tensors_cached()["a_star"]
797:        return self._compute_cell_tensors_cached()["b_star"]
802:        return self._compute_cell_tensors_cached()["c_star"]
807:        return self._compute_cell_tensors_cached()["V"]
822:        1. Static missetting rotation (already applied to reciprocal vectors in compute_cell_tensors)
[2025-10-06T22:18:18] tokens used: 61,591
[2025-10-06T22:18:20] exec bash -lc "sed -n '412,520p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:21] bash -lc "sed -n '412,520p' src/nanobrag_torch/models/crystal.py" succeeded in 705ms:
    def compute_cell_tensors(self) -> dict:
        """
        Calculate real and reciprocal space lattice vectors from cell parameters.

        This is the central, differentiable function for all geometry calculations.
        Uses the nanoBragg.c convention to convert cell parameters (a,b,c,α,β,γ)
        to real-space and reciprocal-space lattice vectors.

        This method now supports general triclinic cells and maintains full
        differentiability for all six cell parameters. The computation graph
        is preserved for gradient-based optimization.

        The implementation follows the nanoBragg.c default orientation convention:
        - a* is placed purely along the x-axis
        - b* is placed in the x-y plane
        - c* fills out 3D space

        C-Code Implementation Reference (from nanoBragg.c):

        Volume calculation from cell parameters (lines 1798-1808):
[2025-10-06T22:18:21] tokens used: 62,002
[2025-10-06T22:18:23] exec bash -lc "sed -n '520,720p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:23] bash -lc "sed -n '520,720p' src/nanobrag_torch/models/crystal.py" succeeded in 670ms:
        # Calculate reciprocal cell lengths using C-code formulas
        a_star_length = self.cell_b * self.cell_c * torch.sin(alpha_rad) * V_star
        b_star_length = self.cell_c * self.cell_a * torch.sin(beta_rad) * V_star
        c_star_length = self.cell_a * self.cell_b * torch.sin(gamma_rad) * V_star

        # Calculate reciprocal angles with numerical stability
        sin_alpha = torch.sin(alpha_rad)
        sin_beta = torch.sin(beta_rad)

        # PERF-PYTORCH-004 Phase 1: Use clamp_min instead of torch.maximum to avoid allocating tensors inside compiled graph
        denom1 = (sin_beta * sin_gamma).clamp_min(1e-12)
        denom2 = (sin_gamma * sin_alpha).clamp_min(1e-12)
        denom3 = (sin_alpha * sin_beta).clamp_min(1e-12)

        cos_alpha_star = (cos_beta * cos_gamma - cos_alpha) / denom1
        cos_beta_star = (cos_gamma * cos_alpha - cos_beta) / denom2
        cos_gamma_star = (cos_alpha * cos_beta - cos_gamma) / denom3

        # Clamp cos_gamma_star to valid range [-1, 1]
        cos_gamma_star_bounded = torch.clamp(cos_gamma_star, -1.0, 1.0)
[2025-10-06T22:18:23] tokens used: 63,457
[2025-10-06T22:18:26] exec bash -lc "sed -n '720,920p' src/nanobrag_torch/models/crystal.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:26] bash -lc "sed -n '720,920p' src/nanobrag_torch/models/crystal.py" succeeded in 696ms:
            a_star_cross_b_star = a_star_cross_b_star * (target_mag_a_star_cross_b_star / mag_a_star_cross_b_star)

        # Real-space vectors: a = (b* × c*) × V_cell
        # After rescaling, these will have exactly the user-specified magnitudes
        a_vec = b_star_cross_c_star * V
        b_vec = c_star_cross_a_star * V
        c_vec = a_star_cross_b_star * V

        # Now that we have real-space vectors, re-generate the reciprocal ones
        # This matches the C-code behavior (lines 2103-2119)
        a_cross_b = torch.cross(a_vec, b_vec, dim=0)
        b_cross_c = torch.cross(b_vec, c_vec, dim=0)
        c_cross_a = torch.cross(c_vec, a_vec, dim=0)

        # Recalculate volume from the actual vectors (Core Rule #13)
        # This is crucial - the volume from the vectors is slightly different
        # from the volume calculated by the formula, and we need to use the
        # actual volume for perfect metric duality (a·a* = 1 within 1e-12)
        V_actual = torch.dot(a_vec, b_cross_c)
        # Ensure volume is not too small
[2025-10-06T22:18:26] tokens used: 66,085

[2025-10-06T22:18:34] thinking

**Planning detailed code analysis**

I'm focusing on the long-term goals by analyzing the CLI parity issue and vectorization plan. I'll produce hypotheses about the base lattice mismatch observed in the project, investigate related artifacts without opening new files if possible, and examine how MOSFLM orientation data is handled, especially by checking the config in `src/nanobrag_torch/config.py` to understand possible root causes.
[2025-10-06T22:18:35] exec bash -lc 'rg "mosflm" -n src/nanobrag_torch/config.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:36] bash -lc 'rg "mosflm" -n src/nanobrag_torch/config.py' succeeded in 678ms:
72:    MOSFLM = "mosflm"
126:    mosflm_a_star: Optional[np.ndarray] = None  # MOSFLM a* reciprocal vector (Å⁻¹)
127:    mosflm_b_star: Optional[np.ndarray] = None  # MOSFLM b* reciprocal vector (Å⁻¹)
128:    mosflm_c_star: Optional[np.ndarray] = None  # MOSFLM c* reciprocal vector (Å⁻¹)
[2025-10-06T22:18:36] tokens used: 68,905

[2025-10-06T22:18:38] thinking

**Preparing to read relevant section**
[2025-10-06T22:18:38] exec bash -lc "sed -n '1,200p' src/nanobrag_torch/config.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:39] bash -lc "sed -n '1,200p' src/nanobrag_torch/config.py" succeeded in 717ms:
"""
Configuration dataclasses for nanoBragg PyTorch implementation.

This module defines strongly-typed configuration objects that are intended to
replace the large set of local variables and command-line parsing logic found
in the original C main() function. Each dataclass will correspond to a physical
component of the simulation (Crystal, Detector, Beam).

For a detailed mapping of these dataclass fields to the original nanoBragg.c 
command-line flags, including implicit conventions and common pitfalls, see:
docs/development/c_to_pytorch_config_map.md

C-Code Implementation Reference (from nanoBragg.c):
The configuration is currently handled by a large argument-parsing loop
in main(). The future dataclasses will encapsulate the variables set
in this block.

Representative examples from nanoBragg.c (lines 506-1101):

// Crystal Parameters
[2025-10-06T22:18:39] tokens used: 69,234

[2025-10-06T22:18:41] thinking

**Searching for CLI argument parsing function**
[2025-10-06T22:18:41] exec bash -lc 'rg "from_cli_args" -n src/nanobrag_torch/config.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:42] bash -lc 'rg "from_cli_args" -n src/nanobrag_torch/config.py' succeeded in 696ms:
388:    def from_cli_args(
[2025-10-06T22:18:42] tokens used: 71,765
[2025-10-06T22:18:46] exec bash -lc "sed -n '388,640p' src/nanobrag_torch/config.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:46] bash -lc "sed -n '388,640p' src/nanobrag_torch/config.py" succeeded in 677ms:
    def from_cli_args(
        cls,
        distance_mm: Optional[Union[float, torch.Tensor]] = None,
        close_distance_mm: Optional[Union[float, torch.Tensor]] = None,
        pivot: Optional[str] = None,
        **kwargs
    ) -> "DetectorConfig":
        """Create DetectorConfig from CLI-style arguments with AT-GEO-002 logic.

        This factory method implements the AT-GEO-002 pivot selection requirements:
        - If only -distance is provided: pivot = BEAM
        - If only -close_distance is provided: pivot = SAMPLE
        - If -pivot is explicitly provided: use that (override wins)

        Args:
            distance_mm: Value from -distance flag (None if not provided)
            close_distance_mm: Value from -close_distance flag (None if not provided)
            pivot: Explicit pivot override from -pivot flag ("beam" or "sample")
            **kwargs: Other DetectorConfig parameters

[2025-10-06T22:18:46] tokens used: 71,982

[2025-10-06T22:18:49] thinking

**Investigating matrix loading in CLI**
[2025-10-06T22:18:49] exec bash -lc 'rg "-mat" -n' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:50] bash -lc 'rg "-mat" -n' exited 2 in 728ms:
rg: error parsing flag -m: value is not a valid number: invalid digit found in string
[2025-10-06T22:18:50] tokens used: 74,474

[2025-10-06T22:18:53] thinking

**Adjusting command options syntax**
[2025-10-06T22:18:54] exec bash -lc 'rg -- "-mat"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:18:55] bash -lc 'rg -- "-mat"' succeeded in 786ms:
UBtoA.awk:# make a B-matrix out of any cell
UBtoA.awk:    # if cell is defined, create a B-matrix
UBtoA.awk:# multiply any U-matrix by the current B-matrix
src/nanobrag_torch/__main__.py:  nanoBragg -hkl P1.hkl -mat A.mat -lambda 6.2 -N 5 -distance 100
src/nanobrag_torch/__main__.py:    parser.add_argument('-mat', type=str, metavar='FILE',
src/nanobrag_torch/__main__.py:        print("Usage: nanoBragg -hkl <file> -mat <file> [options...]")
src/nanobrag_torch/__main__.py:        print("Error: Need -mat file or -cell parameters")
src/nanobrag_torch/__main__.py:        print("Usage: nanoBragg -hkl <file> -mat <file> [options...]")
src/nanobrag_torch/__main__.py:                raise ValueError("Wavelength must be specified (via -lambda or -energy) when using -mat")
SPEC_PROMPT.md:    - All synonyms as parsed (e.g., `-mat`, `-hkl`, `-cell`, `-misset`, `-Na`/`-Nb`/`-Nc`/`-N`, detector flags, etc.).
SPEC_PROMPT.md:  - Unsupported example flags: Explicitly list any flags present in the examples but not recognized by this code (e.g., `-pix0_vector_mm` or `-matrix` if absent), and explain the closest supported equivalent if any.
SPEC_PROMPT.md:  - From `-mat` (MOSFLM A): wavelength scaling removal (`1e-10/λ`) and subsequent magnitude updates.
SPEC_PROMPT.md:  - Exact conditions that print warnings or exit; required flags; compatibility constraints (e.g., need `-mat` or `-cell`; HKL vs `default_F`).
context:./nanoBragg -mat auto.mat -hkl P1.hkl -distance 2500
context:./nanoBragg -mat A.mat -hkl P1.hkl -lambda 1 -dispersion 0.1 -dispstep 3 -distance 100  -detsize 100 -pixel 0.1 \
context:            if(strstr(argv[i], "-mat") && (argc > (i+1)))
context:        printf("usage: nanoBragg -mat auto.mat -hkl Fs.hkl\n");
context:        printf("\t-mat filename.mat\tmosflm-style matrix file containing three reciprocal unit cell vectors\n");
context://            if(strstr(argv[i], "-mat") && (argc >= (i+1)))
context:./nanoBragg -hkl P1.hkl -matrix A.mat -lambda 6.2 -N 10
[2025-10-06T22:18:55] tokens used: 74,675

[2025-10-06T22:19:00] thinking

**Preparing for coin flip and analysis**
[2025-10-06T22:19:00] exec bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:01] bash -lc "python - <<'PY'
import random
print(random.choice(['heads','tails']))
PY" succeeded in 729ms:
heads
[2025-10-06T22:19:01] tokens used: 109,344

[2025-10-06T22:19:04] thinking

**Preparing to review recent commits**
[2025-10-06T22:19:04] exec bash -lc 'git status -sb' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:05] bash -lc 'git status -sb' succeeded in 716ms:
## feature/spec-based-2...origin/feature/spec-based-2
[2025-10-06T22:19:05] tokens used: 109,630

[2025-10-06T22:19:10] thinking

**Reviewing recent commits on feature branch**
[2025-10-06T22:19:11] exec bash -lc 'git log --stat -10' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:11] bash -lc 'git log --stat -10' succeeded in 729ms:
commit 06363bcd80983e1d1a7132b47a78b03be246adb1
Author: ollie <ohoidn@slac.stanford.edu>
Date:   Mon Oct 6 15:17:10 2025 -0700

    [SYNC i=52] actor=galph status=running

 sync/state.json | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 82bbc42bdb2bd9f54a38ced37f4411b41ec3084a
Author: ollie <ohoidn>
Date:   Mon Oct 6 15:17:00 2025 -0700

    [SYNC i=52] actor=ralph → next=galph status=ok ralph_commit=2467064

 sync/state.json | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

commit 24670648292c4768a8410fd8c925864be979d975
Author: ollie <ohoidn>
[2025-10-06T22:19:11] tokens used: 109,792

[2025-10-06T22:19:26] thinking

**Assessing recent commits and planning needs**

I’m reviewing Ralph’s last work commits and checking if the existing plans, especially around the base lattice mismatch (K3f), need updates. There’s a plan entry but it may lack detailed task breakdowns and checkboxes for tracking. I’m considering whether to revise or restructure the plan to add clarity and align with new findings before moving on to preparing input files and finalizing steps.
[2025-10-06T22:19:28] exec bash -lc 'rg "nonoise" -n src' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:29] bash -lc 'rg "nonoise" -n src' succeeded in 915ms:
src/nanobrag_torch/__main__.py:339:    parser.add_argument('-nonoise', action='store_true',
src/nanobrag_torch/__main__.py:711:    config['suppress_noise'] = args.nonoise
src/nanobrag_torch/__main__.py:1185:        # CLI-FLAGS-003: Honor -nonoise flag
[2025-10-06T22:19:29] tokens used: 113,031

[2025-10-06T22:19:31] thinking

**Scanning code near line 1185**
[2025-10-06T22:19:32] exec bash -lc "sed -n '1120,1210p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:33] bash -lc "sed -n '1120,1210p' src/nanobrag_torch/__main__.py" succeeded in 746ms:
        print(f"  Mean: {stats['mean']:.3e}")
        print(f"  RMS: {stats['RMS']:.3e}")
        print(f"  RMSD: {stats['RMSD']:.3e}")

        # Write outputs
        if config.get('floatfile'):
            # Write raw float image
            data = intensity.cpu().numpy().astype(np.float32)
            data.tofile(config['floatfile'])
            print(f"Wrote float image to {config['floatfile']}")

        if config.get('intfile'):
            # Scale and write SMV per AT-CLI-006
            scale = config.get('scale')
            adc_offset = config.get('adc', 40.0)

            if not scale or scale <= 0:
                # Auto-scale: map max float pixel to approximately 55,000 counts
                max_val = intensity.max().item()
                if max_val > 0:
[2025-10-06T22:19:33] tokens used: 114,327

[2025-10-06T22:19:36] thinking

**Investigating matrix parsing for -nonoise**
[2025-10-06T22:19:37] exec bash -lc 'rg "mosflm_a_star" -n src' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:37] bash -lc 'rg "mosflm_a_star" -n src' succeeded in 712ms:
src/nanobrag_torch/__main__.py:432:        config['mosflm_a_star'] = a_star  # numpy array from read_mosflm_matrix
src/nanobrag_torch/__main__.py:844:                mosflm_a_star=config.get('mosflm_a_star'),
src/nanobrag_torch/config.py:126:    mosflm_a_star: Optional[np.ndarray] = None  # MOSFLM a* reciprocal vector (Å⁻¹)
src/nanobrag_torch/models/crystal.py:548:            hasattr(self.config, "mosflm_a_star") and self.config.mosflm_a_star is not None
src/nanobrag_torch/models/crystal.py:555:                self.config.mosflm_a_star,
src/nanobrag_torch/models/crystal.py:689:            hasattr(self.config, "mosflm_a_star") and self.config.mosflm_a_star is not None
[2025-10-06T22:19:37] tokens used: 115,699

[2025-10-06T22:19:39] thinking

**Locating parsing logic section**
[2025-10-06T22:19:40] exec bash -lc "sed -n '360,460p' src/nanobrag_torch/__main__.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:40] bash -lc "sed -n '360,460p' src/nanobrag_torch/__main__.py" succeeded in 695ms:
                        help='Disable progress meter')
    parser.add_argument('-progress', action='store_true',
                        help='Enable progress meter')
    parser.add_argument('-seed', type=int,
                        help='Noise RNG seed')
    parser.add_argument('-show_config', '-echo_config', action='store_true',
                        help='Print configuration parameters for debugging')

    # Performance options (PERF-PYTORCH-006)
    parser.add_argument('-dtype', type=str, choices=['float32', 'float64'],
                        default='float32',
                        help='Floating point precision (float32 for speed, float64 for accuracy)')
    parser.add_argument('-device', type=str, choices=['cpu', 'cuda'],
                        default='cpu',
                        help='Device for computation (cpu or cuda)')

    # Explicitly handle unsupported flags from the spec
    parser.add_argument('-dispstep', dest='_unsupported_dispstep',
                        action=UnsupportedFlagAction,
                        supported_alternative='-dispsteps <int>',
[2025-10-06T22:19:40] tokens used: 116,129

[2025-10-06T22:19:43] thinking

**Searching for read_mosflm_matrix function**
[2025-10-06T22:19:43] exec bash -lc 'rg "def read_mosflm_matrix" -n' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:44] bash -lc 'rg "def read_mosflm_matrix" -n' succeeded in 752ms:
src/nanobrag_torch/io/mosflm.py:12:def read_mosflm_matrix(filepath: Union[str, Path], wavelength_A: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
[2025-10-06T22:19:44] tokens used: 117,371
[2025-10-06T22:19:46] exec bash -lc "sed -n '1,200p' src/nanobrag_torch/io/mosflm.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:47] bash -lc "sed -n '1,200p' src/nanobrag_torch/io/mosflm.py" succeeded in 758ms:
"""MOSFLM matrix file I/O utilities.

This module provides functions for reading MOSFLM-style orientation matrices,
which contain reciprocal lattice vectors scaled by wavelength.
"""

import numpy as np
from pathlib import Path
from typing import Tuple, Union


def read_mosflm_matrix(filepath: Union[str, Path], wavelength_A: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Read MOSFLM A matrix file and extract reciprocal lattice vectors.

    The MOSFLM A matrix format contains 9 values (3x3 matrix) where each row
    is a reciprocal lattice vector (a*, b*, c*) in units of Å^-1·(1/λ_Å).

    C-Code Implementation Reference (from nanoBragg.c, lines 3135-3148):
    ```c
    if(matfilename != NULL)
[2025-10-06T22:19:47] tokens used: 117,614

[2025-10-06T22:19:51] thinking

**Examining base lattice mismatch causes**
[2025-10-06T22:19:52] exec bash -lc 'rg "h_frac" -n src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:19:53] bash -lc 'rg "h_frac" -n src/nanobrag_torch' succeeded in 739ms:
src/nanobrag_torch/simulator.py:255:        h_frac = h - h0
src/nanobrag_torch/simulator.py:258:        hrad_sqr = (h_frac * h_frac * Na * Na +
src/nanobrag_torch/simulator.py:267:        h_frac = h - h0
src/nanobrag_torch/simulator.py:272:            delta_r_star = (h_frac.unsqueeze(-1) * rot_a_star.unsqueeze(0).unsqueeze(0).unsqueeze(0) +
src/nanobrag_torch/simulator.py:277:            delta_r_star = (h_frac.unsqueeze(-1) * rot_a_star.unsqueeze(0).unsqueeze(0) +
src/nanobrag_torch/simulator.py:284:        h_frac = h - h0
src/nanobrag_torch/simulator.py:289:            delta_r_star = (h_frac.unsqueeze(-1) * rot_a_star.unsqueeze(0).unsqueeze(0).unsqueeze(0) +
src/nanobrag_torch/simulator.py:294:            delta_r_star = (h_frac.unsqueeze(-1) * rot_a_star.unsqueeze(0).unsqueeze(0) +
[2025-10-06T22:19:53] tokens used: 119,561

[2025-10-06T22:19:58] thinking

**Inspecting surrounding lines**
[2025-10-06T22:20:00] exec bash -lc "sed -n '200,340p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:20:00] bash -lc "sed -n '200,340p' src/nanobrag_torch/simulator.py" succeeded in 742ms:
    k0 = torch.round(k)
    l0 = torch.round(l)

    # Look up structure factors
    F_cell = crystal_get_structure_factor(h0, k0, l0)

    # Ensure F_cell is on the same device as h (device-neutral implementation per Core Rule #16)
    # The crystal.get_structure_factor may return CPU tensors even when h0/k0/l0 are on CUDA
    if F_cell.device != h.device:
        F_cell = F_cell.to(device=h.device)

    # Calculate lattice structure factor
    #
    # C-Code Implementation Reference (from nanoBragg.c, lines 3062-3081):
    # ```c
    # /* structure factor of the lattice (paralelpiped crystal)
    #     F_latt = sin(M_PI*Na*h)*sin(M_PI*Nb*k)*sin(M_PI*Nc*l)/sin(M_PI*h)/sin(M_PI*k)/sin(M_PI*l);
    # */
    # F_latt = 1.0;
    # if(xtal_shape == SQUARE)
[2025-10-06T22:20:00] tokens used: 119,974

[2025-10-06T22:20:07] thinking

**Investigating vector calculations**
[2025-10-06T22:20:07] exec bash -lc 'rg "h =" -n src/nanobrag_torch/simulator.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:20:08] bash -lc 'rg "h =" -n src/nanobrag_torch/simulator.py' succeeded in 693ms:
150:                wavelength = wavelength.view(n_sources, 1, 1)
153:                wavelength = wavelength.view(n_sources, 1, 1, 1)
194:    h = dot_product(scattering_broadcast, rot_a_broadcast)
505:        self.wavelength = torch.tensor(self.beam_config.wavelength_A, device=self.device, dtype=self.dtype)
639:            wavelength = self.wavelength
1025:            airpath = pixel_magnitudes.squeeze(-1)  # Remove last dimension for broadcasting
1270:                    # Following nanoBragg.c convention: h = dot(a, scattering)
1278:                    h = dot_product(scattering_vec.unsqueeze(0), a_vec.unsqueeze(0)).item()
[2025-10-06T22:20:08] tokens used: 135,790

[2025-10-06T22:20:10] thinking

**Scrolling through lines 150-220**
[2025-10-06T22:20:11] exec bash -lc "sed -n '120,220p' src/nanobrag_torch/simulator.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:20:11] bash -lc "sed -n '120,220p' src/nanobrag_torch/simulator.py" succeeded in 668ms:
    if is_multi_source:
        # Multi-source case: broadcast over sources
        # diffracted_beam_unit: (S, F, 3) or (batch, 3)
        # incident_beam_direction: (n_sources, 3)
        # Need to add source dimension to diffracted_beam_unit

        # Add source dimension: (S, F, 3) -> (1, S, F, 3) or (batch, 3) -> (1, batch, 3)
        diffracted_expanded = diffracted_beam_unit.unsqueeze(0)

        # Handle both 2D (batch, 3) and 3D (S, F, 3) cases for incident beam expansion
        if original_n_dims == 2:
            # (batch, 3) case: expand incident to (n_sources, 1, 3)
            incident_expanded = incident_beam_direction.view(n_sources, 1, 3)
        else:
            # (S, F, 3) case: expand incident to (n_sources, 1, 1, 3)
            incident_expanded = incident_beam_direction.view(n_sources, 1, 1, 3)

        # Expand to match diffracted shape
        incident_beam_unit = incident_expanded.expand(n_sources, *diffracted_beam_unit.shape)
        diffracted_beam_unit = diffracted_expanded.expand_as(incident_beam_unit)
[2025-10-06T22:20:11] tokens used: 136,139

[2025-10-06T22:20:15] thinking

**Searching for dot_product function**
[2025-10-06T22:20:16] exec bash -lc 'rg "def dot_product" -n src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:20:17] bash -lc 'rg "def dot_product" -n src/nanobrag_torch' succeeded in 729ms:
src/nanobrag_torch/utils/geometry.py:13:def dot_product(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:
[2025-10-06T22:20:17] tokens used: 137,825
[2025-10-06T22:20:19] exec bash -lc "sed -n '1,80p' src/nanobrag_torch/utils/geometry.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:20:20] bash -lc "sed -n '1,80p' src/nanobrag_torch/utils/geometry.py" succeeded in 714ms:
"""
Vectorized 3D geometry utilities for nanoBragg PyTorch implementation.

This module contains PyTorch implementations of all vector and geometry
operations from the original C code, designed for broadcasting and GPU acceleration.
"""

from typing import Tuple

import torch


def dot_product(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor:
    """
    Calculate dot product of vectors x and y.

    Args:
        x, y: Tensors with shape (..., 3) representing 3D vectors

    Returns:
[2025-10-06T22:20:20] tokens used: 137,995

[2025-10-06T22:20:44] thinking

**Examining rotational vector discrepancies**
[2025-10-06T22:20:44] exec bash -lc 'head -n 5 A.mat' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:20:45] bash -lc 'head -n 5 A.mat' succeeded in 731ms:
-0.02837711 -0.00305386 0.02535816
-0.02871390 0.01019549 -0.01400049
0.01050048 -0.03209440 -0.01036054
[2025-10-06T22:20:45] tokens used: 140,408

[2025-10-06T22:21:02] thinking

**Analyzing matrix reading and transformation**
[2025-10-06T22:21:03] exec bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/per_phi_summary_20251006-151228.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:04] bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/per_phi_summary_20251006-151228.md' succeeded in 900ms:
# CLI-FLAGS-003 Phase K3e: Per-φ Parity Summary

**Generated:** 20251006-151228  
**Target Pixel:** (133, 134)  
**Configuration:** φ ∈ [0°, 0.1°], 10 steps  

## PyTorch Trace

| φ_tic | φ (deg) | h_frac | k_frac | l_frac | F_latt_b | F_latt |
|-------|---------|--------|--------|--------|----------|--------|
| 0 | 0.000000 | 26.415194 | -9.899110 | -11.067192 | 2.326202 | -3.069002e-01 |
| 1 | 0.011111 | 26.419057 | -9.895139 | -11.062391 | 0.688801 | 5.501208e-01 |
| 2 | 0.022222 | 26.422919 | -9.891167 | -11.057591 | -1.055548 | -3.377610e+00 |
| 3 | 0.033333 | 26.426780 | -9.887194 | -11.052792 | -2.341222 | -1.319461e+01 |
| 4 | 0.044444 | 26.430641 | -9.883221 | -11.047993 | -2.786081 | -1.790987e+01 |
| 5 | 0.055556 | 26.434502 | -9.879247 | -11.043194 | -2.300591 | -1.117186e+01 |
| 6 | 0.066667 | 26.438362 | -9.875271 | -11.038395 | -1.098195 | -2.060702e+00 |
| 7 | 0.077778 | 26.442221 | -9.871296 | -11.033597 | 0.390626 | -7.556347e-02 |
| 8 | 0.088889 | 26.446081 | -9.867319 | -11.028800 | 1.668153 | 1.705728e+00 |
| 9 | 0.100000 | 26.449939 | -9.863341 | -11.024003 | 2.332342 | 1.489655e+01 |
[2025-10-06T22:21:04] tokens used: 141,996

[2025-10-06T22:21:08] thinking

**Comparing k_frac calculations between PyTorch and C**
[2025-10-06T22:21:09] exec bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/comparison_summary.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:10] bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/comparison_summary.md' succeeded in 742ms:
# CLI-FLAGS-003 Phase K3e: Per-φ Parity Comparison

**PyTorch:** `per_phi_pytorch_20251006-151228.json`  
**C:**       `per_phi_c_20251006-151228.log`  

## Comparison Table

| φ_tic | φ (deg) | C k_frac | PyTorch k_frac | Δk | Status |
|-------|---------|----------|----------------|-------|--------|
| 0 | 0.000000 | -3.857043 | -9.899110 | 6.042067e+00 | ❌ |
| 1 | 0.011111 | -3.834197 | -9.895139 | 6.060942e+00 | ❌ |
| 2 | 0.022222 | -3.837054 | -9.891167 | 6.054113e+00 | ❌ |
| 3 | 0.033333 | -3.839910 | -9.887194 | 6.047284e+00 | ❌ |
| 4 | 0.044444 | -3.842767 | -9.883221 | 6.040454e+00 | ❌ |
| 5 | 0.055556 | -3.845623 | -9.879247 | 6.033624e+00 | ❌ |
| 6 | 0.066667 | -3.848478 | -9.875271 | 6.026793e+00 | ❌ |
| 7 | 0.077778 | -3.851333 | -9.871296 | 6.019962e+00 | ❌ |
| 8 | 0.088889 | -3.854188 | -9.867319 | 6.013130e+00 | ❌ |
| 9 | 0.100000 | -3.857043 | -9.863341 | 6.006298e+00 | ❌ |

[2025-10-06T22:21:10] tokens used: 150,938

[2025-10-06T22:21:16] thinking

**Formulating scattering vector hypotheses**
[2025-10-06T22:21:16] exec bash -lc 'rg "pixel_coords_angstroms" -n src/nanobrag_torch' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:17] bash -lc 'rg "pixel_coords_angstroms" -n src/nanobrag_torch' succeeded in 802ms:
src/nanobrag_torch/simulator.py:21:    pixel_coords_angstroms: torch.Tensor,
src/nanobrag_torch/simulator.py:74:        pixel_coords_angstroms: Pixel/subpixel coordinates in Angstroms (S, F, 3) or (batch, 3)
src/nanobrag_torch/simulator.py:105:        pixel_coords_angstroms * pixel_coords_angstroms, dim=-1, keepdim=True
src/nanobrag_torch/simulator.py:110:    diffracted_beam_unit = pixel_coords_angstroms / pixel_magnitudes
src/nanobrag_torch/simulator.py:114:    original_n_dims = pixel_coords_angstroms.dim()  # 2 for (batch, 3), 3 for (S, F, 3)
src/nanobrag_torch/simulator.py:329:        # Need diffracted beam direction: pixel_coords_angstroms normalized
src/nanobrag_torch/simulator.py:330:        pixel_magnitudes = torch.norm(pixel_coords_angstroms, dim=-1, keepdim=True).clamp_min(1e-12)
src/nanobrag_torch/simulator.py:331:        diffracted_beam_unit = pixel_coords_angstroms / pixel_magnitudes
src/nanobrag_torch/simulator.py:614:    def _compute_physics_for_position(self, pixel_coords_angstroms, rot_a, rot_b, rot_c, rot_a_star, rot_b_star, rot_c_star, incident_beam_direction=None, wavelength=None, source_weights=None):
src/nanobrag_torch/simulator.py:625:            pixel_coords_angstroms: Pixel/subpixel coordinates in Angstroms (S, F, 3) or (batch, 3)
src/nanobrag_torch/simulator.py:655:            pixel_coords_angstroms=pixel_coords_angstroms,
src/nanobrag_torch/simulator.py:987:            pixel_coords_angstroms = pixel_coords_meters * 1e10
src/nanobrag_torch/simulator.py:1000:                    pixel_coords_angstroms, rot_a, rot_b, rot_c, rot_a_star, rot_b_star, rot_c_star,
src/nanobrag_torch/simulator.py:1009:                    pixel_coords_angstroms, rot_a, rot_b, rot_c, rot_a_star, rot_b_star, rot_c_star
src/nanobrag_torch/simulator.py:1020:                pixel_coords_angstroms * pixel_coords_angstroms, dim=-1, keepdim=True
[2025-10-06T22:21:17] tokens used: 152,224

[2025-10-06T22:21:21] thinking

**Formulating debugging hypotheses**
[2025-10-06T22:21:21] exec bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:22] bash -lc 'cat reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md' succeeded in 727ms:
/home/ollie/Documents/tmp/nanoBragg/reports/2025-10-cli-flags/phase_k/f_latt_fix/mosflm_rescale.py:84: UserWarning: Using torch.cross without specifying the dim arg is deprecated.
Please either pass the dim explicitly or simply use torch.linalg.cross.
The default value of dim will change to agree with that of linalg.cross in a future release. (Triggered internally at /pytorch/aten/src/ATen/native/Cross.cpp:63.)
  b_cross_c = torch.cross(b_star_t, c_star_t)
================================================================================
MOSFLM Lattice Vector Rescaling Comparison
================================================================================

MOSFLM A.mat Reciprocal Vectors:
  a* = [-0.0290511  -0.02939588  0.01074988]
  b* = [-0.00312639  0.01043764 -0.03285667]
  c* = [ 0.02596044 -0.01433302 -0.01060661]

Derived Cell Parameters:
  a = 26.751388 Å
  b = 31.309964 Å
  c = 33.673354 Å
  α = 88.686974°
  β = 71.529482°
  γ = 68.137528°
[2025-10-06T22:21:22] tokens used: 153,146

[2025-10-06T22:21:29] thinking

**Analyzing discrepancy hypotheses**
[2025-10-06T22:21:30] exec bash -lc 'rg "pix0" src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:30] bash -lc 'rg "pix0" src/nanobrag_torch/models/detector.py' succeeded in 708ms:
        # Calculate and cache pix0_vector (position of first pixel)
        self._calculate_pix0_vector()
        self._cached_pix0_vector = self.pix0_vector.clone()
        # These will be set properly in _calculate_pix0_vector
        if not hasattr(self, 'pix0_vector'):
            self.pix0_vector: Optional[torch.Tensor] = None
        # Recalculate pix0_vector when geometry changes
        self._calculate_pix0_vector()
            tuple: (beam_f_m, beam_s_m) in meters for use in pix0_vector calculation
    def _calculate_pix0_vector(self):
        This follows the C-code convention where pix0_vector represents the
        - BEAM pivot: pix0_vector = -Fbeam*fdet_vec - Sbeam*sdet_vec + distance*beam_vec
        - SAMPLE pivot: Calculate pix0_vector BEFORE rotations, then rotate it
            pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
            pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
            pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
            rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
            rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
            pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
            pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
[2025-10-06T22:21:30] tokens used: 155,431

[2025-10-06T22:21:39] thinking

**Analyzing hypotheses for base mismatch and vectorization**

I’m outlining three main hypotheses to explain the base mismatch problem affecting the command run goal, focusing on matrix duplication, pixel coordinate handling, and wavelength units. I’m gathering evidence for each and planning to reference relevant logs and summaries to inform the debugging and triage steps. Let’s explore the data closely to pinpoint the key issues.
[2025-10-06T22:21:41] exec bash -lc 'head -n 50 reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/per_phi_c_20251006-151228.log' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:42] bash -lc 'head -n 50 reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/per_phi_c_20251006-151228.log' succeeded in 897ms:
TRACE_C_PHI phi_tic=0 phi_deg=0 k_frac=-3.85704298045315 F_latt_b=1.77939148054835 F_latt=-0.0625570140028577
TRACE_C_PHI phi_tic=1 phi_deg=0.01 k_frac=-3.83419705804646 F_latt_b=-1.21790270727074 F_latt=1.54153874233339
TRACE_C_PHI phi_tic=2 phi_deg=0.02 k_frac=-3.83705388790269 F_latt_b=-1.79366704149107 F_latt=1.93155250438784
TRACE_C_PHI phi_tic=3 phi_deg=0.03 k_frac=-3.83991040663139 F_latt_b=-2.06868909472476 F_latt=1.84056843465595
TRACE_C_PHI phi_tic=4 phi_deg=0.04 k_frac=-3.84276661414553 F_latt_b=-1.98441265439103 F_latt=1.40640269037669
TRACE_C_PHI phi_tic=5 phi_deg=0.05 k_frac=-3.84562251035812 F_latt_b=-1.54385611388083 F_latt=0.830828267169329
TRACE_C_PHI phi_tic=6 phi_deg=0.06 k_frac=-3.84847809518216 F_latt_b=-0.813075302075891 F_latt=0.31062852261771
TRACE_C_PHI phi_tic=7 phi_deg=0.07 k_frac=-3.85133336853066 F_latt_b=0.0883683024104133 F_latt=-0.0215694825623858
TRACE_C_PHI phi_tic=8 phi_deg=0.08 k_frac=-3.85418833031664 F_latt_b=1.00662020697567 F_latt=-0.128387321961708
TRACE_C_PHI phi_tic=9 phi_deg=0.09 k_frac=-3.85704298045315 F_latt_b=1.77939148054835 F_latt=-0.0625570140028577
[2025-10-06T22:21:42] tokens used: 157,962

[2025-10-06T22:21:49] thinking

**Analyzing cause of `F_latt_b` discrepancy**
[2025-10-06T22:21:50] exec bash -lc 'rg "custom_beam_vector" -n' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:51] bash -lc 'rg "custom_beam_vector" -n' succeeded in 812ms:
src/nanobrag_torch/__main__.py:551:        config['custom_beam_vector'] = tuple(args.beam_vector)
src/nanobrag_torch/__main__.py:884:            custom_beam_vector=config.get('custom_beam_vector'),
src/nanobrag_torch/simulator.py:495:            # - CUSTOM convention with user-supplied custom_beam_vector
docs/fix_plan.md:596:    Next Actions: **Phase H6f required** — Implement custom-vector-to-SAMPLE-pivot forcing rule in `DetectorConfig.__post_init__`/`from_cli_args` (detect any of `custom_fdet_vector`, `custom_sdet_vector`, `custom_odet_vector`, `custom_beam_vector`, or `pix0_override_m` and force `detector_pivot=DetectorPivot.SAMPLE`), add regression test `tests/test_cli_flags.py::test_custom_vectors_force_sample_pivot` (CPU+CUDA), document in `reports/2025-10-cli-flags/phase_h6/pivot_fix.md`, then proceed to Phase H6g (re-run PyTorch trace harness and require |Δpix0| < 5e-5 m before closing H6).
docs/fix_plan.md:805:      - ✅ pix0 override doesn't mutate custom_beam_vector
docs/fix_plan.md:898:    Observations/Hypotheses: CLI parser stores `custom_beam_vector`, but `Detector` and the divergence/dispersion harness select hard-coded convention defaults, so the supervisor command never threads its custom beam direction through. This invalidates assumptions from the earlier trace that incident_vec matched C—the alignment was coincidental because downstream code normalised geometry using `[0,0,1]`.
docs/fix_plan.md:899:  * [2025-10-05] Attempt #11 (ralph) — Result: success. **Phase F1 complete: `_calculate_pix0_vector()` now honors `custom_beam_vector` from CLI.**
docs/fix_plan.md:913:    Next Actions: Update plan Phase E guidance to document beam-vector evidence (done) and prioritize implementation work that (1) threads `custom_beam_vector` into Detector/BeamConfig while preserving differentiability and device/dtype neutrality, and (2) re-runs Phase E traces to confirm both pix0 and beam vectors match before reattempting parity.
docs/fix_plan.md:915:    Metrics: PyTorch beam_vector = `tensor([0., 0., 1.], dtype=torch.float64)` (CUSTOM/XDS default); C log reports user-supplied `-beam_vector 0.00051387949 0.0 -0.99999986`. Confirms CLI parser stores but does not thread `custom_beam_vector` through to detector instantiation.
docs/fix_plan.md:917:    Observations/Hypotheses: CLI successfully parsed all flags including `-beam_vector`, `-pix0_vector_mm`, `-convention CUSTOM` inputs, but `Detector.__init__` ignores `custom_beam_vector` from config and falls back to convention defaults. This is the second geometry gap alongside the pix0 transform issue documented in Attempt #5 (Phase E). Running the evidence harness also created a duplicate copy of the structure-factor file (`scaled.hkl.1`, identical to `scaled.hkl`) in the repo root; treat it as an artefact that needs removal during the upcoming implementation pass so repo hygiene stays intact.
docs/fix_plan.md:918:    Next Actions: (1) Execute plan Phase E tasks E1-E3 to generate full C/PyTorch traces with this configuration; (2) Implement detector fix to accept and use `custom_beam_vector` from config while maintaining differentiability/device-neutrality (documented in detector.md §5); (3) Re-run beam_vector_check to verify alignment before parity retry; (4) Delete the stray `scaled.hkl.1` artefact once the investigation concludes (confirm prior to Protected Assets scan).
docs/fix_plan.md:931:      - Beam vector incident direction **DOES match** in the trace because the harness explicitly sets `simulator.incident_beam_direction`; CLI wiring still ignores `custom_beam_vector` (see Attempt #7 evidence).
docs/fix_plan.md:940:      - `custom_beam_vector` wiring absent in Detector/Simulator; harness `simulator.incident_beam_direction = ...` is a stopgap that masks the gap.
docs/fix_plan.md:944:  * [2025-10-16] Attempt #10 (ralph) — Result: success (Phase F1 complete). **custom_beam_vector threading implemented and validated.**
docs/fix_plan.md:947:      - `src/nanobrag_torch/config.py:212` - Added `custom_beam_vector` field to DetectorConfig
docs/fix_plan.md:949:      - `src/nanobrag_torch/__main__.py:870` - Threaded `custom_beam_vector` from CLI parser to DetectorConfig
docs/fix_plan.md:1077:      - `reports/2025-10-cli-flags/phase_h/trace_harness.py` - Phase H1 harness with custom_beam_vector passed to DetectorConfig
docs/fix_plan.md:1083:      - **ROOT CAUSE:** DetectorConfig receives `custom_beam_vector=[0.00051387949, 0.0, -0.99999986]` from harness (line 112), but Simulator is using MOSFLM default `[1,0,0]` instead
docs/fix_plan.md:1084:      - Detector.beam_vector property exists and should return custom_beam_vector for CUSTOM convention, but simulator's incident_beam_direction is not being set from it
docs/fix_plan.md:1092:    Metrics: incident_vec perfect match (0.00051387949 0 -0.99999986 vs C 0.000513879494 0 -0.999999868). Miller indices diverge: h Δ=0.097, k Δ=0.024, l Δ=0.120 (exceeds 1e-3 threshold). F_latt components critical: Py [-3.29, 10.74, -1.78] vs C [35.89, 38.63, 25.70]; product 62.68 vs C 35636 (568× difference). Pytest: test_custom_beam_vector_propagates 1/1 passed.
[2025-10-06T22:21:51] tokens used: 159,184

[2025-10-06T22:21:54] thinking

**Investigating pixel coordinate calculations**
[2025-10-06T22:21:55] exec bash -lc 'rg "def get_pixel_coords" -n src/nanobrag_torch/models/detector.py' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:55] bash -lc 'rg "def get_pixel_coords" -n src/nanobrag_torch/models/detector.py' succeeded in 731ms:
728:    def get_pixel_coords(self) -> torch.Tensor:
[2025-10-06T22:21:55] tokens used: 162,528
[2025-10-06T22:21:59] exec bash -lc "sed -n '728,940p' src/nanobrag_torch/models/detector.py" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:21:59] bash -lc "sed -n '728,940p' src/nanobrag_torch/models/detector.py" succeeded in 685ms:
    def get_pixel_coords(self) -> torch.Tensor:
        """
        Get 3D coordinates of all detector pixels.

        Supports both planar and curved (spherical) detector mappings.
        For curved detector: pixels are mapped to a spherical arc by rotating
        from the beam direction by angles Sdet/distance and Fdet/distance.

        Returns:
            torch.Tensor: Pixel coordinates with shape (spixels, fpixels, 3) in meters
        """
        # Check if geometry has changed by comparing cached values
        geometry_changed = False
        if hasattr(self, "_cached_basis_vectors") and hasattr(
            self, "_cached_pix0_vector"
        ):
            # Check if basis vectors have changed
            # Move cached vectors to current device for comparison
            cached_f = self._cached_basis_vectors[0].to(self.device)
            cached_s = self._cached_basis_vectors[1].to(self.device)
[2025-10-06T22:21:59] tokens used: 162,684

[2025-10-06T22:22:16] thinking

**Analyzing pixel coordinate computation and planning detailed tasks**

I’m sorting through the pixel coordinate calculations and noticing subtleties in offsets between Python and C code. There’s a clear next step to break down the big K3f task into smaller sub-tasks with checklists in the plan. I’ll also gather and review relevant documentation to accurately inform the upcoming plan update, ensuring a structured approach to the base lattice parity focus issue.
[2025-10-06T22:22:20] exec bash -lc 'rg "lattice" -n docs/architecture/pytorch_design.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:22:21] bash -lc 'rg "lattice" -n docs/architecture/pytorch_design.md' exited 1 in 937ms:

[2025-10-06T22:22:21] tokens used: 166,313

[2025-10-06T22:22:27] thinking

**Preparing to update plan with new tasks**
[2025-10-06T22:22:28] exec bash -lc "sed -n '200,340p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:22:29] bash -lc "sed -n '200,340p' plans/active/cli-noise-pix0/plan.md" succeeded in 764ms:
| L2 | Regression confirmation | [ ] | Run the CLI flag suite plus any new scaling tests (`env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_cli_flags.py tests/test_cli_scaling.py -v`) with results saved to `phase_l/pytest.log`. |
| L3 | Closeout documentation | [ ] | Update docs/fix_plan.md exit criteria, archive this plan per SOP, and note parity completion in `docs/development/testing_strategy.md` if thresholds changed. |
[2025-10-06T22:22:29] tokens used: 167,507

[2025-10-06T22:22:31] thinking

**Requesting earlier context on K tasks**
[2025-10-06T22:22:32] exec bash -lc "sed -n '140,260p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:22:33] bash -lc "sed -n '140,260p' plans/active/cli-noise-pix0/plan.md" succeeded in 733ms:

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| H6a | Instrument C pix0 calculation | [D] | ✅ Attempt #36 (2025-10-24) captured `reports/2025-10-cli-flags/phase_h6/c_trace/trace_c_pix0.log` plus clean extracts/README. SAMPLE pivot confirmed with C pix0 = (-0.216475836, 0.216343050, -0.230192414) m and basis vectors logged post-rotation. |
| H6b | Extend PyTorch trace harness | [D] | ✅ Attempt #37 (2025-10-06) patched `reports/2025-10-cli-flags/phase_h/trace_harness.py` to emit matching `TRACE_PY` lines after Detector geometry setup, removed the hard-coded BEAM pivot, and executed via `PYTHONPATH=src` to guarantee the editable implementation. Trace archived at `phase_h6/py_trace/trace_py_pix0.log` with env/git snapshots; residual ΔF = −1136 µm confirms instrumentation succeeded and Phase H6c analysis is next. |
| H6c | Diff traces & isolate first divergence | [D] | ✅ Attempt #38 (2025-10-26) produced `phase_h6/analysis.md` and `trace_diff.txt`; first divergence is the trace harness labeling beam-center values in millimetres while C logs meters. Pix0 deltas (ΔF = −1.136 mm, ΔS = +0.139 mm) persist, so the physical mismatch remains unresolved. `phase_h5/parity_summary.md` now records these findings. |
| H6d | Update fix_plan attempt log | [D] | ✅ Attempt #36 logged in `docs/fix_plan.md` with trace artifacts, pivot confirmation, and marching orders for H6b/H6c. |
| H6e | Confirm pivot parity (SAMPLE vs BEAM) | [D] | ✅ Attempt #39 (2025-10-06) documented pivot mismatch in `reports/2025-10-cli-flags/phase_h6/pivot_parity.md`. C evidence: `grep "pivoting"` shows "pivoting detector around sample". PyTorch evidence: inline config snippet shows DetectorPivot.BEAM. Root cause confirmed: `DetectorConfig` missing custom-vector-to-SAMPLE-pivot forcing rule. Spec citations and impact analysis complete. Updated `phase_h5/parity_summary.md` with cross-reference. |
| H6f | Align pivot selection when custom vectors provided | [D] | ✅ Attempt #40 (2025-10-26) updated `DetectorConfig.__post_init__` to force SAMPLE pivot whenever custom detector basis vectors (fdet/sdet/odet/beam) are supplied, added regression suite `TestCLIPivotSelection` (CPU+CUDA, float32/float64), relocated visuals under `reports/2025-10-cli-flags/phase_h6/visuals/`, and logged implementation notes at `pivot_fix.md`. |
| H6g | Re-run pix0 traces after pivot fix | [D] | ✅ Attempt #41 (2025-10-27) reran the harness with SAMPLE pivot enforced; `phase_h6/post_fix/trace_py.log`, `trace_diff.txt`, and `metadata.json` show |Δpix0| ≤ 2.85 µm and zero beam-center deltas. nb-compare smoke stored alongside traces; docs/fix_plan Attempt #41 updated. |
| H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
| H5e | Correct beam-center→F/S mapping units | [D] | ✅ 2025-10-24 Attempt #33. `Detector._configure_geometry` now converts `self.config.beam_center_f/s` (mm) to meters via `/1000.0` before computing Fbeam/Sbeam, resolving the 1.1mm ΔF error. All 26 CLI flags tests passing. Artifacts: `src/nanobrag_torch/models/detector.py:490-515`, `docs/fix_plan.md` Attempt #33. Original task: Investigate the 2025-10-22 trace deltas showing ΔF≈-1.1 mm. Confirm `DetectorConfig.beam_center_*` is stored in millimetres (see `__main__.py:915-937`) and update `Detector._configure_geometry` so BEAM-pivot F/S values convert mm→m before constructing pix0 (match `nanoBragg.c:1184-1239`). Add targeted trace demonstrating the fix under `reports/2025-10-cli-flags/phase_h5/unit_fix/` and record Attempt #33 in fix_plan with metrics. |

### Phase I — Polarization Alignment (follow-up)
Goal: Match C’s Kahn polarization factor once lattice geometry aligns.
Prereqs: Phases F–H complete; traces show `F_latt` parity.
Exit Criteria: Polarization entries in C/PyTorch traces agree (≈0.9126 for supervisor command) and parity smoke stays green.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
[2025-10-06T22:22:33] tokens used: 167,763

[2025-10-06T22:22:37] thinking

**Searching for Phase K section**
[2025-10-06T22:22:37] exec bash -lc "sed -n '260,360p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:22:38] bash -lc "sed -n '260,360p' plans/active/cli-noise-pix0/plan.md" succeeded in 688ms:

[2025-10-06T22:22:38] tokens used: 169,460

[2025-10-06T22:22:40] thinking

**Searching for "Phase K" references**
[2025-10-06T22:22:41] exec bash -lc 'rg "Phase K" -n plans/active/cli-noise-pix0/plan.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:22:42] bash -lc 'rg "Phase K" -n plans/active/cli-noise-pix0/plan.md' succeeded in 692ms:
7:- Gap snapshot refresh (2025-10-22): Attempt #31 restored C precedence for custom detector vectors (pix0 override now gated again). Outstanding work: H5c PyTorch traces and Phase K normalization to eliminate the `F_latt`-driven intensity gap.
9:- Gap snapshot refresh (2025-10-26): Attempt #40 completed Phase H6f — custom detector vectors now force SAMPLE pivot parity, parity visuals relocated under `reports/2025-10-cli-flags/phase_h6/visuals/`, and targeted regression tests cover pivot selection. Outstanding work at that point: Phase H6g trace rerun to confirm |Δpix0| < 5e-5 m before returning to Phase K scalings.
10:- Gap snapshot update (2025-10-27): Attempt #41 validated Phase H6g — SAMPLE pivot parity holds with pix0 deltas ≤2.85 µm, beam center deltas 0.0, and supporting artifacts under `reports/2025-10-cli-flags/phase_h6/post_fix/`. Remaining blockers: rerun the scaling chain (Phase K2), execute the scaling regression + doc updates (Phase K3), then resume Phase L parity once normalization matches C.
18:  * `specs/spec-a-core.md` — canonical lattice-factor formulas (SQUARE uses sincg(π·h, Na); ROUND/GAUSS definitions used to verify Phase K).
150:| H5d | Update fix_plan Attempt log | [D] | ✅ 2025-10-22 Attempt #31. docs/fix_plan.md logs the revert metrics and artifacts (Attempt #31), so Phase K normalization work can proceed with the restored baseline. |
162:| I3 | Final parity sweep | [P] | Attempt #27 (2025-10-06) failed with 124,538× intensity scaling gap; remains blocked pending Phase K fixes (orientation rescale + polarization default). |
173:| J3 | Update fix_plan Attempt log | [D] | ✅ 2025-10-19: Attempt #28 logged in `docs/fix_plan.md` with complete metrics, artifacts, and hypothesis (F_latt calculation error in sincg lattice shape factor). Phase I3 remains blocked pending Phase K F_latt fix. |
175:### Phase K — Normalization Implementation
[2025-10-06T22:22:42] tokens used: 169,716
[2025-10-06T22:22:44] exec bash -lc "sed -n '175,260p' plans/active/cli-noise-pix0/plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:22:45] bash -lc "sed -n '175,260p' plans/active/cli-noise-pix0/plan.md" succeeded in 721ms:
### Phase K — Normalization Implementation
Goal: Align PyTorch normalization logic with C based on Phase J evidence (steps division, fluence, r_e², omega/polarization application order).
Prereqs: Phase J report pinpoints the mismatched factor; existing regression suite green.
Exit Criteria: Code changes merged with targeted tests covering the corrected scaling, and docs/fix_plan.md records Attempt #29 metrics before moving to Phase L.

| ID | Task Description | State | How/Why & Guidance |
| --- | --- | --- | --- |
| K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` with embedded C-code reference; regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
| K2 | Recompute scaling chain & extend diagnostics | [D] | ✅ 2025-10-06 Attempt #42. Fresh PyTorch trace captured (trace_py_after.log); scaling chain refreshed showing F_latt_b=46.98 (Py) vs 38.63 (C) = 21.6% error, polar=1.0 (Py) vs 0.913 (C) = 9.6% error. Updated scaling_chain.md with post-SAMPLE-pivot ratios. |
| K2b | Document MOSFLM rescale mismatch | [D] | ✅ 2025-10-06 Attempt #42. Created mosflm_rescale.py and orientation_delta.md. Finding: C skips vector_rescale when `user_cell==0`, but PyTorch still rescales, leading to persistent F_latt_b drift. |
| K3a | Guard MOSFLM rescale path in `Crystal.compute_cell_tensors` | [D] | ✅ 2025-11-06 Attempt #43 (`a89f6fd`): added `mosflm_provided` guard; `mosflm_rescale.py` now reports Δa/b/c=0.0 Å against C (`orientation_delta.md`). |
| K3b | Realign polarization defaults with C | [D] | ✅ 2025-11-06 Attempt #43: `BeamConfig.polarization_factor` defaults to 0.0; CLI regression updated; scaling harness will be re-run once K3e/K3f land. |
| K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
| K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
| K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |

### Phase L — Final Parity & Regression Sweep
Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.
Prereqs: Phases J–K complete; scaling regression tests green.
[2025-10-06T22:22:45] tokens used: 170,448

[2025-10-06T22:22:58] thinking

**Planning detailed expansion for phase K3f**
[2025-10-06T22:23:05] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/plans/active/cli-noise-pix0/plan.md
@@ -189,3 +189,13 @@
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
[2025-10-06T22:23:05] apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M plans/active/cli-noise-pix0/plan.md
[2025-10-06T22:23:05] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.

[2025-10-06T22:23:05] tokens used: 173,640
[2025-10-06T22:23:05] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:23:10] thinking

**Updating Next Actions in docs/fix_plan.md**
[2025-10-06T22:23:11] exec bash -lc "sed -n '472,520p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:23:12] bash -lc "sed -n '472,520p' docs/fix_plan.md" succeeded in 967ms:
    Observations/Hypotheses:
      - **High correlation (0.998) indicates pattern matches:** Shapes and positions correct, magnitudes catastrophically wrong
      - **Intensity ratio 121,250×:** PyTorch raw values ~124,538× higher than C after normalization
      - **Both implementations completed without errors:** Detector geometry, pix0 vectors, convention selection all agree
      - **Hypotheses for debugging loop:**
        1. Missing division by `steps = sources × mosaic × phisteps × oversample²` (C: steps=10 confirmed)
        2. Missing scaling by r_e² (classical electron radius = 2.818×10⁻¹⁵ m; r_e² = 7.94×10⁻³⁰ m²)
        3. Incorrect fluence calculation (C: 1e24 photons/m², PyTorch: verify derivation from flux/exposure/beamsize)
        4. Missing last-value Ω/polarization multiply (per spec § oversample_* semantics with oversample=1)
      - **Tooling success:** nb-compare now handles non-standard detector dimensions (2463×2527 via -detpixels_x/-detpixels_y)
    Next Actions: Superseded by 2025-10-19 directive; follow Phase J checklist in `plans/active/cli-noise-pix0/plan.md` before any implementation work.
  * [2025-10-19] Attempt #28 (ralph) — Result: **EVIDENCE COMPLETE** (Phase J scaling diagnosis). **First divergence identified: `I_before_scaling` caused by F_latt calculation error.**
    Metrics: C I_before_scaling=1.48e15, PyTorch I_before_scaling=5.34e8 (ratio=3.6e-7, ~2772× difference). Root cause: F_latt components differ drastically (C: F_latt_a=35.9, F_latt_b=38.6, F_latt_c=25.7 → F_latt=35636; PyTorch: F_latt_a=-2.4, F_latt_b=11.8, F_latt_c=-2.7 → F_latt=76.9). This 463× F_latt error squares to create the observed ~2e5× intensity gap.
    Artifacts:
      - `reports/2025-10-cli-flags/phase_j/trace_c_scaling.log` - C scaling trace for pixel (1039,685)
      - `reports/2025-10-cli-flags/phase_j/trace_py_scaling.log` - PyTorch scaling trace for same pixel
      - `reports/2025-10-cli-flags/phase_j/analyze_scaling.py` - Analysis script computing factor-by-factor ratios
      - `reports/2025-10-cli-flags/phase_j/scaling_chain.md` - Full ratio analysis and diagnosis
    Observations/Hypotheses:
      - **F_latt components diverge before normalization:** C values (35.9, 38.6, 25.7) vs PyTorch (-2.4, 11.8, -2.7) indicate lattice shape factor calculation error
[2025-10-06T22:23:12] tokens used: 175,658
[2025-10-06T22:23:12] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:23:17] thinking

**Locating Next Actions section**
[2025-10-06T22:23:18] exec bash -lc "sed -n '456,482p' docs/fix_plan.md" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:23:19] bash -lc "sed -n '456,482p' docs/fix_plan.md" succeeded in 675ms:
  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
- First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
- Next Actions (2025-10-06 refresh):
  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
- Attempts History:
  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
    Artifacts:
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/summary.json` - Complete parity metrics (correlation, RMSE, sums, peak distances)
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/c_stdout.txt` - C simulation output (max_I=446.254, fluence=1e24, steps=10)
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/py_stdout.txt` - PyTorch output (max_I=5.411e7)
      - `reports/2025-10-cli-flags/phase_i/supervisor_command/diff.png` - Difference heatmap (559 KB)
      - `scripts/nb_compare.py:118-180,396-397` - **Tooling fix deployed:** Added -detpixels_x/-detpixels_y parsing to load_float_image()
    Observations/Hypotheses:
      - **High correlation (0.998) indicates pattern matches:** Shapes and positions correct, magnitudes catastrophically wrong
      - **Intensity ratio 121,250×:** PyTorch raw values ~124,538× higher than C after normalization
      - **Both implementations completed without errors:** Detector geometry, pix0 vectors, convention selection all agree
[2025-10-06T22:23:19] tokens used: 178,685
[2025-10-06T22:23:19] turn diff:
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:23:23] thinking

**Updating next actions list with phases**

I'll revise the Next Actions bullets to reflect the new phased plan with dates, detailing steps for phases K3f1–K3f4 and the follow-up K3c, ensuring dates and tasks stay aligned with the latest plan update.
[2025-10-06T22:23:27] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/docs/fix_plan.md
@@ -457,6 +457,6 @@
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
[2025-10-06T22:23:27] apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M docs/fix_plan.md
[2025-10-06T22:23:27] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.

[2025-10-06T22:23:27] tokens used: 180,608
[2025-10-06T22:23:27] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:23:59] thinking

**Preparing detailed supervisor memo**
[2025-10-06T22:24:10] exec bash -lc "cat <<'EOF' > input.md
Summary: Capture C/PyTorch base-lattice traces to isolate the Δk≈6 gap.
Phase: Evidence
Focus: CLI-FLAGS-003 / Phase K3f — Base lattice & scattering parity
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
Do Now: CLI-FLAGS-003 Phase K3f1 – run "'`NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
- docs/fix_plan.md (CLI-FLAGS-003 Next Actions) now points to K3f1–K3f4 as the gating work toward long-term goal #1.
- specs/spec-a-core.md (lattice factor) is needed to interpret h/k/l tolerances while reviewing trace output.
- docs/architecture/detector.md (SAMPLE pivot & beam definitions) anchors expected pixel geometry for Δk diagnosis.
How-To Map:
- Add `TRACE_C_BASE` printf blocks near MOSFLM load, real-vector recomputation, and scattering-vector setup inside `golden_suite_generator/nanoBragg.c`; rebuild with `timeout 30 make -C golden_suite_generator`.
- Run the Do Now command; confirm the log includes MOSFLM a*/b*/c*, real a/b/c, and φ=0 scattering vector components; stash under base_lattice/c_trace.log.
- Mirror the fields in PyTorch by extending `reports/2025-10-cli-flags/phase_k/trace_harness.py` to emit `TRACE_PY_BASE` lines, then execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`.
- Note any instrumentation edits in Attempts History; keep CLAUDE Rule #8 (reuse production helpers) intact.
Pitfalls To Avoid:
- Do not modify simulator normalization paths yet; this loop is evidence-only.
- Keep instrumentation in `golden_suite_generator/` and reports scripts—no hacks inside src/ modules.
- Preserve SAMPLE pivot behavior; avoid toggling detector pivots while logging data.
- Ensure logs print double precision (%.15g) to match existing trace tooling.
- Avoid `pytest` entirely this loop; Evidence phase forbids it.
- Verify `NB_C_BIN` points to the instrumented binary before running.
- Don’t rely on cached pixel coordinates—reinitialize detector if basis vectors change.
- Retain the `TRACE_*` prefixes exactly; comparison tooling expects them.
Pointers:
- plans/active/cli-noise-pix0/plan.md (Phase K3f tasks)
- docs/fix_plan.md (CLI-FLAGS-003 entry)
- docs/architecture/detector.md (§5 pix0 & pivots)
- docs/architecture/pytorch_design.md (§2 lattice pipeline)
- specs/spec-a-core.md (§4 lattice factor equations)
Next Up: Phase K3f3 diff/summary once both traces land.
EOF
' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:24:11] bash -lc "cat <<'EOF' > input.md
Summary: Capture C/PyTorch base-lattice traces to isolate the Δk≈6 gap.
Phase: Evidence
Focus: CLI-FLAGS-003 / Phase K3f — Base lattice & scattering parity
Branch: feature/spec-based-2
Mapped tests: none — evidence-only
Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
Do Now: CLI-FLAGS-003 Phase K3f1 – run "'`NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
Priorities & Rationale:
- plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
- docs/fix_plan.md (CLI-FLAGS-003 Next Actions) now points to K3f1–K3f4 as the gating work toward long-term goal #1.
- specs/spec-a-core.md (lattice factor) is needed to interpret h/k/l tolerances while reviewing trace output.
- docs/architecture/detector.md (SAMPLE pivot & beam definitions) anchors expected pixel geometry for Δk diagnosis.
How-To Map:
- Add `TRACE_C_BASE` printf blocks near MOSFLM load, real-vector recomputation, and scattering-vector setup inside `golden_suite_generator/nanoBragg.c`; rebuild with `timeout 30 make -C golden_suite_generator`.
- Run the Do Now command; confirm the log includes MOSFLM a*/b*/c*, real a/b/c, and φ=0 scattering vector components; stash under base_lattice/c_trace.log.
- Mirror the fields in PyTorch by extending `reports/2025-10-cli-flags/phase_k/trace_harness.py` to emit `TRACE_PY_BASE` lines, then execute `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`.
- Note any instrumentation edits in Attempts History; keep CLAUDE Rule #8 (reuse production helpers) intact.
Pitfalls To Avoid:
- Do not modify simulator normalization paths yet; this loop is evidence-only.
- Keep instrumentation in `golden_suite_generator/` and reports scripts—no hacks inside src/ modules.
- Preserve SAMPLE pivot behavior; avoid toggling detector pivots while logging data.
- Ensure logs print double precision (%.15g) to match existing trace tooling.
- Avoid `pytest` entirely this loop; Evidence phase forbids it.
- Verify `NB_C_BIN` points to the instrumented binary before running.
- Don’t rely on cached pixel coordinates—reinitialize detector if basis vectors change.
- Retain the `TRACE_*` prefixes exactly; comparison tooling expects them.
Pointers:
- plans/active/cli-noise-pix0/plan.md (Phase K3f tasks)
- docs/fix_plan.md (CLI-FLAGS-003 entry)
- docs/architecture/detector.md (§5 pix0 & pivots)
- docs/architecture/pytorch_design.md (§2 lattice pipeline)
- specs/spec-a-core.md (§4 lattice factor equations)
Next Up: Phase K3f3 diff/summary once both traces land.
EOF
' succeeded in 998ms:

[2025-10-06T22:24:11] tokens used: 184,218
[2025-10-06T22:24:11] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:24:28] thinking

**Clarifying environment variable usage in commands**

I'm working through how to properly instruct running a long shell command involving an environment variable `NB_C_BIN`. It’s tricky because inline setting of `NB_C_BIN` doesn’t expand inside the same command line, so referencing `$NB_C_BIN` won’t work as expected. To avoid confusion, I’m leaning toward simplifying the “Do Now” instruction by removing the `NB_C_BIN` prefix and directly calling the binary path with timeout. I’ll adjust the documentation accordingly and suggest setting the environment variable separately if needed later.
[2025-10-06T22:24:34] apply_patch auto_approved=true:
M /Users/ollie/Documents/nanoBragg3/input.md
@@ -6,3 +6,3 @@
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
[2025-10-06T22:24:34] apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M input.md
[2025-10-06T22:24:34] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.

[2025-10-06T22:24:34] tokens used: 186,929
[2025-10-06T22:24:34] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:24:39] thinking

**Reviewing How-To map for environment variables**
[2025-10-06T22:24:40] exec bash -lc 'git status -sb' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:24:41] bash -lc 'git status -sb' succeeded in 963ms:
## feature/spec-based-2...origin/feature/spec-based-2 [ahead 1]
 M docs/fix_plan.md
 M input.md
 M plans/active/cli-noise-pix0/plan.md
[2025-10-06T22:24:41] tokens used: 188,450
[2025-10-06T22:24:41] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:24:46] thinking

**Preparing to review recent commit**
[2025-10-06T22:24:47] exec bash -lc 'git diff' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:24:48] bash -lc 'git diff' succeeded in 757ms:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333c..6ed8cf1 100644
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
[2025-10-06T22:24:48] tokens used: 188,716
[2025-10-06T22:24:48] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:24:51] thinking

**Preparing to commit changes**
[2025-10-06T22:24:52] exec bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:24:52] bash -lc 'git add docs/fix_plan.md plans/active/cli-noise-pix0/plan.md input.md' succeeded in 713ms:

[2025-10-06T22:24:52] tokens used: 190,555
[2025-10-06T22:24:52] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:24:56] thinking

**Committing with specified message**
[2025-10-06T22:24:58] exec bash -lc 'git commit -m "SUPERVISOR: CLI parity K3f prep - tests: not run"' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:24:58] bash -lc 'git commit -m "SUPERVISOR: CLI parity K3f prep - tests: not run"' succeeded in 709ms:
[feature/spec-based-2 e057015] SUPERVISOR: CLI parity K3f prep - tests: not run
 3 files changed, 44 insertions(+), 41 deletions(-)
[2025-10-06T22:24:58] tokens used: 190,741
[2025-10-06T22:24:58] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:25:01] thinking

**Pushing changes to remote**
[2025-10-06T22:25:01] exec bash -lc 'git push' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:25:04] bash -lc 'git push' succeeded in 2.32s:
To github.com:hoidn/nanoBragg.git
   06363bc..e057015  feature/spec-based-2 -> feature/spec-based-2
[2025-10-06T22:25:04] tokens used: 191,344
[2025-10-06T22:25:04] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:25:11] thinking

**Updating galph_memory.md with summary and next steps**

I'll add a new dated section to galph_memory.md that concisely captures recent actions like the git pull and plan updates, along with key findings such as the base-lattice parity issue, and outline follow-up tasks for Ralph to keep everything organized and ensure clear next steps.
[2025-10-06T22:25:15] exec bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-11-07 (galph loop — K3f baseline instrumentation)
- "'`git pull --rebase` clean; reviewed latest Attempt logs and vectorization backlog.
- Deep dive confirmed long-term Goal #1 still blocked by Δk≈6 gap (CLI-FLAGS-003); F_latt parity depends on capturing base lattice & scattering traces before φ rotation.
- Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
- Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
- Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
EOF' in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:25:16] bash -lc "cat <<'EOF' >> galph_memory.md

## 2025-11-07 (galph loop — K3f baseline instrumentation)
- "'`git pull --rebase` clean; reviewed latest Attempt logs and vectorization backlog.
- Deep dive confirmed long-term Goal #1 still blocked by Δk≈6 gap (CLI-FLAGS-003); F_latt parity depends on capturing base lattice & scattering traces before φ rotation.
- Refreshed `plans/active/cli-noise-pix0/plan.md` Phase K3f with checklist K3f1–K3f4 (instrument C/Py, diff traces, document root cause) and synced `docs/fix_plan.md` Next Actions to match.
- Issued new Evidence-phase input.md directing Ralph to execute K3f1 (C trace run) and stage matching PyTorch harness output under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
- Next Ralph steps: add TRACE_C_BASE instrumentation, run the supervisor command into `base_lattice/c_trace.log`, extend the Py harness for `TRACE_PY_BASE`, and prep for K3f3 diff once both logs exist.
EOF' succeeded in 893ms:

[2025-10-06T22:25:16] tokens used: 192,436
[2025-10-06T22:25:16] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:25:46] thinking

**Summarizing final response components**

I’m gathering all key points for the final message: hypotheses with evidence for debugging, review of recent commits by Ralph with evaluation, updates to the plan and fix_plan docs, notes on no code changes, and next steps including file references with approximate line numbers for clarity. I’ll organize this carefully to ensure a clear, structured final response.
[2025-10-06T22:25:48] exec bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '170,240p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:25:49] bash -lc "nl -ba plans/active/cli-noise-pix0/plan.md | sed -n '170,240p'" succeeded in 857ms:
   170	| --- | --- | --- | --- |
   171	| J1 | Capture single-pixel scaling traces | [D] | ✅ 2025-10-19: C trace (`trace_c_scaling.log`) and PyTorch trace (`trace_py_scaling.log`) captured for pixel (1039,685) with full scaling chain (`steps`, `I_before_scaling`, `r_e²`, `fluence`, `polar`, `omega`). |
   172	| J2 | Compute factor-by-factor ratios | [D] | ✅ 2025-10-19: `analyze_scaling.py` created and executed; identifies first divergence as `I_before_scaling` with Py/C ratio=3.6e-7. Root cause: F_latt components differ by ~463× (C: 35636 vs PyTorch: 76.9). Markdown report at `scaling_chain.md`. |
   173	| J3 | Update fix_plan Attempt log | [D] | ✅ 2025-10-19: Attempt #28 logged in `docs/fix_plan.md` with complete metrics, artifacts, and hypothesis (F_latt calculation error in sincg lattice shape factor). Phase I3 remains blocked pending Phase K F_latt fix. |
   174	
   175	### Phase K — Normalization Implementation
   176	Goal: Align PyTorch normalization logic with C based on Phase J evidence (steps division, fluence, r_e², omega/polarization application order).
   177	Prereqs: Phase J report pinpoints the mismatched factor; existing regression suite green.
   178	Exit Criteria: Code changes merged with targeted tests covering the corrected scaling, and docs/fix_plan.md records Attempt #29 metrics before moving to Phase L.
   179	
   180	| ID | Task Description | State | How/Why & Guidance |
   181	| --- | --- | --- | --- |
   182	| K1 | Align lattice factor math with C (SQUARE case) | [D] | ✅ 2025-10-24 Attempt #34 (commit 0fef8f7). `Simulator._compute_physics_for_position` now uses `sincg(torch.pi * h, Na)` with embedded C-code reference; regression `tests/test_cli_scaling.py::test_f_latt_square_matches_c` added (skips unless `NB_RUN_PARALLEL=1`). |
   183	| K2 | Recompute scaling chain & extend diagnostics | [D] | ✅ 2025-10-06 Attempt #42. Fresh PyTorch trace captured (trace_py_after.log); scaling chain refreshed showing F_latt_b=46.98 (Py) vs 38.63 (C) = 21.6% error, polar=1.0 (Py) vs 0.913 (C) = 9.6% error. Updated scaling_chain.md with post-SAMPLE-pivot ratios. |
   184	| K2b | Document MOSFLM rescale mismatch | [D] | ✅ 2025-10-06 Attempt #42. Created mosflm_rescale.py and orientation_delta.md. Finding: C skips vector_rescale when `user_cell==0`, but PyTorch still rescales, leading to persistent F_latt_b drift. |
   185	| K3a | Guard MOSFLM rescale path in `Crystal.compute_cell_tensors` | [D] | ✅ 2025-11-06 Attempt #43 (`a89f6fd`): added `mosflm_provided` guard; `mosflm_rescale.py` now reports Δa/b/c=0.0 Å against C (`orientation_delta.md`). |
   186	| K3b | Realign polarization defaults with C | [D] | ✅ 2025-11-06 Attempt #43: `BeamConfig.polarization_factor` defaults to 0.0; CLI regression updated; scaling harness will be re-run once K3e/K3f land. |
   187	| K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
   188	| K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
   189	| K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
[2025-10-06T22:25:49] tokens used: 227,236
[2025-10-06T22:25:49] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:25:51] thinking

**Recording line numbers in fix_plan.md**
[2025-10-06T22:25:52] exec bash -lc "nl -ba docs/fix_plan.md | sed -n '452,470p'" in /Users/ollie/Documents/nanoBragg3
[2025-10-06T22:25:53] bash -lc "nl -ba docs/fix_plan.md | sed -n '452,470p'" succeeded in 731ms:
   452	- Owner/Date: ralph/2025-10-05
   453	- Plan Reference: `plans/active/cli-noise-pix0/plan.md`
   454	- Reproduction (C & PyTorch):
   455	  * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   456	  * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
   457	- First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
   458	- Next Actions (2025-11-07 refresh):
   459	  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
   460	  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
   461	  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
   462	- Attempts History:
   463	  * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
   464	    Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
   465	    Artifacts:
   466	      - `reports/2025-10-cli-flags/phase_i/supervisor_command/README.md` - Full evidence report with metrics, hypotheses, next actions
   467	      - `reports/2025-10-cli-flags/phase_i/supervisor_command/summary.json` - Complete parity metrics (correlation, RMSE, sums, peak distances)
   468	      - `reports/2025-10-cli-flags/phase_i/supervisor_command/c_stdout.txt` - C simulation output (max_I=446.254, fluence=1e24, steps=10)
   469	      - `reports/2025-10-cli-flags/phase_i/supervisor_command/py_stdout.txt` - PyTorch output (max_I=5.411e7)
   470	      - `reports/2025-10-cli-flags/phase_i/supervisor_command/diff.png` - Difference heatmap (559 KB)
[2025-10-06T22:25:53] tokens used: 232,319
[2025-10-06T22:25:53] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.


[2025-10-06T22:26:04] thinking

**Composing final summary message**

I'm putting together a concise, friendly final message that covers analysis findings, evaluation of Ralph's commits, hypothesis with evidence and next steps, relevant plan and memory file updates with line references, and notes on no tests run, all structured with bulleted lists for clarity.
[2025-10-06T22:26:05] codex

**Key Findings**
- CLI parity still blocked by base-lattice mismatch: per-φ traces show Δk≈6 at every φ_tic, so the gap occurs before any rotation (`reports/2025-10-cli-flags/phase_k/f_latt_fix/per_phi/comparison_summary.md`). Leading hypothesis is that pixel geometry / scattering-vector setup doesn’t yet match C (confidence medium); confirming step is K3f1/K3f2 instrumentation to log MOSFLM vectors, real vectors, and φ=0 scattering components.
- Triage ruled out two alternates: MOSFLM orientation is already in lock-step (Δ=0 in `reports/2025-10-cli-flags/phase_k/f_latt_fix/orientation_delta.md`), and dtype rounding isn’t the culprit (float32/float64 both miss by 93.98% in `reports/2025-10-cli-flags/phase_k/f_latt_fix/dtype_sweep/dtype_sensitivity.md`). No further action on those.
- Vectorization initiative untouched since plan creation; Phase A baselines (tests + benchmarks) remain open in `plans/active/vectorization.md`.

**Ralph Review (coin flip heads)**
- Commit 2467064 adds per-φ tooling / evidence—valuable groundwork, no regressions spotted.
- Commit 271e2b6 executes dtype sweep and clearly documents why precision isn’t the issue; productive evidence loop.
- No corrective feedback needed beyond guiding toward the new K3f instrumentation.

**Plan & Fix-Plan Updates**
- Added Phase K3f checklist (K3f1–K3f4) to drive lattice/scattering diagnostics (`plans/active/cli-noise-pix0/plan.md:190`).
- Synced CLI-FLAGS-003 Next Actions with the new baseline tasks (`docs/fix_plan.md:458`).
- Input memo replaced with Evidence-phase instructions for K3f1 (C trace) plus Py harness follow-up (`input.md:1`).
- Logged loop decisions in `galph_memory.md`.

**Next Guidance**
1. Execute K3f1/K3f2 per input.md, stash logs under `reports/2025-10-cli-flags/phase_k/base_lattice/`.
2. After both traces exist, move to K3f3 diffing, then document root cause via K3f4.
3. Hold off on vectorization work until CLI parity resumes bandwidth; Phase A baselines stay waiting.

No tests were run.
[2025-10-06T22:26:11] tokens used: 234,430
[2025-10-06T22:26:11] turn diff:
diff --git a/docs/fix_plan.md b/docs/fix_plan.md
index 85b333cb4b6c783fc5ff98f8a27c9191d264ae30..6ed8cf1869534b4ab3d16bcb0df69d4f6d411925
--- a/docs/fix_plan.md
+++ b/docs/fix_plan.md
@@ -455,10 +455,10 @@
   * C: Run the supervisor command from `prompts/supervisor.md` (with and without `-nonoise`) using `NB_C_BIN=./golden_suite_generator/nanoBragg`; capture whether the noisefile is skipped and log `DETECTOR_PIX0_VECTOR`.
   * PyTorch: After implementation, `nanoBragg` CLI should parse the same command, respect the pix0 override, and skip noise writes when `-nonoise` is present.
 - First Divergence (if known): Phase K3e evidence reveals a **fundamental lattice/geometry mismatch**, not a φ-grid offset. C reports `k_frac≈−3.857` across all φ steps while PyTorch reports `k_frac≈−9.899` (Δk≈6.04 at φ=0°). This 6-unit discrepancy indicates the base reciprocal lattice vectors or scattering geometry differ before any φ rotation is applied.
-- Next Actions (2025-10-06 refresh):
-  1. Phase K3f — K3e evidence proves Δk≈6 at **all** φ steps, ruling out φ-sampling as the root cause. Instead, debug base lattice vectors: compare `a_star/b_star/c_star` from MOSFLM matrix loading, verify reciprocal→real conversion, and trace `a/b/c` vectors before φ rotation to identify where the 6-unit k offset originates.
-  2. Phase K3f (continued) — Once base lattice parity is restored, regenerate scaling-chain memo and confirm Δk<5e-4 across φ steps, then stage code/tests/docs updates.
-  3. Phase K3c — after K3f lands, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh documentation (`docs/architecture/pytorch_design.md`, `docs/development/testing_strategy.md`), and log Attempt #45 with post-fix metrics.
+- Next Actions (2025-11-07 refresh):
+  1. Phase K3f1–K3f3 — Generate matching C/PyTorch baseline traces for MOSFLM vectors, real lattice vectors, and φ=0 scattering components under `reports/2025-10-cli-flags/phase_k/base_lattice/`, then diff them to pinpoint the first component deviating beyond 5e-4.
+  2. Phase K3f4 — Document the diagnosed root cause and planned remediation in the new `base_lattice/summary.md`, update this plan + fix_plan with the chosen implementation approach before touching simulator/detector code.
+  3. Phase K3c — After K3f resolves the Δk≈6 gap, rerun `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v`, refresh normalization docs, and log the closure attempt.
 - Attempts History:
   * [2025-10-06] Attempt #27 (ralph) — Result: **PARITY FAILURE** (Phase I3 supervisor command). **Intensity scaling discrepancy: 124,538× sum ratio.**
     Metrics: Correlation=0.9978 (< 0.999 threshold), sum_ratio=124,538 (should be ~1.0), C max_I=446, PyTorch max_I=5.411e7 (121,000× discrepancy), mean_peak_distance=37.79 px (> 1 px threshold).
diff --git a/input.md b/input.md
index e1be22e4047e431d5a85668074f56575a99f51b4..c02d75ef0517b3d9d1af55461cbd022daa75528d
--- a/input.md
+++ b/input.md
@@ -4,7 +4,7 @@
 Branch: feature/spec-based-2
 Mapped tests: none — evidence-only
 Artifacts: reports/2025-10-cli-flags/phase_k/base_lattice/
-Do Now: CLI-FLAGS-003 Phase K3f1 – run `NB_C_BIN=./golden_suite_generator/nanoBragg timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
+Do Now: CLI-FLAGS-003 Phase K3f1 – run `timeout 30 ./golden_suite_generator/nanoBragg -mat A.mat -floatfile img.bin -hkl scaled.hkl -nonoise -nointerpolate -oversample 1 -exposure 1 -flux 1e18 -beamsize 1.0 -spindle_axis -1 0 0 -Xbeam 217.742295 -Ybeam 213.907080 -distance 231.274660 -lambda 0.976800 -pixel 0.172 -detpixels_x 2463 -detpixels_y 2527 -odet_vector -0.000088 0.004914 -0.999988 -sdet_vector -0.005998 -0.999970 -0.004913 -fdet_vector 0.999982 -0.005998 -0.000118 -pix0_vector_mm -216.336293 215.205512 -230.200866 -beam_vector 0.00051387949 0.0 -0.99999986 -Na 36 -Nb 47 -Nc 29 -osc 0.1 -phi 0 -phisteps 10 -detector_rotx 0 -detector_roty 0 -detector_rotz 0 -twotheta 0 2>&1 | tee reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`
 If Blocked: Capture a fresh per-φ summary via `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python scripts/trace_per_phi.py --out reports/2025-10-cli-flags/phase_k/base_lattice/per_phi_probe.json` and log the failure in Attempts History.
 Priorities & Rationale:
 - plans/active/cli-noise-pix0/plan.md (Phase K3f table) mandates C+Py baseline traces before any normalization fixes.
diff --git a/plans/active/cli-noise-pix0/plan.md b/plans/active/cli-noise-pix0/plan.md
index 9f6ed2df3401d4a2c720ee33327001225a0f2d64..86f63a02aeebe7b1cb4cab93f6e4c09932cb2af3
--- a/plans/active/cli-noise-pix0/plan.md
+++ b/plans/active/cli-noise-pix0/plan.md
@@ -187,7 +187,17 @@
 | K3d | Diagnose dtype sensitivity of F_latt | [D] | ✅ 2025-11-06 Attempt #44 (`271e2b6`): float64 sweep stored under `phase_k/f_latt_fix/dtype_sweep/` proved precision is not the culprit (F_latt_b error persists at 93.98%). |
 | K3c | Regression & documentation close-out | [ ] | `env KMP_DUPLICATE_LIB_OK=TRUE NB_RUN_PARALLEL=1 pytest tests/test_cli_scaling.py::test_f_latt_square_matches_c -v` plus any new normalization tests. Save log as `phase_k/f_latt_fix/pytest_post_fix.log`, update `docs/architecture/pytorch_design.md` normalization notes and `docs/development/testing_strategy.md`, then record Attempt #43 with metrics and artifacts. |
 | K3e | Capture per-φ Miller index parity | [D] | ✅ 2025-10-06 Attempt #45 (ralph). Created `scripts/trace_per_phi.py`, generated PyTorch trace (`per_phi_pytorch_20251006-151228.json`), added TRACE_C_PHI to nanoBragg.c:3156-3160, ran C trace, compared via `scripts/compare_per_phi_traces.py`. **Finding:** Δk≈6.042 at φ=0° (C k_frac=−3.857, Py k_frac=−9.899), persists across all φ steps. **Root cause:** Not a φ-sampling issue—base lattice vectors or scattering geometry differ before φ rotation. |
-| K3f | Debug base lattice vectors + scattering geometry | [ ] | **REDIRECTED per K3e findings.** K3e proves Δk≈6 at φ=0° (before rotation), ruling out φ-sampling. New scope: (1) Add C trace for MOSFLM a_star/b_star/c_star after matrix load, (2) Add PyTorch trace for same, (3) Compare reciprocal→real conversion (cell_a/b/c formulas), (4) Log a/b/c vectors BEFORE φ rotation, (5) Verify scattering vector S=(d-i)/λ uses identical pixel_pos/pix0/detector geometry. Once base lattice parity achieved (Δk<5e-4), regenerate scaling_chain.md, rerun pytest, capture Attempt #46. |
+#### Phase K3f — Base lattice & scattering parity
+Goal: Eliminate the Δk≈6.0 mismatch uncovered in K3e by proving base lattice vectors, pixel geometry, and scattering-vector math match C before φ rotation.
+Prereqs: K3e per-φ evidence archived; MOSFLM rescale guard (K3a) merged; pix0 SAMPLE pivot parity validated (H6g).
+Exit Criteria: Trace comparison shows |Δh|, |Δk|, |Δl| < 5e-4 at φ=0° with matching lattice vectors and scattering vectors; scaling_chain.md refreshed with post-fix numbers; docs/fix_plan Attempt #46 logged.
+
+| ID | Task Description | State | How/Why & Guidance |
+| --- | --- | --- | --- |
+| K3f1 | Capture C baseline for lattice + scattering | [ ] | Instrument `golden_suite_generator/nanoBragg.c` to dump `a_star/b_star/c_star`, real `a/b/c`, and φ=0 scattering vector components right after MOSFLM load and before phi loop. Rebuild via `make -C golden_suite_generator` and run supervisor command with `TRACE_C_BASE` lines redirected to `reports/2025-10-cli-flags/phase_k/base_lattice/c_trace.log`. |
+| K3f2 | Extend PyTorch trace harness with matching fields | [ ] | Update `reports/2025-10-cli-flags/phase_k/trace_harness.py` (or new helper) to emit `TRACE_PY_BASE` lines capturing the same quantities (MOSFLM vectors, real vectors pre-φ, scattering vector at φ=0). Execute with `PYTHONPATH=src KMP_DUPLICATE_LIB_OK=TRUE python reports/2025-10-cli-flags/phase_k/trace_harness.py --out reports/2025-10-cli-flags/phase_k/base_lattice/trace_py.log`. |
+| K3f3 | Diff base traces & isolate first divergence | [ ] | Author a comparison script (extend `scripts/compare_per_phi_traces.py` or add `compare_base_lattice.py`) that aligns C/Py logs and reports vector component deltas plus scattering-vector residuals. Store summary in `reports/2025-10-cli-flags/phase_k/base_lattice/summary.md` with tables highlighting the first component outside 5e-4 tolerance. |
+| K3f4 | Record root cause & fix outline | [ ] | Based on K3f3 results, document the failure mode (e.g., unit scaling, detector basis ordering) and map the remediation path (affected modules/tests) in `summary.md`. Update this plan and docs/fix_plan Next Actions with the chosen implementation steps before any code changes. |
 
 ### Phase L — Final Parity & Regression Sweep
 Goal: Demonstrate full parity for the supervisor command and close CLI-FLAGS-003.

Reading prompt from stdin...
error: cannot pull with rebase: You have unstaged changes.
error: Please commit or stash them.
