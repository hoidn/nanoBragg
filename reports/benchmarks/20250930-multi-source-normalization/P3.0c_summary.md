# P3.0c Multi-Source Weighted Normalization Summary

**Date:** 2025-09-30
**Task:** PERF-PYTORCH-004 Phase 3 Task P3.0c
**Status:** COMPLETE

## Executive Summary

Validated that PyTorch multi-source intensity normalization correctly implements the spec-compliant behavior where `steps` divides by `n_sources` (not `sum(weights)`). Discovered and documented a semantic difference between C and PyTorch: **C ignores `source_I` weights during accumulation**, while PyTorch applies them as optional multiplicative factors.

## Configuration

**Weighted Source Test Case:**
- Source 1: weight=2.0, λ=6.2Å
- Source 2: weight=3.0, λ=8.0Å
- Both sources: direction=[1,0,0] (MOSFLM beam along +X)
- Crystal: 100Å cubic, 5×5×5 cells, default_F=100
- Detector: 128×128 pixels, 0.1mm pixel size, 100mm distance

## PyTorch Validation Results

### CPU Execution
- Total intensity: 8.914711e-05
- Max intensity: 1.228063e-07
- Non-zero pixels: 16384/16384
- Dtype: torch.float32

### CUDA Execution
- Total intensity: 8.914727e-05
- Max intensity: 1.228063e-07
- Non-zero pixels: 16384/16384
- Dtype: torch.float32

### CPU vs CUDA Agreement
- Relative difference: 1.80e-06 (0.0002%)
- ✓ **PASS** - Results match within tolerance (<0.01%)

## Normalization Analysis

### Current PyTorch Implementation (commit 2e2a6d9)

```python
# src/nanobrag_torch/simulator.py line 691
source_norm = n_sources  # Divide by count, not sum of weights
```

**Behavior:**
1. Each source contributes: `intensity_i = physics_i * weight_i`
2. Final pixel intensity: `sum(intensity_i) / n_sources`
3. With weights [2.0, 3.0]: effective multiplier is `(2+3)/2 = 2.5`

**Spec Compliance:** ✓ PASS - Matches AT-SRC-001 normalization requirement

### C Reference Implementation (golden_suite_generator/nanoBragg.c)

**Code Analysis:**
```c
// Line 2604: Read weight from source file
I = source_I[source];

// Line 2616: RESET weight before accumulation
I = I_bg;
```

**Behavior:**
- `source_I` is read but only used to seed `I` before being overwritten by `I_bg`
- During the accumulation loop, ALL sources contribute equally regardless of weights
- The weight column in source files is effectively ignored

**Implication:** C code cannot be used for weighted-source parity validation because it doesn't honor weights.

## Semantic Difference: C vs PyTorch

| Aspect | C Implementation | PyTorch Implementation |
|--------|-----------------|----------------------|
| Weight usage | Ignores `source_I` | Applies as multiplicative factor |
| Normalization | Divides by `steps` (includes sources) | Divides by `n_sources` |
| Parity | N/A - cannot compare | Self-consistent CPU/CUDA |

## Recommendations

### 1. Accept Current PyTorch Behavior ✓ RECOMMENDED

**Rationale:**
- Spec-compliant (AT-SRC-001)
- Self-consistent across CPU/CUDA
- More flexible than C (supports weighted sources)
- Matches user expectations for weighted averaging

**Action:** Document the semantic difference and proceed with PyTorch implementation as authoritative.

### 2. Alternative: Match C Exactly (NOT RECOMMENDED)

Would require:
- Ignoring `source_weights` parameter
- Removing per-source weight multiplication
- Less intuitive behavior for users

**Rejected:** Reduces functionality without clear benefit.

## Testing Evidence

### Artifacts Generated
- ✓ `validation_results.json` - CPU/CUDA metrics
- ✓ `weighted_sources.txt` - Test configuration file
- ✓ `validate_weighted_source_normalization.py` - Validation script

### Test Commands
```bash
# PyTorch validation
python scripts/validate_weighted_source_normalization.py

# Pytest (multi-source integration)
env KMP_DUPLICATE_LIB_OK=TRUE pytest tests/test_multi_source_integration.py::test_multi_source_intensity_normalization -v
```

### Results
- ✓ CPU test PASSED
- ✓ CUDA test PASSED
- ✓ CPU/CUDA parity PASSED (Δ < 2e-6)
- ✓ Multi-source integration test PASSED

## Exit Criteria Status

| Criterion | Status | Evidence |
|-----------|--------|----------|
| CPU validation | ✓ PASS | validation_results.json |
| CUDA validation | ✓ PASS | validation_results.json |
| CPU/CUDA parity | ✓ PASS | Rel diff < 1e-4 |
| C comparison | N/A | C ignores weights |
| Semantic reconciliation | ✓ DONE | This document |

## Conclusion

**P3.0c is COMPLETE.** PyTorch correctly implements weighted multi-source normalization per AT-SRC-001. The C code's weight-ignoring behavior is documented as a known difference. No changes required to PyTorch implementation.

**Next Actions:**
- Mark P3.0c as `[X]` in phase plan
- Update docs/fix_plan.md with findings
- Proceed with P3.2/P3.3 benchmarking (no blockers)
- Generate Phase 3 decision memo (P3.5)

## References

- Plan: `plans/active/perf-pytorch-compile-refactor/plan.md`
- Fix plan: `docs/fix_plan.md` [PERF-PYTORCH-004]
- Spec: `specs/spec-a-core.md` (AT-SRC-001)
- C code: `golden_suite_generator/nanoBragg.c` lines 2604-2616
- PyTorch: `src/nanobrag_torch/simulator.py` line 691
