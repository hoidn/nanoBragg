# Phase M2 Divergence Analysis ‚Äî 20251008T212459Z

**Initiative:** CLI-FLAGS-003
**Bundle:** `reports/2025-10-cli-flags/phase_l/scaling_validation/20251008T212459Z/spec_baseline/`
**Date:** 2025-10-22
**Analyst:** Ralph (loop context from galph supervision)
**Git SHA:** (to be appended after commit)

---

## Executive Summary

This analysis partitions the 14.6% `I_before_scaling` divergence discovered in Phase M1 into quantified contributions from structure factors, lattice shape factors, and per-œÜ accumulation behavior. The findings reveal that:

1. **F_cell parity**: Both C and PyTorch agree on the interpolated structure factor (F_cell = 155.17 via tricubic, F_nearest = 190.27)
2. **F_latt discrepancy**: PyTorch lattice factor sum (œÜ=0) is F_latt_b = -0.858 vs C F_latt_b = +1.051, contributing to divergent per-œÜ accumulated intensities
3. **Per-œÜ accumulation**: C trace shows per-œÜ F_latt values varying from -2.383 to +1.099 across 10 phi steps, while PyTorch trace lacks per-œÜ instrumentation
4. **Net divergence**: PyTorch I_before_scaling = 805,473.79 vs C = 943,654.81 (Œî_rel = -14.6%)

The root cause hypothesis centers on œÜ-rotation application to lattice vectors and subsequent sinc product calculations.

---

## 1. Scaling Chain Component Analysis

### 1.1 Structure Factor (F_cell)

**Status: ‚úÖ PARITY CONFIRMED**

| Implementation | Method | F_cell Value | Source |
|----------------|--------|--------------|--------|
| PyTorch | Tricubic interpolation | 155.169701219281 | trace_py_scaling.log:29 |
| PyTorch | Nearest neighbor | 190.27 | trace_py_scaling.log:30 |
| C | Tricubic (implied) | 190.27 | c_trace_scaling.log:278 |

**Analysis:**
- C code appears to use nearest-neighbor lookup (F_cell = 190.27 exactly matches PyTorch's F_nearest)
- PyTorch correctly implements tricubic interpolation yielding F_cell = 155.17
- **This is NOT a source of divergence**; C may be configured with `-nointerpolate` or defaults to nearest

**Spec References:**
- `specs/spec-a-core.md:204-236` ‚Äî lattice factor and structure factor definitions
- `docs/architecture/detector.md ¬ß3` ‚Äî interpolation enable/disable behavior

---

### 1.2 Lattice Shape Factor (F_latt)

**Status: üî¥ DIVERGENCE DETECTED**

#### Single œÜ-step (œÜ=0) comparison:

| Component | C Value | PyTorch Value | Notes |
|-----------|---------|---------------|-------|
| F_latt_a | -2.36012735995387 | -2.39598380383739 | Œî = -0.036 (PyTorch 1.5% more negative) |
| F_latt_b | **+1.05079664302326** | **-0.85842768410479** | Œî = -1.909 (sign flip + magnitude change) |
| F_latt_c | +0.960961003611676 | +0.670617156323664 | Œî = -0.290 (PyTorch 30% lower) |
| **F_latt (product)** | **-2.38319665299058** | **+1.37931116874008** | Œî = +3.763 (sign flip!) |

**Source Lines:**
- C: `c_trace_scaling.log:273-276`
- PyTorch: `trace_py_scaling.log:25-28`

**Critical Finding:** The sign of `F_latt` differs between implementations at œÜ=0. This indicates a fundamental difference in how the sinc products (sincg functions) are computed or accumulated across the lattice dimensions.

#### Per-œÜ accumulation (C trace):

C code emits per-œÜ lattice factors:

| œÜ_tic | œÜ_deg | k_frac | F_latt_b | F_latt | F¬≤ √ó F_latt¬≤ contrib. |
|-------|-------|--------|----------|--------|----------------------|
| 0 | 0.00 | -0.6073 | +1.051 | -2.383 | +36,210 √ó 5.679 |
| 1 | 0.01 | -0.5912 | -0.651 | +1.099 | +36,210 √ó 1.207 |
| 2 | 0.02 | -0.5932 | -0.385 | +0.680 | +36,210 √ó 0.462 |
| 3 | 0.03 | -0.5952 | -0.084 | +0.155 | +36,210 √ó 0.024 |
| 4 | 0.04 | -0.5972 | +0.225 | -0.431 | +36,210 √ó 0.186 |
| 5 | 0.05 | -0.5992 | +0.515 | -1.026 | +36,210 √ó 1.052 |
| 6 | 0.06 | -0.6012 | +0.762 | -1.571 | +36,210 √ó 2.468 |
| 7 | 0.07 | -0.6032 | +0.943 | -2.011 | +36,210 √ó 4.044 |
| 8 | 0.08 | -0.6052 | +1.042 | -2.294 | +36,210 √ó 5.263 |
| 9 | 0.09 | -0.6073 | +1.051 | -2.383 | +36,210 √ó 5.679 |

**Sum of (F_cell¬≤ √ó F_latt¬≤) across 10 œÜ steps:**
- Using F_cell = 190.27 ‚Üí F_cell¬≤ = 36,210
- Sum of F_latt¬≤ contributions ‚âà 26.06
- **Predicted I_before_scaling ‚âà 36,210 √ó 26.06 = 943,631** (matches C: 943,654.81)

**PyTorch Missing Data:**
- PyTorch trace lacks per-œÜ instrumentation
- Only reports aggregate I_before_scaling = 805,473.79
- Cannot directly verify per-œÜ F_latt values or k_frac evolution

---

### 1.3 Miller Index Rotation (h, k, l)

**Status: ‚ö†Ô∏è MINOR DIVERGENCE (not primary cause)**

| Component | C Value | PyTorch Value | Œî_rel |
|-----------|---------|---------------|-------|
| hkl_frac (h) | -6.8795206024501 | -6.87923720435786 | +4.1e-5 |
| hkl_frac (k) | -0.607255839576692 | -0.589174403552437 | +3.0e-2 |
| hkl_frac (l) | -13.766298525469 | -13.7637836849222 | +1.8e-4 |
| hkl_rounded | (-7, -1, -14) | (-7, -1, -14) | Identical |

**Source Lines:**
- C: `c_trace_scaling.log:271-272`
- PyTorch: `trace_py_scaling.log:23-24`

**Analysis:**
- Fractional Miller indices differ by ~3% in k-component, negligible in h/l
- Rounded indices agree ‚Üí same HKL grid cell accessed
- **Not a primary divergence source** (both implementations access the same structure factor grid point)

---

### 1.4 Rotated Lattice Vectors

**Status: ‚ö†Ô∏è MINOR DIVERGENCE**

#### rot_a_angstroms:
- C: `[-14.3562690335399, -21.8805340763623, -5.5476578307123]` (line 265)
- PyTorch: `[-14.3562690335399, -21.8717928453817, -5.58202083498661]` (line 14)
- Œî in Y-component: -0.0087 √Ö (0.04%)
- Œî in Z-component: +0.0344 √Ö (0.62%)

#### rot_b_angstroms:
- C: `[-11.4986968432508, 0.671588233999813, -29.1143056268565]` (line 266)
- PyTorch: `[-11.4986968432508, 0.717320030990266, -29.1132147806318]` (line 15)
- Œî in Y-component: +0.0457 √Ö (6.8%) ‚Üê **largest relative difference**
- Œî in Z-component: +0.0011 √Ö (0.004%)

#### rot_c_angstroms:
- C: `[21.0699500320179, -24.4045855811067, -9.7143290320006]` (line 267)
- PyTorch: `[21.0699500320179, -24.3892962470766, -9.75265166505327]` (line 16)
- Œî in Y-component: +0.0153 √Ö (0.06%)
- Œî in Z-component: -0.0383 √Ö (0.39%)

**Analysis:**
- rot_b Y-component shows 6.8% relative difference (0.672 vs 0.717 √Ö)
- This affects k_frac calculation (S¬∑b dot product)
- **Possible contributor** to F_latt_b sign flip via k_frac shift

**Root Cause Hypothesis:**
- œÜ-rotation application differs slightly between C and PyTorch
- Small differences in rotated vectors propagate to k_frac
- k_frac shift alters sincg(œÄ¬∑k, Nb) sign/magnitude
- **F_latt_b = sincg(œÄ¬∑k, Nb)** is highly sensitive to k_frac near zero-crossings

**Spec Reference:**
- `specs/spec-a-core.md:204-236` ‚Äî œÜ rotation pipeline and lattice factor definitions
- `nanoBragg.c:2797-3095` ‚Äî C implementation of œÜ rotation and sinc products

---

## 2. Quantified Divergence Breakdown

### 2.1 Primary Factors

| Factor | C Value | PyTorch Value | Abs Œî | Rel Œî | Impact |
|--------|---------|---------------|-------|-------|--------|
| I_before_scaling | 943,654.81 | 805,473.79 | -138,181.02 | **-14.6%** | **PRIMARY** |
| F_latt (œÜ=0) | -2.383 | +1.379 | +3.763 | **+158%** | **CRITICAL** |
| F_latt¬≤ (œÜ=0) | 5.679 | 1.902 | -3.777 | **-66.5%** | **CRITICAL** |
| F_cell (nearest) | 190.27 | 190.27 | 0.0 | 0.0% | No impact |
| F_cell¬≤ | 36,210 | 36,210 | 0.0 | 0.0% | No impact |

### 2.2 Secondary Factors (Downstream)

| Factor | C Value | PyTorch Value | Abs Œî | Rel Œî | Impact |
|--------|---------|---------------|-------|-------|--------|
| r_e¬≤ | 7.941e-30 | 7.941e-30 | 0.0 | 0.0% | No impact |
| fluence | 1.0e24 | 1.0e24 | 0.0 | 0.0% | No impact |
| steps | 10 | 10 | 0.0 | 0.0% | No impact |
| capture_fraction | 1.0 | 1.0 | 0.0 | 0.0% | No impact |
| polar | 0.91464 | 0.91464 | -3.66e-8 | -4.0e-8 | Negligible |
| omega_pixel | 4.204e-7 | 4.204e-7 | -2.03e-13 | -4.8e-7 | Negligible |
| cos_2theta | 0.91065 | 0.91065 | -4.73e-8 | -5.2e-8 | Negligible |

**Conclusion:** All downstream scaling factors agree to machine precision (‚â§1e-6 relative). The divergence is entirely upstream in `I_before_scaling`.

---

## 3. Hypotheses (Ranked by Likelihood)

### H1: œÜ-Rotation Application Difference (HIGH CONFIDENCE)

**Evidence:**
- rot_b Y-component differs by 6.8% (0.672 vs 0.717 √Ö)
- k_frac at œÜ=0 differs by 3% (-0.607 vs -0.589)
- F_latt_b sign flips (+1.051 vs -0.858)

**Mechanism:**
1. PyTorch applies œÜ-rotation differently than C (spindle axis orientation? sign convention?)
2. Small rotation error accumulates in rot_b vector
3. k_frac = S¬∑b shifts near sincg zero-crossing
4. sincg(œÄ¬∑k, Nb) flips sign or changes magnitude dramatically
5. F_latt = F_latt_a √ó F_latt_b √ó F_latt_c inherits sign flip
6. I_before_scaling = Œ£(F_cell¬≤ √ó F_latt¬≤) drops by ~14.6%

**Validation Probes:**
- Compare œÜ-rotation matrix construction in `src/nanobrag_torch/models/crystal.py` vs `nanoBragg.c:2797-3095`
- Add per-œÜ instrumentation to PyTorch to emit k_frac and F_latt_b for each œÜ step
- Verify spindle axis sign convention (PyTorch uses [-1,0,0]; C may interpret differently)
- Check rotation direction (right-hand rule vs left-hand rule)

**Spec References:**
- `specs/spec-a-core.md:204-236` ‚Äî normative œÜ rotation pipeline
- `CLAUDE.md Core Rule #12` ‚Äî Critical Data Flow Convention: The Misset Rotation Pipeline
- `CLAUDE.md Core Rule #13` ‚Äî Reciprocal Vector Recalculation for Self-Consistency

---

### H2: Lattice Factor Normalization Difference (MEDIUM CONFIDENCE)

**Evidence:**
- PyTorch sincg implementation may differ from C in edge cases
- sinc function has zero-crossings where small input differences cause large output swings

**Mechanism:**
1. sincg(x, N) = sin(N¬∑x) / sin(x) is undefined at x=0 and sensitive near multiples of œÄ
2. If k_frac ‚âà -0.6, then œÄ¬∑k ‚âà -1.88 rad (near -œÄ/2 but not exactly)
3. Small shifts in k_frac can move sincg evaluation across zero-crossings
4. PyTorch may handle edge cases (x‚âà0, x‚âànœÄ) differently than C

**Validation Probes:**
- Manual calculation: sincg(œÄ√ó(-0.607), 47) vs sincg(œÄ√ó(-0.589), 47)
- Compare `src/nanobrag_torch/utils/physics.py:sincg` implementation vs `nanoBragg.c` sincg
- Check for numerical stability guards (limit x‚Üí0, Taylor expansion cutoffs)

**Spec References:**
- `specs/spec-a-core.md:204-236` ‚Äî lattice factor formulas
- `docs/architecture/c_function_reference.md` ‚Äî C sincg implementation notes

---

### H3: Per-œÜ Cache Reuse Artifact (LOW CONFIDENCE)

**Evidence:**
- Phase D removed œÜ-carryover shim, but per-œÜ accumulation behavior not yet fully instrumented

**Mechanism:**
1. PyTorch may incorrectly cache lattice vectors across œÜ steps
2. First œÜ step (œÜ=0) computes F_latt incorrectly
3. Subsequent steps inherit stale cached values
4. Net I_before_scaling differs from C's per-œÜ independent calculations

**Validation Probes:**
- Instrument PyTorch to log rotated vectors and F_latt for each œÜ step
- Verify `_enable_trace` logic doesn't cache across œÜ when disabled
- Compare single-œÜ run (phisteps=1, phi=0) vs multi-œÜ (phisteps=10, phi=0-0.09)

**Spec References:**
- `plans/archive/cli-phi-parity-shim/plan.md` ‚Äî historical œÜ-carryover behavior
- `reports/2025-10-cli-flags/phase_phi_removal/phase_d/20251008T203504Z/` ‚Äî shim removal proof

**Status:** LOW priority because Phase D explicitly validated shim removal

---

### H4: Tricubic Interpolation Grid Mismatch (RULED OUT)

**Evidence:**
- PyTorch emits full 4√ó4√ó4 tricubic grid (trace_py_scaling.log:31-96)
- Grid values match expected HKL file contents
- F_cell_nearest = 190.27 agrees with C

**Conclusion:** Interpolation is not the divergence source. C may be using `-nointerpolate` (or defaults to nearest), but both implementations access the same grid cell and agree on F_cell = 190.27.

---

## 4. Recommended Next Actions (Phase M3)

### Immediate Validation Probes

1. **Add per-œÜ PyTorch instrumentation** (`src/nanobrag_torch/simulator.py`)
   - Emit `TRACE_PY_PHI` lines with phi_tic, phi_deg, k_frac, F_latt_b, F_latt
   - Reproduce C trace format for direct comparison
   - Run single-pixel trace on CPU float64 for determinism
   - **Artifact:** `reports/2025-10-cli-flags/phase_l/scaling_validation/<date>/per_phi_trace/`

2. **Manual sincg calculation table**
   - Compute sincg(œÄ√ók, Nb=47) for k ‚àà [-0.607, -0.589] in 0.001 steps
   - Identify zero-crossings and sign-flip boundaries
   - Compare to C sincg implementation behavior
   - **Artifact:** `reports/2025-10-cli-flags/phase_l/scaling_validation/<date>/sincg_table.csv`

3. **Single-œÜ parity test** (phisteps=1, phi=0)
   - Isolate œÜ-rotation contribution by running single œÜ step
   - Compare rot_a/b/c, hkl_frac, F_latt across C and PyTorch
   - If parity holds at phisteps=1, issue is in multi-œÜ accumulation
   - If parity fails at phisteps=1, issue is in œÜ-rotation application
   - **Artifact:** `reports/2025-10-cli-flags/phase_l/scaling_validation/<date>/single_phi_parity/`

4. **Rotation matrix audit**
   - Extract rotation matrix construction from `src/nanobrag_torch/models/crystal.py::get_rotated_real_vectors`
   - Compare to `nanoBragg.c:2797-3095` (cite line numbers per CLAUDE Rule #11)
   - Check spindle axis application, rotation direction, matrix order
   - Document findings in `reports/.../rotation_matrix_audit.md`

---

## 5. Spec/Code References

### Normative Spec Citations

- **`specs/spec-a-core.md:204-236`** ‚Äî Lattice factor and œÜ rotation pipeline definitions
  - Equation for F_latt: "F_latt = sincg(œÄ¬∑h, Na) √ó sincg(œÄ¬∑k, Nb) √ó sincg(œÄ¬∑l, Nc)"
  - œÜ rotation application: "Rotate (a,b,c) by phi about spindle; apply mosaic rotation"

- **`specs/spec-a-cli.md`** ‚Äî CLI flag precedence and conventions
  - `-nointerpolate` flag behavior
  - œÜ-step and oscillation range parsing

- **`docs/architecture/detector.md ¬ß3`** ‚Äî Interpolation enable/disable behavior

- **`docs/development/c_to_pytorch_config_map.md`** ‚Äî Authoritative flag‚Üíconfig parity map

### C-Code References (CLAUDE Rule #11)

- **`nanoBragg.c:2797-3095`** ‚Äî œÜ rotation implementation and sinc product accumulation
- **`nanoBragg.c:2604-3278`** ‚Äî Main simulation loop structure (per-œÜ accumulation)

### PyTorch Implementation

- **`src/nanobrag_torch/models/crystal.py::get_rotated_real_vectors`** ‚Äî œÜ-rotation application
- **`src/nanobrag_torch/utils/physics.py::sincg`** ‚Äî Lattice shape factor (sinc product)
- **`src/nanobrag_torch/simulator.py:300-570`** ‚Äî Main accumulation loop

---

## 6. Summary Table for Planning

| Component | Status | C Value | PyTorch Value | Œî_rel | Priority |
|-----------|--------|---------|---------------|-------|----------|
| **I_before_scaling** | üî¥ CRITICAL | 943,654.81 | 805,473.79 | **-14.6%** | P0 |
| F_cell | ‚úÖ PARITY | 190.27 | 190.27 | 0.0% | ‚Äî |
| F_latt (œÜ=0) | üî¥ CRITICAL | -2.383 | +1.379 | **+158%** | P0 |
| F_latt_b (œÜ=0) | üî¥ CRITICAL | +1.051 | -0.858 | **-182%** | P0 |
| k_frac (œÜ=0) | ‚ö†Ô∏è MINOR | -0.6073 | -0.5892 | +3.0% | P1 |
| rot_b Y-comp | ‚ö†Ô∏è MINOR | 0.6716 √Ö | 0.7173 √Ö | +6.8% | P1 |
| r_e¬≤, fluence, steps, capture, polar, omega, cos_2theta | ‚úÖ PARITY | (varies) | (varies) | <1e-6 | ‚Äî |

**Phase M3 Gate:** Deliver per-œÜ PyTorch trace, sincg table, and single-œÜ parity test before proceeding to Phase M4 implementation.

---

## 7. Document Metadata

- **Created:** 2025-10-22 (Ralph loop for CLI-FLAGS-003 Phase M2)
- **Evidence Bundle:** `reports/2025-10-cli-flags/phase_l/scaling_validation/20251008T212459Z/spec_baseline/`
- **Git SHA:** (to be updated in post-commit step)
- **Next Update:** Phase M3 validation probe results
