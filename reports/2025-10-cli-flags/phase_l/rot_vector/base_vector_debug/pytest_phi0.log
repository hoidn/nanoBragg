============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/ollie/miniconda3/envs/myenv/bin/python3.13
cachedir: .pytest_cache
rootdir: /home/ollie/Documents/tmp/nanoBragg
configfile: pyproject.toml
collecting ... collected 1 item

tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_rot_b_matches_c FAILED [100%]

=================================== FAILURES ===================================
____________________ TestPhiZeroParity.test_rot_b_matches_c ____________________

self = <tests.test_cli_scaling_phi0.TestPhiZeroParity object at 0x7d9a1ea7fd90>

    def test_rot_b_matches_c(self):
        """
        Verify φ=0 rot_b[0,0,1] and k_frac match C trace values.
    
        This test captures the base-vector divergence documented in:
        - reports/2025-10-cli-flags/phase_l/scaling_audit/c_trace_scaling.log:266-277
        - reports/2025-10-cli-flags/phase_l/scaling_audit/trace_py_scaling_20251119.log:15,20
    
        Expected (from C trace):
        - rot_b[0,0,1] = 0.6715882339 Å (Y component, φ=0)
        - k_frac = -0.6072558396 (fractional Miller index k at φ=0)
    
        This test is EXPECTED TO FAIL until the φ rotation fix lands.
        Failure documents the bug for TDD; passing proves the fix works.
        """
        from nanobrag_torch.models.crystal import Crystal, CrystalConfig
        from nanobrag_torch.models.detector import Detector, DetectorConfig
        from nanobrag_torch.config import BeamConfig
        from nanobrag_torch.io.mosflm import read_mosflm_matrix
        from nanobrag_torch import utils
    
        # Supervisor command configuration (from input.md and Phase L scaling audit)
        # Command: nanoBragg -mat A.mat -hkl scaled.hkl -lambda 0.9768 -N 36 47 29
        #                    -distance 100 -detpixels 2124 -pixel 0.1 -phi 0 -osc 0.1
        #                    -phisteps 10 -mosaic_dom 1 -oversample 1 -floatfile out.bin
    
        # Check prerequisites
        mat_file = Path('A.mat')
        hkl_file = Path('scaled.hkl')
        if not mat_file.exists():
            pytest.skip("A.mat not found (required for supervisor command reproduction)")
        if not hkl_file.exists():
            pytest.skip("scaled.hkl not found (required for supervisor command reproduction)")
    
        # Device and dtype (CPU float32 per input.md guidance)
        device = torch.device('cpu')
        dtype = torch.float32
    
        # Beam configuration
        wavelength_A = 0.976800
        beam_config = BeamConfig(wavelength_A=wavelength_A)
    
        # Load MOSFLM matrix
        a_star, b_star, c_star = read_mosflm_matrix(str(mat_file), wavelength_A)
    
        # Crystal configuration (supervisor command)
        crystal_config = CrystalConfig(
            cell_a=100.0,  # placeholder (overridden by MOSFLM)
            cell_b=100.0,
            cell_c=100.0,
            cell_alpha=90.0,
            cell_beta=90.0,
            cell_gamma=90.0,
            N_cells=(36, 47, 29),
            mosflm_a_star=a_star,
            mosflm_b_star=b_star,
            mosflm_c_star=c_star,
            phi_start_deg=0.0,
            osc_range_deg=0.1,
            phi_steps=10,
            mosaic_domains=1,
            misset_deg=[0.0, 0.0, 0.0],
            spindle_axis=[-1.0, 0.0, 0.0],  # supervisor command convention
        )
    
        # Detector configuration (supervisor command)
        from nanobrag_torch.config import DetectorConvention
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=2124,
            fpixels=2124,
            detector_convention=DetectorConvention.MOSFLM,
        )
    
        # Instantiate Crystal
        crystal = Crystal(crystal_config, beam_config=beam_config, device=device, dtype=dtype)
    
        # Get rotated real vectors (includes φ rotation)
        # Returns tuple of (real_vectors, reciprocal_vectors)
        (rot_a, rot_b, rot_c), (rot_a_star, rot_b_star, rot_c_star) = crystal.get_rotated_real_vectors(crystal_config)
    
        # Verify φ dimensions match config
        assert rot_b.shape[0] == crystal_config.phi_steps, \
            f"φ count mismatch: expected {crystal_config.phi_steps}, got {rot_b.shape[0]}"
    
        # Extract φ=0 b-vector Y component
        rot_b_phi0_y = rot_b[0, 0, 1].item()  # (phi, mosaic, xyz) → φ=0, mosaic=0, Y
    
        # Expected from C trace (c_trace_scaling.log:266)
        expected_rot_b_y = 0.6715882339
    
        # Tolerance (5e-4 from fix_checklist.md VG-1.4)
        tolerance = 5e-4
    
        # Assertion (EXPECTED TO FAIL until fix lands)
        rel_error = abs(rot_b_phi0_y - expected_rot_b_y) / abs(expected_rot_b_y)
>       assert rel_error <= tolerance, \
            f"rot_b[0,0,1] (φ=0 Y component) relative error {rel_error:.6g} > {tolerance}. " \
            f"Expected {expected_rot_b_y:.10f}, got {rot_b_phi0_y:.10f} Å. " \
            f"Absolute delta: {rot_b_phi0_y - expected_rot_b_y:.10g} Å. " \
            f"This documents the φ rotation bug (independent real/reciprocal drift)."
E       AssertionError: rot_b[0,0,1] (φ=0 Y component) relative error 0.0680946 > 0.0005. Expected 0.6715882339, got 0.7173197865 Å. Absolute delta: 0.04573155265 Å. This documents the φ rotation bug (independent real/reciprocal drift).
E       assert 0.06809463051942623 <= 0.0005

tests/test_cli_scaling_phi0.py:122: AssertionError
=========================== short test summary info ============================
FAILED tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_rot_b_matches_c
============================== 1 failed in 2.09s ===============================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/ollie/miniconda3/envs/myenv/bin/python3.13
cachedir: .pytest_cache
rootdir: /home/ollie/Documents/tmp/nanoBragg
configfile: pyproject.toml
collecting ... collected 1 item

tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_k_frac_phi0_matches_c FAILED [100%]

=================================== FAILURES ===================================
_________________ TestPhiZeroParity.test_k_frac_phi0_matches_c _________________

self = <tests.test_cli_scaling_phi0.TestPhiZeroParity object at 0x73351ccac190>

    def test_k_frac_phi0_matches_c(self):
        """
        Verify φ=0 fractional Miller index k matches C trace value.
    
        This test computes k_frac at φ=0 for the target pixel (685, 1039)
        and compares against C expectations.
    
        Expected (from C trace):
        - k_frac(φ=0) = -0.6072558396
    
        This test is EXPECTED TO FAIL until the φ rotation fix lands.
        """
        from nanobrag_torch.models.crystal import Crystal, CrystalConfig
        from nanobrag_torch.models.detector import Detector, DetectorConfig
        from nanobrag_torch.config import BeamConfig, DetectorConvention
        from nanobrag_torch.io.mosflm import read_mosflm_matrix
        from nanobrag_torch import utils
    
        # Check prerequisites
        mat_file = Path('A.mat')
        hkl_file = Path('scaled.hkl')
        if not mat_file.exists():
            pytest.skip("A.mat not found")
        if not hkl_file.exists():
            pytest.skip("scaled.hkl not found")
    
        # Device and dtype
        device = torch.device('cpu')
        dtype = torch.float32
    
        # Beam configuration
        wavelength_A = 0.976800
        beam_config = BeamConfig(wavelength_A=wavelength_A)
    
        # Load MOSFLM matrix
        a_star, b_star, c_star = read_mosflm_matrix(str(mat_file), wavelength_A)
    
        # Crystal configuration
        crystal_config = CrystalConfig(
            cell_a=100.0,
            cell_b=100.0,
            cell_c=100.0,
            cell_alpha=90.0,
            cell_beta=90.0,
            cell_gamma=90.0,
            N_cells=(36, 47, 29),
            mosflm_a_star=a_star,
            mosflm_b_star=b_star,
            mosflm_c_star=c_star,
            phi_start_deg=0.0,
            osc_range_deg=0.1,
            phi_steps=10,
            mosaic_domains=1,
            misset_deg=[0.0, 0.0, 0.0],
            spindle_axis=[-1.0, 0.0, 0.0],  # supervisor command convention
        )
    
        # Detector configuration
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=2124,
            fpixels=2124,
            detector_convention=DetectorConvention.MOSFLM,
        )
    
        # Instantiate models
        crystal = Crystal(crystal_config, beam_config=beam_config, device=device, dtype=dtype)
        detector = Detector(detector_config, device=device, dtype=dtype)
    
        # Get rotated vectors at φ=0
        # Returns tuple of (real_vectors, reciprocal_vectors)
        (rot_a, rot_b, rot_c), (rot_a_star, rot_b_star, rot_c_star) = crystal.get_rotated_real_vectors(crystal_config)
    
        # Target pixel from C trace (slow=685, fast=1039)
        # These are the indices from c_trace_scaling.log
        target_s = 685
        target_f = 1039
    
        # Get pixel position for target
        # detector.get_pixel_coords() returns (S, F, 3) in meters
        pixel_coords = detector.get_pixel_coords()  # (2124, 2124, 3)
        pixel_pos_m = pixel_coords[target_s, target_f, :]  # (3,) meters
    
        # Convert to Angstroms for physics
        pixel_pos_A = pixel_pos_m * 1e10  # m → Å
    
        # Compute scattering vector (supervisor command uses -lambda 0.9768)
        wavelength_m = wavelength_A * 1e-10  # Å → m
    
        # Incident beam (MOSFLM convention: [1, 0, 0])
        incident = torch.tensor([1.0, 0.0, 0.0], device=device, dtype=dtype)
    
        # Diffracted direction (unit vector to pixel)
        diffracted = pixel_pos_A / torch.norm(pixel_pos_A)
    
        # Scattering vector S = (d - i) / λ (in Å⁻¹)
        scattering = (diffracted - incident) / wavelength_A
    
        # Compute Miller indices at φ=0 using dot product
        # k_frac = b · S (where b is the φ=0, mosaic=0 real-space vector)
        b_phi0 = rot_b[0, 0, :]  # (3,) Å
        k_frac = utils.dot_product(scattering, b_phi0).item()
    
        # Expected from C trace (c_trace_scaling.log:271)
        expected_k_frac = -0.6072558396
    
        # Tolerance (absolute for fractional indices)
        tolerance = 5e-4
    
        # Assertion (EXPECTED TO FAIL)
        abs_error = abs(k_frac - expected_k_frac)
>       assert abs_error <= tolerance, \
            f"k_frac(φ=0) absolute error {abs_error:.6g} > {tolerance}. " \
            f"Expected {expected_k_frac:.10f}, got {k_frac:.10f}. " \
            f"Absolute delta: {k_frac - expected_k_frac:.10g}. " \
            f"This documents the φ rotation bug affecting Miller indices."
E       AssertionError: k_frac(φ=0) absolute error 2.28292 > 0.0005. Expected -0.6072558396, got 1.6756687164. Absolute delta: 2.282924556. This documents the φ rotation bug affecting Miller indices.
E       assert 2.282924556030664 <= 0.0005

tests/test_cli_scaling_phi0.py:240: AssertionError
=========================== short test summary info ============================
FAILED tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_k_frac_phi0_matches_c
============================== 1 failed in 2.14s ===============================
