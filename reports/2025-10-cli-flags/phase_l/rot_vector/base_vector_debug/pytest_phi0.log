============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/ollie/miniconda3/envs/myenv/bin/python3.13
cachedir: .pytest_cache
rootdir: /home/ollie/Documents/tmp/nanoBragg
configfile: pyproject.toml
collecting ... collected 1 item

tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_rot_b_matches_c FAILED [100%]

=================================== FAILURES ===================================
____________________ TestPhiZeroParity.test_rot_b_matches_c ____________________

self = <tests.test_cli_scaling_phi0.TestPhiZeroParity object at 0x703c91a7fed0>

    def test_rot_b_matches_c(self):
        """
        Verify φ=0 rot_b[0,0,1] and k_frac match C trace values.
    
        This test captures the base-vector divergence documented in:
        - reports/2025-10-cli-flags/phase_l/scaling_audit/c_trace_scaling.log:266-277
        - reports/2025-10-cli-flags/phase_l/scaling_audit/trace_py_scaling_20251119.log:15,20
    
        Expected (from C trace):
        - rot_b[0,0,1] = 0.6715882339 Å (Y component, φ=0)
        - k_frac = -0.6072558396 (fractional Miller index k at φ=0)
    
        This test is EXPECTED TO FAIL until the φ rotation fix lands.
        Failure documents the bug for TDD; passing proves the fix works.
        """
        from nanobrag_torch.models.crystal import Crystal, CrystalConfig
        from nanobrag_torch.models.detector import Detector, DetectorConfig
        from nanobrag_torch.config import BeamConfig
        from nanobrag_torch.io.mosflm import read_mosflm_matrix
        from nanobrag_torch import utils
    
        # Supervisor command configuration (from input.md and Phase L scaling audit)
        # Command: nanoBragg -mat A.mat -hkl scaled.hkl -lambda 0.9768 -N 36 47 29
        #                    -distance 100 -detpixels 2124 -pixel 0.1 -phi 0 -osc 0.1
        #                    -phisteps 10 -mosaic_dom 1 -oversample 1 -floatfile out.bin
    
        # Check prerequisites
        mat_file = Path('A.mat')
        hkl_file = Path('scaled.hkl')
        if not mat_file.exists():
            pytest.skip("A.mat not found (required for supervisor command reproduction)")
        if not hkl_file.exists():
            pytest.skip("scaled.hkl not found (required for supervisor command reproduction)")
    
        # Device and dtype (CPU float32 per input.md guidance)
        device = torch.device('cpu')
        dtype = torch.float32
    
        # Beam configuration
        wavelength_A = 0.976800
        beam_config = BeamConfig(wavelength_A=wavelength_A)
    
        # Load MOSFLM matrix
        a_star, b_star, c_star = read_mosflm_matrix(str(mat_file), wavelength_A)
    
        # Crystal configuration (supervisor command)
        crystal_config = CrystalConfig(
            cell_a=100.0,  # placeholder (overridden by MOSFLM)
            cell_b=100.0,
            cell_c=100.0,
            cell_alpha=90.0,
            cell_beta=90.0,
            cell_gamma=90.0,
            N_cells=(36, 47, 29),
            mosflm_a_star=a_star,
            mosflm_b_star=b_star,
            mosflm_c_star=c_star,
            phi_start_deg=0.0,
            osc_range_deg=0.1,
            phi_steps=10,
            mosaic_domains=1,
            misset_deg=[0.0, 0.0, 0.0],
            spindle_axis=[0.0, 1.0, 0.0],  # default Y-axis
        )
    
        # Detector configuration (supervisor command)
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=2124,
            fpixels=2124,
            detector_convention='MOSFLM',
        )
    
        # Instantiate Crystal
        crystal = Crystal(crystal_config, beam_config=beam_config, device=device, dtype=dtype)
    
        # Get rotated real vectors (includes φ rotation)
        # Returns tuple of (real_vectors, reciprocal_vectors)
        (rot_a, rot_b, rot_c), (rot_a_star, rot_b_star, rot_c_star) = crystal.get_rotated_real_vectors(crystal_config)
    
        # Verify φ dimensions match config
        assert rot_b.shape[0] == crystal_config.phi_steps, \
            f"φ count mismatch: expected {crystal_config.phi_steps}, got {rot_b.shape[0]}"
    
        # Extract φ=0 b-vector Y component
        rot_b_phi0_y = rot_b[0, 0, 1].item()  # (phi, mosaic, xyz) → φ=0, mosaic=0, Y
    
        # Expected from C trace (c_trace_scaling.log:266)
        expected_rot_b_y = 0.6715882339
    
        # Tolerance (5e-4 from fix_checklist.md VG-1.4)
        tolerance = 5e-4
    
        # Assertion (EXPECTED TO FAIL until fix lands)
        rel_error = abs(rot_b_phi0_y - expected_rot_b_y) / abs(expected_rot_b_y)
>       assert rel_error <= tolerance, \
            f"rot_b[0,0,1] (φ=0 Y component) relative error {rel_error:.6g} > {tolerance}. " \
            f"Expected {expected_rot_b_y:.10f}, got {rot_b_phi0_y:.10f} Å. " \
            f"Absolute delta: {rot_b_phi0_y - expected_rot_b_y:.10g} Å. " \
            f"This documents the φ rotation bug (independent real/reciprocal drift)."
E       AssertionError: rot_b[0,0,1] (φ=0 Y component) relative error 0.0680946 > 0.0005. Expected 0.6715882339, got 0.7173197865 Å. Absolute delta: 0.04573155265 Å. This documents the φ rotation bug (independent real/reciprocal drift).
E       assert 0.06809463051942623 <= 0.0005

tests/test_cli_scaling_phi0.py:121: AssertionError
=========================== short test summary info ============================
FAILED tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_rot_b_matches_c
============================== 1 failed in 2.11s ===============================
============================= test session starts ==============================
platform linux -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0 -- /home/ollie/miniconda3/envs/myenv/bin/python3.13
cachedir: .pytest_cache
rootdir: /home/ollie/Documents/tmp/nanoBragg
configfile: pyproject.toml
collecting ... collected 1 item

tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_k_frac_phi0_matches_c FAILED [100%]

=================================== FAILURES ===================================
_________________ TestPhiZeroParity.test_k_frac_phi0_matches_c _________________

self = <tests.test_cli_scaling_phi0.TestPhiZeroParity object at 0x788403bac2d0>

    def test_k_frac_phi0_matches_c(self):
        """
        Verify φ=0 fractional Miller index k matches C trace value.
    
        This test computes k_frac at φ=0 for the target pixel (685, 1039)
        and compares against C expectations.
    
        Expected (from C trace):
        - k_frac(φ=0) = -0.6072558396
    
        This test is EXPECTED TO FAIL until the φ rotation fix lands.
        """
        from nanobrag_torch.models.crystal import Crystal, CrystalConfig
        from nanobrag_torch.models.detector import Detector, DetectorConfig
        from nanobrag_torch.config import BeamConfig
        from nanobrag_torch.io.mosflm import read_mosflm_matrix
        from nanobrag_torch import utils
    
        # Check prerequisites
        mat_file = Path('A.mat')
        hkl_file = Path('scaled.hkl')
        if not mat_file.exists():
            pytest.skip("A.mat not found")
        if not hkl_file.exists():
            pytest.skip("scaled.hkl not found")
    
        # Device and dtype
        device = torch.device('cpu')
        dtype = torch.float32
    
        # Beam configuration
        wavelength_A = 0.976800
        beam_config = BeamConfig(wavelength_A=wavelength_A)
    
        # Load MOSFLM matrix
        a_star, b_star, c_star = read_mosflm_matrix(str(mat_file), wavelength_A)
    
        # Crystal configuration
        crystal_config = CrystalConfig(
            cell_a=100.0,
            cell_b=100.0,
            cell_c=100.0,
            cell_alpha=90.0,
            cell_beta=90.0,
            cell_gamma=90.0,
            N_cells=(36, 47, 29),
            mosflm_a_star=a_star,
            mosflm_b_star=b_star,
            mosflm_c_star=c_star,
            phi_start_deg=0.0,
            osc_range_deg=0.1,
            phi_steps=10,
            mosaic_domains=1,
            misset_deg=[0.0, 0.0, 0.0],
            spindle_axis=[0.0, 1.0, 0.0],
        )
    
        # Detector configuration
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=2124,
            fpixels=2124,
            detector_convention='MOSFLM',
        )
    
        # Instantiate models
        crystal = Crystal(crystal_config, beam_config=beam_config, device=device, dtype=dtype)
>       detector = Detector(detector_config, device=device, dtype=dtype)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_cli_scaling_phi0.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/nanobrag_torch/models/detector.py:131: in __init__
    self._calculate_basis_vectors()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.models.detector.Detector object at 0x7883e6a24d70>

    def _calculate_basis_vectors(
        self,
    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Calculate detector basis vectors from configuration.
    
        This method dynamically computes the detector's fast, slow, and
        normal basis vectors based on user-provided configuration, such as
        detector rotations (`-detector_rot*`) and the two-theta angle.
    
        The calculation follows this exact sequence:
        1. Initialize basis vectors according to detector convention (MOSFLM or XDS)
        2. Apply detector rotations in order: X-axis, Y-axis, Z-axis
        3. Apply two-theta rotation around the specified axis (if non-zero)
    
        All rotations preserve the orthonormality of the basis vectors and
        maintain differentiability when rotation angles are provided as tensors
        with requires_grad=True.
    
        Note: This method takes no parameters as it uses self.config and
        self.device/dtype. The returned vectors are guaranteed to be on the
        same device and have the same dtype as the detector.
    
        C-Code Implementation Reference (from nanoBragg.c, lines 1319-1412):
        The C code performs these calculations in a large block within main()
        after parsing arguments. The key operations to replicate are:
    
        ```c
            /* initialize detector origin from a beam center and distance */
            /* there are two conventions here: mosflm and XDS */
            // ... logic to handle different conventions ...
    
            if(detector_pivot == SAMPLE){
                printf("pivoting detector around sample\n");
                /* initialize detector origin before rotating detector */
                pix0_vector[1] = -Fclose*fdet_vector[1]-Sclose*sdet_vector[1]+close_distance*odet_vector[1];
                pix0_vector[2] = -Fclose*fdet_vector[2]-Sclose*sdet_vector[2]+close_distance*odet_vector[2];
                pix0_vector[3] = -Fclose*fdet_vector[3]-Sclose*sdet_vector[3]+close_distance*odet_vector[3];
    
                /* now swing the detector origin around */
                rotate(pix0_vector,pix0_vector,detector_rotx,detector_roty,detector_rotz);
                rotate_axis(pix0_vector,pix0_vector,twotheta_axis,detector_twotheta);
            }
            /* now orient the detector plane */
            rotate(fdet_vector,fdet_vector,detector_rotx,detector_roty,detector_rotz);
            rotate(sdet_vector,sdet_vector,detector_rotx,detector_roty,detector_rotz);
            rotate(odet_vector,odet_vector,detector_rotx,detector_roty,detector_rotz);
    
            /* also apply orientation part of twotheta swing */
            rotate_axis(fdet_vector,fdet_vector,twotheta_axis,detector_twotheta);
            rotate_axis(sdet_vector,sdet_vector,twotheta_axis,detector_twotheta);
            rotate_axis(odet_vector,odet_vector,twotheta_axis,detector_twotheta);
    
            /* make sure beam center is preserved */
            if(detector_pivot == BEAM){
                printf("pivoting detector around direct beam spot\n");
                pix0_vector[1] = -Fbeam*fdet_vector[1]-Sbeam*sdet_vector[1]+distance*beam_vector[1];
                pix0_vector[2] = -Fbeam*fdet_vector[2]-Sbeam*sdet_vector[2]+distance*beam_vector[2];
                pix0_vector[3] = -Fbeam*fdet_vector[3]-Sbeam*sdet_vector[3]+distance*beam_vector[3];
            }
        ```
    
        Returns:
            Tuple[torch.Tensor, torch.Tensor, torch.Tensor]: The calculated
            (fdet_vec, sdet_vec, odet_vec) basis vectors, each with shape (3,)
        """
        from ..utils.geometry import angles_to_rotation_matrix, rotate_axis
    
        # Get configuration parameters
        c = self.config
    
        # Convert rotation angles to radians (handling both scalar and tensor inputs)
        detector_rotx = degrees_to_radians(c.detector_rotx_deg)
        detector_roty = degrees_to_radians(c.detector_roty_deg)
        detector_rotz = degrees_to_radians(c.detector_rotz_deg)
        detector_twotheta = degrees_to_radians(c.detector_twotheta_deg)
    
        # Ensure all angles are tensors for consistent handling
        if not isinstance(detector_rotx, torch.Tensor):
            detector_rotx = torch.tensor(
                detector_rotx, device=self.device, dtype=self.dtype
            )
        elif detector_rotx.device != self.device or detector_rotx.dtype != self.dtype:
            detector_rotx = detector_rotx.to(device=self.device, dtype=self.dtype)
    
        if not isinstance(detector_roty, torch.Tensor):
            detector_roty = torch.tensor(
                detector_roty, device=self.device, dtype=self.dtype
            )
        elif detector_roty.device != self.device or detector_roty.dtype != self.dtype:
            detector_roty = detector_roty.to(device=self.device, dtype=self.dtype)
    
        if not isinstance(detector_rotz, torch.Tensor):
            detector_rotz = torch.tensor(
                detector_rotz, device=self.device, dtype=self.dtype
            )
        elif detector_rotz.device != self.device or detector_rotz.dtype != self.dtype:
            detector_rotz = detector_rotz.to(device=self.device, dtype=self.dtype)
    
        if not isinstance(detector_twotheta, torch.Tensor):
            detector_twotheta = torch.tensor(
                detector_twotheta, device=self.device, dtype=self.dtype
            )
        elif detector_twotheta.device != self.device or detector_twotheta.dtype != self.dtype:
            detector_twotheta = detector_twotheta.to(device=self.device, dtype=self.dtype)
    
        # Initialize basis vectors based on detector convention
        from ..config import DetectorConvention
    
        if c.detector_convention == DetectorConvention.MOSFLM:
            # PHASE 1 FIX: Corrected MOSFLM basis vectors to match C implementation
            fdet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype  # Fast along +Z (CORRECT)
            )
            sdet_vec = torch.tensor(
                [0.0, -1.0, 0.0], device=self.device, dtype=self.dtype  # Slow along -Y (CORRECT)
            )
            odet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype   # Normal along +X (CORRECT)
            )
        elif c.detector_convention == DetectorConvention.XDS:
            # XDS convention: detector surface normal points away from source
            fdet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
            sdet_vec = torch.tensor(
                [0.0, 1.0, 0.0], device=self.device, dtype=self.dtype
            )
            odet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype
            )
        elif c.detector_convention == DetectorConvention.DIALS:
            # DIALS convention: beam [0,0,1], f=[1,0,0], s=[0,1,0], o=[0,0,1]
            # Similar to XDS but with specific beam and twotheta axis conventions
            fdet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype  # Fast along +X
            )
            sdet_vec = torch.tensor(
                [0.0, 1.0, 0.0], device=self.device, dtype=self.dtype  # Slow along +Y
            )
            odet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype  # Normal along +Z
            )
        elif c.detector_convention == DetectorConvention.ADXV:
            # ADXV convention per spec: beam b = [0 0 1]; f = [1 0 0]; s = [0 -1 0]; o = [0 0 1]
            fdet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype  # Fast along +X
            )
            sdet_vec = torch.tensor(
                [0.0, -1.0, 0.0], device=self.device, dtype=self.dtype  # Slow along -Y (like MOSFLM)
            )
            odet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype  # Normal along +Z (beam direction)
            )
        elif c.detector_convention == DetectorConvention.DENZO:
            # DENZO convention per spec: Same as MOSFLM bases (beam [1,0,0], f=[0,0,1], s=[0,-1,0], o=[1,0,0])
            # Note: Different beam center mapping but same basis vectors as MOSFLM
            fdet_vec = torch.tensor(
                [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype  # Fast along +Z (same as MOSFLM)
            )
            sdet_vec = torch.tensor(
                [0.0, -1.0, 0.0], device=self.device, dtype=self.dtype  # Slow along -Y (same as MOSFLM)
            )
            odet_vec = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype   # Normal along +X (same as MOSFLM)
            )
        elif c.detector_convention == DetectorConvention.CUSTOM:
            # CUSTOM convention uses user-provided vectors or defaults to MOSFLM
            if c.custom_fdet_vector is not None:
                fdet_vec = torch.tensor(
                    c.custom_fdet_vector, device=self.device, dtype=self.dtype
                )
            else:
                # Default to MOSFLM fast vector
                fdet_vec = torch.tensor(
                    [0.0, 0.0, 1.0], device=self.device, dtype=self.dtype
                )
    
            if c.custom_sdet_vector is not None:
                sdet_vec = torch.tensor(
                    c.custom_sdet_vector, device=self.device, dtype=self.dtype
                )
            else:
                # Default to MOSFLM slow vector
                sdet_vec = torch.tensor(
                    [0.0, -1.0, 0.0], device=self.device, dtype=self.dtype
                )
    
            if c.custom_odet_vector is not None:
                odet_vec = torch.tensor(
                    c.custom_odet_vector, device=self.device, dtype=self.dtype
                )
            else:
                # Default to MOSFLM normal vector
                odet_vec = torch.tensor(
                    [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
                )
        else:
>           raise ValueError(f"Unknown detector convention: {c.detector_convention}")
E           ValueError: Unknown detector convention: MOSFLM

src/nanobrag_torch/models/detector.py:1284: ValueError
=========================== short test summary info ============================
FAILED tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_k_frac_phi0_matches_c
============================== 1 failed in 2.10s ===============================
