============================= test session starts ==============================
platform linux -- Python 3.13.5, pytest-8.4.1, pluggy-1.5.0 -- /home/ollie/miniconda3/bin/python3.13
cachedir: .pytest_cache
rootdir: /home/ollie/Documents/tmp/nanoBragg
configfile: pyproject.toml
plugins: anyio-4.9.0
collecting ... collected 72 items

tests/test_at_cli_004.py::test_header_precedence_img_then_mask PASSED    [  1%]
tests/test_at_cli_004.py::test_mask_zeros_are_skipped PASSED             [  2%]
tests/test_at_cli_004.py::test_mask_beam_center_y_flip PASSED            [  4%]
tests/test_at_cli_004.py::test_conflicting_detector_size PASSED          [  5%]
tests/test_at_cli_004.py::test_img_only_no_mask PASSED                   [  6%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_r_factor_calculation PASSED [  8%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_distance_update_with_close_distance PASSED [  9%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_preservation_beam_pivot PASSED [ 11%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_preservation_sample_pivot PASSED [ 12%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_no_rotations_r_factor_equals_one PASSED [ 13%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_with_various_rotations[DetectorPivot.BEAM] PASSED [ 15%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_with_various_rotations[DetectorPivot.SAMPLE] PASSED [ 16%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_gradients_flow_through_r_factor PASSED [ 18%]
tests/test_at_parallel_002.py::TestATParallel002::test_beam_center_scales_with_pixel_size FAILED [ 19%]
tests/test_at_parallel_002.py::TestATParallel002::test_peak_position_scales_inversely_with_pixel_size PASSED [ 20%]
tests/test_at_parallel_002.py::TestATParallel002::test_pattern_correlation_across_pixel_sizes PASSED [ 22%]
tests/test_at_parallel_002.py::TestATParallel002::test_beam_center_parameter_consistency FAILED [ 23%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_simple_cubic_correlation PASSED [ 25%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_triclinic_P1_correlation PASSED [ 26%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_cubic_tilted_detector_correlation PASSED [ 27%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_high_resolution_variant PASSED [ 29%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles0-cubic-cell_params0] SKIPPED [ 30%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles0-triclinic-cell_params1] SKIPPED [ 31%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles1-cubic-cell_params0] SKIPPED [ 33%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles1-triclinic-cell_params1] SKIPPED [ 34%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles2-cubic-cell_params0] SKIPPED [ 36%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles2-triclinic-cell_params1] SKIPPED [ 37%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles3-cubic-cell_params0] SKIPPED [ 38%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles3-triclinic-cell_params1] SKIPPED [ 40%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles4-cubic-cell_params0] SKIPPED [ 41%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles4-triclinic-cell_params1] SKIPPED [ 43%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_misset_changes_pattern SKIPPED [ 44%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_sincg_throughput PASSED [ 45%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_dot_product_throughput PASSED [ 47%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_profile_hot_paths PASSED [ 48%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_vectorization_efficiency PASSED [ 50%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_critical_operations_performance PASSED [ 51%]
tests/test_at_sam_002.py::TestAT_SAM_002_OversampleLastValue::test_oversample_omega_last_value_semantics PASSED [ 52%]
tests/test_at_sam_002.py::TestAT_SAM_002_OversampleLastValue::test_oversample_without_subpixel_flags PASSED [ 54%]
tests/test_at_sam_002.py::TestAT_SAM_002_OversampleLastValue::test_oversample_flag_precedence PASSED [ 55%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_square_shape_model PASSED [ 56%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_round_shape_model PASSED [ 58%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_gauss_shape_model FAILED [ 59%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_tophat_shape_model PASSED [ 61%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_shape_model_comparison FAILED [ 62%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_fudge_parameter_scaling PASSED [ 63%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_shape_models_at_bragg_peak PASSED [ 65%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_printout_flag FAILED [ 66%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_printout_pixel_flag PASSED [ 68%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_trace_pixel_flag FAILED [ 69%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_combined_debug_flags FAILED [ 70%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_out_of_bounds_pixel FAILED [ 72%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_auto_select_formula PASSED [ 73%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_different_crystal_sizes PASSED [ 75%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_explicit_oversample_overrides_auto PASSED [ 76%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_different_wavelengths PASSED [ 77%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_vectorized_matches_scalar PASSED [ 79%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_neighborhood_gathering_internals PASSED [ 80%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_oob_warning_single_fire ✓ Phase C2: OOB warning single-fire behavior validated
  - First OOB: warning printed, interpolation disabled, returned default_F=100.0
  - Second OOB: no warning, still returns default_F=100.0
  - In-bounds post-disable: uses fallback path, returns 50.0
PASSED [ 81%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_device_neutrality[cpu] PASSED [ 83%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_device_neutrality[cuda] SKIPPED [ 84%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polint_matches_scalar_batched PASSED [ 86%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polint_gradient_flow PASSED [ 87%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin2_matches_scalar_batched PASSED [ 88%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin2_gradient_flow PASSED [ 90%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin3_matches_scalar_batched PASSED [ 91%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin3_gradient_flow PASSED [ 93%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin3_batch_shape_preserved PASSED [ 94%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_support_float64[dtype0] PASSED [ 95%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_support_float64[dtype1] PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_device_neutral[cpu] PASSED [ 98%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_device_neutral[cuda] SKIPPED [100%]

=================================== FAILURES ===================================
__________ TestATParallel002.test_beam_center_scales_with_pixel_size ___________

self = <tests.test_at_parallel_002.TestATParallel002 object at 0x7c8736884910>

    def test_beam_center_scales_with_pixel_size(self):
        """Test that beam center in pixels scales inversely with pixel size.
    
        AT-PARALLEL-002: With fixed 256x256 detector and beam center at 25.6mm,
        the beam center in pixels SHALL equal 25.6mm / pixel_size_mm ±0.1 pixels.
        """
        pixel_sizes = [0.05, 0.1, 0.2, 0.4]  # mm
        # Use detector center (128 pixels for 256x256 detector)
        fixed_beam_center_pixels = 128  # Center pixel
    
        for pixel_size in pixel_sizes:
            # Calculate beam center in mm for this pixel size
            beam_center_mm = fixed_beam_center_pixels * pixel_size
    
            # Create detector config with fixed size and varying pixel size
            detector_config = DetectorConfig(
                detector_convention=DetectorConvention.MOSFLM,
                distance_mm=100.0,
                pixel_size_mm=pixel_size,
                spixels=256,
                fpixels=256,
                beam_center_s=beam_center_mm,
                beam_center_f=beam_center_mm,
            )
    
            # Verify that the beam center in mm is preserved
            assert abs(detector_config.beam_center_s - beam_center_mm) < 0.001, \
                f"Beam center S (mm) not preserved for pixel_size={pixel_size}mm"
            assert abs(detector_config.beam_center_f - beam_center_mm) < 0.001, \
                f"Beam center F (mm) not preserved for pixel_size={pixel_size}mm"
    
            # Create detector to verify pixel coordinates
            detector = Detector(detector_config)
    
            # Calculate expected beam center in pixels
            # When user explicitly provides beam_center in mm, it's converted directly to pixels
            # (MOSFLM +0.5 offset is only applied when beam_center is auto-calculated in DetectorConfig)
            expected_beam_pixel = beam_center_mm / pixel_size
    
            # The detector internally stores beam centers in pixels
            # Verify the beam center in pixels scales inversely with pixel size
>           assert abs(detector.beam_center_s.item() - expected_beam_pixel) < 0.1, \
                f"Beam center S (pixels) mismatch for pixel_size={pixel_size}mm: {detector.beam_center_s.item()} vs {expected_beam_pixel}"
E           AssertionError: Beam center S (pixels) mismatch for pixel_size=0.05mm: 128.5 vs 128.0
E           assert 0.5 < 0.1
E            +  where 0.5 = abs((128.5 - 128.0))
E            +    where 128.5 = <built-in method item of Tensor object at 0x7c86de17eee0>()
E            +      where <built-in method item of Tensor object at 0x7c86de17eee0> = tensor(128.5000).item
E            +        where tensor(128.5000) = <src.nanobrag_torch.models.detector.Detector object at 0x7c86de329450>.beam_center_s

tests/test_at_parallel_002.py:71: AssertionError
___________ TestATParallel002.test_beam_center_parameter_consistency ___________

self = <tests.test_at_parallel_002.TestATParallel002 object at 0x7c8736858e90>

    def test_beam_center_parameter_consistency(self):
        """Test that beam center parameters are handled consistently across pixel sizes.
    
        Additional test to verify parameter handling.
        """
        pixel_sizes = [0.05, 0.1, 0.2, 0.4]  # mm
        # Use detector center (128 pixels for 256x256 detector)
        fixed_beam_center_pixels = 128  # Center pixel
    
        for pixel_size in pixel_sizes:
            # Calculate beam center in mm for this pixel size
            beam_center_mm = fixed_beam_center_pixels * pixel_size
            # Calculate beam center in mm for this pixel size
            beam_center_mm = fixed_beam_center_pixels * pixel_size
    
            # Test that setting beam center in mm is properly converted
            detector_config = DetectorConfig(
                detector_convention=DetectorConvention.MOSFLM,
                distance_mm=100.0,
                pixel_size_mm=pixel_size,
                spixels=256,
                fpixels=256,
                beam_center_s=beam_center_mm,
                beam_center_f=beam_center_mm,
            )
    
            detector = Detector(detector_config)
    
            # Verify the detector stores beam centers correctly in pixels
            # When user explicitly provides beam_center, it's converted directly without offset
            expected_beam_pixel = beam_center_mm / pixel_size
    
>           assert abs(detector.beam_center_s.item() - expected_beam_pixel) < 0.01, \
                f"Detector beam_center_s incorrect for pixel_size={pixel_size}mm"
E           AssertionError: Detector beam_center_s incorrect for pixel_size=0.05mm
E           assert 0.5 < 0.01
E            +  where 0.5 = abs((128.5 - 128.0))
E            +    where 128.5 = <built-in method item of Tensor object at 0x7c8867c699a0>()
E            +      where <built-in method item of Tensor object at 0x7c8867c699a0> = tensor(128.5000).item
E            +        where tensor(128.5000) = <src.nanobrag_torch.models.detector.Detector object at 0x7c86d619fa50>.beam_center_s

tests/test_at_parallel_002.py:269: AssertionError
___________ TestAT_STR_003_LatticeShapeModels.test_gauss_shape_model ___________

self = <tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels object at 0x7c86de2b6ea0>

    def test_gauss_shape_model(self):
        """Test GAUSS (Gaussian in reciprocal space) lattice shape model."""
        # Configure for GAUSS shape
        self.crystal_config.shape = CrystalShape.GAUSS
        self.crystal_config.fudge = 1.0
    
        # Create simulator to test the full implementation
>       simulator = Simulator(
            crystal=Crystal(self.crystal_config),
            detector=None,  # Not needed for this test
            crystal_config=self.crystal_config,
            beam_config=self.beam_config,
        )

tests/test_at_str_003.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.simulator.Simulator object at 0x7c86dc2b0dd0>
crystal = <nanobrag_torch.models.crystal.Crystal object at 0x7c86ce8527a0>
detector = None
crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=(...'gauss'>, fudge=1.0, sample_x=1.0000000000000001e-07, sample_y=1.0000000000000001e-07, sample_z=1.0000000000000001e-07)
beam_config = BeamConfig(wavelength_A=1.0, N_source_points=1, source_distance_mm=10000.0, source_size_mm=0.0, source_directions=None...=(0.0, 0.0, 1.0), flux=0.0, exposure=0.0, beamsize_mm=0.0, fluence=1.2593201528622709e+29, dmin=0.0, water_size_um=0.0)
device = None, dtype = torch.float32, debug_config = None

    def __init__(
        self,
        crystal: Crystal,
        detector: Detector,
        crystal_config: Optional[CrystalConfig] = None,
        beam_config: Optional[BeamConfig] = None,
        device=None,
        dtype=torch.float32,
        debug_config: Optional[dict] = None,
    ):
        """
        Initialize simulator with crystal, detector, and configurations.
    
        Args:
            crystal: Crystal object containing unit cell and structure factors
            detector: Detector object with geometry parameters
            crystal_config: Configuration for crystal rotation parameters (phi, mosaic)
            beam_config: Beam configuration (optional, for future use)
            device: PyTorch device (cpu/cuda)
            dtype: PyTorch data type
            debug_config: Debug configuration with printout, printout_pixel, trace_pixel options
        """
        self.crystal = crystal
        self.detector = detector
        # If crystal_config is provided, update only the rotation-related parameters
        # This preserves essential parameters like cell dimensions and default_F
        if crystal_config is not None:
            # Update only the rotation-related fields that are explicitly set
            # This preserves the crystal's essential parameters while allowing rotation updates
            if hasattr(crystal_config, 'phi_start_deg'):
                self.crystal.config.phi_start_deg = crystal_config.phi_start_deg
            if hasattr(crystal_config, 'osc_range_deg'):
                self.crystal.config.osc_range_deg = crystal_config.osc_range_deg
            if hasattr(crystal_config, 'phi_steps'):
                self.crystal.config.phi_steps = crystal_config.phi_steps
            if hasattr(crystal_config, 'mosaic_spread_deg'):
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
        else:
            self.device = torch.device("cpu")
        self.dtype = dtype
    
        # PERF-PYTORCH-004 Attempt #14: Ensure detector is on the same device/dtype as simulator
        # This prevents device mismatch errors when detector tensors (beam_vector, pixel_coords)
        # interact with simulator tensors (wavelength, incident_beam_direction) during compilation
        if self.detector is not None:
            self.detector = self.detector.to(device=self.device, dtype=self.dtype)
    
        # Store debug configuration
        self.debug_config = debug_config if debug_config is not None else {}
        self.printout = self.debug_config.get('printout', False)
        self.printout_pixel = self.debug_config.get('printout_pixel', None)  # [fast, slow]
        self.trace_pixel = self.debug_config.get('trace_pixel', None)  # [slow, fast]
    
        # Phase CLI-FLAGS-003 M0a: Enable trace instrumentation on Crystal when trace_pixel is active
        # This guards _last_tricubic_neighborhood population to prevent unconditional debug payload retention
        if self.trace_pixel is not None:
            self.crystal._enable_trace = True
    
        # Set incident beam direction from detector.beam_vector
        # This is critical for convention consistency (AT-PARALLEL-004) and CLI override support (CLI-FLAGS-003 Phase H2)
        # The detector.beam_vector property handles both convention defaults and CUSTOM overrides (e.g., -beam_vector)
        if self.detector is not None:
            # Use detector's beam_vector property which handles:
            # - CUSTOM convention with user-supplied custom_beam_vector
            # - Convention defaults (MOSFLM: [1,0,0], XDS/DIALS: [0,0,1])
            # The detector normalizes and returns the vector with correct device/dtype
            self.incident_beam_direction = self.detector.beam_vector.clone()
        else:
            # If no detector provided, default to MOSFLM beam direction
            self.incident_beam_direction = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        # PERF-PYTORCH-006: Store wavelength as tensor with correct dtype
        self.wavelength = torch.tensor(self.beam_config.wavelength_A, device=self.device, dtype=self.dtype)
    
        # Physical constants (from nanoBragg.c ~line 240)
        # PERF-PYTORCH-006: Store as tensors with correct dtype to avoid implicit float64 upcasting
        self.r_e_sqr = torch.tensor(
            7.94079248018965e-30, device=self.device, dtype=self.dtype  # classical electron radius squared (meters squared)
        )
        # Use fluence from beam config (AT-FLU-001)
        self.fluence = torch.tensor(self.beam_config.fluence, device=self.device, dtype=self.dtype)
        # Polarization setup from beam config
        # PERF-PYTORCH-006: Store as tensor with correct dtype
        kahn_value = self.beam_config.polarization_factor if not self.beam_config.nopolar else 0.0
        self.kahn_factor = torch.tensor(kahn_value, device=self.device, dtype=self.dtype)
        self.polarization_axis = torch.tensor(
            self.beam_config.polarization_axis, device=self.device, dtype=self.dtype
        )
    
        # PERF-PYTORCH-004 P1.2 + P3.0: Pre-normalize source tensors to avoid repeated .to() calls in run()
        # Move source direction/wavelength/weight tensors to correct device/dtype once during init
        # P3.0: Seed fallback tensors (equal weights, primary wavelength) when omitted before device cast
        _has_sources = (self.beam_config.source_directions is not None and
                       len(self.beam_config.source_directions) > 0)
        if _has_sources:
            self._source_directions = self.beam_config.source_directions.to(device=self.device, dtype=self.dtype)
    
            # P3.0: Default source_wavelengths to primary wavelength if not provided (AT-SRC-001)
            if self.beam_config.source_wavelengths is not None:
                self._source_wavelengths = self.beam_config.source_wavelengths.to(device=self.device, dtype=self.dtype)  # meters
            else:
                # Use primary wavelength for all sources
                primary_wavelength_m = self.beam_config.wavelength_A * 1e-10
                n_sources = len(self.beam_config.source_directions)
                self._source_wavelengths = torch.full((n_sources,), primary_wavelength_m, device=self.device, dtype=self.dtype)
    
            self._source_wavelengths_A = self._source_wavelengths * 1e10  # Convert to Angstroms once
    
            # P3.0: Default source_weights to equal weights if not provided
            if self.beam_config.source_weights is not None:
                self._source_weights = self.beam_config.source_weights.to(device=self.device, dtype=self.dtype)
            else:
                # Default to equal weights if not provided
                self._source_weights = torch.ones(len(self.beam_config.source_directions), device=self.device, dtype=self.dtype)
        else:
            self._source_directions = None
            self._source_wavelengths_A = None
            self._source_weights = None
    
        # PERF-PYTORCH-004 P3.4: Cache frequently-accessed tensors to reduce per-run allocations
        # Pre-convert pixel coordinates to correct device/dtype once
>       self._cached_pixel_coords_meters = self.detector.get_pixel_coords().to(device=self.device, dtype=self.dtype)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'

src/nanobrag_torch/simulator.py:569: AttributeError
________ TestAT_STR_003_LatticeShapeModels.test_shape_model_comparison _________

self = <tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels object at 0x7c86de3572f0>

    def test_shape_model_comparison(self):
        """Compare all four shape models at the same reflection."""
        # Test point slightly off a Bragg peak
        h_frac = 0.1  # Fractional Miller index offset
        k_frac = 0.1
        l_frac = 0.1
    
        results = {}
    
        for shape in [CrystalShape.SQUARE, CrystalShape.ROUND,
                     CrystalShape.GAUSS, CrystalShape.TOPHAT]:
            self.crystal_config.shape = shape
    
            # Create simulator with this shape
>           simulator = Simulator(
                crystal=Crystal(self.crystal_config),
                detector=None,
                crystal_config=self.crystal_config,
                beam_config=self.beam_config,
            )

tests/test_at_str_003.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.simulator.Simulator object at 0x7c86dbf231d0>
crystal = <nanobrag_torch.models.crystal.Crystal object at 0x7c86dc1fee50>
detector = None
crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=(...square'>, fudge=1.0, sample_x=1.0000000000000001e-07, sample_y=1.0000000000000001e-07, sample_z=1.0000000000000001e-07)
beam_config = BeamConfig(wavelength_A=1.0, N_source_points=1, source_distance_mm=10000.0, source_size_mm=0.0, source_directions=None...=(0.0, 0.0, 1.0), flux=0.0, exposure=0.0, beamsize_mm=0.0, fluence=1.2593201528622709e+29, dmin=0.0, water_size_um=0.0)
device = None, dtype = torch.float32, debug_config = None

    def __init__(
        self,
        crystal: Crystal,
        detector: Detector,
        crystal_config: Optional[CrystalConfig] = None,
        beam_config: Optional[BeamConfig] = None,
        device=None,
        dtype=torch.float32,
        debug_config: Optional[dict] = None,
    ):
        """
        Initialize simulator with crystal, detector, and configurations.
    
        Args:
            crystal: Crystal object containing unit cell and structure factors
            detector: Detector object with geometry parameters
            crystal_config: Configuration for crystal rotation parameters (phi, mosaic)
            beam_config: Beam configuration (optional, for future use)
            device: PyTorch device (cpu/cuda)
            dtype: PyTorch data type
            debug_config: Debug configuration with printout, printout_pixel, trace_pixel options
        """
        self.crystal = crystal
        self.detector = detector
        # If crystal_config is provided, update only the rotation-related parameters
        # This preserves essential parameters like cell dimensions and default_F
        if crystal_config is not None:
            # Update only the rotation-related fields that are explicitly set
            # This preserves the crystal's essential parameters while allowing rotation updates
            if hasattr(crystal_config, 'phi_start_deg'):
                self.crystal.config.phi_start_deg = crystal_config.phi_start_deg
            if hasattr(crystal_config, 'osc_range_deg'):
                self.crystal.config.osc_range_deg = crystal_config.osc_range_deg
            if hasattr(crystal_config, 'phi_steps'):
                self.crystal.config.phi_steps = crystal_config.phi_steps
            if hasattr(crystal_config, 'mosaic_spread_deg'):
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
        else:
            self.device = torch.device("cpu")
        self.dtype = dtype
    
        # PERF-PYTORCH-004 Attempt #14: Ensure detector is on the same device/dtype as simulator
        # This prevents device mismatch errors when detector tensors (beam_vector, pixel_coords)
        # interact with simulator tensors (wavelength, incident_beam_direction) during compilation
        if self.detector is not None:
            self.detector = self.detector.to(device=self.device, dtype=self.dtype)
    
        # Store debug configuration
        self.debug_config = debug_config if debug_config is not None else {}
        self.printout = self.debug_config.get('printout', False)
        self.printout_pixel = self.debug_config.get('printout_pixel', None)  # [fast, slow]
        self.trace_pixel = self.debug_config.get('trace_pixel', None)  # [slow, fast]
    
        # Phase CLI-FLAGS-003 M0a: Enable trace instrumentation on Crystal when trace_pixel is active
        # This guards _last_tricubic_neighborhood population to prevent unconditional debug payload retention
        if self.trace_pixel is not None:
            self.crystal._enable_trace = True
    
        # Set incident beam direction from detector.beam_vector
        # This is critical for convention consistency (AT-PARALLEL-004) and CLI override support (CLI-FLAGS-003 Phase H2)
        # The detector.beam_vector property handles both convention defaults and CUSTOM overrides (e.g., -beam_vector)
        if self.detector is not None:
            # Use detector's beam_vector property which handles:
            # - CUSTOM convention with user-supplied custom_beam_vector
            # - Convention defaults (MOSFLM: [1,0,0], XDS/DIALS: [0,0,1])
            # The detector normalizes and returns the vector with correct device/dtype
            self.incident_beam_direction = self.detector.beam_vector.clone()
        else:
            # If no detector provided, default to MOSFLM beam direction
            self.incident_beam_direction = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        # PERF-PYTORCH-006: Store wavelength as tensor with correct dtype
        self.wavelength = torch.tensor(self.beam_config.wavelength_A, device=self.device, dtype=self.dtype)
    
        # Physical constants (from nanoBragg.c ~line 240)
        # PERF-PYTORCH-006: Store as tensors with correct dtype to avoid implicit float64 upcasting
        self.r_e_sqr = torch.tensor(
            7.94079248018965e-30, device=self.device, dtype=self.dtype  # classical electron radius squared (meters squared)
        )
        # Use fluence from beam config (AT-FLU-001)
        self.fluence = torch.tensor(self.beam_config.fluence, device=self.device, dtype=self.dtype)
        # Polarization setup from beam config
        # PERF-PYTORCH-006: Store as tensor with correct dtype
        kahn_value = self.beam_config.polarization_factor if not self.beam_config.nopolar else 0.0
        self.kahn_factor = torch.tensor(kahn_value, device=self.device, dtype=self.dtype)
        self.polarization_axis = torch.tensor(
            self.beam_config.polarization_axis, device=self.device, dtype=self.dtype
        )
    
        # PERF-PYTORCH-004 P1.2 + P3.0: Pre-normalize source tensors to avoid repeated .to() calls in run()
        # Move source direction/wavelength/weight tensors to correct device/dtype once during init
        # P3.0: Seed fallback tensors (equal weights, primary wavelength) when omitted before device cast
        _has_sources = (self.beam_config.source_directions is not None and
                       len(self.beam_config.source_directions) > 0)
        if _has_sources:
            self._source_directions = self.beam_config.source_directions.to(device=self.device, dtype=self.dtype)
    
            # P3.0: Default source_wavelengths to primary wavelength if not provided (AT-SRC-001)
            if self.beam_config.source_wavelengths is not None:
                self._source_wavelengths = self.beam_config.source_wavelengths.to(device=self.device, dtype=self.dtype)  # meters
            else:
                # Use primary wavelength for all sources
                primary_wavelength_m = self.beam_config.wavelength_A * 1e-10
                n_sources = len(self.beam_config.source_directions)
                self._source_wavelengths = torch.full((n_sources,), primary_wavelength_m, device=self.device, dtype=self.dtype)
    
            self._source_wavelengths_A = self._source_wavelengths * 1e10  # Convert to Angstroms once
    
            # P3.0: Default source_weights to equal weights if not provided
            if self.beam_config.source_weights is not None:
                self._source_weights = self.beam_config.source_weights.to(device=self.device, dtype=self.dtype)
            else:
                # Default to equal weights if not provided
                self._source_weights = torch.ones(len(self.beam_config.source_directions), device=self.device, dtype=self.dtype)
        else:
            self._source_directions = None
            self._source_wavelengths_A = None
            self._source_weights = None
    
        # PERF-PYTORCH-004 P3.4: Cache frequently-accessed tensors to reduce per-run allocations
        # Pre-convert pixel coordinates to correct device/dtype once
>       self._cached_pixel_coords_meters = self.detector.get_pixel_coords().to(device=self.device, dtype=self.dtype)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'

src/nanobrag_torch/simulator.py:569: AttributeError
__________________ TestDebugTraceFeatures.test_printout_flag ___________________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7c86de344e10>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_printout_flag(self, minimal_args):
        """Test that -printout produces verbose debug output."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with -printout flag
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-printout'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: No CUDA runtime is found, using CUDA_HOME='/usr'
E             Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmpoah6aw4u.bin', '-printout'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\nauto-selected 2-fold oversampling\n', stderr='No CUDA runtime is found, using CUDA_HOME=\'/usr\'\nError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

tests/test_debug_trace.py:50: AssertionError
_________________ TestDebugTraceFeatures.test_trace_pixel_flag _________________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7c86de2b6fd0>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_trace_pixel_flag(self, minimal_args):
        """Test that -trace_pixel produces detailed trace for specific pixel."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with -trace_pixel flag for pixel (32, 32) [slow, fast]
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-trace_pixel', '32', '32'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: No CUDA runtime is found, using CUDA_HOME='/usr'
E             Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmpw__22zip.bin', '-trace_pixel', '32', '32'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=32, fast=32)\nauto-selected 2-fold oversampling\n', stderr='No CUDA runtime is found, using CUDA_HOME=\'/usr\'\nError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

tests/test_debug_trace.py:121: AssertionError
_______________ TestDebugTraceFeatures.test_combined_debug_flags _______________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7c86de2b7100>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_combined_debug_flags(self, minimal_args):
        """Test that multiple debug flags can be used together."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with both -printout and -trace_pixel
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-printout',
                '-trace_pixel', '30', '30'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: No CUDA runtime is found, using CUDA_HOME='/usr'
E             Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp1qiouclc.bin', '-printout', '-trace_pixel', '30', '30'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\n  Tracing pixel (slow=30, fast=30)\nauto-selected 2-fold oversampling\n', stderr='No CUDA runtime is found, using CUDA_HOME=\'/usr\'\nError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

tests/test_debug_trace.py:160: AssertionError
_______________ TestDebugTraceFeatures.test_out_of_bounds_pixel ________________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7c86de1745f0>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_out_of_bounds_pixel(self, minimal_args):
        """Test that out-of-bounds pixel indices are handled gracefully."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with out-of-bounds pixel (detector is 64x64)
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-trace_pixel', '100', '100'  # Out of bounds
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Should still succeed (gracefully handle out of bounds)
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: No CUDA runtime is found, using CUDA_HOME='/usr'
E             Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp80fj18ed.bin', '-trace_pixel', '100', '100'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=100, fast=100)\nauto-selected 2-fold oversampling\n', stderr='No CUDA runtime is found, using CUDA_HOME=\'/usr\'\nError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

tests/test_debug_trace.py:198: AssertionError
- generated xml file: /home/ollie/Documents/tmp/nanoBragg/reports/2026-01-test-suite-triage/phase_m0/20251011T153931Z/chunks/chunk_06/pytest.xml -
============================= slowest 5 durations ==============================
4.94s call     tests/test_at_cli_004.py::test_header_precedence_img_then_mask
4.89s call     tests/test_at_cli_004.py::test_img_only_no_mask
4.88s call     tests/test_at_cli_004.py::test_mask_beam_center_y_flip
4.88s call     tests/test_at_cli_004.py::test_mask_zeros_are_skipped
4.84s call     tests/test_at_cli_004.py::test_conflicting_detector_size
=========================== short test summary info ============================
FAILED tests/test_at_parallel_002.py::TestATParallel002::test_beam_center_scales_with_pixel_size
FAILED tests/test_at_parallel_002.py::TestATParallel002::test_beam_center_parameter_consistency
FAILED tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_gauss_shape_model
FAILED tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_shape_model_comparison
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_printout_flag
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_trace_pixel_flag
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_combined_debug_flags
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_out_of_bounds_pixel
============= 8 failed, 51 passed, 13 skipped in 61.91s (0:01:01) ==============
EXIT_CODE=1
