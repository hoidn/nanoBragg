============================= test session starts ==============================
platform linux -- Python 3.13.5, pytest-8.4.1, pluggy-1.5.0 -- /home/ollie/miniconda3/bin/python3.13
cachedir: .pytest_cache
rootdir: /home/ollie/Documents/tmp/nanoBragg
configfile: pyproject.toml
plugins: anyio-4.9.0
collecting ... collected 1 item

tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_pytorch_determinism FAILED [100%]

=================================== FAILURES ===================================
_________________ TestAT_PARALLEL_024.test_pytorch_determinism _________________

self = <tests.test_at_parallel_024.TestAT_PARALLEL_024 object at 0x786d6e300190>
base_config = {'N_cells': (5, 5, 5), 'cell_params': (100.0, 100.0, 100.0, 90.0, 90.0, 90.0), 'default_F': 100.0, 'detector_size': (256, 256), ...}
tmp_path = PosixPath('/tmp/pytest-of-ollie/pytest-481/test_pytorch_determinism0')

    def test_pytorch_determinism(self, base_config, tmp_path):
        """Test that same seed produces identical results in PyTorch."""
        seeds = [12345, 54321]
    
        for seed in seeds:
            # Create two identical crystal configurations with the same seed
            crystal_config1 = CrystalConfig(
                cell_a=base_config['cell_params'][0],
                cell_b=base_config['cell_params'][1],
                cell_c=base_config['cell_params'][2],
                cell_alpha=base_config['cell_params'][3],
                cell_beta=base_config['cell_params'][4],
                cell_gamma=base_config['cell_params'][5],
                N_cells=base_config['N_cells'],
                default_F=base_config['default_F'],
                phi_start_deg=base_config['phi'],
                osc_range_deg=base_config['osc'],
                mosaic_spread_deg=base_config['mosaic'],
                misset_random=True,
                misset_seed=seed
            )
    
            crystal_config2 = CrystalConfig(
                cell_a=base_config['cell_params'][0],
                cell_b=base_config['cell_params'][1],
                cell_c=base_config['cell_params'][2],
                cell_alpha=base_config['cell_params'][3],
                cell_beta=base_config['cell_params'][4],
                cell_gamma=base_config['cell_params'][5],
                N_cells=base_config['N_cells'],
                default_F=base_config['default_F'],
                phi_start_deg=base_config['phi'],
                osc_range_deg=base_config['osc'],
                mosaic_spread_deg=base_config['mosaic'],
                misset_random=True,
                misset_seed=seed
            )
    
            # Create detector and beam configs
            detector_config = DetectorConfig(
                distance_mm=base_config['distance'],
                pixel_size_mm=base_config['pixel_size'],
                spixels=base_config['detector_size'][0],
                fpixels=base_config['detector_size'][1],
                oversample=base_config['oversample']
            )
    
            beam_config = BeamConfig(
                wavelength_A=base_config['wavelength']
            )
    
            # Create two separate simulators
            crystal1 = Crystal(crystal_config1, beam_config, dtype=torch.float64)
            detector1 = Detector(detector_config, dtype=torch.float64)
>           sim1 = Simulator(crystal1, detector1, crystal_config1, beam_config)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_at_parallel_024.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/nanobrag_torch/simulator.py:569: in __init__
    self._cached_pixel_coords_meters = self.detector.get_pixel_coords().to(device=self.device, dtype=self.dtype)
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.models.detector.Detector object at 0x786d6e48bcb0>

    def get_pixel_coords(self) -> torch.Tensor:
        """
        Get 3D coordinates of all detector pixels.
    
        Supports both planar and curved (spherical) detector mappings.
        For curved detector: pixels are mapped to a spherical arc by rotating
        from the beam direction by angles Sdet/distance and Fdet/distance.
    
        Returns:
            torch.Tensor: Pixel coordinates with shape (spixels, fpixels, 3) in meters
        """
        # Check if geometry has changed by comparing cached values
        geometry_changed = False
        if hasattr(self, "_cached_basis_vectors") and hasattr(
            self, "_cached_pix0_vector"
        ):
            # Check if basis vectors have changed
            # Move cached vectors to current device for comparison
            cached_f = self._cached_basis_vectors[0].to(self.device)
            cached_s = self._cached_basis_vectors[1].to(self.device)
            cached_o = self._cached_basis_vectors[2].to(self.device)
    
            if not (
>               torch.allclose(self.fdet_vec, cached_f, atol=1e-15)
                and torch.allclose(
                    self.sdet_vec, cached_s, atol=1e-15
                )
                and torch.allclose(
                    self.odet_vec, cached_o, atol=1e-15
                )
            ):
E           RuntimeError: Float did not match Double

src/nanobrag_torch/models/detector.py:767: RuntimeError
============================= slowest 10 durations =============================

(3 durations < 0.005s hidden.  Use -vv to show these durations.)
=========================== short test summary info ============================
FAILED tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_pytorch_determinism
============================== 1 failed in 2.08s ===============================
