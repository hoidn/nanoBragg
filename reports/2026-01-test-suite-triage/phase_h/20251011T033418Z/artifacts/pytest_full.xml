<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="36" skipped="145" tests="685" time="1867.551" timestamp="2025-10-10T20:34:59.052043-07:00" hostname="ollie-System-Product-Name"><testcase classname="" name="tests.test_at_parallel_009" time="0.000"><skipped message="collection skipped">('/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_009.py', 24, 'Skipped: Skipping parallel validation tests. Set NB_RUN_PARALLEL=1 to run.')</skipped></testcase><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_absorption_disabled_when_zero[cpu]" time="1.596" /><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_capture_fraction_calculation[False-cpu]" time="0.002" /><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_capture_fraction_calculation[True-cpu]" time="0.001" /><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_last_value_vs_accumulation_semantics[cpu]" time="0.424" /><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_parallax_dependence[False-cpu]" time="0.281" /><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_parallax_dependence[True-cpu]" time="0.006" /><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_absorption_with_tilted_detector[False-cpu]" time="0.007" /><testcase classname="tests.test_at_abs_001.TestAT_ABS_001" name="test_absorption_with_tilted_detector[True-cpu]" time="0.006" /><testcase classname="tests.test_at_bkg_001.TestAT_BKG_001" name="test_water_background_calculation" time="1.115" /><testcase classname="tests.test_at_bkg_001.TestAT_BKG_001" name="test_water_background_zero" time="0.003" /><testcase classname="tests.test_at_bkg_001.TestAT_BKG_001" name="test_water_background_additive" time="0.005" /><testcase classname="tests.test_at_cli_001.TestAT_CLI_001" name="test_cli_help_short_flag" time="1.009" /><testcase classname="tests.test_at_cli_001.TestAT_CLI_001" name="test_cli_help_long_flag" time="0.987" /><testcase classname="tests.test_at_cli_001.TestAT_CLI_001" name="test_cli_invocable" time="0.000" /><testcase classname="tests.test_at_cli_001.TestAT_CLI_001" name="test_cli_help_includes_examples" time="0.992" /><testcase classname="tests.test_at_cli_001.TestAT_CLI_001" name="test_cli_help_includes_wavelength_synonyms" time="0.990" /><testcase classname="tests.test_at_cli_001.TestAT_CLI_001" name="test_cli_help_includes_output_synonyms" time="0.999" /><testcase classname="tests.test_at_cli_002.TestAT_CLI_002" name="test_minimal_render_with_default_F" time="1.000" /><testcase classname="tests.test_at_cli_002.TestAT_CLI_002" name="test_minimal_render_with_hkl_file" time="1.007" /><testcase classname="tests.test_at_cli_002.TestAT_CLI_002" name="test_data_ordering_fast_major" time="0.987" /><testcase classname="tests.test_at_cli_002.TestAT_CLI_002" name="test_error_without_required_inputs" time="0.988" /><testcase classname="tests.test_at_cli_003.TestATCLI003" name="test_mosflm_default_pivot_beam" time="1.008" /><testcase classname="tests.test_at_cli_003.TestATCLI003" name="test_xds_default_pivot_sample" time="1.005" /><testcase classname="tests.test_at_cli_003.TestATCLI003" name="test_pivot_override_mosflm_to_sample" time="1.005" /><testcase classname="tests.test_at_cli_003.TestATCLI003" name="test_pivot_override_xds_to_beam" time="1.000" /><testcase classname="tests.test_at_cli_003.TestATCLI003" name="test_convention_header_keys_consistency" time="3.018" /><testcase classname="tests.test_at_cli_004" name="test_header_precedence_img_then_mask" time="1.009" /><testcase classname="tests.test_at_cli_004" name="test_mask_zeros_are_skipped" time="1.002" /><testcase classname="tests.test_at_cli_004" name="test_mask_beam_center_y_flip" time="1.001" /><testcase classname="tests.test_at_cli_004" name="test_conflicting_detector_size" time="1.002" /><testcase classname="tests.test_at_cli_004" name="test_img_only_no_mask" time="1.004" /><testcase classname="tests.test_at_cli_005" name="test_cli_roi_basic" time="1.012" /><testcase classname="tests.test_at_cli_005" name="test_cli_roi_with_noise" time="1.021" /><testcase classname="tests.test_at_cli_005" name="test_cli_roi_edge_cases" time="2.008" /><testcase classname="tests.test_at_cli_005" name="test_cli_roi_different_conventions" time="2.018" /><testcase classname="tests.test_at_cli_006" name="test_autoscale_without_scale_flag" time="1.010" /><testcase classname="tests.test_at_cli_006" name="test_explicit_scale_flag" time="1.001" /><testcase classname="tests.test_at_cli_006" name="test_pgm_without_pgmscale" time="0.997" /><testcase classname="tests.test_at_cli_006" name="test_pgm_with_explicit_pgmscale" time="1.000" /><testcase classname="tests.test_at_cli_006" name="test_pgm_format_compliance" time="0.998" /><testcase classname="tests.test_at_cli_007.TestATCLI007NoiseDeterminism" name="test_identical_seed_produces_identical_noise" time="2.006" /><testcase classname="tests.test_at_cli_007.TestATCLI007NoiseDeterminism" name="test_different_seed_produces_different_noise" time="2.017" /><testcase classname="tests.test_at_cli_007.TestATCLI007NoiseDeterminism" name="test_seed_determinism_without_roi" time="2.004" /><testcase classname="tests.test_at_cli_007.TestATCLI007NoiseDeterminism" name="test_negative_seed_accepted" time="2.013" /><testcase classname="tests.test_at_cli_007.TestATCLI007NoiseDeterminism" name="test_overload_count_determinism" time="3.038" /><testcase classname="tests.test_at_cli_008.TestATCLI008DminFiltering" name="test_dmin_filtering_reduces_intensity" time="2.033" /><testcase classname="tests.test_at_cli_008.TestATCLI008DminFiltering" name="test_dmin_very_strict_removes_most_intensity" time="1.030" /><testcase classname="tests.test_at_cli_008.TestATCLI008DminFiltering" name="test_dmin_zero_has_no_effect" time="2.019" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_missing_hkl_and_fdump_with_default_f_zero" time="0.994" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_missing_hkl_but_has_default_f" time="1.000" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_missing_cell_parameters" time="0.988" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_fdump_fallback" time="1.005" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_help_message" time="0.995" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_unsupported_flag_dispstep" time="0.993" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_unsupported_flag_hdiv" time="0.999" /><testcase classname="tests.test_at_cli_009.TestATCLI009ErrorHandling" name="test_unsupported_flag_vdiv" time="0.990" /><testcase classname="tests.test_at_crystal_absolute.TestATCrystalAbsolute" name="test_triclinic_absolute_positions" time="0.268" /><testcase classname="tests.test_at_crystal_absolute.TestATCrystalAbsolute" name="test_cubic_vs_triclinic_systematic_difference" time="0.011" /><testcase classname="tests.test_at_crystal_absolute.TestATCrystalAbsolute" name="test_known_reflection_d_spacings" time="0.003" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_fluence_calculation_from_flux_exposure_beamsize" time="0.000" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_no_fluence_calculation_when_flux_zero" time="0.000" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_no_fluence_calculation_when_exposure_zero" time="0.000" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_fluence_calculation_with_beamsize_zero" time="0.000" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_flux_recomputation_from_fluence_and_exposure" time="0.000" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_sample_clipping_warning" time="0.001" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_no_clipping_when_beamsize_larger" time="0.000" /><testcase classname="tests.test_at_flu_001.TestAT_FLU_001" name="test_no_clipping_when_beamsize_zero" time="0.000" /><testcase classname="tests.test_at_geo_001" name="test_at_geo_001_mosflm_beam_center_mapping" time="0.001" /><testcase classname="tests.test_at_geo_002" name="test_at_geo_002_setup_a_distance_only" time="0.000" /><testcase classname="tests.test_at_geo_002" name="test_at_geo_002_setup_b_close_distance_only" time="0.000" /><testcase classname="tests.test_at_geo_002" name="test_at_geo_002_setup_c_explicit_override" time="0.000" /><testcase classname="tests.test_at_geo_002" name="test_at_geo_002_setup_c_beam_override" time="0.000" /><testcase classname="tests.test_at_geo_002" name="test_at_geo_002_direct_instantiation" time="0.000" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_r_factor_calculation" time="0.001" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_distance_update_with_close_distance" time="0.001" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_beam_center_preservation_beam_pivot" time="0.001" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_beam_center_preservation_sample_pivot" time="0.001" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_no_rotations_r_factor_equals_one" time="0.001" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_beam_center_with_various_rotations[DetectorPivot.BEAM]" time="0.003" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_beam_center_with_various_rotations[DetectorPivot.SAMPLE]" time="0.004" /><testcase classname="tests.test_at_geo_003.TestATGEO003RFactorAndBeamCenter" name="test_gradients_flow_through_r_factor" time="0.001" /><testcase classname="tests.test_at_geo_004" name="test_twotheta_axis_defaults" time="0.000" /><testcase classname="tests.test_at_geo_004" name="test_twotheta_axis_override" time="0.000" /><testcase classname="tests.test_at_geo_004" name="test_twotheta_rotation_applied" time="0.001" /><testcase classname="tests.test_at_geo_004" name="test_twotheta_value_preserved" time="0.001" /><testcase classname="tests.test_at_geo_004" name="test_mosflm_twotheta_rotation" time="0.001" /><testcase classname="tests.test_at_geo_004" name="test_dials_twotheta_rotation" time="0.000" /><testcase classname="tests.test_at_geo_005.TestATGEO005CurvedDetector" name="test_curved_detector_equal_distance" time="0.001" /><testcase classname="tests.test_at_geo_005.TestATGEO005CurvedDetector" name="test_curved_vs_planar_difference" time="0.002" /><testcase classname="tests.test_at_geo_005.TestATGEO005CurvedDetector" name="test_small_angle_rotation_consistency" time="0.001" /><testcase classname="tests.test_at_geo_005.TestATGEO005CurvedDetector" name="test_gradient_flow_curved_detector" time="0.001" /><testcase classname="tests.test_at_geo_005.TestATGEO005CurvedDetector" name="test_beam_center_affects_curvature" time="0.002" /><testcase classname="tests.test_at_geo_006.TestATGEO006PointPixelSolidAngle" name="test_point_pixel_solid_angle" time="0.001" /><testcase classname="tests.test_at_geo_006.TestATGEO006PointPixelSolidAngle" name="test_default_solid_angle_with_obliquity" time="0.001" /><testcase classname="tests.test_at_geo_006.TestATGEO006PointPixelSolidAngle" name="test_off_center_pixel_comparison" time="0.002" /><testcase classname="tests.test_at_geo_006.TestATGEO006PointPixelSolidAngle" name="test_gradient_flow" time="0.001" /><testcase classname="tests.test_at_geo_006.TestATGEO006PointPixelSolidAngle" name="test_corner_pixel_values" time="0.001" /><testcase classname="tests.test_at_io_001.TestAT_IO_001" name="test_smv_header_required_keys" time="0.001" /><testcase classname="tests.test_at_io_001.TestAT_IO_001" name="test_smv_data_ordering" time="0.000" /><testcase classname="tests.test_at_io_001.TestAT_IO_001" name="test_smv_convention_specific_headers" time="0.001" /><testcase classname="tests.test_at_io_001.TestAT_IO_001" name="test_smv_torch_tensor_input" time="0.001" /><testcase classname="tests.test_at_io_001.TestAT_IO_001" name="test_smv_byte_order" time="0.001" /><testcase classname="tests.test_at_io_002.TestAT_IO_002" name="test_pgm_header_format" time="0.000" /><testcase classname="tests.test_at_io_002.TestAT_IO_002" name="test_pgm_pixel_scaling" time="0.000" /><testcase classname="tests.test_at_io_002.TestAT_IO_002" name="test_pgm_with_default_scale" time="0.000" /><testcase classname="tests.test_at_io_002.TestAT_IO_002" name="test_pgm_torch_tensor_input" time="0.000" /><testcase classname="tests.test_at_io_002.TestAT_IO_002" name="test_pgm_clipping_behavior" time="0.000" /><testcase classname="tests.test_at_io_003.TestAT_IO_003" name="test_fdump_write_and_read" time="0.001" /><testcase classname="tests.test_at_io_003.TestAT_IO_003" name="test_fdump_cache_behavior" time="0.001" /><testcase classname="tests.test_at_io_003.TestAT_IO_003" name="test_fdump_no_files_with_default_F" time="0.000" /><testcase classname="tests.test_at_io_003.TestAT_IO_003" name="test_fdump_no_files_zero_default" time="0.000" /><testcase classname="tests.test_at_io_003.TestAT_IO_003" name="test_fdump_preserves_default_F" time="0.001" /><testcase classname="tests.test_at_io_003.TestAT_IO_003" name="test_fdump_header_structure" time="0.001" /><testcase classname="tests.test_at_io_004.TestAT_IO_004" name="test_minimal_hkl_format" time="0.001" /><testcase classname="tests.test_at_io_004.TestAT_IO_004" name="test_five_column_with_phase" time="0.001" /><testcase classname="tests.test_at_io_004.TestAT_IO_004" name="test_six_column_with_sigma_and_phase" time="0.001" /><testcase classname="tests.test_at_io_004.TestAT_IO_004" name="test_negative_indices_handling" time="0.001" /><testcase classname="tests.test_at_io_004.TestAT_IO_004" name="test_all_formats_produce_same_pattern" time="0.011" /><testcase classname="tests.test_at_io_004.TestAT_IO_004" name="test_fdump_caching_for_all_formats" time="0.002" /><testcase classname="tests.test_at_io_004.TestAT_IO_004" name="test_comment_and_blank_line_handling" time="0.001" /><testcase classname="tests.test_at_noise_001.TestATNoise001" name="test_small_mean_exact_poisson" time="0.659" /><testcase classname="tests.test_at_noise_001.TestATNoise001" name="test_medium_mean_rejection_sampling" time="0.070" /><testcase classname="tests.test_at_noise_001.TestATNoise001" name="test_large_mean_gaussian_approximation" time="0.008" /><testcase classname="tests.test_at_noise_001.TestATNoise001" name="test_seed_reproducibility" time="0.001" /><testcase classname="tests.test_at_noise_001.TestATNoise001" name="test_adc_and_clipping" time="0.000" /><testcase classname="tests.test_at_noise_001.TestATNoise001" name="test_all_regimes_in_single_image" time="0.000" /><testcase classname="tests.test_at_noise_001.TestATNoise001" name="test_noise_config_integration" time="0.000" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_beam_center_scales_with_detector_size[64]" time="0.000" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_beam_center_scales_with_detector_size[128]" time="0.000" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_beam_center_scales_with_detector_size[256]" time="0.000" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_beam_center_scales_with_detector_size[512]" time="0.000" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_beam_center_scales_with_detector_size[1024]" time="0.000" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_peak_position_at_beam_center" time="0.004" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_cli_beam_center_calculation" time="3.042" /><testcase classname="tests.test_at_parallel_001.TestATParallel001" name="test_intensity_scaling_with_solid_angle" time="0.009" /><testcase classname="tests.test_at_parallel_002.TestATParallel002" name="test_beam_center_scales_with_pixel_size" time="0.003" /><testcase classname="tests.test_at_parallel_002.TestATParallel002" name="test_peak_position_scales_inversely_with_pixel_size" time="0.027" /><testcase classname="tests.test_at_parallel_002.TestATParallel002" name="test_pattern_correlation_across_pixel_sizes" time="0.142" /><testcase classname="tests.test_at_parallel_002.TestATParallel002" name="test_beam_center_parameter_consistency" time="0.003" /><testcase classname="tests.test_at_parallel_003.TestATParallel003" name="test_detector_offset_preservation" time="0.006" /><testcase classname="tests.test_at_parallel_003.TestATParallel003" name="test_peak_position_at_offset_beam_centers" time="0.018" /><testcase classname="tests.test_at_parallel_003.TestATParallel003" name="test_offset_ratio_preservation" time="0.000" /><testcase classname="tests.test_at_parallel_004.TestAT_PARALLEL_004" name="test_mosflm_adds_half_pixel_offset" time="0.001" /><testcase classname="tests.test_at_parallel_004.TestAT_PARALLEL_004" name="test_xds_has_no_pixel_offset" time="0.001" /><testcase classname="tests.test_at_parallel_004.TestAT_PARALLEL_004" name="test_peak_position_difference" time="0.391" /><testcase classname="tests.test_at_parallel_004.TestAT_PARALLEL_004" name="test_pattern_correlation_when_aligned" time="0.012" /><testcase classname="tests.test_at_parallel_004.TestAT_PARALLEL_004" name="test_beam_center_calculation_consistency" time="0.001" /><testcase classname="tests.test_at_parallel_005.TestAT_PARALLEL_005_BeamCenterMapping" name="test_mosflm_xbeam_ybeam_mapping" time="0.000"><skipped type="pytest.skip" message="Parallel validation tests only run with NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_005.py:39: Parallel validation tests only run with NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_005.TestAT_PARALLEL_005_BeamCenterMapping" name="test_xds_orgx_orgy_mapping" time="0.000"><skipped type="pytest.skip" message="Parallel validation tests only run with NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_005.py:64: Parallel validation tests only run with NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_005.TestAT_PARALLEL_005_BeamCenterMapping" name="test_pivot_mode_consistency" time="0.000"><skipped type="pytest.skip" message="Parallel validation tests only run with NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_005.py:90: Parallel validation tests only run with NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_005.TestAT_PARALLEL_005_BeamCenterMapping" name="test_equivalent_configurations_produce_same_pattern" time="0.000"><skipped type="pytest.skip" message="Parallel validation tests only run with NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_005.py:131: Parallel validation tests only run with NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_006.TestATParallel006SingleReflection" name="test_bragg_angle_prediction_single_distance" time="0.180" /><testcase classname="tests.test_at_parallel_006.TestATParallel006SingleReflection" name="test_distance_scaling" time="0.089" /><testcase classname="tests.test_at_parallel_006.TestATParallel006SingleReflection" name="test_combined_wavelength_and_distance" time="0.072" /><testcase classname="tests.test_at_parallel_007.TestATParallel007PeakPositionWithRotations" name="test_peak_positions_with_rotations" time="0.000"><skipped type="pytest.skip" message="Parallel C-PyTorch tests disabled (set NB_RUN_PARALLEL=1)">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_007.py:244: Parallel C-PyTorch tests disabled (set NB_RUN_PARALLEL=1)</skipped></testcase><testcase classname="tests.test_at_parallel_007.TestATParallel007PeakPositionWithRotations" name="test_peak_intensity_ordering" time="0.000"><skipped type="pytest.skip" message="Parallel C-PyTorch tests disabled">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_007.py:303: Parallel C-PyTorch tests disabled</skipped></testcase><testcase classname="tests.test_at_parallel_007.TestATParallel007PeakPositionWithRotations" name="test_rotation_effect_on_pattern" time="0.000"><skipped type="pytest.skip" message="Parallel C-PyTorch tests disabled">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_007.py:335: Parallel C-PyTorch tests disabled</skipped></testcase><testcase classname="tests.test_at_parallel_008.TestAT_PARALLEL_008" name="test_triclinic_multi_peak_pattern" time="0.000"><skipped type="pytest.skip" message="Requires NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_008.py:187: Requires NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_008.TestAT_PARALLEL_008" name="test_peak_intensity_ordering" time="0.000"><skipped type="pytest.skip" message="Requires NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_008.py:324: Requires NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_008.TestAT_PARALLEL_008" name="test_non_max_suppression" time="0.000"><skipped type="pytest.skip" message="Requires NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_008.py:368: Requires NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_010.TestATParallel010SolidAngleCorrections" name="test_point_pixel_distance_scaling" time="0.000"><skipped type="pytest.skip" message="AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_010.py:152: AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary</skipped></testcase><testcase classname="tests.test_at_parallel_010.TestATParallel010SolidAngleCorrections" name="test_obliquity_distance_scaling" time="0.000"><skipped type="pytest.skip" message="AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_010.py:228: AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary</skipped></testcase><testcase classname="tests.test_at_parallel_010.TestATParallel010SolidAngleCorrections" name="test_obliquity_with_tilts" time="0.000"><skipped type="pytest.skip" message="AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_010.py:285: AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary</skipped></testcase><testcase classname="tests.test_at_parallel_010.TestATParallel010SolidAngleCorrections" name="test_combined_distance_and_tilt" time="0.000"><skipped type="pytest.skip" message="AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_010.py:340: AT-PARALLEL tests require NB_RUN_PARALLEL=1 and C binary</skipped></testcase><testcase classname="tests.test_at_parallel_011.TestATParallel011PolarizationFactor" name="test_unpolarized_theory" time="0.008" /><testcase classname="tests.test_at_parallel_011.TestATParallel011PolarizationFactor" name="test_polarized_kahn_model" time="0.007" /><testcase classname="tests.test_at_parallel_011.TestATParallel011PolarizationFactor" name="test_c_pytorch_equivalence" time="0.000"><skipped type="pytest.skip" message="Parallel validation requires NB_RUN_PARALLEL=1 environment variable">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_011.py:360: Parallel validation requires NB_RUN_PARALLEL=1 environment variable</skipped></testcase><testcase classname="tests.test_at_parallel_012.TestATParallel012ReferencePatternCorrelation" name="test_simple_cubic_correlation" time="0.165" /><testcase classname="tests.test_at_parallel_012.TestATParallel012ReferencePatternCorrelation" name="test_triclinic_P1_correlation" time="0.094" /><testcase classname="tests.test_at_parallel_012.TestATParallel012ReferencePatternCorrelation" name="test_cubic_tilted_detector_correlation" time="0.180" /><testcase classname="tests.test_at_parallel_012.TestATParallel012ReferencePatternCorrelation" name="test_high_resolution_variant" time="2.323" /><testcase classname="tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency" name="test_pytorch_determinism_same_seed" time="1.069"><failure message="AssertionError: Correlation 0.9999873042106628 &lt; 0.9999999 for same-seed runs&#10;assert np.float32(0.9999873) &gt;= 0.9999999">self = &lt;tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency object at 0x7ab044e3de50&gt;

    def test_pytorch_determinism_same_seed(self):
        """Test that PyTorch produces identical results with same seed."""
        # Run simulation twice with same seed
        result1 = run_simulation_deterministic(seed=42)
        result2 = run_simulation_deterministic(seed=42)
    
        # Should be exactly identical (bit-for-bit)
        assert np.array_equal(result1, result2), (
            "PyTorch not deterministic - results differ with same seed"
        )
    
        # Also check with allclose for numerical precision
        np.testing.assert_allclose(
            result1, result2,
            rtol=1e-7,
            atol=1e-12,
            err_msg="PyTorch determinism: tolerance check failed"
        )
    
        # Correlation should be perfect (1.0)
        corr, _ = pearsonr(result1.flatten(), result2.flatten())
&gt;       assert corr &gt;= 0.9999999, f"Correlation {corr} &lt; 0.9999999 for same-seed runs"
E       AssertionError: Correlation 0.9999873042106628 &lt; 0.9999999 for same-seed runs
E       assert np.float32(0.9999873) &gt;= 0.9999999

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_013.py:164: AssertionError</failure></testcase><testcase classname="tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency" name="test_pytorch_determinism_different_seeds" time="0.350"><failure message="AssertionError: Correlation 0.9999873042106628 &lt; 0.9999999 for identical physics&#10;assert np.float32(0.9999873) &gt;= 0.9999999">self = &lt;tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency object at 0x7ab044e3df90&gt;

    def test_pytorch_determinism_different_seeds(self):
        """Test that PyTorch produces different results with different seeds."""
        # Note: This test configuration uses fixed misset angles and no mosaic/noise,
        # so different seeds won't affect the result. We expect identical results.
    
        # Run simulation with different seeds
        result1 = run_simulation_deterministic(seed=42)
        result2 = run_simulation_deterministic(seed=123)
    
        # With no random components (fixed misset, no mosaic, no noise),
        # results should be identical regardless of seed
        np.testing.assert_allclose(
            result1, result2,
            rtol=1e-7,
            atol=1e-12,
            err_msg="Results differ despite no random components"
        )
    
        # Correlation should be perfect
        corr, _ = pearsonr(result1.flatten(), result2.flatten())
&gt;       assert corr &gt;= 0.9999999, f"Correlation {corr} &lt; 0.9999999 for identical physics"
E       AssertionError: Correlation 0.9999873042106628 &lt; 0.9999999 for identical physics
E       assert np.float32(0.9999873) &gt;= 0.9999999

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_013.py:191: AssertionError</failure></testcase><testcase classname="tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency" name="test_pytorch_consistency_across_runs" time="0.886" /><testcase classname="tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency" name="test_c_pytorch_equivalence" time="0.000"><skipped type="pytest.skip" message="Requires NB_RUN_PARALLEL=1 and C binary">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_013.py:218: Requires NB_RUN_PARALLEL=1 and C binary</skipped></testcase><testcase classname="tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency" name="test_platform_fingerprint" time="0.002" /><testcase classname="tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency" name="test_numerical_precision_float64" time="0.713" /><testcase classname="tests.test_at_parallel_014.TestATParallel014NoiseRobustness" name="test_mean_preservation_after_scaling" time="0.546" /><testcase classname="tests.test_at_parallel_014.TestATParallel014NoiseRobustness" name="test_peak_centroid_stability" time="0.033" /><testcase classname="tests.test_at_parallel_014.TestATParallel014NoiseRobustness" name="test_overload_count_consistency" time="0.023" /><testcase classname="tests.test_at_parallel_014.TestATParallel014NoiseRobustness" name="test_noise_statistics" time="1.462" /><testcase classname="tests.test_at_parallel_014.TestATParallel014NoiseRobustness" name="test_deterministic_noise_with_seed" time="0.016" /><testcase classname="tests.test_at_parallel_015.TestATParallel015MixedUnits" name="test_distance_units_consistency" time="0.010" /><testcase classname="tests.test_at_parallel_015.TestATParallel015MixedUnits" name="test_wavelength_units_consistency" time="0.018" /><testcase classname="tests.test_at_parallel_015.TestATParallel015MixedUnits" name="test_angle_units_consistency" time="0.014" /><testcase classname="tests.test_at_parallel_015.TestATParallel015MixedUnits" name="test_mixed_units_comprehensive" time="0.341"><failure message="AssertionError: Zero maximum intensity&#10;assert tensor(0., dtype=torch.float32) &gt; 0&#10; +  where tensor(0., dtype=torch.float32) = &lt;built-in method max of Tensor object at 0x7ab034cd4d20&gt;()&#10; +    where &lt;built-in method max of Tensor object at 0x7ab034cd4d20&gt; = tensor([[0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.]], dtype=torch.float32).max">self = &lt;tests.test_at_parallel_015.TestATParallel015MixedUnits object at 0x7ab044de3950&gt;

    def test_mixed_units_comprehensive(self):
        """Test comprehensive mixed unit scenario."""
        # Configuration with explicit units
        crystal_config = CrystalConfig(
            cell_a=75.5,      # Angstroms
            cell_b=82.3,      # Angstroms
            cell_c=91.7,      # Angstroms
            cell_alpha=87.5,  # degrees
            cell_beta=92.3,   # degrees
            cell_gamma=95.8,  # degrees
            default_F=100.0,
            N_cells=(3, 3, 3),
            phi_start_deg=0.0,    # degrees
            osc_range_deg=1.0,    # degrees
            phi_steps=1,
        )
    
        detector_config = DetectorConfig(
            distance_mm=150.5,      # millimeters
            pixel_size_mm=0.172,    # millimeters
            spixels=128,
            fpixels=128,
            detector_convention=DetectorConvention.XDS,
            detector_rotx_deg=5.0,  # degrees
            detector_roty_deg=3.0,  # degrees
            detector_rotz_deg=2.0,  # degrees
            detector_twotheta_deg=10.0,  # degrees
        )
    
        beam_config = BeamConfig(
            wavelength_A=1.54,  # Angstroms (Cu K-alpha)
            fluence=1e23,
            polarization_factor=0.95,  # dimensionless
            dmin=2.0,          # Angstroms
        )
    
        # Create models
        det = Detector(detector_config)
        crystal = Crystal(crystal_config)
    
        # Verify unit conversions happened correctly
        # Detector distance should be in meters internally
        assert np.isclose(det.distance, 0.1505, rtol=1e-6), \
            f"Distance conversion error: {det.distance} != 0.1505"
    
        # Pixel size should be in meters internally
        assert np.isclose(det.pixel_size, 0.000172, rtol=1e-6), \
            f"Pixel size conversion error: {det.pixel_size} != 0.000172"
    
        # Rotations are converted internally but not exposed as attributes
        # We can verify they work correctly by running the simulation
    
        # Wavelength should be in meters internally (used in simulator)
        # Note: BeamConfig stores in Angstroms, conversion happens in simulator
        assert beam_config.wavelength_A == 1.54, "Wavelength storage error"
    
        # Run simulation
        sim = Simulator(detector=det, crystal=crystal, beam_config=beam_config)
        intensity = sim.run(oversample=1)
    
        # Comprehensive checks
        assert intensity.shape == (128, 128), f"Wrong output shape: {intensity.shape}"
&gt;       assert intensity.max() &gt; 0, "Zero maximum intensity"
E       AssertionError: Zero maximum intensity
E       assert tensor(0., dtype=torch.float32) &gt; 0
E        +  where tensor(0., dtype=torch.float32) = &lt;built-in method max of Tensor object at 0x7ab034cd4d20&gt;()
E        +    where &lt;built-in method max of Tensor object at 0x7ab034cd4d20&gt; = tensor([[0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.]], dtype=torch.float32).max

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_015.py:274: AssertionError</failure></testcase><testcase classname="tests.test_at_parallel_015.TestATParallel015MixedUnits" name="test_detector_rotation_units" time="0.026" /><testcase classname="tests.test_at_parallel_016.TestATParallel016ExtremeScale" name="test_tiny_scale" time="1.046" /><testcase classname="tests.test_at_parallel_016.TestATParallel016ExtremeScale" name="test_large_cell" time="0.872" /><testcase classname="tests.test_at_parallel_016.TestATParallel016ExtremeScale" name="test_long_distance" time="0.012" /><testcase classname="tests.test_at_parallel_016.TestATParallel016ExtremeScale" name="test_extreme_scale_c_comparison" time="0.000"><skipped type="pytest.skip" message="C-PyTorch parallel tests require NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_016.py:223: C-PyTorch parallel tests require NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_016.TestATParallel016ExtremeScale" name="test_combined_extremes" time="0.012" /><testcase classname="tests.test_at_parallel_016.TestATParallel016ExtremeScale" name="test_numerical_stability_metrics" time="0.004" /><testcase classname="tests.test_at_parallel_017.TestATParallel017GrazingIncidence" name="test_large_detector_tilts" time="0.388" /><testcase classname="tests.test_at_parallel_017.TestATParallel017GrazingIncidence" name="test_large_twotheta" time="0.014" /><testcase classname="tests.test_at_parallel_017.TestATParallel017GrazingIncidence" name="test_combined_extreme_angles" time="0.008" /><testcase classname="tests.test_at_parallel_017.TestATParallel017GrazingIncidence" name="test_near_90_degree_incidence" time="0.007" /><testcase classname="tests.test_at_parallel_017.TestATParallel017GrazingIncidence" name="test_solid_angle_obliquity_corrections" time="0.002" /><testcase classname="tests.test_at_parallel_017.TestATParallel017GrazingIncidence" name="test_extreme_rotation_stability" time="0.005" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_cubic_crystal_aligned_axes" time="0.005" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_zero_angle_rotations" time="0.005" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_near_singular_cell_angles" time="0.010" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_aligned_spindle_and_beam" time="0.407" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_very_small_unit_cell" time="0.006" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_very_large_unit_cell" time="0.005" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_continuity_near_90_degrees" time="0.036" /><testcase classname="tests.test_at_parallel_018.TestATParallel018CrystalBoundaryConditions" name="test_identity_misset_matrix" time="0.005" /><testcase classname="tests.test_at_parallel_020.TestATParallel020" name="test_comprehensive_integration" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_020.py:280: NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)</skipped></testcase><testcase classname="tests.test_at_parallel_020.TestATParallel020" name="test_comprehensive_without_absorption" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_020.py:332: NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)</skipped></testcase><testcase classname="tests.test_at_parallel_020.TestATParallel020" name="test_phi_rotation_only" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_020.py:364: NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)</skipped></testcase><testcase classname="tests.test_at_parallel_020.TestATParallel020" name="test_comprehensive_minimal_features" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_020.py:399: NB_RUN_PARALLEL=1 not set (C-PyTorch validation tests disabled)</skipped></testcase><testcase classname="tests.test_at_parallel_021.TestCrystalPhiRotation" name="test_single_step_phi_rotation" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_021.py:114: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_021.TestCrystalPhiRotation" name="test_multi_step_phi_rotation" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_021.py:252: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_022.TestATParallel022" name="test_single_step_with_detector_rotations" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_022.py:188: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_022.TestATParallel022" name="test_multi_step_with_detector_rotations" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_022.py:265: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_022.TestATParallel022" name="test_large_detector_rotations" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_022.py:343: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles0-cubic-cell_params0]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles0-triclinic-cell_params1]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles1-cubic-cell_params0]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles1-triclinic-cell_params1]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles2-cubic-cell_params0]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles2-triclinic-cell_params1]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles3-cubic-cell_params0]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles3-triclinic-cell_params1]" time="0.229"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles4-cubic-cell_params0]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_explicit_misset_equivalence[misset_angles4-triclinic-cell_params1]" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:194: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_023.TestAT_PARALLEL_023_MissetAnglesEquivalence" name="test_misset_changes_pattern" time="0.000"><skipped type="pytest.skip" message="C binary not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_023.py:293: C binary not available</skipped></testcase><testcase classname="tests.test_at_parallel_024.TestAT_PARALLEL_024" name="test_pytorch_determinism" time="0.057" /><testcase classname="tests.test_at_parallel_024.TestAT_PARALLEL_024" name="test_seed_independence" time="0.028" /><testcase classname="tests.test_at_parallel_024.TestAT_PARALLEL_024" name="test_c_pytorch_equivalence" time="0.000"><skipped type="pytest.skip" message="Known scaling issue: ~500x difference between C and PyTorch implementations. Interface fix is complete - C code correctly receives misset parameters.">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_024.py:192: Known scaling issue: ~500x difference between C and PyTorch implementations. Interface fix is complete - C code correctly receives misset parameters.</skipped></testcase><testcase classname="tests.test_at_parallel_024.TestAT_PARALLEL_024" name="test_lcg_compatibility" time="0.000" /><testcase classname="tests.test_at_parallel_024.TestAT_PARALLEL_024" name="test_mosaic_rotation_umat_determinism" time="0.001"><failure message="RuntimeError: Float did not match Double">self = &lt;tests.test_at_parallel_024.TestAT_PARALLEL_024 object at 0x7ab044ebe450&gt;

    def test_mosaic_rotation_umat_determinism(self):
        """Test that mosaic_rotation_umat is deterministic with same seed."""
        seed = 12345
        mosaicity = np.pi / 2.0  # 90 degrees
    
        # Generate two matrices with same seed
        umat1 = mosaic_rotation_umat(mosaicity, seed)
        umat2 = mosaic_rotation_umat(mosaicity, seed)
    
        # They should be identical
        assert torch.allclose(umat1, umat2, rtol=1e-12, atol=1e-15), \
            "Same seed did not produce identical rotation matrices"
    
        # Check that it's unitary (rotation matrix property)
        identity = torch.matmul(umat1, umat1.T)
        expected_identity = torch.eye(3, dtype=torch.float64)
&gt;       assert torch.allclose(identity, expected_identity, rtol=1e-10, atol=1e-12), \
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            "Generated matrix is not unitary"

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_024.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;torch.utils._device.DeviceContext object at 0x7ab03667e150&gt;
func = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;, types = ()
args = (tensor([[ 1.0000e+00,  1.4901e-08,  0.0000e+00],
        [ 1.4901e-08,  1.0000e+00, -2.2352e-08],
        [ 0.0000e+00, -2.2352e-08,  1.0000e+00]], dtype=torch.float32), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
kwargs = {'atol': 1e-12, 'rtol': 1e-10}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
&gt;       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^
E       RuntimeError: Float did not match Double

/home/ollie/miniconda3/lib/python3.13/site-packages/torch/utils/_device.py:104: RuntimeError</failure></testcase><testcase classname="tests.test_at_parallel_024.TestAT_PARALLEL_024" name="test_umat2misset_round_trip" time="0.002" /><testcase classname="tests.test_at_parallel_025" name="test_maximum_intensity_simple_case" time="0.000"><skipped type="pytest.skip" message="AT-PARALLEL tests require NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_025.py:60: AT-PARALLEL tests require NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_025" name="test_maximum_intensity_with_offset" time="0.000"><skipped type="pytest.skip" message="AT-PARALLEL tests require NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_025.py:126: AT-PARALLEL tests require NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_025" name="test_maximum_intensity_triclinic" time="0.000"><skipped type="pytest.skip" message="AT-PARALLEL tests require NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_025.py:193: AT-PARALLEL tests require NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_026.TestAT_PARALLEL_026_TriclinicAbsolutePosition" name="test_triclinic_absolute_peak_position_pytorch_only" time="0.013" /><testcase classname="tests.test_at_parallel_026.TestAT_PARALLEL_026_TriclinicAbsolutePosition" name="test_triclinic_absolute_peak_position_vs_c" time="0.012"><failure message="AssertionError: C reference run failed&#10;assert None is not None">self = &lt;tests.test_at_parallel_026.TestAT_PARALLEL_026_TriclinicAbsolutePosition object at 0x7ab044cf8410&gt;

    @pytest.mark.requires_c_binary
    def test_triclinic_absolute_peak_position_vs_c(self):
        """Test that PyTorch and C produce peaks at the same absolute position"""
    
        from scripts.c_reference_runner import CReferenceRunner
    
        # Setup configuration
        crystal_config, detector_config, beam_config = self.setup_triclinic_config()
    
        # Create models
        crystal = Crystal(crystal_config)
        detector = Detector(detector_config)
    
        # Create PyTorch simulator
        simulator = Simulator(crystal, detector, crystal_config, beam_config)
    
        # Run PyTorch simulation
        pytorch_image = simulator.run()
        pytorch_slow, pytorch_fast, pytorch_intensity = self.find_peak_position(pytorch_image)
    
        # Setup C runner
        runner = CReferenceRunner()
    
        # Run C simulation with same configs
        c_image = runner.run_simulation(
            detector_config,
            crystal_config,
            beam_config,
            label="Triclinic absolute position test"
        )
    
&gt;       assert c_image is not None, "C reference run failed"
E       AssertionError: C reference run failed
E       assert None is not None

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_026.py:147: AssertionError</failure></testcase><testcase classname="tests.test_at_parallel_026.TestAT_PARALLEL_026_TriclinicAbsolutePosition" name="test_triclinic_vs_cubic_peak_difference" time="0.024" /><testcase classname="tests.test_at_parallel_027.TestAT_PARALLEL_027" name="test_structure_factor_loading" time="0.001" /><testcase classname="tests.test_at_parallel_027.TestAT_PARALLEL_027" name="test_intensity_ratios" time="0.006" /><testcase classname="tests.test_at_parallel_027.TestAT_PARALLEL_027" name="test_pattern_structure" time="0.006" /><testcase classname="tests.test_at_parallel_027.TestAT_PARALLEL_027" name="test_c_pytorch_equivalence" time="0.000"><skipped type="pytest.skip" message="C-PyTorch parallel tests disabled unless NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_027.py:156: C-PyTorch parallel tests disabled unless NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_027.TestAT_PARALLEL_027" name="test_f_squared_scaling" time="0.001" /><testcase classname="tests.test_at_parallel_028.TestATParallel028PerformanceParity" name="test_cpu_performance_parity" time="0.000"><skipped type="pytest.skip" message="Performance tests disabled by default. Set NB_RUN_PERFORMANCE=1 to run.">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_028.py:171: Performance tests disabled by default. Set NB_RUN_PERFORMANCE=1 to run.</skipped></testcase><testcase classname="tests.test_at_parallel_028.TestATParallel028PerformanceParity" name="test_gpu_performance_superiority" time="0.000"><skipped type="pytest.skip" message="Performance tests disabled by default. Set NB_RUN_PERFORMANCE=1 to run.">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_028.py:204: Performance tests disabled by default. Set NB_RUN_PERFORMANCE=1 to run.</skipped></testcase><testcase classname="tests.test_at_parallel_028.TestATParallel028PerformanceParity" name="test_performance_measurement_validity" time="0.795" /><testcase classname="tests.test_at_parallel_029.TestSubpixelSamplingAT029" name="test_pytorch_aliasing_reduction" time="1.024" /><testcase classname="tests.test_at_parallel_029.TestSubpixelSamplingAT029" name="test_pytorch_peak_stability" time="1.024" /><testcase classname="tests.test_at_parallel_029.TestSubpixelSamplingAT029" name="test_pytorch_fwhm_convergence" time="1.025" /><testcase classname="tests.test_at_parallel_029.TestSubpixelSamplingAT029" name="test_c_pytorch_oversample_equivalence" time="0.000"><skipped type="pytest.skip" message="Parallel validation requires C binary and NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_029.py:271: Parallel validation requires C binary and NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_parallel_029.TestSubpixelSamplingAT029" name="test_issue_subpixel_aliasing" time="0.000"><skipped type="pytest.skip" message="Parallel validation requires C binary and NB_RUN_PARALLEL=1">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_029.py:326: Parallel validation requires C binary and NB_RUN_PARALLEL=1</skipped></testcase><testcase classname="tests.test_at_perf_001.TestATPERF001VectorizationPerformance" name="test_vectorization_scaling" time="3.002" /><testcase classname="tests.test_at_perf_001.TestATPERF001VectorizationPerformance" name="test_performance_parity_with_c" time="0.035"><skipped type="pytest.skip" message="C binary not found at ./nanoBragg">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_001.py:99: C binary not found at ./nanoBragg</skipped></testcase><testcase classname="tests.test_at_perf_001.TestATPERF001VectorizationPerformance" name="test_memory_scaling" time="0.137" /><testcase classname="tests.test_at_perf_002.TestATPERF002ParallelExecution" name="test_cpu_thread_scaling" time="2.065" /><testcase classname="tests.test_at_perf_002.TestATPERF002ParallelExecution" name="test_pytorch_cpu_vs_c_performance" time="0.393"><skipped type="pytest.skip" message="C binary not found at ./nanoBragg">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_002.py:87: C binary not found at ./nanoBragg</skipped></testcase><testcase classname="tests.test_at_perf_002.TestATPERF002ParallelExecution" name="test_gpu_acceleration" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_002.py:183: CUDA not available</skipped></testcase><testcase classname="tests.test_at_perf_002.TestATPERF002ParallelExecution" name="test_thread_efficiency" time="1.917" /><testcase classname="tests.test_at_perf_003.TestATPERF003MemoryBandwidth" name="test_peak_memory_usage" time="5.408" /><testcase classname="tests.test_at_perf_003.TestATPERF003MemoryBandwidth" name="test_float32_vs_float64_performance" time="7.789" /><testcase classname="tests.test_at_perf_003.TestATPERF003MemoryBandwidth" name="test_cache_friendly_access" time="0.629" /><testcase classname="tests.test_at_perf_003.TestATPERF003MemoryBandwidth" name="test_memory_bandwidth_utilization" time="2.172" /><testcase classname="tests.test_at_perf_003.TestATPERF003MemoryBandwidth" name="test_intermediate_tensor_optimization" time="0.024" /><testcase classname="tests.test_at_perf_004.TestATPERF004HotPathOptimization" name="test_sincg_throughput" time="0.572" /><testcase classname="tests.test_at_perf_004.TestATPERF004HotPathOptimization" name="test_dot_product_throughput" time="0.106" /><testcase classname="tests.test_at_perf_004.TestATPERF004HotPathOptimization" name="test_profile_hot_paths" time="0.082" /><testcase classname="tests.test_at_perf_004.TestATPERF004HotPathOptimization" name="test_vectorization_efficiency" time="0.052" /><testcase classname="tests.test_at_perf_004.TestATPERF004HotPathOptimization" name="test_critical_operations_performance" time="0.283" /><testcase classname="tests.test_at_perf_005.TestATPERF005CompilationOptimization" name="test_torch_compile_speedup" time="11.774" /><testcase classname="tests.test_at_perf_005.TestATPERF005CompilationOptimization" name="test_hot_function_compilation" time="0.150" /><testcase classname="tests.test_at_perf_005.TestATPERF005CompilationOptimization" name="test_compilation_amortization" time="7.420" /><testcase classname="tests.test_at_perf_005.TestATPERF005CompilationOptimization" name="test_gpu_kernel_compilation" time="0.000"><skipped type="pytest.skip" message="CUDA required for GPU compilation test">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_005.py:281: CUDA required for GPU compilation test</skipped></testcase><testcase classname="tests.test_at_perf_005.TestATPERF005CompilationOptimization" name="test_dtype_optimization_impact" time="0.589" /><testcase classname="tests.test_at_perf_006.TestATPERF006TensorVectorization" name="test_no_python_loops_in_core_path" time="0.002" /><testcase classname="tests.test_at_perf_006.TestATPERF006TensorVectorization" name="test_profile_tensor_operations_ratio" time="0.022" /><testcase classname="tests.test_at_perf_006.TestATPERF006TensorVectorization" name="test_vectorized_speedup" time="0.120" /><testcase classname="tests.test_at_perf_006.TestATPERF006TensorVectorization" name="test_tensor_shapes_include_all_dimensions" time="0.002"><skipped type="pytest.skip" message="Cannot verify tensor shapes without access to intermediate values">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_006.py:218: Cannot verify tensor shapes without access to intermediate values</skipped></testcase><testcase classname="tests.test_at_perf_006" name="test_oversample_performance_scaling[1]" time="0.007" /><testcase classname="tests.test_at_perf_006" name="test_oversample_performance_scaling[2]" time="0.009" /><testcase classname="tests.test_at_perf_006" name="test_oversample_performance_scaling[3]" time="0.012" /><testcase classname="tests.test_at_perf_006" name="test_oversample_performance_scaling[4]" time="0.018" /><testcase classname="tests.test_at_perf_006" name="test_detector_thickness_vectorization" time="0.024" /><testcase classname="tests.test_at_perf_007.TestATPerf007ComprehensiveBenchmark" name="test_benchmark_suite_execution" time="0.000"><skipped type="pytest.skip" message="Set NB_RUN_BENCHMARKS=1 to run comprehensive benchmarks">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_007.py:376: Set NB_RUN_BENCHMARKS=1 to run comprehensive benchmarks</skipped></testcase><testcase classname="tests.test_at_perf_007.TestATPerf007ComprehensiveBenchmark" name="test_pytorch_performance_basic" time="0.030" /><testcase classname="tests.test_at_perf_007.TestATPerf007ComprehensiveBenchmark" name="test_memory_scaling" time="0.077" /><testcase classname="tests.test_at_perf_007.TestATPerf007ComprehensiveBenchmark" name="test_gpu_performance" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_007.py:465: CUDA not available</skipped></testcase><testcase classname="tests.test_at_perf_007.TestATPerf007ComprehensiveBenchmark" name="test_benchmark_output_format" time="0.001" /><testcase classname="tests.test_at_perf_008.TestATPERF008CUDATensorResidency" name="test_large_tensor_gpu_residency" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_008.py:141: CUDA not available</skipped></testcase><testcase classname="tests.test_at_perf_008.TestATPERF008CUDATensorResidency" name="test_auto_device_selection_uses_cuda" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_008.py:212: CUDA not available</skipped></testcase><testcase classname="tests.test_at_perf_008.TestATPERF008CUDATensorResidency" name="test_skip_when_cuda_unavailable" time="0.006" /><testcase classname="tests.test_at_perf_008.TestATPERF008CUDATensorResidency" name="test_memory_efficient_gpu_usage" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_at_perf_008.py:283: CUDA not available</skipped></testcase><testcase classname="tests.test_at_pol_001.TestATPOL001KahnModel" name="test_polarization_factor_calculation" time="0.001" /><testcase classname="tests.test_at_pol_001.TestATPOL001KahnModel" name="test_nopolar_toggle" time="0.010" /><testcase classname="tests.test_at_pol_001.TestATPOL001KahnModel" name="test_oversample_polar_last_value_semantics" time="0.014" /><testcase classname="tests.test_at_pol_001.TestATPOL001KahnModel" name="test_polarization_with_tilted_detector" time="0.010" /><testcase classname="tests.test_at_pol_001.TestATPOL001KahnModel" name="test_polarization_factor_range" time="0.120" /><testcase classname="tests.test_at_pre_001" name="test_header_precedence_img_then_mask" time="0.985" /><testcase classname="tests.test_at_pre_001" name="test_mask_beam_center_y_flip" time="0.992" /><testcase classname="tests.test_at_pre_001" name="test_img_only_no_mask" time="0.977" /><testcase classname="tests.test_at_pre_002" name="test_xbeam_ybeam_forces_beam_pivot" time="0.981" /><testcase classname="tests.test_at_pre_002" name="test_xclose_yclose_forces_sample_pivot" time="0.988" /><testcase classname="tests.test_at_pre_002" name="test_orgx_orgy_forces_sample_pivot" time="0.979" /><testcase classname="tests.test_at_pre_002" name="test_explicit_pivot_override" time="1.949" /><testcase classname="tests.test_at_pre_002" name="test_distance_vs_close_distance_pivot_defaults" time="1.962" /><testcase classname="tests.test_at_pre_002" name="test_convention_default_pivots" time="1.964" /><testcase classname="tests.test_at_roi_001.TestAT_ROI_001" name="test_roi_bounds_default_to_full_detector" time="0.000" /><testcase classname="tests.test_at_roi_001.TestAT_ROI_001" name="test_roi_bounds_validation" time="0.000" /><testcase classname="tests.test_at_roi_001.TestAT_ROI_001" name="test_roi_limits_rendering_area" time="0.007" /><testcase classname="tests.test_at_roi_001.TestAT_ROI_001" name="test_mask_array_filtering" time="0.006" /><testcase classname="tests.test_at_roi_001.TestAT_ROI_001" name="test_roi_and_mask_combination" time="0.006" /><testcase classname="tests.test_at_roi_001.TestAT_ROI_001" name="test_mask_array_dimension_validation" time="0.000" /><testcase classname="tests.test_at_roi_001.TestAT_ROI_001" name="test_statistics_exclude_masked_pixels" time="0.011" /><testcase classname="tests.test_at_sam_001" name="test_at_sam_001_steps_normalization" time="0.685" /><testcase classname="tests.test_at_sam_002.TestAT_SAM_002_OversampleLastValue" name="test_oversample_omega_last_value_semantics" time="0.323" /><testcase classname="tests.test_at_sam_002.TestAT_SAM_002_OversampleLastValue" name="test_oversample_without_subpixel_flags" time="0.961" /><testcase classname="tests.test_at_sam_002.TestAT_SAM_002_OversampleLastValue" name="test_oversample_flag_precedence" time="0.005" /><testcase classname="tests.test_at_sam_003" name="test_dmin_culling_basic" time="0.014" /><testcase classname="tests.test_at_sam_003" name="test_dmin_culling_exact_threshold" time="0.006" /><testcase classname="tests.test_at_sam_003" name="test_dmin_zero_no_culling" time="0.006" /><testcase classname="tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting" name="test_sourcefile_with_all_columns" time="0.001"><failure message="AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.">self = &lt;tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044b73610&gt;

        def test_sourcefile_with_all_columns(self):
            """Test reading sourcefile with all 5 columns specified."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Write test source file with two sources
                # X, Y, Z, weight, wavelength (in meters)
                content = """# Test source file
    -10.0  0.0  0.0  2.0  1.0e-10
    0.0  -10.0  0.0  3.0  1.5e-10
    """
                sourcefile.write_text(content)
    
                # Read source file
                default_wavelength_m = 6.2e-10  # 6.2 Angstroms
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=default_wavelength_m,
                    default_source_distance_m=10.0
                )
    
                # Check we got 2 sources
                assert directions.shape == (2, 3)
                assert weights.shape == (2,)
                assert wavelengths.shape == (2,)
    
                # Check directions are normalized (unit vectors)
                norms = torch.linalg.norm(directions, dim=1)
&gt;               torch.testing.assert_close(norms, torch.ones(2, dtype=torch.float64))
E               AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:64: AssertionError</failure></testcase><testcase classname="tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting" name="test_sourcefile_with_missing_columns" time="0.001"><failure message="assert 6.199999957878788e-10 == 1e-10 ± 1.0e-12&#10;  &#10;  comparison failed&#10;  Obtained: 6.199999957878788e-10&#10;  Expected: 1e-10 ± 1.0e-12">self = &lt;tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044b73750&gt;

        def test_sourcefile_with_missing_columns(self):
            """Test reading sourcefile with missing columns (using defaults)."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Write test source file with varying number of columns
                content = """# Test source file with missing columns
    # Full specification
    -10.0  0.0  0.0  2.0  1.0e-10
    # Only position
    0.0  -10.0  0.0
    # No columns (should use defaults)
    
    # Comment line
    # Only position and weight
    5.0  5.0  0.0  1.5
    """
                sourcefile.write_text(content)
    
                # Read source file
                default_wavelength_m = 6.2e-10  # 6.2 Angstroms
                default_source_distance_m = 10.0
                beam_direction = torch.tensor([0.0, 0.0, 1.0], dtype=torch.float64)
    
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=default_wavelength_m,
                    default_source_distance_m=default_source_distance_m,
                    beam_direction=beam_direction
                )
    
                # Check we got 3 sources (empty line is skipped)
                assert directions.shape == (3, 3)
                assert weights.shape == (3,)
                assert wavelengths.shape == (3,)
    
                # Check wavelengths
&gt;               assert wavelengths[0].item() == pytest.approx(1.0e-10)  # Specified
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               assert 6.199999957878788e-10 == 1e-10 ± 1.0e-12
E                 
E                 comparison failed
E                 Obtained: 6.199999957878788e-10
E                 Expected: 1e-10 ± 1.0e-12

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:112: AssertionError</failure></testcase><testcase classname="tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting" name="test_sourcefile_default_position" time="0.001"><failure message="AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.">self = &lt;tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044c190f0&gt;

        def test_sourcefile_default_position(self):
            """Test that missing X,Y,Z defaults to -source_distance·b position."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Write source file with partial position (X, Y only, no Z)
                # Per spec, columns are: X, Y, Z, weight, wavelength
                # If we provide X=-15, Y=0 (no Z), position should be [-15, 0, 0] -&gt; normalized [-1, 0, 0]
                content = """# Source with only X, Y position
    -15.0  0.0
    """
                sourcefile.write_text(content)
    
                # Read with specific beam direction (not actually used when X,Y provided)
                default_wavelength_m = 6.2e-10
                default_source_distance_m = 15.0  # 15 meters
                beam_direction = torch.tensor([1.0, 0.0, 0.0], dtype=torch.float64)  # Along +X
    
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=default_wavelength_m,
                    default_source_distance_m=default_source_distance_m,
                    beam_direction=beam_direction
                )
    
                # Position [-15, 0, 0] normalized to unit vector: [-1, 0, 0]
                expected_direction = torch.tensor([[-1.0, 0.0, 0.0]], dtype=torch.float64)
&gt;               torch.testing.assert_close(directions, expected_direction)
E               AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:148: AssertionError</failure></testcase><testcase classname="tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting" name="test_multiple_sources_normalization" time="0.001"><failure message="AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.">self = &lt;tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044c19220&gt;

        def test_multiple_sources_normalization(self):
            """Test that intensity is properly normalized by number of sources."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Create two sources with same wavelength but different positions
                content = """# Two sources for normalization test
    -10.0  0.0  0.0  1.0  6.2e-10
    10.0  0.0  0.0  1.0  6.2e-10
    """
                sourcefile.write_text(content)
    
                # Read sources
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=6.2e-10
                )
    
                # Verify we have 2 sources
                assert len(directions) == 2
                assert len(weights) == 2
                assert len(wavelengths) == 2
    
                # Verify directions are opposite (sources on opposite sides)
                torch.testing.assert_close(directions[0], -directions[1])
    
                # Both sources have weight 1.0 specified in the file
&gt;               torch.testing.assert_close(weights, torch.ones(2, dtype=torch.float64))
E               AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:180: AssertionError</failure></testcase><testcase classname="tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting" name="test_empty_sourcefile" time="0.001" /><testcase classname="tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting" name="test_weighted_sources_integration" time="0.001"><failure message="assert 6.199999957878788e-10 == 8e-10 ± 1.0e-12&#10;  &#10;  comparison failed&#10;  Obtained: 6.199999957878788e-10&#10;  Expected: 8e-10 ± 1.0e-12">self = &lt;tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044dc2cf0&gt;

        def test_weighted_sources_integration(self):
            """Test that sources with weights can be loaded and simulated (AT-SRC-001)."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "weighted_sources.txt"
    
                # Create two sources with different weights as specified in AT-SRC-001
                # "Setup: -sourcefile with two sources having distinct weights and λ"
                content = """# Two sources with different weights and wavelengths
    # X Y Z weight wavelength
    0.0  0.0  -10.0  2.0  6.2e-10
    0.0  0.0  -10.0  3.0  8.0e-10
    """
                sourcefile.write_text(content)
    
                # Read sources
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=6.2e-10
                )
    
                # Verify weights are preserved per AT-SRC-001
                # "intensity contributions SHALL sum with per-source λ and weight"
                assert weights[0].item() == pytest.approx(2.0)
                assert weights[1].item() == pytest.approx(3.0)
    
                # Verify wavelengths are preserved
                assert wavelengths[0].item() == pytest.approx(6.2e-10)
&gt;               assert wavelengths[1].item() == pytest.approx(8.0e-10)
E               assert 6.199999957878788e-10 == 8e-10 ± 1.0e-12
E                 
E                 comparison failed
E                 Obtained: 6.199999957878788e-10
E                 Expected: 8e-10 ± 1.0e-12

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:224: AssertionError</failure></testcase><testcase classname="tests.test_at_src_001_cli.TestAT_SRC_001_CLI" name="test_sourcefile_loading_via_cli" time="0.979" /><testcase classname="tests.test_at_src_001_cli.TestAT_SRC_001_CLI" name="test_sourcefile_with_missing_columns" time="0.974" /><testcase classname="tests.test_at_src_001_cli.TestAT_SRC_001_CLI" name="test_sourcefile_takes_precedence_over_divergence" time="0.972" /><testcase classname="tests.test_at_src_001_simple" name="test_sourcefile_parsing" time="0.001"><failure message="AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.">def test_sourcefile_parsing():
        """Basic test of source file parsing."""
        with tempfile.TemporaryDirectory() as tmpdir:
            sourcefile = Path(tmpdir) / "test_sources.txt"
    
            # Write test source file with two sources
            content = """# Test source file
    -10.0  0.0  0.0  2.0  1.0e-10
    0.0  -10.0  0.0  3.0  1.5e-10
    """
            sourcefile.write_text(content)
    
            # Read source file
            default_wavelength_m = 6.2e-10
            directions, weights, wavelengths = read_sourcefile(
                sourcefile,
                default_wavelength_m=default_wavelength_m
            )
    
            # Check results
            assert directions.shape == (2, 3)
            assert weights.shape == (2,)
            assert wavelengths.shape == (2,)
    
            # Check directions are normalized
            norms = torch.linalg.norm(directions, dim=1)
&gt;           torch.testing.assert_close(norms, torch.ones(2, dtype=torch.float64))
E           AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001_simple.py:41: AssertionError</failure></testcase><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_no_parameters_provided" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_only_step_provided" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_only_range_provided" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_only_count_provided_angles" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_only_count_provided_thickness" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_range_and_step_provided" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_count_and_range_provided" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_divergence_auto_selection" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_dispersion_auto_selection" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_thickness_auto_selection" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_all_parameters_provided" time="0.000" /><testcase classname="tests.test_at_src_002.TestAT_SRC_002" name="test_conflicting_parameters" time="0.000" /><testcase classname="tests.test_at_src_003.TestSourcefileLambdaOverride" name="test_lambda_override_single_source" time="0.001" /><testcase classname="tests.test_at_src_003.TestSourcefileLambdaOverride" name="test_lambda_override_multiple_sources" time="0.001" /><testcase classname="tests.test_at_src_003.TestSourcefileWarningEmission" name="test_warning_emitted_on_mismatch" time="0.000" /><testcase classname="tests.test_at_src_003.TestSourcefileWarningEmission" name="test_no_warning_when_matching" time="0.000" /><testcase classname="tests.test_at_src_003.TestSourcefileWarningEmission" name="test_no_warning_when_column_missing" time="0.000" /><testcase classname="tests.test_at_src_003.TestStepsNormalizationParity" name="test_steps_count_includes_zero_weight_sources" time="0.000" /><testcase classname="tests.test_at_src_003.TestStepsNormalizationParity" name="test_equal_weighting_preserved" time="0.000" /><testcase classname="tests.test_at_sta_001.TestAT_STA_001" name="test_statistics_basic" time="0.007" /><testcase classname="tests.test_at_sta_001.TestAT_STA_001" name="test_statistics_with_roi" time="0.005" /><testcase classname="tests.test_at_sta_001.TestAT_STA_001" name="test_statistics_with_mask" time="0.002" /><testcase classname="tests.test_at_sta_001.TestAT_STA_001" name="test_statistics_empty_roi" time="0.005" /><testcase classname="tests.test_at_sta_001.TestAT_STA_001" name="test_statistics_last_max_location" time="0.005" /><testcase classname="tests.test_at_str_001" name="test_at_str_001_nearest_neighbor_lookup" time="0.002" /><testcase classname="tests.test_at_str_002" name="test_tricubic_interpolation_enabled" time="0.007" /><testcase classname="tests.test_at_str_002" name="test_tricubic_out_of_bounds_fallback" time="0.001" /><testcase classname="tests.test_at_str_002" name="test_auto_enable_interpolation" time="0.001" /><testcase classname="tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels" name="test_square_shape_model" time="0.001" /><testcase classname="tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels" name="test_round_shape_model" time="0.160" /><testcase classname="tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels" name="test_gauss_shape_model" time="0.001"><failure message="AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'">self = &lt;tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels object at 0x7ab044c19f30&gt;

    def test_gauss_shape_model(self):
        """Test GAUSS (Gaussian in reciprocal space) lattice shape model."""
        # Configure for GAUSS shape
        self.crystal_config.shape = CrystalShape.GAUSS
        self.crystal_config.fudge = 1.0
    
        # Create simulator to test the full implementation
&gt;       simulator = Simulator(
            crystal=Crystal(self.crystal_config),
            detector=None,  # Not needed for this test
            crystal_config=self.crystal_config,
            beam_config=self.beam_config,
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_str_003.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;nanobrag_torch.simulator.Simulator object at 0x7ab03b66f0b0&gt;
crystal = &lt;nanobrag_torch.models.crystal.Crystal object at 0x7ab040a76e40&gt;
detector = None
crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=(...'gauss'&gt;, fudge=1.0, sample_x=1.0000000000000001e-07, sample_y=1.0000000000000001e-07, sample_z=1.0000000000000001e-07)
beam_config = BeamConfig(wavelength_A=1.0, N_source_points=1, source_distance_mm=10000.0, source_size_mm=0.0, source_directions=None...=(0.0, 0.0, 1.0), flux=0.0, exposure=0.0, beamsize_mm=0.0, fluence=1.2593201528622709e+29, dmin=0.0, water_size_um=0.0)
device = None, dtype = torch.float32, debug_config = None

    def __init__(
        self,
        crystal: Crystal,
        detector: Detector,
        crystal_config: Optional[CrystalConfig] = None,
        beam_config: Optional[BeamConfig] = None,
        device=None,
        dtype=torch.float32,
        debug_config: Optional[dict] = None,
    ):
        """
        Initialize simulator with crystal, detector, and configurations.
    
        Args:
            crystal: Crystal object containing unit cell and structure factors
            detector: Detector object with geometry parameters
            crystal_config: Configuration for crystal rotation parameters (phi, mosaic)
            beam_config: Beam configuration (optional, for future use)
            device: PyTorch device (cpu/cuda)
            dtype: PyTorch data type
            debug_config: Debug configuration with printout, printout_pixel, trace_pixel options
        """
        self.crystal = crystal
        self.detector = detector
        # If crystal_config is provided, update only the rotation-related parameters
        # This preserves essential parameters like cell dimensions and default_F
        if crystal_config is not None:
            # Update only the rotation-related fields that are explicitly set
            # This preserves the crystal's essential parameters while allowing rotation updates
            if hasattr(crystal_config, 'phi_start_deg'):
                self.crystal.config.phi_start_deg = crystal_config.phi_start_deg
            if hasattr(crystal_config, 'osc_range_deg'):
                self.crystal.config.osc_range_deg = crystal_config.osc_range_deg
            if hasattr(crystal_config, 'phi_steps'):
                self.crystal.config.phi_steps = crystal_config.phi_steps
            if hasattr(crystal_config, 'mosaic_spread_deg'):
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
        else:
            self.device = torch.device("cpu")
        self.dtype = dtype
    
        # PERF-PYTORCH-004 Attempt #14: Ensure detector is on the same device/dtype as simulator
        # This prevents device mismatch errors when detector tensors (beam_vector, pixel_coords)
        # interact with simulator tensors (wavelength, incident_beam_direction) during compilation
        if self.detector is not None:
            self.detector = self.detector.to(device=self.device, dtype=self.dtype)
    
        # Store debug configuration
        self.debug_config = debug_config if debug_config is not None else {}
        self.printout = self.debug_config.get('printout', False)
        self.printout_pixel = self.debug_config.get('printout_pixel', None)  # [fast, slow]
        self.trace_pixel = self.debug_config.get('trace_pixel', None)  # [slow, fast]
    
        # Phase CLI-FLAGS-003 M0a: Enable trace instrumentation on Crystal when trace_pixel is active
        # This guards _last_tricubic_neighborhood population to prevent unconditional debug payload retention
        if self.trace_pixel is not None:
            self.crystal._enable_trace = True
    
        # Set incident beam direction from detector.beam_vector
        # This is critical for convention consistency (AT-PARALLEL-004) and CLI override support (CLI-FLAGS-003 Phase H2)
        # The detector.beam_vector property handles both convention defaults and CUSTOM overrides (e.g., -beam_vector)
        if self.detector is not None:
            # Use detector's beam_vector property which handles:
            # - CUSTOM convention with user-supplied custom_beam_vector
            # - Convention defaults (MOSFLM: [1,0,0], XDS/DIALS: [0,0,1])
            # The detector normalizes and returns the vector with correct device/dtype
            self.incident_beam_direction = self.detector.beam_vector.clone()
        else:
            # If no detector provided, default to MOSFLM beam direction
            self.incident_beam_direction = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        # PERF-PYTORCH-006: Store wavelength as tensor with correct dtype
        self.wavelength = torch.tensor(self.beam_config.wavelength_A, device=self.device, dtype=self.dtype)
    
        # Physical constants (from nanoBragg.c ~line 240)
        # PERF-PYTORCH-006: Store as tensors with correct dtype to avoid implicit float64 upcasting
        self.r_e_sqr = torch.tensor(
            7.94079248018965e-30, device=self.device, dtype=self.dtype  # classical electron radius squared (meters squared)
        )
        # Use fluence from beam config (AT-FLU-001)
        self.fluence = torch.tensor(self.beam_config.fluence, device=self.device, dtype=self.dtype)
        # Polarization setup from beam config
        # PERF-PYTORCH-006: Store as tensor with correct dtype
        kahn_value = self.beam_config.polarization_factor if not self.beam_config.nopolar else 0.0
        self.kahn_factor = torch.tensor(kahn_value, device=self.device, dtype=self.dtype)
        self.polarization_axis = torch.tensor(
            self.beam_config.polarization_axis, device=self.device, dtype=self.dtype
        )
    
        # PERF-PYTORCH-004 P1.2 + P3.0: Pre-normalize source tensors to avoid repeated .to() calls in run()
        # Move source direction/wavelength/weight tensors to correct device/dtype once during init
        # P3.0: Seed fallback tensors (equal weights, primary wavelength) when omitted before device cast
        _has_sources = (self.beam_config.source_directions is not None and
                       len(self.beam_config.source_directions) &gt; 0)
        if _has_sources:
            self._source_directions = self.beam_config.source_directions.to(device=self.device, dtype=self.dtype)
    
            # P3.0: Default source_wavelengths to primary wavelength if not provided (AT-SRC-001)
            if self.beam_config.source_wavelengths is not None:
                self._source_wavelengths = self.beam_config.source_wavelengths.to(device=self.device, dtype=self.dtype)  # meters
            else:
                # Use primary wavelength for all sources
                primary_wavelength_m = self.beam_config.wavelength_A * 1e-10
                n_sources = len(self.beam_config.source_directions)
                self._source_wavelengths = torch.full((n_sources,), primary_wavelength_m, device=self.device, dtype=self.dtype)
    
            self._source_wavelengths_A = self._source_wavelengths * 1e10  # Convert to Angstroms once
    
            # P3.0: Default source_weights to equal weights if not provided
            if self.beam_config.source_weights is not None:
                self._source_weights = self.beam_config.source_weights.to(device=self.device, dtype=self.dtype)
            else:
                # Default to equal weights if not provided
                self._source_weights = torch.ones(len(self.beam_config.source_directions), device=self.device, dtype=self.dtype)
        else:
            self._source_directions = None
            self._source_wavelengths_A = None
            self._source_weights = None
    
        # PERF-PYTORCH-004 P3.4: Cache frequently-accessed tensors to reduce per-run allocations
        # Pre-convert pixel coordinates to correct device/dtype once
&gt;       self._cached_pixel_coords_meters = self.detector.get_pixel_coords().to(device=self.device, dtype=self.dtype)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:569: AttributeError</failure></testcase><testcase classname="tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels" name="test_tophat_shape_model" time="0.000" /><testcase classname="tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels" name="test_shape_model_comparison" time="0.001"><failure message="AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'">self = &lt;tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels object at 0x7ab044a89130&gt;

    def test_shape_model_comparison(self):
        """Compare all four shape models at the same reflection."""
        # Test point slightly off a Bragg peak
        h_frac = 0.1  # Fractional Miller index offset
        k_frac = 0.1
        l_frac = 0.1
    
        results = {}
    
        for shape in [CrystalShape.SQUARE, CrystalShape.ROUND,
                     CrystalShape.GAUSS, CrystalShape.TOPHAT]:
            self.crystal_config.shape = shape
    
            # Create simulator with this shape
&gt;           simulator = Simulator(
                crystal=Crystal(self.crystal_config),
                detector=None,
                crystal_config=self.crystal_config,
                beam_config=self.beam_config,
            )

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_str_003.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;nanobrag_torch.simulator.Simulator object at 0x7ab0408dd490&gt;
crystal = &lt;nanobrag_torch.models.crystal.Crystal object at 0x7ab040f2d9a0&gt;
detector = None
crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=(...square'&gt;, fudge=1.0, sample_x=1.0000000000000001e-07, sample_y=1.0000000000000001e-07, sample_z=1.0000000000000001e-07)
beam_config = BeamConfig(wavelength_A=1.0, N_source_points=1, source_distance_mm=10000.0, source_size_mm=0.0, source_directions=None...=(0.0, 0.0, 1.0), flux=0.0, exposure=0.0, beamsize_mm=0.0, fluence=1.2593201528622709e+29, dmin=0.0, water_size_um=0.0)
device = None, dtype = torch.float32, debug_config = None

    def __init__(
        self,
        crystal: Crystal,
        detector: Detector,
        crystal_config: Optional[CrystalConfig] = None,
        beam_config: Optional[BeamConfig] = None,
        device=None,
        dtype=torch.float32,
        debug_config: Optional[dict] = None,
    ):
        """
        Initialize simulator with crystal, detector, and configurations.
    
        Args:
            crystal: Crystal object containing unit cell and structure factors
            detector: Detector object with geometry parameters
            crystal_config: Configuration for crystal rotation parameters (phi, mosaic)
            beam_config: Beam configuration (optional, for future use)
            device: PyTorch device (cpu/cuda)
            dtype: PyTorch data type
            debug_config: Debug configuration with printout, printout_pixel, trace_pixel options
        """
        self.crystal = crystal
        self.detector = detector
        # If crystal_config is provided, update only the rotation-related parameters
        # This preserves essential parameters like cell dimensions and default_F
        if crystal_config is not None:
            # Update only the rotation-related fields that are explicitly set
            # This preserves the crystal's essential parameters while allowing rotation updates
            if hasattr(crystal_config, 'phi_start_deg'):
                self.crystal.config.phi_start_deg = crystal_config.phi_start_deg
            if hasattr(crystal_config, 'osc_range_deg'):
                self.crystal.config.osc_range_deg = crystal_config.osc_range_deg
            if hasattr(crystal_config, 'phi_steps'):
                self.crystal.config.phi_steps = crystal_config.phi_steps
            if hasattr(crystal_config, 'mosaic_spread_deg'):
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
        else:
            self.device = torch.device("cpu")
        self.dtype = dtype
    
        # PERF-PYTORCH-004 Attempt #14: Ensure detector is on the same device/dtype as simulator
        # This prevents device mismatch errors when detector tensors (beam_vector, pixel_coords)
        # interact with simulator tensors (wavelength, incident_beam_direction) during compilation
        if self.detector is not None:
            self.detector = self.detector.to(device=self.device, dtype=self.dtype)
    
        # Store debug configuration
        self.debug_config = debug_config if debug_config is not None else {}
        self.printout = self.debug_config.get('printout', False)
        self.printout_pixel = self.debug_config.get('printout_pixel', None)  # [fast, slow]
        self.trace_pixel = self.debug_config.get('trace_pixel', None)  # [slow, fast]
    
        # Phase CLI-FLAGS-003 M0a: Enable trace instrumentation on Crystal when trace_pixel is active
        # This guards _last_tricubic_neighborhood population to prevent unconditional debug payload retention
        if self.trace_pixel is not None:
            self.crystal._enable_trace = True
    
        # Set incident beam direction from detector.beam_vector
        # This is critical for convention consistency (AT-PARALLEL-004) and CLI override support (CLI-FLAGS-003 Phase H2)
        # The detector.beam_vector property handles both convention defaults and CUSTOM overrides (e.g., -beam_vector)
        if self.detector is not None:
            # Use detector's beam_vector property which handles:
            # - CUSTOM convention with user-supplied custom_beam_vector
            # - Convention defaults (MOSFLM: [1,0,0], XDS/DIALS: [0,0,1])
            # The detector normalizes and returns the vector with correct device/dtype
            self.incident_beam_direction = self.detector.beam_vector.clone()
        else:
            # If no detector provided, default to MOSFLM beam direction
            self.incident_beam_direction = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        # PERF-PYTORCH-006: Store wavelength as tensor with correct dtype
        self.wavelength = torch.tensor(self.beam_config.wavelength_A, device=self.device, dtype=self.dtype)
    
        # Physical constants (from nanoBragg.c ~line 240)
        # PERF-PYTORCH-006: Store as tensors with correct dtype to avoid implicit float64 upcasting
        self.r_e_sqr = torch.tensor(
            7.94079248018965e-30, device=self.device, dtype=self.dtype  # classical electron radius squared (meters squared)
        )
        # Use fluence from beam config (AT-FLU-001)
        self.fluence = torch.tensor(self.beam_config.fluence, device=self.device, dtype=self.dtype)
        # Polarization setup from beam config
        # PERF-PYTORCH-006: Store as tensor with correct dtype
        kahn_value = self.beam_config.polarization_factor if not self.beam_config.nopolar else 0.0
        self.kahn_factor = torch.tensor(kahn_value, device=self.device, dtype=self.dtype)
        self.polarization_axis = torch.tensor(
            self.beam_config.polarization_axis, device=self.device, dtype=self.dtype
        )
    
        # PERF-PYTORCH-004 P1.2 + P3.0: Pre-normalize source tensors to avoid repeated .to() calls in run()
        # Move source direction/wavelength/weight tensors to correct device/dtype once during init
        # P3.0: Seed fallback tensors (equal weights, primary wavelength) when omitted before device cast
        _has_sources = (self.beam_config.source_directions is not None and
                       len(self.beam_config.source_directions) &gt; 0)
        if _has_sources:
            self._source_directions = self.beam_config.source_directions.to(device=self.device, dtype=self.dtype)
    
            # P3.0: Default source_wavelengths to primary wavelength if not provided (AT-SRC-001)
            if self.beam_config.source_wavelengths is not None:
                self._source_wavelengths = self.beam_config.source_wavelengths.to(device=self.device, dtype=self.dtype)  # meters
            else:
                # Use primary wavelength for all sources
                primary_wavelength_m = self.beam_config.wavelength_A * 1e-10
                n_sources = len(self.beam_config.source_directions)
                self._source_wavelengths = torch.full((n_sources,), primary_wavelength_m, device=self.device, dtype=self.dtype)
    
            self._source_wavelengths_A = self._source_wavelengths * 1e10  # Convert to Angstroms once
    
            # P3.0: Default source_weights to equal weights if not provided
            if self.beam_config.source_weights is not None:
                self._source_weights = self.beam_config.source_weights.to(device=self.device, dtype=self.dtype)
            else:
                # Default to equal weights if not provided
                self._source_weights = torch.ones(len(self.beam_config.source_directions), device=self.device, dtype=self.dtype)
        else:
            self._source_directions = None
            self._source_wavelengths_A = None
            self._source_weights = None
    
        # PERF-PYTORCH-004 P3.4: Cache frequently-accessed tensors to reduce per-run allocations
        # Pre-convert pixel coordinates to correct device/dtype once
&gt;       self._cached_pixel_coords_meters = self.detector.get_pixel_coords().to(device=self.device, dtype=self.dtype)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:569: AttributeError</failure></testcase><testcase classname="tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels" name="test_fudge_parameter_scaling" time="0.142" /><testcase classname="tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels" name="test_shape_models_at_bragg_peak" time="0.001" /><testcase classname="tests.test_at_str_004.TestAT_STR_004" name="test_sparse_hkl_loading" time="0.000" /><testcase classname="tests.test_at_str_004.TestAT_STR_004" name="test_missing_reflection_uses_default_f" time="0.001" /><testcase classname="tests.test_at_str_004.TestAT_STR_004" name="test_intensity_ratios_with_sparse_hkl" time="0.007" /><testcase classname="tests.test_at_str_004.TestAT_STR_004" name="test_fallback_with_no_hkl_uses_default_f" time="0.000" /><testcase classname="tests.test_at_str_004.TestAT_STR_004" name="test_fdump_preserves_sparse_behavior" time="0.002" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_find_c_binary_resolution" time="0.001" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_find_py_binary_resolution" time="0.977" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_load_float_image" time="0.002" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_resample_image" time="0.001" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_compute_metrics" time="0.003" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_find_peaks" time="0.001" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_script_integration" time="0.010"><failure message="assert 2 in [0, 3]&#10; +  where 2 = CompletedProcess(args=['python', 'scripts/nb_compare.py', '--outdir', 'test_comparison', '--', '-default_F', '100', '-cell', '100', '100', '100', '90', '90', '90', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-floatfile', 'test.bin'], returncode=2, stdout='', stderr=&quot;python: can't open file '/tmp/pytest-of-ollie/pytest-488/test_fdump_preserves_sparse_be0/scripts/nb_compare.py': [Errno 2] No such file or directory\n&quot;).returncode">self = &lt;tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison object at 0x7ab044aa0160&gt;

    @pytest.mark.skipif(
        not Path("./nanoBragg").exists() and not Path("./golden_suite_generator/nanoBragg").exists(),
        reason="Requires C binary for integration test"
    )
    def test_script_integration(self):
        """Test the full script execution."""
        # Run with minimal arguments
        cmd = [
            'python', 'scripts/nb_compare.py',
            '--outdir', 'test_comparison',
            '--',
            '-default_F', '100',
            '-cell', '100', '100', '100', '90', '90', '90',
            '-lambda', '1.0',
            '-distance', '100',
            '-detpixels', '64',
            '-floatfile', 'test.bin'
        ]
    
        # Run the script
        result = subprocess.run(cmd, capture_output=True, text=True)
    
        # Check that it ran without critical errors per spec
        # Exit codes: 0=success, 1=usage error, 2=runner failure, 3=correlation&lt;threshold, 4=shape mismatch, 5=I/O error
&gt;       assert result.returncode in [0, 3]  # 0=pass, 3=correlation below threshold
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 2 in [0, 3]
E        +  where 2 = CompletedProcess(args=['python', 'scripts/nb_compare.py', '--outdir', 'test_comparison', '--', '-default_F', '100', '-cell', '100', '100', '100', '90', '90', '90', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-floatfile', 'test.bin'], returncode=2, stdout='', stderr="python: can't open file '/tmp/pytest-of-ollie/pytest-488/test_fdump_preserves_sparse_be0/scripts/nb_compare.py': [Errno 2] No such file or directory\n").returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_tools_001.py:191: AssertionError</failure></testcase><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_metrics_with_identical_images" time="0.002" /><testcase classname="tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison" name="test_metrics_with_scaled_images" time="0.002" /><testcase classname="tests.test_cli_flags.TestPix0VectorAlias" name="test_pix0_meters_alias" time="0.002" /><testcase classname="tests.test_cli_flags.TestPix0VectorAlias" name="test_pix0_millimeter_alias" time="0.002" /><testcase classname="tests.test_cli_flags.TestPix0VectorAlias" name="test_pix0_meters_and_mm_equivalence" time="0.003" /><testcase classname="tests.test_cli_flags.TestPix0VectorAlias" name="test_dual_pix0_flag_rejection" time="0.002" /><testcase classname="tests.test_cli_flags.TestPix0VectorAlias" name="test_pix0_signed_combinations[pix0_m0-pix0_mm0]" time="0.003" /><testcase classname="tests.test_cli_flags.TestPix0VectorAlias" name="test_pix0_signed_combinations[pix0_m1-pix0_mm1]" time="0.003" /><testcase classname="tests.test_cli_flags.TestPix0VectorAlias" name="test_pix0_signed_combinations[pix0_m2-pix0_mm2]" time="0.003" /><testcase classname="tests.test_cli_flags.TestDetectorOverridePersistence" name="test_detector_override_persistence_cpu" time="0.002" /><testcase classname="tests.test_cli_flags.TestDetectorOverridePersistence" name="test_detector_override_persistence_cuda" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:151: CUDA not available</skipped></testcase><testcase classname="tests.test_cli_flags.TestDetectorOverridePersistence" name="test_detector_override_dtype_preservation" time="0.002" /><testcase classname="tests.test_cli_flags.TestNoiseSuppressionFlag" name="test_nonoise_suppresses_noise_output" time="0.002" /><testcase classname="tests.test_cli_flags.TestNoiseSuppressionFlag" name="test_noisefile_without_nonoise" time="0.002" /><testcase classname="tests.test_cli_flags.TestNoiseSuppressionFlag" name="test_nonoise_preserves_seed" time="0.001" /><testcase classname="tests.test_cli_flags.TestNoiseSuppressionFlag" name="test_nonoise_without_noisefile" time="0.001" /><testcase classname="tests.test_cli_flags.TestCLIIntegrationSanity" name="test_pix0_does_not_alter_beam_vector" time="0.002" /><testcase classname="tests.test_cli_flags.TestCLIIntegrationSanity" name="test_pix0_triggers_custom_convention" time="0.001" /><testcase classname="tests.test_cli_flags.TestCLIIntegrationSanity" name="test_roi_unaffected_by_new_flags" time="0.001" /><testcase classname="tests.test_cli_flags.TestCLIIntegrationSanity" name="test_convention_preserved_without_pix0" time="0.002" /><testcase classname="tests.test_cli_flags.TestCLIBeamVector" name="test_custom_beam_vector_propagates" time="0.003" /><testcase classname="tests.test_cli_flags.TestCLIPix0Override" name="test_pix0_override_beam_pivot_transform[cpu-dtype0]" time="0.001" /><testcase classname="tests.test_cli_flags.TestCLIPix0Override" name="test_pix0_override_beam_pivot_transform[cuda-dtype1]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:384: CUDA not available</skipped></testcase><testcase classname="tests.test_cli_flags.TestCLIPix0Override" name="test_pix0_vector_mm_beam_pivot[cpu]" time="0.000"><failure message="FileNotFoundError: [Errno 2] No such file or directory: 'reports/2025-10-cli-flags/phase_h/implementation/pix0_expected.json'">self = &lt;tests.test_cli_flags.TestCLIPix0Override object at 0x7ab044c1b6f0&gt;
device = 'cpu'

    @pytest.mark.parametrize("device", ["cpu", pytest.param("cuda", marks=pytest.mark.skipif(
        not torch.cuda.is_available(), reason="CUDA not available"))])
    def test_pix0_vector_mm_beam_pivot(self, device):
        """
        Regression test for CLI-FLAGS-003 Phase H3b.
    
        CRITICAL FINDING from Phase H3b1:
        When custom detector vectors are provided, C code IGNORES -pix0_vector_mm entirely.
        The custom vectors already define the detector geometry completely.
    
        This test verifies BOTH scenarios:
        1. WITH custom vectors: pix0_override has NO EFFECT (matches C behavior)
        2. WITHOUT custom vectors: pix0_override IS applied
    
        Expected pix0 vector from C trace (phase_h) WITH custom vectors:
        -0.216336514802265, 0.215206668836451, -0.230198010448577 meters
    
        Reference: plans/active/cli-noise-pix0/plan.md Phase H3b
        Evidence: reports/2025-10-cli-flags/phase_h/implementation/pix0_mapping_analysis.md
        """
        import json
        from pathlib import Path
    
        # Load expected C pix0 vector
        expected_json_path = Path("reports/2025-10-cli-flags/phase_h/implementation/pix0_expected.json")
&gt;       with open(expected_json_path) as f:
             ^^^^^^^^^^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'reports/2025-10-cli-flags/phase_h/implementation/pix0_expected.json'

/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:462: FileNotFoundError</failure></testcase><testcase classname="tests.test_cli_flags.TestCLIPix0Override" name="test_pix0_vector_mm_beam_pivot[cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:437: CUDA not available</skipped></testcase><testcase classname="tests.test_cli_flags.TestCLIPolarization" name="test_default_polarization_parity" time="0.002" /><testcase classname="tests.test_cli_flags.TestCLIPolarization" name="test_nopolar_flag" time="0.001" /><testcase classname="tests.test_cli_flags.TestCLIPolarization" name="test_polar_override" time="0.002" /><testcase classname="tests.test_cli_flags.TestCLIPivotSelection" name="test_custom_vectors_force_sample_pivot[float32-cpu]" time="0.001" /><testcase classname="tests.test_cli_flags.TestCLIPivotSelection" name="test_custom_vectors_force_sample_pivot[float32-cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:705: CUDA not available</skipped></testcase><testcase classname="tests.test_cli_flags.TestCLIPivotSelection" name="test_custom_vectors_force_sample_pivot[float64-cpu]" time="0.001" /><testcase classname="tests.test_cli_flags.TestCLIPivotSelection" name="test_custom_vectors_force_sample_pivot[float64-cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:705: CUDA not available</skipped></testcase><testcase classname="tests.test_cli_flags.TestHKLFdumpParity" name="test_scaled_hkl_roundtrip" time="0.000"><failure message="AssertionError: Missing scaled.hkl&#10;assert False&#10; +  where False = exists()&#10; +    where exists = PosixPath('scaled.hkl').exists&#10; +      where PosixPath('scaled.hkl') = &lt;class 'pathlib._local.Path'&gt;('scaled.hkl')">self = &lt;tests.test_cli_flags.TestHKLFdumpParity object at 0x7ab044a7f250&gt;

    def test_scaled_hkl_roundtrip(self):
        """
        Roundtrip test: HKL text → PyTorch grid → Fdump → PyTorch grid.
    
        Expected failure (before fix):
        - read_fdump will fail to match HKL grid due to padding mismatch
        - C allocates (range+1) dimensions but PyTorch currently uses range
    
        After fix:
        - Both readers should produce identical grids
        - Max |ΔF| ≤ 1e-6 electrons (spec-a-core.md:460)
        """
        from pathlib import Path
        import tempfile
        from nanobrag_torch.io.hkl import read_hkl_file, write_fdump, read_fdump
    
        # Input files from Phase L1b analysis
        hkl_path = "scaled.hkl"
        c_fdump_path = "reports/2025-10-cli-flags/phase_l/hkl_parity/Fdump_scaled_20251006181401.bin"
    
        # Verify files exist
&gt;       assert Path(hkl_path).exists(), f"Missing {hkl_path}"
E       AssertionError: Missing scaled.hkl
E       assert False
E        +  where False = exists()
E        +    where exists = PosixPath('scaled.hkl').exists
E        +      where PosixPath('scaled.hkl') = &lt;class 'pathlib._local.Path'&gt;('scaled.hkl')

/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:835: AssertionError</failure></testcase><testcase classname="tests.test_cli_scaling.TestMOSFLMCellVectors" name="test_mosflm_cell_vectors" time="0.000"><skipped type="pytest.skip" message="A.mat not found in repository root">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:81: A.mat not found in repository root</skipped></testcase><testcase classname="tests.test_cli_scaling.TestFlattSquareMatchesC" name="test_f_latt_square_matches_c" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL=1 required for C↔PyTorch parity">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:144: NB_RUN_PARALLEL=1 required for C↔PyTorch parity</skipped></testcase><testcase classname="tests.test_cli_scaling.TestSourceWeights" name="test_source_weights_ignored_per_spec" time="1.986" /><testcase classname="tests.test_cli_scaling.TestSourceWeights" name="test_cli_lambda_overrides_sourcefile" time="0.021" /><testcase classname="tests.test_cli_scaling.TestSourceWeights" name="test_uniform_weights_ignored" time="0.000" /><testcase classname="tests.test_cli_scaling.TestSourceWeights" name="test_edge_case_zero_sum_accepted" time="0.000" /><testcase classname="tests.test_cli_scaling.TestSourceWeights" name="test_edge_case_negative_weights_accepted" time="0.000" /><testcase classname="tests.test_cli_scaling.TestSourceWeights" name="test_single_source_fallback" time="0.007" /><testcase classname="tests.test_cli_scaling.TestSourceWeightsDivergence" name="test_c_divergence_reference" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL=1 required">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:585: NB_RUN_PARALLEL=1 required</skipped></testcase><testcase classname="tests.test_cli_scaling.TestSourceWeightsDivergence" name="test_sourcefile_divergence_warning" time="0.000"><skipped type="pytest.skip" message="two_sources.txt fixture not found in expected locations">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:715: two_sources.txt fixture not found in expected locations</skipped></testcase><testcase classname="tests.test_cli_scaling.TestHKLDevice" name="test_hkl_tensor_respects_device[cpu-float32]" time="0.001"><skipped type="pytest.skip" message="scaled.hkl not found (required for Phase L supervisor command)">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:807: scaled.hkl not found (required for Phase L supervisor command)</skipped></testcase><testcase classname="tests.test_cli_scaling.TestHKLDevice" name="test_hkl_tensor_respects_device[cpu-float64]" time="0.000"><skipped type="pytest.skip" message="scaled.hkl not found (required for Phase L supervisor command)">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:807: scaled.hkl not found (required for Phase L supervisor command)</skipped></testcase><testcase classname="tests.test_cli_scaling.TestHKLDevice" name="test_hkl_tensor_respects_device[cuda-float32]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:775: CUDA not available</skipped></testcase><testcase classname="tests.test_cli_scaling.TestHKLDevice" name="test_hkl_tensor_respects_device[cuda-float64]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling.py:775: CUDA not available</skipped></testcase><testcase classname="tests.test_cli_scaling_phi0.TestPhiZeroParity" name="test_rot_b_matches_c" time="0.000"><skipped type="pytest.skip" message="A.mat not found (required for supervisor command reproduction)">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling_phi0.py:56: A.mat not found (required for supervisor command reproduction)</skipped></testcase><testcase classname="tests.test_cli_scaling_phi0.TestPhiZeroParity" name="test_k_frac_phi0_matches_c" time="0.000"><skipped type="pytest.skip" message="A.mat not found">/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_scaling_phi0.py:165: A.mat not found</skipped></testcase><testcase classname="tests.test_configuration_consistency.TestConfigurationConsistency" name="test_explicit_defaults_equal_implicit" time="0.001"><skipped type="pytest.xfail" message="C nanoBragg has known bug: passing default twotheta_axis switches to CUSTOM mode" /></testcase><testcase classname="tests.test_configuration_consistency.TestConfigurationConsistency" name="test_configuration_echo_present" time="0.000"><skipped type="pytest.skip" message="Requires special nanoBragg_config binary with diagnostic output that doesn't exist in standard build">/home/ollie/Documents/tmp/nanoBragg/tests/test_configuration_consistency.py:113: Requires special nanoBragg_config binary with diagnostic output that doesn't exist in standard build</skipped></testcase><testcase classname="tests.test_configuration_consistency.TestConfigurationConsistency" name="test_mode_detection_accuracy" time="0.000"><skipped type="pytest.skip" message="Requires special nanoBragg_config binary with diagnostic output">/home/ollie/Documents/tmp/nanoBragg/tests/test_configuration_consistency.py:147: Requires special nanoBragg_config binary with diagnostic output</skipped></testcase><testcase classname="tests.test_configuration_consistency.TestConfigurationConsistency" name="test_trigger_tracking" time="0.000"><skipped type="pytest.skip" message="Requires special nanoBragg_config binary with diagnostic output">/home/ollie/Documents/tmp/nanoBragg/tests/test_configuration_consistency.py:162: Requires special nanoBragg_config binary with diagnostic output</skipped></testcase><testcase classname="tests.test_configuration_consistency.TestConfigurationConsistency" name="test_all_vector_parameters_trigger_custom" time="0.000"><skipped type="pytest.skip" message="Requires special nanoBragg_config binary with diagnostic output">/home/ollie/Documents/tmp/nanoBragg/tests/test_configuration_consistency.py:177: Requires special nanoBragg_config binary with diagnostic output</skipped></testcase><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_cubic_regression" time="0.005" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_triclinic_correctness" time="0.001" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_metric_duality" time="0.003" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_volume_identity" time="0.001" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_resolution_shell_consistency" time="0.002" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_rotation_invariance" time="0.003" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_gradient_flow" time="0.008" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_angles_to_rotation_matrix_identity" time="0.000" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_angles_to_rotation_matrix_x_rotation" time="0.000" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_angles_to_rotation_matrix_y_rotation" time="0.000" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_angles_to_rotation_matrix_z_rotation" time="0.000" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_angles_to_rotation_matrix_order" time="0.000" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_angles_to_rotation_matrix_properties" time="0.001" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_angles_to_rotation_matrix_tensor_types" time="0.000" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_misset_orientation" time="0.002" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_misset_zero_rotation" time="0.003" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_misset_tensor_inputs" time="0.005" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_misset_rotation_order" time="0.002" /><testcase classname="tests.test_crystal_geometry.TestCrystalGeometry" name="test_misset_gradient_flow" time="0.004" /><testcase classname="tests.test_custom_vectors.TestCustomVectors" name="test_custom_vectors_in_detector_config" time="0.000" /><testcase classname="tests.test_custom_vectors.TestCustomVectors" name="test_custom_vectors_in_detector" time="0.006" /><testcase classname="tests.test_custom_vectors.TestCustomVectors" name="test_cli_custom_vectors" time="0.980" /><testcase classname="tests.test_custom_vectors.TestCustomVectors" name="test_custom_convention_detection" time="0.975" /><testcase classname="tests.test_custom_vectors.TestCustomVectors" name="test_custom_spindle_axis" time="0.979" /><testcase classname="tests.test_debug_trace.TestDebugTraceFeatures" name="test_printout_flag" time="0.988"><failure message="AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  Traceback (most recent call last):&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main&#10;      intensity = simulator.run()&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run&#10;      I_before_normalization_pre_polar  # Pre-polar accumulated intensity&#10;      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  &#10;assert 1 == 0&#10; +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmpxi8o4yya.bin', '-printout'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main\n    intensity = simulator.run()\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode">self = &lt;tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044b00f50&gt;
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_printout_flag(self, minimal_args):
        """Test that -printout produces verbose debug output."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with -printout flag
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-printout'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
&gt;           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmpxi8o4yya.bin', '-printout'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:50: AssertionError</failure></testcase><testcase classname="tests.test_debug_trace.TestDebugTraceFeatures" name="test_printout_pixel_flag" time="0.984" /><testcase classname="tests.test_debug_trace.TestDebugTraceFeatures" name="test_trace_pixel_flag" time="0.986"><failure message="AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  Traceback (most recent call last):&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main&#10;      intensity = simulator.run()&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run&#10;      I_before_normalization_pre_polar  # Pre-polar accumulated intensity&#10;      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  &#10;assert 1 == 0&#10; +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp_7129prb.bin', '-trace_pixel', '32', '32'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=32, fast=32)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main\n    intensity = simulator.run()\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode">self = &lt;tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044af8e90&gt;
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_trace_pixel_flag(self, minimal_args):
        """Test that -trace_pixel produces detailed trace for specific pixel."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with -trace_pixel flag for pixel (32, 32) [slow, fast]
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-trace_pixel', '32', '32'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
&gt;           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp_7129prb.bin', '-trace_pixel', '32', '32'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=32, fast=32)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:121: AssertionError</failure></testcase><testcase classname="tests.test_debug_trace.TestDebugTraceFeatures" name="test_combined_debug_flags" time="0.977"><failure message="AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  Traceback (most recent call last):&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main&#10;      intensity = simulator.run()&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run&#10;      I_before_normalization_pre_polar  # Pre-polar accumulated intensity&#10;      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  &#10;assert 1 == 0&#10; +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp6lthhg8g.bin', '-printout', '-trace_pixel', '30', '30'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\n  Tracing pixel (slow=30, fast=30)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main\n    intensity = simulator.run()\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode">self = &lt;tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044af8fc0&gt;
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_combined_debug_flags(self, minimal_args):
        """Test that multiple debug flags can be used together."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with both -printout and -trace_pixel
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-printout',
                '-trace_pixel', '30', '30'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
&gt;           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp6lthhg8g.bin', '-printout', '-trace_pixel', '30', '30'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\n  Tracing pixel (slow=30, fast=30)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:160: AssertionError</failure></testcase><testcase classname="tests.test_debug_trace.TestDebugTraceFeatures" name="test_out_of_bounds_pixel" time="0.988"><failure message="AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  Traceback (most recent call last):&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main&#10;      intensity = simulator.run()&#10;    File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run&#10;      I_before_normalization_pre_polar  # Pre-polar accumulated intensity&#10;      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value&#10;  &#10;assert 1 == 0&#10; +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp95dnwva2.bin', '-trace_pixel', '100', '100'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=100, fast=100)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py&quot;, line 1136, in main\n    intensity = simulator.run()\n  File &quot;/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py&quot;, line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode">self = &lt;tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044b216d0&gt;
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_out_of_bounds_pixel(self, minimal_args):
        """Test that out-of-bounds pixel indices are handled gracefully."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with out-of-bounds pixel (detector is 64x64)
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-trace_pixel', '100', '100'  # Out of bounds
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Should still succeed (gracefully handle out of bounds)
&gt;           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp95dnwva2.bin', '-trace_pixel', '100', '100'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 Å\n  Wavelength: 1.00 Å\n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=100, fast=100)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:198: AssertionError</failure></testcase><testcase classname="tests.test_detector_basis_vectors.TestDetectorBasisVectors" name="test_default_mosflm_convention" time="0.001" /><testcase classname="tests.test_detector_basis_vectors.TestDetectorBasisVectors" name="test_default_xds_convention" time="0.001" /><testcase classname="tests.test_detector_basis_vectors.TestDetectorBasisVectors" name="test_single_axis_rotations" time="0.002" /><testcase classname="tests.test_detector_basis_vectors.TestDetectorBasisVectors" name="test_combined_rotations" time="0.001" /><testcase classname="tests.test_detector_basis_vectors.TestDetectorBasisVectors" name="test_twotheta_rotation" time="0.001" /><testcase classname="tests.test_detector_basis_vectors.TestDetectorBasisVectors" name="test_all_rotations_combined" time="0.001" /><testcase classname="tests.test_detector_basis_vectors.TestDetectorBasisVectors" name="test_tensor_rotation_parameters" time="0.001" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_default_values" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_post_init_defaults" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_custom_twotheta_axis" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_xds_convention_defaults" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_invalid_pixel_counts" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_invalid_distance" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_invalid_pixel_size" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_invalid_oversample" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorConfig" name="test_tensor_parameters" time="0.000" /><testcase classname="tests.test_detector_config.TestDetectorInitialization" name="test_default_initialization" time="0.001"><failure message="assert tensor(512.5000) == 513.0&#10; +  where tensor(512.5000) = &lt;src.nanobrag_torch.models.detector.Detector object at 0x7ab039330750&gt;.beam_center_s">self = &lt;tests.test_detector_config.TestDetectorInitialization object at 0x7ab044b01810&gt;

    def test_default_initialization(self):
        """Test that Detector initializes with default config."""
        detector = Detector(dtype=torch.float64)
    
        # Check that config was created
        assert detector.config is not None
        assert isinstance(detector.config, DetectorConfig)
    
        # Check unit conversions (detector uses meters internally)
        assert detector.distance == 0.1  # 100 mm = 0.1 m
        assert detector.pixel_size == 0.0001  # 0.1 mm = 0.0001 m
    
        # Check dimensions
        assert detector.spixels == 1024
        assert detector.fpixels == 1024
    
        # Check beam center in pixels
        # MOSFLM convention: 51.25 mm / 0.1 mm per pixel + 0.5 = 513.0
&gt;       assert detector.beam_center_s == 513.0
E       assert tensor(512.5000) == 513.0
E        +  where tensor(512.5000) = &lt;src.nanobrag_torch.models.detector.Detector object at 0x7ab039330750&gt;.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_config.py:142: AssertionError</failure></testcase><testcase classname="tests.test_detector_config.TestDetectorInitialization" name="test_custom_config_initialization" time="0.001"><failure message="assert tensor(1024.) == 1024.5&#10; +  where tensor(1024.) = &lt;src.nanobrag_torch.models.detector.Detector object at 0x7ab03b95ed50&gt;.beam_center_s">self = &lt;tests.test_detector_config.TestDetectorInitialization object at 0x7ab044b01950&gt;

    def test_custom_config_initialization(self):
        """Test that Detector initializes with custom config."""
        config = DetectorConfig(
            distance_mm=200.0,
            pixel_size_mm=0.2,
            spixels=2048,
            fpixels=2048,
            beam_center_s=204.8,  # 1024 pixels * 0.2 mm
            beam_center_f=204.8,
        )
        detector = Detector(config, dtype=torch.float64)
    
        # Check unit conversions (detector uses meters internally)
        assert detector.distance == 0.2  # 200 mm = 0.2 m
        assert detector.pixel_size == 0.0002  # 0.2 mm = 0.0002 m
    
        # Check dimensions
        assert detector.spixels == 2048
        assert detector.fpixels == 2048
    
        # Check beam center in pixels
        # Default convention is MOSFLM which adds +0.5 pixel offset
&gt;       assert detector.beam_center_s == 1024.5  # 204.8 mm / 0.2 mm per pixel + 0.5
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert tensor(1024.) == 1024.5
E        +  where tensor(1024.) = &lt;src.nanobrag_torch.models.detector.Detector object at 0x7ab03b95ed50&gt;.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_config.py:171: AssertionError</failure></testcase><testcase classname="tests.test_detector_config.TestDetectorInitialization" name="test_backward_compatibility_check" time="0.001" /><testcase classname="tests.test_detector_config.TestDetectorInitialization" name="test_custom_config_not_default" time="0.001" /><testcase classname="tests.test_detector_config.TestDetectorInitialization" name="test_basis_vectors_initialization" time="0.001" /><testcase classname="tests.test_detector_config.TestDetectorInitialization" name="test_device_and_dtype" time="0.000" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_adxv_convention_basis_vectors" time="0.001" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_denzo_convention_basis_vectors" time="0.002" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_denzo_beam_center_mapping" time="0.002"><failure message="AssertionError: MOSFLM beam_center_s should be 500.5, got 500.0&#10;assert False&#10; +  where False = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;(tensor(500.), tensor(500.5000), atol=1e-06)&#10; +    where &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt; = torch.allclose&#10; +    and   tensor(500.) = &lt;src.nanobrag_torch.models.detector.Detector object at 0x7ab039330a50&gt;.beam_center_s&#10; +    and   tensor(500.5000) = &lt;built-in method tensor of type object at 0x7ab1c6980fc0&gt;(500.5, dtype=torch.float64)&#10; +      where &lt;built-in method tensor of type object at 0x7ab1c6980fc0&gt; = torch.tensor&#10; +      and   torch.float64 = torch.float64">self = &lt;tests.test_detector_conventions.TestDetectorConventions object at 0x7ab044af9a70&gt;

    def test_denzo_beam_center_mapping(self):
        """Test DENZO beam center mapping differs from MOSFLM (no +0.5 pixel offset)."""
        # Use explicit beam centers to test the offset behavior
        beam_center_mm_s = 50.0  # mm
        beam_center_mm_f = 50.0  # mm
        pixel_size = 0.1  # mm
    
        config_denzo = DetectorConfig(
            detector_convention=DetectorConvention.DENZO,
            spixels=1024,
            fpixels=1024,
            pixel_size_mm=pixel_size,
            distance_mm=100.0,
            beam_center_s=beam_center_mm_s,
            beam_center_f=beam_center_mm_f
        )
    
        config_mosflm = DetectorConfig(
            detector_convention=DetectorConvention.MOSFLM,
            spixels=1024,
            fpixels=1024,
            pixel_size_mm=pixel_size,
            distance_mm=100.0,
            beam_center_s=beam_center_mm_s,
            beam_center_f=beam_center_mm_f
        )
    
        detector_denzo = Detector(config_denzo, dtype=torch.float64)
        detector_mosflm = Detector(config_mosflm, dtype=torch.float64)
    
        # Convert mm to pixels for comparison
        beam_center_pixels = beam_center_mm_s / pixel_size  # 500 pixels
    
        # DENZO should store beam center as-is in pixels
        # MOSFLM should add +0.5 pixel offset
        expected_denzo = beam_center_pixels  # 500.0
        expected_mosflm = beam_center_pixels + 0.5  # 500.5
    
        assert torch.allclose(detector_denzo.beam_center_s, torch.tensor(expected_denzo, dtype=torch.float64), atol=1e-6), \
            f"DENZO beam_center_s should be {expected_denzo}, got {detector_denzo.beam_center_s}"
        assert torch.allclose(detector_denzo.beam_center_f, torch.tensor(expected_denzo, dtype=torch.float64), atol=1e-6), \
            f"DENZO beam_center_f should be {expected_denzo}, got {detector_denzo.beam_center_f}"
&gt;       assert torch.allclose(detector_mosflm.beam_center_s, torch.tensor(expected_mosflm, dtype=torch.float64), atol=1e-6), \
            f"MOSFLM beam_center_s should be {expected_mosflm}, got {detector_mosflm.beam_center_s}"
E       AssertionError: MOSFLM beam_center_s should be 500.5, got 500.0
E       assert False
E        +  where False = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;(tensor(500.), tensor(500.5000), atol=1e-06)
E        +    where &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt; = torch.allclose
E        +    and   tensor(500.) = &lt;src.nanobrag_torch.models.detector.Detector object at 0x7ab039330a50&gt;.beam_center_s
E        +    and   tensor(500.5000) = &lt;built-in method tensor of type object at 0x7ab1c6980fc0&gt;(500.5, dtype=torch.float64)
E        +      where &lt;built-in method tensor of type object at 0x7ab1c6980fc0&gt; = torch.tensor
E        +      and   torch.float64 = torch.float64

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_conventions.py:113: AssertionError</failure></testcase><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_adxv_beam_direction" time="0.001" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_adxv_twotheta_axis_default" time="0.000" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_denzo_twotheta_axis_default" time="0.000" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_adxv_default_beam_centers" time="0.000" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_all_conventions_orthonormal" time="0.005" /><testcase classname="tests.test_detector_conventions.TestDetectorConventions" name="test_conventions_with_rotations" time="0.004" /><testcase classname="tests.test_detector_geometry.TestDetectorGeometryRegressions" name="test_rotated_basis_vectors_match_c_reference" time="0.001" /><testcase classname="tests.test_detector_geometry.TestDetectorGeometryRegressions" name="test_pix0_vector_matches_c_reference_in_beam_pivot" time="0.000" /><testcase classname="tests.test_detector_geometry.TestDetectorGeometryRegressions" name="test_mosflm_axis_mapping_correctness" time="0.001" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_detector_parameter_gradients" time="0.056" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_basis_vector_gradients" time="0.010" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_pixel_coords_basis_vector_gradients" time="0.016" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_comprehensive_gradcheck" time="0.018" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_beam_strike_invariant_in_beam_pivot_mode" time="0.007" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_xds_convention_basic_geometry" time="0.002" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_detector_real_valued_gradients" time="0.003" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_detector_complex_gradient_edge_cases" time="0.001" /><testcase classname="tests.test_detector_geometry.TestDetectorDifferentiability" name="test_simulator_real_valued_gradients" time="0.009" /><testcase classname="tests.test_detector_pivots" name="test_beam_pivot_keeps_beam_indices_and_alignment" time="0.001"><failure message="assert False&#10; +  where False = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;(tensor(512.5000), tensor(512.), atol=1e-12)&#10; +    where &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt; = torch.allclose&#10; +    and   tensor(512.) = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039330250&gt;.beam_center_s">def test_beam_pivot_keeps_beam_indices_and_alignment():
        cfg = DetectorConfig(
            detector_convention=DetectorConvention.MOSFLM,
            detector_pivot=DetectorPivot.BEAM,
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=1024, fpixels=1024,
            beam_center_s=51.2, beam_center_f=51.2,
            detector_twotheta_deg=0.0,
        )
        d = Detector(cfg, dtype=torch.float64)
    
        # 1) Direct beam fractional indices must be equal to beam_center_s and beam_center_f
        # (Note: MOSFLM +0.5 offset is already included in d.beam_center_s/f)
        s0, f0 = _beam_indices(d)
&gt;       assert torch.allclose(s0, d.beam_center_s, atol=1e-12)
E       assert False
E        +  where False = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;(tensor(512.5000), tensor(512.), atol=1e-12)
E        +    where &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt; = torch.allclose
E        +    and   tensor(512.) = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039330250&gt;.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_pivots.py:43: AssertionError</failure></testcase><testcase classname="tests.test_detector_pivots" name="test_sample_pivot_moves_beam_indices_with_twotheta" time="0.002"><failure message="assert False&#10; +  where False = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;(tensor(512.5000), tensor(512.), atol=1e-12)&#10; +    where &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt; = torch.allclose&#10; +    and   tensor(512.) = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039330b50&gt;.beam_center_s">def test_sample_pivot_moves_beam_indices_with_twotheta():
        cfg = DetectorConfig(
            detector_convention=DetectorConvention.MOSFLM,
            detector_pivot=DetectorPivot.SAMPLE,
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=1024, fpixels=1024,
            beam_center_s=51.2, beam_center_f=51.2,
            detector_twotheta_deg=0.0,
        )
        d = Detector(cfg, dtype=torch.float64)
    
        # At zero rotation with center-based indexing, beam indices equal beam centers
        s0, f0 = _beam_indices(d)
&gt;       assert torch.allclose(s0, d.beam_center_s, atol=1e-12)
E       assert False
E        +  where False = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;(tensor(512.5000), tensor(512.), atol=1e-12)
E        +    where &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt; = torch.allclose
E        +    and   tensor(512.) = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039330b50&gt;.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_pivots.py:75: AssertionError</failure></testcase><testcase classname="tests.test_divergence_culling.TestDivergenceCullingModes" name="test_round_div_applies_elliptical_trimming" time="0.001" /><testcase classname="tests.test_divergence_culling.TestDivergenceCullingModes" name="test_square_div_uses_full_grid" time="0.001" /><testcase classname="tests.test_divergence_culling.TestDivergenceCullingModes" name="test_round_vs_square_source_count_difference" time="0.001" /><testcase classname="tests.test_divergence_culling.TestDivergenceCullingModes" name="test_single_divergence_point_unaffected" time="0.001" /><testcase classname="tests.test_divergence_culling.TestDivergenceCullingModes" name="test_elliptical_trimming_threshold" time="0.001" /><testcase classname="tests.test_divergence_culling.TestDivergenceCullingModes" name="test_combined_divergence_and_dispersion" time="0.001" /><testcase classname="tests.test_gradients.TestCellParameterGradients" name="test_gradcheck_cell_a" time="46.455" /><testcase classname="tests.test_gradients.TestCellParameterGradients" name="test_gradcheck_cell_b" time="128.242" /><testcase classname="tests.test_gradients.TestCellParameterGradients" name="test_gradcheck_cell_c" time="71.375" /><testcase classname="tests.test_gradients.TestCellParameterGradients" name="test_gradcheck_cell_alpha" time="62.101" /><testcase classname="tests.test_gradients.TestCellParameterGradients" name="test_gradcheck_cell_beta" time="48.253" /><testcase classname="tests.test_gradients.TestCellParameterGradients" name="test_gradcheck_cell_gamma" time="48.382" /><testcase classname="tests.test_gradients.TestAdvancedGradients" name="test_joint_gradcheck" time="144.634" /><testcase classname="tests.test_gradients.TestAdvancedGradients" name="test_gradgradcheck_cell_params" time="50.669" /><testcase classname="tests.test_gradients.TestAdvancedGradients" name="test_gradient_flow_simulation" time="1.829"><failure message="AssertionError: At least one gradient should be non-zero&#10;assert False&#10; +  where False = any(&lt;generator object TestAdvancedGradients.test_gradient_flow_simulation.&lt;locals&gt;.&lt;genexpr&gt; at 0x7ab03935b9f0&gt;)">self = &lt;tests.test_gradients.TestAdvancedGradients object at 0x7ab044afa9e0&gt;

    def test_gradient_flow_simulation(self):
        """Verify end-to-end gradient flow through full simulation pipeline."""
        device = torch.device("cpu")
        dtype = torch.float64
    
        # Create differentiable cell parameters
        cell_a = torch.tensor(100.0, dtype=dtype, requires_grad=True)
        cell_b = torch.tensor(100.0, dtype=dtype, requires_grad=True)
        cell_c = torch.tensor(100.0, dtype=dtype, requires_grad=True)
        cell_alpha = torch.tensor(90.0, dtype=dtype, requires_grad=True)
        cell_beta = torch.tensor(90.0, dtype=dtype, requires_grad=True)
        cell_gamma = torch.tensor(90.0, dtype=dtype, requires_grad=True)
    
        # Create config with tensor parameters
        config = CrystalConfig(
            cell_a=cell_a,
            cell_b=cell_b,
            cell_c=cell_c,
            cell_alpha=cell_alpha,
            cell_beta=cell_beta,
            cell_gamma=cell_gamma,
            mosaic_spread_deg=0.0,
            mosaic_domains=1,
            N_cells=(5, 5, 5),
        )
    
        # Create objects
        crystal = Crystal(config=config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
    
        # Run simulation
        simulator = Simulator(
            crystal, detector, crystal_config=config, device=device, dtype=dtype
        )
        image = simulator.run()
    
        # Compute loss
        loss = image.sum()
    
        # Verify image requires grad
        assert image.requires_grad, "Output image should require gradients"
    
        # Backward pass
        loss.backward()
    
        # Verify all parameters have gradients
        assert cell_a.grad is not None, "cell_a should have gradient"
        assert cell_b.grad is not None, "cell_b should have gradient"
        assert cell_c.grad is not None, "cell_c should have gradient"
        assert cell_alpha.grad is not None, "cell_alpha should have gradient"
        assert cell_beta.grad is not None, "cell_beta should have gradient"
        assert cell_gamma.grad is not None, "cell_gamma should have gradient"
    
        # Verify gradients are non-zero (at least one should be)
        grad_magnitudes = [
            cell_a.grad.abs().item(),
            cell_b.grad.abs().item(),
            cell_c.grad.abs().item(),
            cell_alpha.grad.abs().item(),
            cell_beta.grad.abs().item(),
            cell_gamma.grad.abs().item(),
        ]
&gt;       assert any(
            mag &gt; 1e-10 for mag in grad_magnitudes
        ), "At least one gradient should be non-zero"
E       AssertionError: At least one gradient should be non-zero
E       assert False
E        +  where False = any(&lt;generator object TestAdvancedGradients.test_gradient_flow_simulation.&lt;locals&gt;.&lt;genexpr&gt; at 0x7ab03935b9f0&gt;)

/home/ollie/Documents/tmp/nanoBragg/tests/test_gradients.py:447: AssertionError</failure></testcase><testcase classname="tests.test_gradients.TestPropertyBasedGradients" name="test_property_metric_duality" time="0.129" /><testcase classname="tests.test_gradients.TestPropertyBasedGradients" name="test_property_volume_consistency" time="0.082" /><testcase classname="tests.test_gradients.TestPropertyBasedGradients" name="test_property_gradient_stability" time="1100.606" /><testcase classname="tests.test_gradients.TestOptimizationRecovery" name="test_optimization_recovers_cell" time="0.080" /><testcase classname="tests.test_gradients.TestOptimizationRecovery" name="test_multiple_optimization_scenarios" time="0.354" /><testcase classname="tests.test_mosflm_matrix.TestMOSFLMMatrixLoading" name="test_read_identity_matrix" time="0.001" /><testcase classname="tests.test_mosflm_matrix.TestMOSFLMMatrixLoading" name="test_read_cubic_matrix" time="0.001" /><testcase classname="tests.test_mosflm_matrix.TestMOSFLMMatrixLoading" name="test_wavelength_scaling" time="0.001" /><testcase classname="tests.test_mosflm_matrix.TestMOSFLMMatrixLoading" name="test_triclinic_matrix" time="0.000" /><testcase classname="tests.test_mosflm_matrix.TestMOSFLMMatrixLoading" name="test_missing_file" time="0.000" /><testcase classname="tests.test_mosflm_matrix.TestMOSFLMMatrixLoading" name="test_invalid_format" time="0.000" /><testcase classname="tests.test_mosflm_matrix.TestMOSFLMMatrixLoading" name="test_comments_and_whitespace" time="0.000" /><testcase classname="tests.test_multi_source_integration" name="test_multi_source_intensity_normalization" time="0.019" /><testcase classname="tests.test_oversample_autoselect.TestOversampleAutoSelect" name="test_auto_select_formula" time="0.011" /><testcase classname="tests.test_oversample_autoselect.TestOversampleAutoSelect" name="test_different_crystal_sizes" time="0.038" /><testcase classname="tests.test_oversample_autoselect.TestOversampleAutoSelect" name="test_explicit_oversample_overrides_auto" time="0.018" /><testcase classname="tests.test_oversample_autoselect.TestOversampleAutoSelect" name="test_different_wavelengths" time="0.033" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_linter_finds_repo_root" time="0.000" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_linter_loads_yaml" time="0.013" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_yaml_structure_validation" time="0.002" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_missing_yaml_file" time="0.000" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_invalid_yaml" time="0.001" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_real_repo_linting" time="0.013" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_extraction_of_spec_ats" time="0.000" /><testcase classname="tests.test_parity_coverage_lint.TestParityCoverageLinter" name="test_extraction_of_yaml_ats" time="0.012" /><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-001-detpixels-64]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-001-detpixels-128]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-001-detpixels-256]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-001-detpixels-512]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-002-pixel-0.05mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-002-pixel-0.1mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-002-pixel-0.2mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-002-pixel-0.4mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-003-beam-20-20-detpixels-256]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-003-beam-30-40-detpixels-256]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-003-beam-45-25-detpixels-512]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-003-beam-60-60-detpixels-1024]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-004-mosflm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-004-xds]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-005-mosflm-xbeam-ybeam-beam-pivot]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-005-xds-xbeam-ybeam-sample-pivot]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-005-mosflm-close-distance-sample-pivot]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-005-xds-close-distance-sample-pivot]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-006-dist-50mm-lambda-1.0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-006-dist-100mm-lambda-1.5]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-006-dist-200mm-lambda-2.0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-007-rot-0-0-0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-007-rot-5-3-2]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-007-rot-10-5-3]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-012-simple_cubic]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-011-unpolarized]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-011-polarized]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-020-comprehensive]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-021-single_step_phi]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-021-multi_step_phi]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-022-single_step_phi]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-022-multi_step_phi]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-cubic-misset-0-0-0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-cubic-misset-10p5-0-0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-cubic-misset-0-10p25-0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-cubic-misset-0-0-9p75]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-cubic-misset-15-20p5-30p25]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-triclinic-misset-0-0-0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-triclinic-misset-10p5-0-0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-triclinic-misset-0-10p25-0]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-triclinic-misset-0-0-9p75]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-023-triclinic-misset-15-20p5-30p25]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-024-random-misset-seed-12345]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-024-random-misset-seed-54321]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-point-pixel-distance-50mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-point-pixel-distance-100mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-point-pixel-distance-200mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-point-pixel-distance-400mm]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-0deg]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-10deg]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-20deg]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-30deg]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-016-extreme-tiny]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-016-extreme-large-cell]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_parity_matrix" name="test_parity_case[AT-PARALLEL-016-extreme-long-distance]" time="0.000"><skipped type="pytest.skip" message="NB_RUN_PARALLEL not set to 1">/home/ollie/Documents/tmp/nanoBragg/tests/test_parity_matrix.py:296: NB_RUN_PARALLEL not set to 1</skipped></testcase><testcase classname="tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility" name="test_basic_execution[cpu]" time="0.000"><failure message="TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'">self = &lt;tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility object at 0x7ab0449aa490&gt;
device = 'cpu'

    @pytest.mark.parametrize("device", ["cpu", pytest.param("cuda", marks=pytest.mark.skipif(not torch.cuda.is_available(), reason="CUDA not available"))])
    def test_basic_execution(self, device):
        """Test that basic simulation runs on both CPU and CUDA without errors."""
        # Simple cubic crystal configuration
        crystal_config = CrystalConfig(
            cell_a=100.0, cell_b=100.0, cell_c=100.0,
            cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0,
            misset_deg=(0.0, 0.0, 0.0),
            phi_start_deg=0.0, osc_range_deg=0.0, phi_steps=1,
            spindle_axis=(0.0, 0.0, 1.0),
            mosaic_spread_deg=0.0, mosaic_domains=1,
            N_cells=(3, 3, 3),
            default_F=100.0
        )
    
        # Small detector for fast test
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=64, fpixels=64,
            beam_center_s=3.2, beam_center_f=3.2
        )
    
        beam_config = BeamConfig(
            wavelength_A=6.2
        )
    
        # Create simulator on target device (dtype defaults to float32)
&gt;       simulator = Simulator(
            crystal_config=crystal_config,
            detector_config=detector_config,
            beam_config=beam_config,
            device=device,
            dtype=torch.float32
        )
E       TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'

/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:53: TypeError</failure></testcase><testcase classname="tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility" name="test_basic_execution[cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:25: CUDA not available</skipped></testcase><testcase classname="tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility" name="test_cuda_multiple_runs" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:70: CUDA not available</skipped></testcase><testcase classname="tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility" name="test_gradient_flow_preserved" time="0.000"><failure message="TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'">self = &lt;tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility object at 0x7ab044a04b00&gt;

    def test_gradient_flow_preserved(self):
        """Test that cloning incident_beam_direction preserves gradient flow."""
        # Use float64 for gradcheck precision
        distance_tensor = torch.tensor(100.0, requires_grad=True, dtype=torch.float64)
    
        crystal_config = CrystalConfig(
            cell_a=100.0, cell_b=100.0, cell_c=100.0,
            cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0,
            misset_deg=(0.0, 0.0, 0.0),
            phi_start_deg=0.0, osc_range_deg=0.0, phi_steps=1,
            spindle_axis=(0.0, 0.0, 1.0),
            mosaic_spread_deg=0.0, mosaic_domains=1,
            N_cells=(3, 3, 3),
            default_F=100.0
        )
    
        detector_config = DetectorConfig(
            distance_mm=distance_tensor,
            pixel_size_mm=0.1,
            spixels=32, fpixels=32,
            beam_center_s=1.6, beam_center_f=1.6
        )
    
        beam_config = BeamConfig(
            wavelength_A=6.2
        )
    
&gt;       simulator = Simulator(
            crystal_config=crystal_config,
            detector_config=detector_config,
            beam_config=beam_config,
            device="cpu",
            dtype=torch.float64
        )
E       TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'

/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:142: TypeError</failure></testcase><testcase classname="tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility" name="test_cpu_cuda_correlation[cpu]" time="0.000"><failure message="TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'">self = &lt;tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility object at 0x7ab0448631d0&gt;
device = 'cpu'

    @pytest.mark.parametrize("device", ["cpu", pytest.param("cuda", marks=pytest.mark.skipif(not torch.cuda.is_available(), reason="CUDA not available"))])
    def test_cpu_cuda_correlation(self, device):
        """Test that CPU and CUDA (if available) produce highly correlated results."""
        crystal_config = CrystalConfig(
            cell_a=100.0, cell_b=100.0, cell_c=100.0,
            cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0,
            misset_deg=(0.0, 0.0, 0.0),
            phi_start_deg=0.0, osc_range_deg=0.0, phi_steps=1,
            spindle_axis=(0.0, 0.0, 1.0),
            mosaic_spread_deg=0.0, mosaic_domains=1,
            N_cells=(3, 3, 3),
            default_F=100.0
        )
    
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=64, fpixels=64,
            beam_center_s=3.2, beam_center_f=3.2
        )
    
        beam_config = BeamConfig(
            wavelength_A=6.2
        )
    
        # Run on CPU
&gt;       simulator_cpu = Simulator(
            crystal_config=crystal_config,
            detector_config=detector_config,
            beam_config=beam_config,
            device="cpu",
            dtype=torch.float32
        )
E       TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'

/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:184: TypeError</failure></testcase><testcase classname="tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility" name="test_cpu_cuda_correlation[cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:158: CUDA not available</skipped></testcase><testcase classname="tests.test_perf_pytorch_006" name="test_dtype_support[dtype0]" time="0.006" /><testcase classname="tests.test_perf_pytorch_006" name="test_dtype_support[dtype1]" time="0.006" /><testcase classname="tests.test_perf_pytorch_006" name="test_float32_float64_correlation" time="0.021" /><testcase classname="tests.test_physics.TestPhysicsFunctions" name="test_sincg_against_c_value" time="0.001" /><testcase classname="tests.test_physics.TestPhysicsFunctions" name="test_sincg_fractional_miller_index" time="0.001" /><testcase classname="tests.test_physics.TestPhysicsFunctions" name="test_sincg_at_zero" time="0.001" /><testcase classname="tests.test_physics.TestPhysicsFunctions" name="test_sincg_vectorized" time="0.000" /><testcase classname="tests.test_physics.TestPhysicsFunctions" name="test_sincg_broadcast_N" time="0.000" /><testcase classname="tests.test_pivot_mode_selection.TestPivotModeSelection" name="test_twotheta_zero_uses_config_pivot" time="0.000" /><testcase classname="tests.test_pivot_mode_selection.TestPivotModeSelection" name="test_twotheta_nonzero_forces_sample_pivot" time="0.000" /><testcase classname="tests.test_pivot_mode_selection.TestPivotModeSelection" name="test_small_twotheta_values" time="0.000" /><testcase classname="tests.test_pivot_mode_selection.TestPivotModeSelection" name="test_negative_twotheta_forces_sample_pivot" time="0.000" /><testcase classname="tests.test_pivot_mode_selection.TestPivotModeSelection" name="test_pivot_fix_integration" time="0.000" /><testcase classname="tests.test_show_config.TestShowConfig" name="test_show_config_basic" time="0.984" /><testcase classname="tests.test_show_config.TestShowConfig" name="test_show_config_with_divergence" time="0.981" /><testcase classname="tests.test_show_config.TestShowConfig" name="test_show_config_with_rotations" time="0.984" /><testcase classname="tests.test_show_config.TestShowConfig" name="test_echo_config_alias" time="0.984" /><testcase classname="tests.test_suite.TestGeometryFunctions" name="test_dot_product" time="0.001" /><testcase classname="tests.test_suite.TestGeometryFunctions" name="test_cross_product" time="0.000" /><testcase classname="tests.test_suite.TestGeometryFunctions" name="test_magnitude" time="0.000" /><testcase classname="tests.test_suite.TestGeometryFunctions" name="test_unitize" time="0.000" /><testcase classname="tests.test_suite.TestGeometryFunctions" name="test_rotate_axis" time="0.001" /><testcase classname="tests.test_suite.TestGeometryFunctions" name="test_rotate_umat" time="0.000" /><testcase classname="tests.test_suite.TestCrystalModel" name="test_zero_rotation" time="0.004" /><testcase classname="tests.test_suite.TestCrystalModel" name="test_phi_rotation_90_deg" time="0.004" /><testcase classname="tests.test_suite.TestCrystalModel" name="test_rotation_gradients" time="0.019" /><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_golden_data_exists" time="0.000" /><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_simple_cubic_reproduction" time="0.208"><skipped type="pytest.xfail" message="Requires completion of parallel trace debugging initiative - see initiatives/parallel-trace-validation/" /></testcase><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_cubic_tilted_detector_reproduction" time="0.207" /><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_triclinic_P1_reproduction" time="0.196" /><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_peak_position_validation" time="0.000" /><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_sensitivity_to_cell_params" time="0.001"><failure message="AttributeError: 'float' object has no attribute 'to'">self = &lt;tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab044a28380&gt;

    def test_sensitivity_to_cell_params(self):
        """Test that the model behaves physically when cell parameters change."""
        import os
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        # Set up base triclinic cell
        device = torch.device("cpu")
        dtype = torch.float64
    
        base_config = CrystalConfig(
            cell_a=70.0,
            cell_b=80.0,
            cell_c=90.0,
            cell_alpha=75.0,
            cell_beta=85.0,
            cell_gamma=95.0,
            N_cells=[3, 3, 3],  # Smaller for speed
        )
    
        # Create base simulation
        crystal = Crystal(config=base_config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        detector.spixels = 256  # Smaller for speed
        detector.fpixels = 256
        detector.beam_center_f = 128.5
        detector.beam_center_s = 128.5
    
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
            phi_steps=1,  # Explicitly set phi_steps
            osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
            mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
        )
    
&gt;       simulator = Simulator(
            crystal, detector, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:678: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039331950&gt;
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
&gt;       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError</failure></testcase><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_performance_simple_cubic" time="0.001"><failure message="AttributeError: 'float' object has no attribute 'to'">self = &lt;tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab044a28af0&gt;

    def test_performance_simple_cubic(self):
        """Test performance of simple cubic simulation."""
        import os
        import time
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        # Create simple cubic crystal
        crystal = Crystal(device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        # Use smaller detector for consistent timing
        detector.spixels = 256
        detector.fpixels = 256
        detector.beam_center_f = 128.5
        detector.beam_center_s = 128.5
    
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
            phi_steps=1,  # Explicitly set phi_steps
            osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
            mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
        )
    
&gt;       simulator = Simulator(
            crystal, detector, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:804: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039331850&gt;
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
&gt;       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError</failure></testcase><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_performance_triclinic" time="0.001"><failure message="AttributeError: 'float' object has no attribute 'to'">self = &lt;tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab044a10750&gt;

    def test_performance_triclinic(self):
        """Test performance of triclinic simulation.
    
        This test verifies that triclinic crystal simulation does not
        have excessive overhead compared to simple cubic. Due to system
        load variations, we use a median of multiple runs and a relaxed
        tolerance.
        """
        import os
        import time
        import statistics
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        # Create triclinic crystal
        triclinic_config = CrystalConfig(
            cell_a=70.0,
            cell_b=80.0,
            cell_c=90.0,
            cell_alpha=75.0,
            cell_beta=85.0,
            cell_gamma=95.0,
            N_cells=[5, 5, 5],
        )
    
        crystal = Crystal(config=triclinic_config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        # Use smaller detector for consistent timing
        detector.spixels = 256
        detector.fpixels = 256
        detector.beam_center_f = 128.5
        detector.beam_center_s = 128.5
    
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
            phi_steps=1,  # Explicitly set phi_steps
            osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
            mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
        )
    
        # Set beam config with wavelength
        from nanobrag_torch.config import BeamConfig
        beam_config = BeamConfig(wavelength_A=1.0)
    
&gt;       simulator = Simulator(
            crystal, detector, beam_config=beam_config, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:879: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039331b50&gt;
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
&gt;       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError</failure></testcase><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_memory_usage_analysis" time="0.421" /><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_extreme_cell_parameters" time="0.001"><failure message="AttributeError: 'float' object has no attribute 'to'">self = &lt;tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab0449b3890&gt;

    def test_extreme_cell_parameters(self):
        """Test numerical stability for edge cases."""
        import os
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        print("\n=== Testing Extreme Cell Parameters ===")
    
        # Test cases with different extreme parameters
        test_cases = [
            # Nearly cubic cells (angles near 90°)
            {
                "name": "Nearly cubic",
                "config": CrystalConfig(
                    cell_a=100.0,
                    cell_b=100.1,
                    cell_c=99.9,
                    cell_alpha=89.9,
                    cell_beta=90.1,
                    cell_gamma=90.0,
                    N_cells=[2, 2, 2],
                ),
            },
            # Moderately skewed cells (challenging but not extreme)
            {
                "name": "Moderately skewed",
                "config": CrystalConfig(
                    cell_a=50.0,
                    cell_b=60.0,
                    cell_c=70.0,
                    cell_alpha=70.0,  # Less extreme than 45°
                    cell_beta=110.0,  # Less extreme than 135°
                    cell_gamma=80.0,   # Less extreme than 60°
                    N_cells=[2, 2, 2],
                ),
            },
            # Very small cell dimensions
            {
                "name": "Very small cells",
                "config": CrystalConfig(
                    cell_a=1.0,
                    cell_b=1.5,
                    cell_c=2.0,
                    cell_alpha=90.0,
                    cell_beta=90.0,
                    cell_gamma=90.0,
                    N_cells=[10, 10, 10],
                ),
            },
            # Very large cell dimensions
            {
                "name": "Very large cells",
                "config": CrystalConfig(
                    cell_a=1000.0,
                    cell_b=1200.0,
                    cell_c=1500.0,
                    cell_alpha=90.0,
                    cell_beta=90.0,
                    cell_gamma=90.0,
                    N_cells=[1, 1, 1],
                ),
            },
        ]
    
        for test_case in test_cases:
            print(f"\nTesting: {test_case['name']}")
    
            try:
                # Create crystal
                crystal = Crystal(
                    config=test_case["config"], device=device, dtype=dtype
                )
    
                # Check geometry calculations
                tensors = crystal.compute_cell_tensors()
    
                # Verify no NaN or Inf values
                for key, tensor in tensors.items():
                    if key == "V":  # Volume is scalar
                        assert torch.isfinite(
                            tensor
                        ), f"NaN/Inf in {key} for {test_case['name']}"
                        print(f"  Volume: {tensor.item():.3e}")
                        # Check for reasonable volume bounds
                        assert tensor.item() &gt; 1e-12, f"Volume too small for {test_case['name']}: {tensor.item():.3e}"
                        assert tensor.item() &lt; 1e15, f"Volume too large for {test_case['name']}: {tensor.item():.3e}"
                    else:  # Vectors
                        assert torch.all(
                            torch.isfinite(tensor)
                        ), f"NaN/Inf in {key} for {test_case['name']}"
                        magnitude = torch.norm(tensor).item()
                        print(f"  |{key}|: {magnitude:.3e}")
                        # Check for reasonable vector magnitude bounds
                        assert magnitude &lt; 1e10, f"Vector {key} magnitude too large for {test_case['name']}: {magnitude:.3e}"
    
                # Try to run a small simulation
                detector = Detector(device=device, dtype=dtype)
                detector.spixels = 64
                detector.fpixels = 64
                detector.beam_center_f = 32.5
                detector.beam_center_s = 32.5
    
                rot_config = CrystalConfig(
                    phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
                    osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
                    mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
                )
    
&gt;               simulator = Simulator(
                    crystal,
                    detector,
                    crystal_config=rot_config,
                    device=device,
                    dtype=dtype,
                )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab03b48b550&gt;
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
&gt;       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError</failure></testcase><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_rotation_compatibility" time="0.001"><failure message="AttributeError: 'float' object has no attribute 'to'">self = &lt;tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab0449b3e30&gt;

    def test_rotation_compatibility(self):
        """Test that dynamic geometry works with crystal rotations."""
        import os
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        print("\n=== Testing Rotation Compatibility ===")
    
        # Create triclinic crystal with proper parameters
        config = CrystalConfig(
            cell_a=70.0,
            cell_b=80.0,
            cell_c=90.0,
            cell_alpha=75.0,
            cell_beta=85.0,
            cell_gamma=95.0,
            N_cells=[3, 3, 3],
            default_F=100.0,  # Add non-zero structure factor
        )
    
        crystal = Crystal(config=config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        detector.spixels = 128
        detector.fpixels = 128
        detector.beam_center_f = 64.5
        detector.beam_center_s = 64.5
    
        # Test with phi rotation and mosaic spread
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(10.0, device=device, dtype=dtype),
            osc_range_deg=torch.tensor(20.0, device=device, dtype=dtype),
            phi_steps=5,
            mosaic_spread_deg=torch.tensor(0.5, device=device, dtype=dtype),
            mosaic_domains=10,
        )
    
        # Create beam config with proper wavelength
        from nanobrag_torch.config import BeamConfig
        beam_config = BeamConfig(wavelength_A=1.0)
    
&gt;       simulator = Simulator(
            crystal, detector, beam_config=beam_config, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;nanobrag_torch.models.detector.Detector object at 0x7ab039330950&gt;
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
&gt;       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError</failure></testcase><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_simple_cubic_mosaic_reproduction" time="1.963" /><testcase classname="tests.test_suite.TestTier1TranslationCorrectness" name="test_simulator_phi_rotation" time="0.417" /><testcase classname="tests.test_suite.TestTier2GradientCorrectness" name="test_gradcheck_crystal_params" time="0.064" /><testcase classname="tests.test_suite.TestTier2GradientCorrectness" name="test_gradcheck_detector_params" time="0.008" /><testcase classname="tests.test_suite.TestTier2GradientCorrectness" name="test_gradcheck_phi_rotation" time="0.005"><skipped type="pytest.skip" message="Phi gradient check not yet working: not enough values to unpack (expected 3, got 2)">/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1821: Phi gradient check not yet working: not enough values to unpack (expected 3, got 2)</skipped></testcase><testcase classname="tests.test_suite.TestTier2GradientCorrectness" name="test_gradcheck_mosaic_spread" time="0.005"><skipped type="pytest.skip" message="Mosaic spread gradient check not yet working: not enough values to unpack (expected 3, got 2)">/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1879: Mosaic spread gradient check not yet working: not enough values to unpack (expected 3, got 2)</skipped></testcase><testcase classname="tests.test_suite.TestTier2GradientCorrectness" name="test_gradient_numerical_stability" time="0.005"><skipped type="pytest.skip" message="Gradient stability test not yet working: not enough values to unpack (expected 3, got 2)">/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1954: Gradient stability test not yet working: not enough values to unpack (expected 3, got 2)</skipped></testcase><testcase classname="tests.test_suite.TestTier3ScientificValidation" name="test_bragg_spot_position" time="0.000"><skipped type="pytest.skip" message="Requires implementation of simulation">/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1960: Requires implementation of simulation</skipped></testcase><testcase classname="tests.test_suite.TestTier3ScientificValidation" name="test_polarization_limits" time="0.000"><skipped type="pytest.skip" message="Requires implementation of simulation">/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1966: Requires implementation of simulation</skipped></testcase><testcase classname="tests.test_suite" name="test_import" time="0.000" /><testcase classname="tests.test_trace_pixel.TestScalingTrace" name="test_scaling_trace_matches_physics[dtype0-cpu]" time="0.010" /><testcase classname="tests.test_trace_pixel.TestScalingTrace" name="test_scaling_trace_matches_physics[dtype0-cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_trace_pixel.py:25: CUDA not available</skipped></testcase><testcase classname="tests.test_trace_pixel.TestScalingTrace" name="test_scaling_trace_matches_physics[dtype1-cpu]" time="0.011" /><testcase classname="tests.test_trace_pixel.TestScalingTrace" name="test_scaling_trace_matches_physics[dtype1-cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_trace_pixel.py:25: CUDA not available</skipped></testcase><testcase classname="tests.test_trace_pixel.TestScalingTrace" name="test_scaling_trace_with_absorption[cpu]" time="0.011" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicGather" name="test_vectorized_matches_scalar" time="0.016"><failure message="RuntimeError: Float did not match Double">self = &lt;tests.test_tricubic_vectorized.TestTricubicGather object at 0x7ab0448e0190&gt;
crystal_with_data = &lt;nanobrag_torch.models.crystal.Crystal object at 0x7ab0393899a0&gt;

    def test_vectorized_matches_scalar(self, crystal_with_data):
        """
        Verify that batched gather produces correct neighborhoods.
    
        Phase C1 requirement: Build (B, 4, 4, 4) neighborhoods via advanced indexing.
        This test validates the gather mechanism by comparing:
        1. Scalar interpolation (existing path, B=1)
        2. Shape assertions on batched gather output
        3. Neighborhood contents match expected HKL data
    
        Reference: design_notes.md Section 2.2, Section 5.1
        """
        crystal = crystal_with_data
    
        # Test case 1: Single query point (scalar path, B=1)
        h_scalar = torch.tensor([1.5], dtype=torch.float32)
        k_scalar = torch.tensor([2.3], dtype=torch.float32)
        l_scalar = torch.tensor([0.5], dtype=torch.float32)
    
        # This should use the scalar path (B=1)
        F_scalar = crystal._tricubic_interpolation(h_scalar, k_scalar, l_scalar)
    
        assert F_scalar.shape == h_scalar.shape, f"Scalar output shape mismatch: {F_scalar.shape} vs {h_scalar.shape}"
        assert not torch.isnan(F_scalar).any(), "Scalar output contains NaNs"
        assert not torch.isinf(F_scalar).any(), "Scalar output contains Infs"
    
        # Test case 2: Batched query points (gather path, B&gt;1)
        # Use a small batch to verify neighborhood gathering
        h_batch = torch.tensor([1.5, 2.3, -1.2], dtype=torch.float32)
        k_batch = torch.tensor([2.3, -0.5, 3.1], dtype=torch.float32)
        l_batch = torch.tensor([0.5, 1.8, -2.0], dtype=torch.float32)
    
        # This triggers the batched gather path (B=3)
        # Currently falls back to nearest-neighbor but builds neighborhoods internally
        F_batch = crystal._tricubic_interpolation(h_batch, k_batch, l_batch)
    
        assert F_batch.shape == h_batch.shape, f"Batch output shape mismatch: {F_batch.shape} vs {h_batch.shape}"
        assert not torch.isnan(F_batch).any(), "Batch output contains NaNs"
        assert not torch.isinf(F_batch).any(), "Batch output contains Infs"
    
        # Test case 3: Multi-dimensional batch (detector grid simulation)
        # Simulate a small detector region: (S=2, F=3)
        h_grid = torch.tensor([[1.5, 2.3, 0.8], [-1.2, 3.1, 1.9]], dtype=torch.float32)
        k_grid = torch.tensor([[2.3, -0.5, 1.2], [3.1, -2.0, 0.5]], dtype=torch.float32)
        l_grid = torch.tensor([[0.5, 1.8, -1.0], [-2.0, 0.3, 2.5]], dtype=torch.float32)
    
        # Flatten to (B=6) internally
        F_grid = crystal._tricubic_interpolation(h_grid, k_grid, l_grid)
    
        assert F_grid.shape == h_grid.shape, f"Grid output shape mismatch: {F_grid.shape} vs {h_grid.shape}"
        assert not torch.isnan(F_grid).any(), "Grid output contains NaNs"
        assert not torch.isinf(F_grid).any(), "Grid output contains Infs"
    
        # Test case 4: Verify neighborhood bounds checking still works
        # Query point near edge (h=4.5 → floor=4 → needs neighbors 3,4,5,6; 6&gt;h_max=5)
        h_edge = torch.tensor([4.5], dtype=torch.float32)
        k_edge = torch.tensor([0.0], dtype=torch.float32)
        l_edge = torch.tensor([0.0], dtype=torch.float32)
    
        # Capture warning state before test
        warning_shown_before = crystal._interpolation_warning_shown
    
        # This should trigger OOB fallback and return default_F
        F_edge = crystal._tricubic_interpolation(h_edge, k_edge, l_edge)
    
        # Should fallback to default_F due to OOB
        expected_default = crystal.config.default_F
        # Allow small tolerance due to potential floating point ops
&gt;       assert torch.allclose(F_edge, torch.tensor(expected_default), atol=1e-5), \
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            f"OOB fallback failed: expected {expected_default}, got {F_edge.item()}"

/home/ollie/Documents/tmp/nanoBragg/tests/test_tricubic_vectorized.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;torch.utils._device.DeviceContext object at 0x7ab03667e150&gt;
func = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;, types = ()
args = (tensor([100.], dtype=torch.float32), tensor(100.))
kwargs = {'atol': 1e-05}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
&gt;       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^
E       RuntimeError: Float did not match Double

/home/ollie/miniconda3/lib/python3.13/site-packages/torch/utils/_device.py:104: RuntimeError</failure></testcase><testcase classname="tests.test_tricubic_vectorized.TestTricubicGather" name="test_neighborhood_gathering_internals" time="0.007" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicGather" name="test_oob_warning_single_fire" time="0.001"><failure message="RuntimeError: Float did not match Double">self = &lt;tests.test_tricubic_vectorized.TestTricubicGather object at 0x7ab044a06650&gt;
simple_crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=[...square'&gt;, fudge=1.0, sample_x=5.0000000000000004e-08, sample_y=5.0000000000000004e-08, sample_z=5.0000000000000004e-08)

    def test_oob_warning_single_fire(self, simple_crystal_config):
        """
        Verify that out-of-bounds warning fires exactly once and disables interpolation.
    
        Phase C2 requirement: Lock the single-warning behavior for OOB fallback.
        When tricubic interpolation encounters an out-of-bounds neighborhood query:
        1. First occurrence triggers warning message (printed once only)
        2. Interpolation is permanently disabled (self.interpolate = False)
        3. Subsequent OOB queries return default_F without additional warnings
    
        Reference: plans/active/vectorization.md Phase C2
        """
        # Create crystal with small HKL data range to easily trigger OOB
        crystal = Crystal(simple_crystal_config)
    
        h_range, k_range, l_range = 11, 11, 11  # covers h,k,l ∈ [-5, 5]
        hkl_data = torch.ones((h_range, k_range, l_range), dtype=torch.float32) * 50.0
        crystal.hkl_data = hkl_data
        crystal.hkl_metadata = {
            'h_min': -5, 'h_max': 5,
            'k_min': -5, 'k_max': 5,
            'l_min': -5, 'l_max': 5,
            'h_range': 10, 'k_range': 10, 'l_range': 10
        }
    
        # Enable interpolation explicitly
        crystal.interpolate = True
        initial_warning_state = crystal._interpolation_warning_shown
        assert not initial_warning_state, "Warning flag should start False"
        assert crystal.interpolate, "Interpolation should start enabled"
    
        # First OOB query: h=4.8 → floor=4 → needs neighbors [3,4,5,6]
        # Since h_max=5, neighbor h=6 is out of range
        h_oob = torch.tensor([4.8], dtype=torch.float32)
        k_oob = torch.tensor([0.0], dtype=torch.float32)
        l_oob = torch.tensor([0.0], dtype=torch.float32)
    
        # Capture stdout to verify warning message
        import io
        import sys
        captured_output = io.StringIO()
        sys.stdout = captured_output
    
        # First call: should trigger warning
        F_first = crystal._tricubic_interpolation(h_oob, k_oob, l_oob)
    
        # Restore stdout
        sys.stdout = sys.__stdout__
        warning_text = captured_output.getvalue()
    
        # Verify warning was printed
        assert "WARNING: out of range for three point interpolation" in warning_text, \
            "First OOB call should print warning"
        assert "further warnings will not be printed" in warning_text, \
            "Warning should indicate no further warnings"
    
        # Verify state changes
        assert crystal._interpolation_warning_shown, "Warning flag should be set"
        assert not crystal.interpolate, "Interpolation should be disabled"
    
        # Verify fallback to default_F
        expected_default = crystal.config.default_F
&gt;       assert torch.allclose(F_first, torch.tensor(expected_default), atol=1e-5), \
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            f"First OOB call should return default_F={expected_default}, got {F_first.item()}"

/home/ollie/Documents/tmp/nanoBragg/tests/test_tricubic_vectorized.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;torch.utils._device.DeviceContext object at 0x7ab03667e150&gt;
func = &lt;built-in method allclose of type object at 0x7ab1c6980fc0&gt;, types = ()
args = (tensor([100.], dtype=torch.float32), tensor(100.))
kwargs = {'atol': 1e-05}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
&gt;       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^
E       RuntimeError: Float did not match Double

/home/ollie/miniconda3/lib/python3.13/site-packages/torch/utils/_device.py:104: RuntimeError</failure></testcase><testcase classname="tests.test_tricubic_vectorized.TestTricubicGather" name="test_device_neutrality[cpu]" time="0.004" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicGather" name="test_device_neutrality[cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_tricubic_vectorized.py:316: CUDA not available</skipped></testcase><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polint_matches_scalar_batched" time="0.002" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polint_gradient_flow" time="0.006" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polin2_matches_scalar_batched" time="0.003" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polin2_gradient_flow" time="0.007" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polin3_matches_scalar_batched" time="0.010" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polin3_gradient_flow" time="0.021" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polin3_batch_shape_preserved" time="0.004" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polynomials_support_float64[dtype0]" time="0.001" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polynomials_support_float64[dtype1]" time="0.001" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polynomials_device_neutral[cpu]" time="0.004" /><testcase classname="tests.test_tricubic_vectorized.TestTricubicPoly" name="test_polynomials_device_neutral[cuda]" time="0.000"><skipped type="pytest.skip" message="CUDA not available">/home/ollie/Documents/tmp/nanoBragg/tests/test_tricubic_vectorized.py:726: CUDA not available</skipped></testcase><testcase classname="tests.test_units.TestUnitConversions" name="test_mm_to_angstroms_scalar" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_mm_to_angstroms_tensor" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_mm_to_angstroms_gradient" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_meters_to_angstroms_scalar" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_meters_to_angstroms_tensor" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_degrees_to_radians_scalar" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_degrees_to_radians_tensor" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_degrees_to_radians_gradient" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_inverse_conversions" time="0.000" /><testcase classname="tests.test_units.TestUnitConversions" name="test_batch_tensor_conversions" time="0.000" /></testsuite></testsuites>