============================= test session starts ==============================
platform linux -- Python 3.13.5, pytest-8.4.1, pluggy-1.5.0 -- /home/ollie/miniconda3/bin/python3.13
cachedir: .pytest_cache
rootdir: /home/ollie/Documents/tmp/nanoBragg
configfile: pyproject.toml
plugins: anyio-4.9.0
collecting ... collected 684 items / 1 skipped

tests/test_at_abs_001.py::TestAT_ABS_001::test_absorption_disabled_when_zero[cpu] PASSED [  0%]
tests/test_at_abs_001.py::TestAT_ABS_001::test_capture_fraction_calculation[False-cpu] PASSED [  0%]
tests/test_at_abs_001.py::TestAT_ABS_001::test_capture_fraction_calculation[True-cpu] PASSED [  0%]
tests/test_at_abs_001.py::TestAT_ABS_001::test_last_value_vs_accumulation_semantics[cpu] PASSED [  0%]
tests/test_at_abs_001.py::TestAT_ABS_001::test_parallax_dependence[False-cpu] PASSED [  0%]
tests/test_at_abs_001.py::TestAT_ABS_001::test_parallax_dependence[True-cpu] PASSED [  0%]
tests/test_at_abs_001.py::TestAT_ABS_001::test_absorption_with_tilted_detector[False-cpu] PASSED [  1%]
tests/test_at_abs_001.py::TestAT_ABS_001::test_absorption_with_tilted_detector[True-cpu] PASSED [  1%]
tests/test_at_bkg_001.py::TestAT_BKG_001::test_water_background_calculation PASSED [  1%]
tests/test_at_bkg_001.py::TestAT_BKG_001::test_water_background_zero PASSED [  1%]
tests/test_at_bkg_001.py::TestAT_BKG_001::test_water_background_additive PASSED [  1%]
tests/test_at_cli_001.py::TestAT_CLI_001::test_cli_help_short_flag PASSED [  1%]
tests/test_at_cli_001.py::TestAT_CLI_001::test_cli_help_long_flag PASSED [  1%]
tests/test_at_cli_001.py::TestAT_CLI_001::test_cli_invocable PASSED      [  2%]
tests/test_at_cli_001.py::TestAT_CLI_001::test_cli_help_includes_examples PASSED [  2%]
tests/test_at_cli_001.py::TestAT_CLI_001::test_cli_help_includes_wavelength_synonyms PASSED [  2%]
tests/test_at_cli_001.py::TestAT_CLI_001::test_cli_help_includes_output_synonyms PASSED [  2%]
tests/test_at_cli_002.py::TestAT_CLI_002::test_minimal_render_with_default_F PASSED [  2%]
tests/test_at_cli_002.py::TestAT_CLI_002::test_minimal_render_with_hkl_file PASSED [  2%]
tests/test_at_cli_002.py::TestAT_CLI_002::test_data_ordering_fast_major PASSED [  2%]
tests/test_at_cli_002.py::TestAT_CLI_002::test_error_without_required_inputs PASSED [  3%]
tests/test_at_cli_003.py::TestATCLI003::test_mosflm_default_pivot_beam PASSED [  3%]
tests/test_at_cli_003.py::TestATCLI003::test_xds_default_pivot_sample PASSED [  3%]
tests/test_at_cli_003.py::TestATCLI003::test_pivot_override_mosflm_to_sample PASSED [  3%]
tests/test_at_cli_003.py::TestATCLI003::test_pivot_override_xds_to_beam PASSED [  3%]
tests/test_at_cli_003.py::TestATCLI003::test_convention_header_keys_consistency PASSED [  3%]
tests/test_at_cli_004.py::test_header_precedence_img_then_mask PASSED    [  3%]
tests/test_at_cli_004.py::test_mask_zeros_are_skipped PASSED             [  4%]
tests/test_at_cli_004.py::test_mask_beam_center_y_flip PASSED            [  4%]
tests/test_at_cli_004.py::test_conflicting_detector_size PASSED          [  4%]
tests/test_at_cli_004.py::test_img_only_no_mask PASSED                   [  4%]
tests/test_at_cli_005.py::test_cli_roi_basic PASSED                      [  4%]
tests/test_at_cli_005.py::test_cli_roi_with_noise PASSED                 [  4%]
tests/test_at_cli_005.py::test_cli_roi_edge_cases PASSED                 [  4%]
tests/test_at_cli_005.py::test_cli_roi_different_conventions PASSED      [  5%]
tests/test_at_cli_006.py::test_autoscale_without_scale_flag PASSED       [  5%]
tests/test_at_cli_006.py::test_explicit_scale_flag PASSED                [  5%]
tests/test_at_cli_006.py::test_pgm_without_pgmscale PASSED               [  5%]
tests/test_at_cli_006.py::test_pgm_with_explicit_pgmscale PASSED         [  5%]
tests/test_at_cli_006.py::test_pgm_format_compliance PASSED              [  5%]
tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_identical_seed_produces_identical_noise PASSED [  5%]
tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_different_seed_produces_different_noise PASSED [  6%]
tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_seed_determinism_without_roi PASSED [  6%]
tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_negative_seed_accepted PASSED [  6%]
tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_overload_count_determinism PASSED [  6%]
tests/test_at_cli_008.py::TestATCLI008DminFiltering::test_dmin_filtering_reduces_intensity PASSED [  6%]
tests/test_at_cli_008.py::TestATCLI008DminFiltering::test_dmin_very_strict_removes_most_intensity PASSED [  6%]
tests/test_at_cli_008.py::TestATCLI008DminFiltering::test_dmin_zero_has_no_effect PASSED [  7%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_missing_hkl_and_fdump_with_default_f_zero PASSED [  7%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_missing_hkl_but_has_default_f PASSED [  7%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_missing_cell_parameters PASSED [  7%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_fdump_fallback PASSED [  7%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_help_message PASSED [  7%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_unsupported_flag_dispstep PASSED [  7%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_unsupported_flag_hdiv PASSED [  8%]
tests/test_at_cli_009.py::TestATCLI009ErrorHandling::test_unsupported_flag_vdiv PASSED [  8%]
tests/test_at_crystal_absolute.py::TestATCrystalAbsolute::test_triclinic_absolute_positions PASSED [  8%]
tests/test_at_crystal_absolute.py::TestATCrystalAbsolute::test_cubic_vs_triclinic_systematic_difference PASSED [  8%]
tests/test_at_crystal_absolute.py::TestATCrystalAbsolute::test_known_reflection_d_spacings PASSED [  8%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_fluence_calculation_from_flux_exposure_beamsize PASSED [  8%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_no_fluence_calculation_when_flux_zero PASSED [  8%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_no_fluence_calculation_when_exposure_zero PASSED [  9%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_fluence_calculation_with_beamsize_zero PASSED [  9%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_flux_recomputation_from_fluence_and_exposure PASSED [  9%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_sample_clipping_warning PASSED [  9%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_no_clipping_when_beamsize_larger PASSED [  9%]
tests/test_at_flu_001.py::TestAT_FLU_001::test_no_clipping_when_beamsize_zero PASSED [  9%]
tests/test_at_geo_001.py::test_at_geo_001_mosflm_beam_center_mapping PASSED [  9%]
tests/test_at_geo_002.py::test_at_geo_002_setup_a_distance_only PASSED   [ 10%]
tests/test_at_geo_002.py::test_at_geo_002_setup_b_close_distance_only PASSED [ 10%]
tests/test_at_geo_002.py::test_at_geo_002_setup_c_explicit_override PASSED [ 10%]
tests/test_at_geo_002.py::test_at_geo_002_setup_c_beam_override PASSED   [ 10%]
tests/test_at_geo_002.py::test_at_geo_002_direct_instantiation PASSED    [ 10%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_r_factor_calculation PASSED [ 10%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_distance_update_with_close_distance PASSED [ 10%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_preservation_beam_pivot PASSED [ 11%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_preservation_sample_pivot PASSED [ 11%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_no_rotations_r_factor_equals_one PASSED [ 11%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_with_various_rotations[DetectorPivot.BEAM] PASSED [ 11%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_beam_center_with_various_rotations[DetectorPivot.SAMPLE] PASSED [ 11%]
tests/test_at_geo_003.py::TestATGEO003RFactorAndBeamCenter::test_gradients_flow_through_r_factor PASSED [ 11%]
tests/test_at_geo_004.py::test_twotheta_axis_defaults PASSED             [ 11%]
tests/test_at_geo_004.py::test_twotheta_axis_override PASSED             [ 12%]
tests/test_at_geo_004.py::test_twotheta_rotation_applied PASSED          [ 12%]
tests/test_at_geo_004.py::test_twotheta_value_preserved PASSED           [ 12%]
tests/test_at_geo_004.py::test_mosflm_twotheta_rotation PASSED           [ 12%]
tests/test_at_geo_004.py::test_dials_twotheta_rotation PASSED            [ 12%]
tests/test_at_geo_005.py::TestATGEO005CurvedDetector::test_curved_detector_equal_distance PASSED [ 12%]
tests/test_at_geo_005.py::TestATGEO005CurvedDetector::test_curved_vs_planar_difference PASSED [ 13%]
tests/test_at_geo_005.py::TestATGEO005CurvedDetector::test_small_angle_rotation_consistency PASSED [ 13%]
tests/test_at_geo_005.py::TestATGEO005CurvedDetector::test_gradient_flow_curved_detector PASSED [ 13%]
tests/test_at_geo_005.py::TestATGEO005CurvedDetector::test_beam_center_affects_curvature PASSED [ 13%]
tests/test_at_geo_006.py::TestATGEO006PointPixelSolidAngle::test_point_pixel_solid_angle PASSED [ 13%]
tests/test_at_geo_006.py::TestATGEO006PointPixelSolidAngle::test_default_solid_angle_with_obliquity PASSED [ 13%]
tests/test_at_geo_006.py::TestATGEO006PointPixelSolidAngle::test_off_center_pixel_comparison PASSED [ 13%]
tests/test_at_geo_006.py::TestATGEO006PointPixelSolidAngle::test_gradient_flow PASSED [ 14%]
tests/test_at_geo_006.py::TestATGEO006PointPixelSolidAngle::test_corner_pixel_values PASSED [ 14%]
tests/test_at_io_001.py::TestAT_IO_001::test_smv_header_required_keys PASSED [ 14%]
tests/test_at_io_001.py::TestAT_IO_001::test_smv_data_ordering PASSED    [ 14%]
tests/test_at_io_001.py::TestAT_IO_001::test_smv_convention_specific_headers PASSED [ 14%]
tests/test_at_io_001.py::TestAT_IO_001::test_smv_torch_tensor_input PASSED [ 14%]
tests/test_at_io_001.py::TestAT_IO_001::test_smv_byte_order PASSED       [ 14%]
tests/test_at_io_002.py::TestAT_IO_002::test_pgm_header_format PASSED    [ 15%]
tests/test_at_io_002.py::TestAT_IO_002::test_pgm_pixel_scaling PASSED    [ 15%]
tests/test_at_io_002.py::TestAT_IO_002::test_pgm_with_default_scale PASSED [ 15%]
tests/test_at_io_002.py::TestAT_IO_002::test_pgm_torch_tensor_input PASSED [ 15%]
tests/test_at_io_002.py::TestAT_IO_002::test_pgm_clipping_behavior PASSED [ 15%]
tests/test_at_io_003.py::TestAT_IO_003::test_fdump_write_and_read PASSED [ 15%]
tests/test_at_io_003.py::TestAT_IO_003::test_fdump_cache_behavior PASSED [ 15%]
tests/test_at_io_003.py::TestAT_IO_003::test_fdump_no_files_with_default_F PASSED [ 16%]
tests/test_at_io_003.py::TestAT_IO_003::test_fdump_no_files_zero_default PASSED [ 16%]
tests/test_at_io_003.py::TestAT_IO_003::test_fdump_preserves_default_F PASSED [ 16%]
tests/test_at_io_003.py::TestAT_IO_003::test_fdump_header_structure PASSED [ 16%]
tests/test_at_io_004.py::TestAT_IO_004::test_minimal_hkl_format PASSED   [ 16%]
tests/test_at_io_004.py::TestAT_IO_004::test_five_column_with_phase PASSED [ 16%]
tests/test_at_io_004.py::TestAT_IO_004::test_six_column_with_sigma_and_phase PASSED [ 16%]
tests/test_at_io_004.py::TestAT_IO_004::test_negative_indices_handling PASSED [ 17%]
tests/test_at_io_004.py::TestAT_IO_004::test_all_formats_produce_same_pattern PASSED [ 17%]
tests/test_at_io_004.py::TestAT_IO_004::test_fdump_caching_for_all_formats PASSED [ 17%]
tests/test_at_io_004.py::TestAT_IO_004::test_comment_and_blank_line_handling PASSED [ 17%]
tests/test_at_noise_001.py::TestATNoise001::test_small_mean_exact_poisson PASSED [ 17%]
tests/test_at_noise_001.py::TestATNoise001::test_medium_mean_rejection_sampling PASSED [ 17%]
tests/test_at_noise_001.py::TestATNoise001::test_large_mean_gaussian_approximation PASSED [ 17%]
tests/test_at_noise_001.py::TestATNoise001::test_seed_reproducibility PASSED [ 18%]
tests/test_at_noise_001.py::TestATNoise001::test_adc_and_clipping PASSED [ 18%]
tests/test_at_noise_001.py::TestATNoise001::test_all_regimes_in_single_image PASSED [ 18%]
tests/test_at_noise_001.py::TestATNoise001::test_noise_config_integration PASSED [ 18%]
tests/test_at_parallel_001.py::TestATParallel001::test_beam_center_scales_with_detector_size[64] PASSED [ 18%]
tests/test_at_parallel_001.py::TestATParallel001::test_beam_center_scales_with_detector_size[128] PASSED [ 18%]
tests/test_at_parallel_001.py::TestATParallel001::test_beam_center_scales_with_detector_size[256] PASSED [ 19%]
tests/test_at_parallel_001.py::TestATParallel001::test_beam_center_scales_with_detector_size[512] PASSED [ 19%]
tests/test_at_parallel_001.py::TestATParallel001::test_beam_center_scales_with_detector_size[1024] PASSED [ 19%]
tests/test_at_parallel_001.py::TestATParallel001::test_peak_position_at_beam_center PASSED [ 19%]
tests/test_at_parallel_001.py::TestATParallel001::test_cli_beam_center_calculation PASSED [ 19%]
tests/test_at_parallel_001.py::TestATParallel001::test_intensity_scaling_with_solid_angle PASSED [ 19%]
tests/test_at_parallel_002.py::TestATParallel002::test_beam_center_scales_with_pixel_size PASSED [ 19%]
tests/test_at_parallel_002.py::TestATParallel002::test_peak_position_scales_inversely_with_pixel_size PASSED [ 20%]
tests/test_at_parallel_002.py::TestATParallel002::test_pattern_correlation_across_pixel_sizes PASSED [ 20%]
tests/test_at_parallel_002.py::TestATParallel002::test_beam_center_parameter_consistency PASSED [ 20%]
tests/test_at_parallel_003.py::TestATParallel003::test_detector_offset_preservation PASSED [ 20%]
tests/test_at_parallel_003.py::TestATParallel003::test_peak_position_at_offset_beam_centers PASSED [ 20%]
tests/test_at_parallel_003.py::TestATParallel003::test_offset_ratio_preservation PASSED [ 20%]
tests/test_at_parallel_004.py::TestAT_PARALLEL_004::test_mosflm_adds_half_pixel_offset PASSED [ 20%]
tests/test_at_parallel_004.py::TestAT_PARALLEL_004::test_xds_has_no_pixel_offset PASSED [ 21%]
tests/test_at_parallel_004.py::TestAT_PARALLEL_004::test_peak_position_difference PASSED [ 21%]
tests/test_at_parallel_004.py::TestAT_PARALLEL_004::test_pattern_correlation_when_aligned PASSED [ 21%]
tests/test_at_parallel_004.py::TestAT_PARALLEL_004::test_beam_center_calculation_consistency PASSED [ 21%]
tests/test_at_parallel_005.py::TestAT_PARALLEL_005_BeamCenterMapping::test_mosflm_xbeam_ybeam_mapping SKIPPED [ 21%]
tests/test_at_parallel_005.py::TestAT_PARALLEL_005_BeamCenterMapping::test_xds_orgx_orgy_mapping SKIPPED [ 21%]
tests/test_at_parallel_005.py::TestAT_PARALLEL_005_BeamCenterMapping::test_pivot_mode_consistency SKIPPED [ 21%]
tests/test_at_parallel_005.py::TestAT_PARALLEL_005_BeamCenterMapping::test_equivalent_configurations_produce_same_pattern SKIPPED [ 22%]
tests/test_at_parallel_006.py::TestATParallel006SingleReflection::test_bragg_angle_prediction_single_distance PASSED [ 22%]
tests/test_at_parallel_006.py::TestATParallel006SingleReflection::test_distance_scaling PASSED [ 22%]
tests/test_at_parallel_006.py::TestATParallel006SingleReflection::test_combined_wavelength_and_distance PASSED [ 22%]
tests/test_at_parallel_007.py::TestATParallel007PeakPositionWithRotations::test_peak_positions_with_rotations SKIPPED [ 22%]
tests/test_at_parallel_007.py::TestATParallel007PeakPositionWithRotations::test_peak_intensity_ordering SKIPPED [ 22%]
tests/test_at_parallel_007.py::TestATParallel007PeakPositionWithRotations::test_rotation_effect_on_pattern SKIPPED [ 22%]
tests/test_at_parallel_008.py::TestAT_PARALLEL_008::test_triclinic_multi_peak_pattern SKIPPED [ 23%]
tests/test_at_parallel_008.py::TestAT_PARALLEL_008::test_peak_intensity_ordering SKIPPED [ 23%]
tests/test_at_parallel_008.py::TestAT_PARALLEL_008::test_non_max_suppression SKIPPED [ 23%]
tests/test_at_parallel_010.py::TestATParallel010SolidAngleCorrections::test_point_pixel_distance_scaling SKIPPED [ 23%]
tests/test_at_parallel_010.py::TestATParallel010SolidAngleCorrections::test_obliquity_distance_scaling SKIPPED [ 23%]
tests/test_at_parallel_010.py::TestATParallel010SolidAngleCorrections::test_obliquity_with_tilts SKIPPED [ 23%]
tests/test_at_parallel_010.py::TestATParallel010SolidAngleCorrections::test_combined_distance_and_tilt SKIPPED [ 23%]
tests/test_at_parallel_011.py::TestATParallel011PolarizationFactor::test_unpolarized_theory PASSED [ 24%]
tests/test_at_parallel_011.py::TestATParallel011PolarizationFactor::test_polarized_kahn_model PASSED [ 24%]
tests/test_at_parallel_011.py::TestATParallel011PolarizationFactor::test_c_pytorch_equivalence SKIPPED [ 24%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_simple_cubic_correlation PASSED [ 24%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_triclinic_P1_correlation PASSED [ 24%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_cubic_tilted_detector_correlation PASSED [ 24%]
tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_high_resolution_variant PASSED [ 25%]
tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_pytorch_determinism_same_seed FAILED [ 25%]
tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_pytorch_determinism_different_seeds FAILED [ 25%]
tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_pytorch_consistency_across_runs PASSED [ 25%]
tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_c_pytorch_equivalence SKIPPED [ 25%]
tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_platform_fingerprint PASSED [ 25%]
tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_numerical_precision_float64 PASSED [ 25%]
tests/test_at_parallel_014.py::TestATParallel014NoiseRobustness::test_mean_preservation_after_scaling PASSED [ 26%]
tests/test_at_parallel_014.py::TestATParallel014NoiseRobustness::test_peak_centroid_stability PASSED [ 26%]
tests/test_at_parallel_014.py::TestATParallel014NoiseRobustness::test_overload_count_consistency PASSED [ 26%]
tests/test_at_parallel_014.py::TestATParallel014NoiseRobustness::test_noise_statistics PASSED [ 26%]
tests/test_at_parallel_014.py::TestATParallel014NoiseRobustness::test_deterministic_noise_with_seed PASSED [ 26%]
tests/test_at_parallel_015.py::TestATParallel015MixedUnits::test_distance_units_consistency PASSED [ 26%]
tests/test_at_parallel_015.py::TestATParallel015MixedUnits::test_wavelength_units_consistency PASSED [ 26%]
tests/test_at_parallel_015.py::TestATParallel015MixedUnits::test_angle_units_consistency PASSED [ 27%]
tests/test_at_parallel_015.py::TestATParallel015MixedUnits::test_mixed_units_comprehensive FAILED [ 27%]
tests/test_at_parallel_015.py::TestATParallel015MixedUnits::test_detector_rotation_units PASSED [ 27%]
tests/test_at_parallel_016.py::TestATParallel016ExtremeScale::test_tiny_scale PASSED [ 27%]
tests/test_at_parallel_016.py::TestATParallel016ExtremeScale::test_large_cell PASSED [ 27%]
tests/test_at_parallel_016.py::TestATParallel016ExtremeScale::test_long_distance PASSED [ 27%]
tests/test_at_parallel_016.py::TestATParallel016ExtremeScale::test_extreme_scale_c_comparison SKIPPED [ 27%]
tests/test_at_parallel_016.py::TestATParallel016ExtremeScale::test_combined_extremes PASSED [ 28%]
tests/test_at_parallel_016.py::TestATParallel016ExtremeScale::test_numerical_stability_metrics PASSED [ 28%]
tests/test_at_parallel_017.py::TestATParallel017GrazingIncidence::test_large_detector_tilts PASSED [ 28%]
tests/test_at_parallel_017.py::TestATParallel017GrazingIncidence::test_large_twotheta PASSED [ 28%]
tests/test_at_parallel_017.py::TestATParallel017GrazingIncidence::test_combined_extreme_angles PASSED [ 28%]
tests/test_at_parallel_017.py::TestATParallel017GrazingIncidence::test_near_90_degree_incidence PASSED [ 28%]
tests/test_at_parallel_017.py::TestATParallel017GrazingIncidence::test_solid_angle_obliquity_corrections PASSED [ 28%]
tests/test_at_parallel_017.py::TestATParallel017GrazingIncidence::test_extreme_rotation_stability PASSED [ 29%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_cubic_crystal_aligned_axes PASSED [ 29%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_zero_angle_rotations PASSED [ 29%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_near_singular_cell_angles PASSED [ 29%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_aligned_spindle_and_beam PASSED [ 29%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_very_small_unit_cell PASSED [ 29%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_very_large_unit_cell PASSED [ 29%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_continuity_near_90_degrees PASSED [ 30%]
tests/test_at_parallel_018.py::TestATParallel018CrystalBoundaryConditions::test_identity_misset_matrix PASSED [ 30%]
tests/test_at_parallel_020.py::TestATParallel020::test_comprehensive_integration SKIPPED [ 30%]
tests/test_at_parallel_020.py::TestATParallel020::test_comprehensive_without_absorption SKIPPED [ 30%]
tests/test_at_parallel_020.py::TestATParallel020::test_phi_rotation_only SKIPPED [ 30%]
tests/test_at_parallel_020.py::TestATParallel020::test_comprehensive_minimal_features SKIPPED [ 30%]
tests/test_at_parallel_021.py::TestCrystalPhiRotation::test_single_step_phi_rotation SKIPPED [ 30%]
tests/test_at_parallel_021.py::TestCrystalPhiRotation::test_multi_step_phi_rotation SKIPPED [ 31%]
tests/test_at_parallel_022.py::TestATParallel022::test_single_step_with_detector_rotations SKIPPED [ 31%]
tests/test_at_parallel_022.py::TestATParallel022::test_multi_step_with_detector_rotations SKIPPED [ 31%]
tests/test_at_parallel_022.py::TestATParallel022::test_large_detector_rotations SKIPPED [ 31%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles0-cubic-cell_params0] SKIPPED [ 31%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles0-triclinic-cell_params1] SKIPPED [ 31%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles1-cubic-cell_params0] SKIPPED [ 32%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles1-triclinic-cell_params1] SKIPPED [ 32%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles2-cubic-cell_params0] SKIPPED [ 32%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles2-triclinic-cell_params1] SKIPPED [ 32%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles3-cubic-cell_params0] SKIPPED [ 32%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles3-triclinic-cell_params1] SKIPPED [ 32%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles4-cubic-cell_params0] SKIPPED [ 32%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_explicit_misset_equivalence[misset_angles4-triclinic-cell_params1] SKIPPED [ 33%]
tests/test_at_parallel_023.py::TestAT_PARALLEL_023_MissetAnglesEquivalence::test_misset_changes_pattern SKIPPED [ 33%]
tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_pytorch_determinism PASSED [ 33%]
tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_seed_independence PASSED [ 33%]
tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_c_pytorch_equivalence SKIPPED [ 33%]
tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_lcg_compatibility PASSED [ 33%]
tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_mosaic_rotation_umat_determinism FAILED [ 33%]
tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_umat2misset_round_trip PASSED [ 34%]
tests/test_at_parallel_025.py::test_maximum_intensity_simple_case SKIPPED [ 34%]
tests/test_at_parallel_025.py::test_maximum_intensity_with_offset SKIPPED [ 34%]
tests/test_at_parallel_025.py::test_maximum_intensity_triclinic SKIPPED  [ 34%]
tests/test_at_parallel_026.py::TestAT_PARALLEL_026_TriclinicAbsolutePosition::test_triclinic_absolute_peak_position_pytorch_only PASSED [ 34%]
tests/test_at_parallel_026.py::TestAT_PARALLEL_026_TriclinicAbsolutePosition::test_triclinic_absolute_peak_position_vs_c FAILED [ 34%]
tests/test_at_parallel_026.py::TestAT_PARALLEL_026_TriclinicAbsolutePosition::test_triclinic_vs_cubic_peak_difference PASSED [ 34%]
tests/test_at_parallel_027.py::TestAT_PARALLEL_027::test_structure_factor_loading PASSED [ 35%]
tests/test_at_parallel_027.py::TestAT_PARALLEL_027::test_intensity_ratios PASSED [ 35%]
tests/test_at_parallel_027.py::TestAT_PARALLEL_027::test_pattern_structure PASSED [ 35%]
tests/test_at_parallel_027.py::TestAT_PARALLEL_027::test_c_pytorch_equivalence SKIPPED [ 35%]
tests/test_at_parallel_027.py::TestAT_PARALLEL_027::test_f_squared_scaling PASSED [ 35%]
tests/test_at_parallel_028.py::TestATParallel028PerformanceParity::test_cpu_performance_parity SKIPPED [ 35%]
tests/test_at_parallel_028.py::TestATParallel028PerformanceParity::test_gpu_performance_superiority SKIPPED [ 35%]
tests/test_at_parallel_028.py::TestATParallel028PerformanceParity::test_performance_measurement_validity PASSED [ 36%]
tests/test_at_parallel_029.py::TestSubpixelSamplingAT029::test_pytorch_aliasing_reduction PASSED [ 36%]
tests/test_at_parallel_029.py::TestSubpixelSamplingAT029::test_pytorch_peak_stability PASSED [ 36%]
tests/test_at_parallel_029.py::TestSubpixelSamplingAT029::test_pytorch_fwhm_convergence PASSED [ 36%]
tests/test_at_parallel_029.py::TestSubpixelSamplingAT029::test_c_pytorch_oversample_equivalence SKIPPED [ 36%]
tests/test_at_parallel_029.py::TestSubpixelSamplingAT029::test_issue_subpixel_aliasing SKIPPED [ 36%]
tests/test_at_perf_001.py::TestATPERF001VectorizationPerformance::test_vectorization_scaling PASSED [ 36%]
tests/test_at_perf_001.py::TestATPERF001VectorizationPerformance::test_performance_parity_with_c SKIPPED [ 37%]
tests/test_at_perf_001.py::TestATPERF001VectorizationPerformance::test_memory_scaling PASSED [ 37%]
tests/test_at_perf_002.py::TestATPERF002ParallelExecution::test_cpu_thread_scaling PASSED [ 37%]
tests/test_at_perf_002.py::TestATPERF002ParallelExecution::test_pytorch_cpu_vs_c_performance SKIPPED [ 37%]
tests/test_at_perf_002.py::TestATPERF002ParallelExecution::test_gpu_acceleration SKIPPED [ 37%]
tests/test_at_perf_002.py::TestATPERF002ParallelExecution::test_thread_efficiency PASSED [ 37%]
tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_peak_memory_usage PASSED [ 38%]
tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_float32_vs_float64_performance PASSED [ 38%]
tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_cache_friendly_access PASSED [ 38%]
tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_memory_bandwidth_utilization PASSED [ 38%]
tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_intermediate_tensor_optimization PASSED [ 38%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_sincg_throughput PASSED [ 38%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_dot_product_throughput PASSED [ 38%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_profile_hot_paths PASSED [ 39%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_vectorization_efficiency PASSED [ 39%]
tests/test_at_perf_004.py::TestATPERF004HotPathOptimization::test_critical_operations_performance PASSED [ 39%]
tests/test_at_perf_005.py::TestATPERF005CompilationOptimization::test_torch_compile_speedup PASSED [ 39%]
tests/test_at_perf_005.py::TestATPERF005CompilationOptimization::test_hot_function_compilation PASSED [ 39%]
tests/test_at_perf_005.py::TestATPERF005CompilationOptimization::test_compilation_amortization PASSED [ 39%]
tests/test_at_perf_005.py::TestATPERF005CompilationOptimization::test_gpu_kernel_compilation SKIPPED [ 39%]
tests/test_at_perf_005.py::TestATPERF005CompilationOptimization::test_dtype_optimization_impact PASSED [ 40%]
tests/test_at_perf_006.py::TestATPERF006TensorVectorization::test_no_python_loops_in_core_path PASSED [ 40%]
tests/test_at_perf_006.py::TestATPERF006TensorVectorization::test_profile_tensor_operations_ratio PASSED [ 40%]
tests/test_at_perf_006.py::TestATPERF006TensorVectorization::test_vectorized_speedup PASSED [ 40%]
tests/test_at_perf_006.py::TestATPERF006TensorVectorization::test_tensor_shapes_include_all_dimensions SKIPPED [ 40%]
tests/test_at_perf_006.py::test_oversample_performance_scaling[1] PASSED [ 40%]
tests/test_at_perf_006.py::test_oversample_performance_scaling[2] PASSED [ 40%]
tests/test_at_perf_006.py::test_oversample_performance_scaling[3] PASSED [ 41%]
tests/test_at_perf_006.py::test_oversample_performance_scaling[4] PASSED [ 41%]
tests/test_at_perf_006.py::test_detector_thickness_vectorization PASSED  [ 41%]
tests/test_at_perf_007.py::TestATPerf007ComprehensiveBenchmark::test_benchmark_suite_execution SKIPPED [ 41%]
tests/test_at_perf_007.py::TestATPerf007ComprehensiveBenchmark::test_pytorch_performance_basic PASSED [ 41%]
tests/test_at_perf_007.py::TestATPerf007ComprehensiveBenchmark::test_memory_scaling PASSED [ 41%]
tests/test_at_perf_007.py::TestATPerf007ComprehensiveBenchmark::test_gpu_performance SKIPPED [ 41%]
tests/test_at_perf_007.py::TestATPerf007ComprehensiveBenchmark::test_benchmark_output_format PASSED [ 42%]
tests/test_at_perf_008.py::TestATPERF008CUDATensorResidency::test_large_tensor_gpu_residency SKIPPED [ 42%]
tests/test_at_perf_008.py::TestATPERF008CUDATensorResidency::test_auto_device_selection_uses_cuda SKIPPED [ 42%]
tests/test_at_perf_008.py::TestATPERF008CUDATensorResidency::test_skip_when_cuda_unavailable PASSED [ 42%]
tests/test_at_perf_008.py::TestATPERF008CUDATensorResidency::test_memory_efficient_gpu_usage SKIPPED [ 42%]
tests/test_at_pol_001.py::TestATPOL001KahnModel::test_polarization_factor_calculation PASSED [ 42%]
tests/test_at_pol_001.py::TestATPOL001KahnModel::test_nopolar_toggle PASSED [ 42%]
tests/test_at_pol_001.py::TestATPOL001KahnModel::test_oversample_polar_last_value_semantics PASSED [ 43%]
tests/test_at_pol_001.py::TestATPOL001KahnModel::test_polarization_with_tilted_detector PASSED [ 43%]
tests/test_at_pol_001.py::TestATPOL001KahnModel::test_polarization_factor_range PASSED [ 43%]
tests/test_at_pre_001.py::test_header_precedence_img_then_mask PASSED    [ 43%]
tests/test_at_pre_001.py::test_mask_beam_center_y_flip PASSED            [ 43%]
tests/test_at_pre_001.py::test_img_only_no_mask PASSED                   [ 43%]
tests/test_at_pre_002.py::test_xbeam_ybeam_forces_beam_pivot PASSED      [ 44%]
tests/test_at_pre_002.py::test_xclose_yclose_forces_sample_pivot PASSED  [ 44%]
tests/test_at_pre_002.py::test_orgx_orgy_forces_sample_pivot PASSED      [ 44%]
tests/test_at_pre_002.py::test_explicit_pivot_override PASSED            [ 44%]
tests/test_at_pre_002.py::test_distance_vs_close_distance_pivot_defaults PASSED [ 44%]
tests/test_at_pre_002.py::test_convention_default_pivots PASSED          [ 44%]
tests/test_at_roi_001.py::TestAT_ROI_001::test_roi_bounds_default_to_full_detector PASSED [ 44%]
tests/test_at_roi_001.py::TestAT_ROI_001::test_roi_bounds_validation PASSED [ 45%]
tests/test_at_roi_001.py::TestAT_ROI_001::test_roi_limits_rendering_area PASSED [ 45%]
tests/test_at_roi_001.py::TestAT_ROI_001::test_mask_array_filtering PASSED [ 45%]
tests/test_at_roi_001.py::TestAT_ROI_001::test_roi_and_mask_combination PASSED [ 45%]
tests/test_at_roi_001.py::TestAT_ROI_001::test_mask_array_dimension_validation PASSED [ 45%]
tests/test_at_roi_001.py::TestAT_ROI_001::test_statistics_exclude_masked_pixels PASSED [ 45%]
tests/test_at_sam_001.py::test_at_sam_001_steps_normalization PASSED     [ 45%]
tests/test_at_sam_002.py::TestAT_SAM_002_OversampleLastValue::test_oversample_omega_last_value_semantics PASSED [ 46%]
tests/test_at_sam_002.py::TestAT_SAM_002_OversampleLastValue::test_oversample_without_subpixel_flags PASSED [ 46%]
tests/test_at_sam_002.py::TestAT_SAM_002_OversampleLastValue::test_oversample_flag_precedence PASSED [ 46%]
tests/test_at_sam_003.py::test_dmin_culling_basic PASSED                 [ 46%]
tests/test_at_sam_003.py::test_dmin_culling_exact_threshold PASSED       [ 46%]
tests/test_at_sam_003.py::test_dmin_zero_no_culling PASSED               [ 46%]
tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_sourcefile_with_all_columns FAILED [ 46%]
tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_sourcefile_with_missing_columns FAILED [ 47%]
tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_sourcefile_default_position FAILED [ 47%]
tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_multiple_sources_normalization FAILED [ 47%]
tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_empty_sourcefile PASSED [ 47%]
tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_weighted_sources_integration FAILED [ 47%]
tests/test_at_src_001_cli.py::TestAT_SRC_001_CLI::test_sourcefile_loading_via_cli PASSED [ 47%]
tests/test_at_src_001_cli.py::TestAT_SRC_001_CLI::test_sourcefile_with_missing_columns PASSED [ 47%]
tests/test_at_src_001_cli.py::TestAT_SRC_001_CLI::test_sourcefile_takes_precedence_over_divergence PASSED [ 48%]
tests/test_at_src_001_simple.py::test_sourcefile_parsing FAILED          [ 48%]
tests/test_at_src_002.py::TestAT_SRC_002::test_no_parameters_provided PASSED [ 48%]
tests/test_at_src_002.py::TestAT_SRC_002::test_only_step_provided PASSED [ 48%]
tests/test_at_src_002.py::TestAT_SRC_002::test_only_range_provided PASSED [ 48%]
tests/test_at_src_002.py::TestAT_SRC_002::test_only_count_provided_angles PASSED [ 48%]
tests/test_at_src_002.py::TestAT_SRC_002::test_only_count_provided_thickness PASSED [ 48%]
tests/test_at_src_002.py::TestAT_SRC_002::test_range_and_step_provided PASSED [ 49%]
tests/test_at_src_002.py::TestAT_SRC_002::test_count_and_range_provided PASSED [ 49%]
tests/test_at_src_002.py::TestAT_SRC_002::test_divergence_auto_selection PASSED [ 49%]
tests/test_at_src_002.py::TestAT_SRC_002::test_dispersion_auto_selection PASSED [ 49%]
tests/test_at_src_002.py::TestAT_SRC_002::test_thickness_auto_selection PASSED [ 49%]
tests/test_at_src_002.py::TestAT_SRC_002::test_all_parameters_provided PASSED [ 49%]
tests/test_at_src_002.py::TestAT_SRC_002::test_conflicting_parameters PASSED [ 50%]
tests/test_at_src_003.py::TestSourcefileLambdaOverride::test_lambda_override_single_source PASSED [ 50%]
tests/test_at_src_003.py::TestSourcefileLambdaOverride::test_lambda_override_multiple_sources PASSED [ 50%]
tests/test_at_src_003.py::TestSourcefileWarningEmission::test_warning_emitted_on_mismatch PASSED [ 50%]
tests/test_at_src_003.py::TestSourcefileWarningEmission::test_no_warning_when_matching PASSED [ 50%]
tests/test_at_src_003.py::TestSourcefileWarningEmission::test_no_warning_when_column_missing PASSED [ 50%]
tests/test_at_src_003.py::TestStepsNormalizationParity::test_steps_count_includes_zero_weight_sources PASSED [ 50%]
tests/test_at_src_003.py::TestStepsNormalizationParity::test_equal_weighting_preserved PASSED [ 51%]
tests/test_at_sta_001.py::TestAT_STA_001::test_statistics_basic PASSED   [ 51%]
tests/test_at_sta_001.py::TestAT_STA_001::test_statistics_with_roi PASSED [ 51%]
tests/test_at_sta_001.py::TestAT_STA_001::test_statistics_with_mask PASSED [ 51%]
tests/test_at_sta_001.py::TestAT_STA_001::test_statistics_empty_roi PASSED [ 51%]
tests/test_at_sta_001.py::TestAT_STA_001::test_statistics_last_max_location PASSED [ 51%]
tests/test_at_str_001.py::test_at_str_001_nearest_neighbor_lookup PASSED [ 51%]
tests/test_at_str_002.py::test_tricubic_interpolation_enabled PASSED     [ 52%]
tests/test_at_str_002.py::test_tricubic_out_of_bounds_fallback PASSED    [ 52%]
tests/test_at_str_002.py::test_auto_enable_interpolation PASSED          [ 52%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_square_shape_model PASSED [ 52%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_round_shape_model PASSED [ 52%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_gauss_shape_model FAILED [ 52%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_tophat_shape_model PASSED [ 52%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_shape_model_comparison FAILED [ 53%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_fudge_parameter_scaling PASSED [ 53%]
tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_shape_models_at_bragg_peak PASSED [ 53%]
tests/test_at_str_004.py::TestAT_STR_004::test_sparse_hkl_loading PASSED [ 53%]
tests/test_at_str_004.py::TestAT_STR_004::test_missing_reflection_uses_default_f PASSED [ 53%]
tests/test_at_str_004.py::TestAT_STR_004::test_intensity_ratios_with_sparse_hkl PASSED [ 53%]
tests/test_at_str_004.py::TestAT_STR_004::test_fallback_with_no_hkl_uses_default_f PASSED [ 53%]
tests/test_at_str_004.py::TestAT_STR_004::test_fdump_preserves_sparse_behavior PASSED [ 54%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_find_c_binary_resolution PASSED [ 54%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_find_py_binary_resolution PASSED [ 54%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_load_float_image PASSED [ 54%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_resample_image PASSED [ 54%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_compute_metrics PASSED [ 54%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_find_peaks PASSED [ 54%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_script_integration FAILED [ 55%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_metrics_with_identical_images PASSED [ 55%]
tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_metrics_with_scaled_images PASSED [ 55%]
tests/test_cli_flags.py::TestPix0VectorAlias::test_pix0_meters_alias PASSED [ 55%]
tests/test_cli_flags.py::TestPix0VectorAlias::test_pix0_millimeter_alias PASSED [ 55%]
tests/test_cli_flags.py::TestPix0VectorAlias::test_pix0_meters_and_mm_equivalence PASSED [ 55%]
tests/test_cli_flags.py::TestPix0VectorAlias::test_dual_pix0_flag_rejection PASSED [ 55%]
tests/test_cli_flags.py::TestPix0VectorAlias::test_pix0_signed_combinations[pix0_m0-pix0_mm0] PASSED [ 56%]
tests/test_cli_flags.py::TestPix0VectorAlias::test_pix0_signed_combinations[pix0_m1-pix0_mm1] PASSED [ 56%]
tests/test_cli_flags.py::TestPix0VectorAlias::test_pix0_signed_combinations[pix0_m2-pix0_mm2] PASSED [ 56%]
tests/test_cli_flags.py::TestDetectorOverridePersistence::test_detector_override_persistence_cpu PASSED [ 56%]
tests/test_cli_flags.py::TestDetectorOverridePersistence::test_detector_override_persistence_cuda SKIPPED [ 56%]
tests/test_cli_flags.py::TestDetectorOverridePersistence::test_detector_override_dtype_preservation PASSED [ 56%]
tests/test_cli_flags.py::TestNoiseSuppressionFlag::test_nonoise_suppresses_noise_output PASSED [ 57%]
tests/test_cli_flags.py::TestNoiseSuppressionFlag::test_noisefile_without_nonoise PASSED [ 57%]
tests/test_cli_flags.py::TestNoiseSuppressionFlag::test_nonoise_preserves_seed PASSED [ 57%]
tests/test_cli_flags.py::TestNoiseSuppressionFlag::test_nonoise_without_noisefile PASSED [ 57%]
tests/test_cli_flags.py::TestCLIIntegrationSanity::test_pix0_does_not_alter_beam_vector PASSED [ 57%]
tests/test_cli_flags.py::TestCLIIntegrationSanity::test_pix0_triggers_custom_convention PASSED [ 57%]
tests/test_cli_flags.py::TestCLIIntegrationSanity::test_roi_unaffected_by_new_flags PASSED [ 57%]
tests/test_cli_flags.py::TestCLIIntegrationSanity::test_convention_preserved_without_pix0 PASSED [ 58%]
tests/test_cli_flags.py::TestCLIBeamVector::test_custom_beam_vector_propagates PASSED [ 58%]
tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_override_beam_pivot_transform[cpu-dtype0] PASSED [ 58%]
tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_override_beam_pivot_transform[cuda-dtype1] SKIPPED [ 58%]
tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot[cpu] FAILED [ 58%]
tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot[cuda] SKIPPED [ 58%]
tests/test_cli_flags.py::TestCLIPolarization::test_default_polarization_parity PASSED [ 58%]
tests/test_cli_flags.py::TestCLIPolarization::test_nopolar_flag PASSED   [ 59%]
tests/test_cli_flags.py::TestCLIPolarization::test_polar_override PASSED [ 59%]
tests/test_cli_flags.py::TestCLIPivotSelection::test_custom_vectors_force_sample_pivot[float32-cpu] PASSED [ 59%]
tests/test_cli_flags.py::TestCLIPivotSelection::test_custom_vectors_force_sample_pivot[float32-cuda] SKIPPED [ 59%]
tests/test_cli_flags.py::TestCLIPivotSelection::test_custom_vectors_force_sample_pivot[float64-cpu] PASSED [ 59%]
tests/test_cli_flags.py::TestCLIPivotSelection::test_custom_vectors_force_sample_pivot[float64-cuda] SKIPPED [ 59%]
tests/test_cli_flags.py::TestHKLFdumpParity::test_scaled_hkl_roundtrip FAILED [ 59%]
tests/test_cli_scaling.py::TestMOSFLMCellVectors::test_mosflm_cell_vectors SKIPPED [ 60%]
tests/test_cli_scaling.py::TestFlattSquareMatchesC::test_f_latt_square_matches_c SKIPPED [ 60%]
tests/test_cli_scaling.py::TestSourceWeights::test_source_weights_ignored_per_spec PASSED [ 60%]
tests/test_cli_scaling.py::TestSourceWeights::test_cli_lambda_overrides_sourcefile PASSED [ 60%]
tests/test_cli_scaling.py::TestSourceWeights::test_uniform_weights_ignored PASSED [ 60%]
tests/test_cli_scaling.py::TestSourceWeights::test_edge_case_zero_sum_accepted PASSED [ 60%]
tests/test_cli_scaling.py::TestSourceWeights::test_edge_case_negative_weights_accepted PASSED [ 60%]
tests/test_cli_scaling.py::TestSourceWeights::test_single_source_fallback PASSED [ 61%]
tests/test_cli_scaling.py::TestSourceWeightsDivergence::test_c_divergence_reference SKIPPED [ 61%]
tests/test_cli_scaling.py::TestSourceWeightsDivergence::test_sourcefile_divergence_warning SKIPPED [ 61%]
tests/test_cli_scaling.py::TestHKLDevice::test_hkl_tensor_respects_device[cpu-float32] SKIPPED [ 61%]
tests/test_cli_scaling.py::TestHKLDevice::test_hkl_tensor_respects_device[cpu-float64] SKIPPED [ 61%]
tests/test_cli_scaling.py::TestHKLDevice::test_hkl_tensor_respects_device[cuda-float32] SKIPPED [ 61%]
tests/test_cli_scaling.py::TestHKLDevice::test_hkl_tensor_respects_device[cuda-float64] SKIPPED [ 61%]
tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_rot_b_matches_c SKIPPED [ 62%]
tests/test_cli_scaling_phi0.py::TestPhiZeroParity::test_k_frac_phi0_matches_c SKIPPED [ 62%]
tests/test_configuration_consistency.py::TestConfigurationConsistency::test_explicit_defaults_equal_implicit XFAIL [ 62%]
tests/test_configuration_consistency.py::TestConfigurationConsistency::test_configuration_echo_present SKIPPED [ 62%]
tests/test_configuration_consistency.py::TestConfigurationConsistency::test_mode_detection_accuracy SKIPPED [ 62%]
tests/test_configuration_consistency.py::TestConfigurationConsistency::test_trigger_tracking SKIPPED [ 62%]
tests/test_configuration_consistency.py::TestConfigurationConsistency::test_all_vector_parameters_trigger_custom SKIPPED [ 63%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_cubic_regression PASSED [ 63%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_triclinic_correctness PASSED [ 63%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_metric_duality PASSED [ 63%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_volume_identity PASSED [ 63%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_resolution_shell_consistency PASSED [ 63%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_rotation_invariance PASSED [ 63%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_gradient_flow PASSED [ 64%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_angles_to_rotation_matrix_identity PASSED [ 64%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_angles_to_rotation_matrix_x_rotation PASSED [ 64%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_angles_to_rotation_matrix_y_rotation PASSED [ 64%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_angles_to_rotation_matrix_z_rotation PASSED [ 64%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_angles_to_rotation_matrix_order PASSED [ 64%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_angles_to_rotation_matrix_properties PASSED [ 64%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_angles_to_rotation_matrix_tensor_types PASSED [ 65%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_misset_orientation PASSED [ 65%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_misset_zero_rotation PASSED [ 65%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_misset_tensor_inputs PASSED [ 65%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_misset_rotation_order PASSED [ 65%]
tests/test_crystal_geometry.py::TestCrystalGeometry::test_misset_gradient_flow PASSED [ 65%]
tests/test_custom_vectors.py::TestCustomVectors::test_custom_vectors_in_detector_config PASSED [ 65%]
tests/test_custom_vectors.py::TestCustomVectors::test_custom_vectors_in_detector PASSED [ 66%]
tests/test_custom_vectors.py::TestCustomVectors::test_cli_custom_vectors PASSED [ 66%]
tests/test_custom_vectors.py::TestCustomVectors::test_custom_convention_detection PASSED [ 66%]
tests/test_custom_vectors.py::TestCustomVectors::test_custom_spindle_axis PASSED [ 66%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_printout_flag FAILED [ 66%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_printout_pixel_flag PASSED [ 66%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_trace_pixel_flag FAILED [ 66%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_combined_debug_flags FAILED [ 67%]
tests/test_debug_trace.py::TestDebugTraceFeatures::test_out_of_bounds_pixel FAILED [ 67%]
tests/test_detector_basis_vectors.py::TestDetectorBasisVectors::test_default_mosflm_convention PASSED [ 67%]
tests/test_detector_basis_vectors.py::TestDetectorBasisVectors::test_default_xds_convention PASSED [ 67%]
tests/test_detector_basis_vectors.py::TestDetectorBasisVectors::test_single_axis_rotations PASSED [ 67%]
tests/test_detector_basis_vectors.py::TestDetectorBasisVectors::test_combined_rotations PASSED [ 67%]
tests/test_detector_basis_vectors.py::TestDetectorBasisVectors::test_twotheta_rotation PASSED [ 67%]
tests/test_detector_basis_vectors.py::TestDetectorBasisVectors::test_all_rotations_combined PASSED [ 68%]
tests/test_detector_basis_vectors.py::TestDetectorBasisVectors::test_tensor_rotation_parameters PASSED [ 68%]
tests/test_detector_config.py::TestDetectorConfig::test_default_values PASSED [ 68%]
tests/test_detector_config.py::TestDetectorConfig::test_post_init_defaults PASSED [ 68%]
tests/test_detector_config.py::TestDetectorConfig::test_custom_twotheta_axis PASSED [ 68%]
tests/test_detector_config.py::TestDetectorConfig::test_xds_convention_defaults PASSED [ 68%]
tests/test_detector_config.py::TestDetectorConfig::test_invalid_pixel_counts PASSED [ 69%]
tests/test_detector_config.py::TestDetectorConfig::test_invalid_distance PASSED [ 69%]
tests/test_detector_config.py::TestDetectorConfig::test_invalid_pixel_size PASSED [ 69%]
tests/test_detector_config.py::TestDetectorConfig::test_invalid_oversample PASSED [ 69%]
tests/test_detector_config.py::TestDetectorConfig::test_tensor_parameters PASSED [ 69%]
tests/test_detector_config.py::TestDetectorInitialization::test_default_initialization FAILED [ 69%]
tests/test_detector_config.py::TestDetectorInitialization::test_custom_config_initialization FAILED [ 69%]
tests/test_detector_config.py::TestDetectorInitialization::test_backward_compatibility_check PASSED [ 70%]
tests/test_detector_config.py::TestDetectorInitialization::test_custom_config_not_default PASSED [ 70%]
tests/test_detector_config.py::TestDetectorInitialization::test_basis_vectors_initialization PASSED [ 70%]
tests/test_detector_config.py::TestDetectorInitialization::test_device_and_dtype PASSED [ 70%]
tests/test_detector_conventions.py::TestDetectorConventions::test_adxv_convention_basis_vectors PASSED [ 70%]
tests/test_detector_conventions.py::TestDetectorConventions::test_denzo_convention_basis_vectors PASSED [ 70%]
tests/test_detector_conventions.py::TestDetectorConventions::test_denzo_beam_center_mapping FAILED [ 70%]
tests/test_detector_conventions.py::TestDetectorConventions::test_adxv_beam_direction PASSED [ 71%]
tests/test_detector_conventions.py::TestDetectorConventions::test_adxv_twotheta_axis_default PASSED [ 71%]
tests/test_detector_conventions.py::TestDetectorConventions::test_denzo_twotheta_axis_default PASSED [ 71%]
tests/test_detector_conventions.py::TestDetectorConventions::test_adxv_default_beam_centers PASSED [ 71%]
tests/test_detector_conventions.py::TestDetectorConventions::test_all_conventions_orthonormal PASSED [ 71%]
tests/test_detector_conventions.py::TestDetectorConventions::test_conventions_with_rotations PASSED [ 71%]
tests/test_detector_geometry.py::TestDetectorGeometryRegressions::test_rotated_basis_vectors_match_c_reference PASSED [ 71%]
tests/test_detector_geometry.py::TestDetectorGeometryRegressions::test_pix0_vector_matches_c_reference_in_beam_pivot PASSED [ 72%]
tests/test_detector_geometry.py::TestDetectorGeometryRegressions::test_mosflm_axis_mapping_correctness PASSED [ 72%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_detector_parameter_gradients PASSED [ 72%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_basis_vector_gradients PASSED [ 72%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_pixel_coords_basis_vector_gradients PASSED [ 72%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_comprehensive_gradcheck PASSED [ 72%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_beam_strike_invariant_in_beam_pivot_mode PASSED [ 72%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_xds_convention_basic_geometry PASSED [ 73%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_detector_real_valued_gradients PASSED [ 73%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_detector_complex_gradient_edge_cases PASSED [ 73%]
tests/test_detector_geometry.py::TestDetectorDifferentiability::test_simulator_real_valued_gradients PASSED [ 73%]
tests/test_detector_pivots.py::test_beam_pivot_keeps_beam_indices_and_alignment FAILED [ 73%]
tests/test_detector_pivots.py::test_sample_pivot_moves_beam_indices_with_twotheta FAILED [ 73%]
tests/test_divergence_culling.py::TestDivergenceCullingModes::test_round_div_applies_elliptical_trimming PASSED [ 73%]
tests/test_divergence_culling.py::TestDivergenceCullingModes::test_square_div_uses_full_grid PASSED [ 74%]
tests/test_divergence_culling.py::TestDivergenceCullingModes::test_round_vs_square_source_count_difference PASSED [ 74%]
tests/test_divergence_culling.py::TestDivergenceCullingModes::test_single_divergence_point_unaffected PASSED [ 74%]
tests/test_divergence_culling.py::TestDivergenceCullingModes::test_elliptical_trimming_threshold PASSED [ 74%]
tests/test_divergence_culling.py::TestDivergenceCullingModes::test_combined_divergence_and_dispersion PASSED [ 74%]
tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_a PASSED [ 74%]
tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_b PASSED [ 75%]
tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_c PASSED [ 75%]
tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_alpha PASSED [ 75%]
tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_beta PASSED [ 75%]
tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_gamma PASSED [ 75%]
tests/test_gradients.py::TestAdvancedGradients::test_joint_gradcheck PASSED [ 75%]
tests/test_gradients.py::TestAdvancedGradients::test_gradgradcheck_cell_params PASSED [ 75%]
tests/test_gradients.py::TestAdvancedGradients::test_gradient_flow_simulation FAILED [ 76%]
tests/test_gradients.py::TestPropertyBasedGradients::test_property_metric_duality PASSED [ 76%]
tests/test_gradients.py::TestPropertyBasedGradients::test_property_volume_consistency PASSED [ 76%]
tests/test_gradients.py::TestPropertyBasedGradients::test_property_gradient_stability PASSED [ 76%]
tests/test_gradients.py::TestOptimizationRecovery::test_optimization_recovers_cell PASSED [ 76%]
tests/test_gradients.py::TestOptimizationRecovery::test_multiple_optimization_scenarios PASSED [ 76%]
tests/test_mosflm_matrix.py::TestMOSFLMMatrixLoading::test_read_identity_matrix PASSED [ 76%]
tests/test_mosflm_matrix.py::TestMOSFLMMatrixLoading::test_read_cubic_matrix PASSED [ 77%]
tests/test_mosflm_matrix.py::TestMOSFLMMatrixLoading::test_wavelength_scaling PASSED [ 77%]
tests/test_mosflm_matrix.py::TestMOSFLMMatrixLoading::test_triclinic_matrix PASSED [ 77%]
tests/test_mosflm_matrix.py::TestMOSFLMMatrixLoading::test_missing_file PASSED [ 77%]
tests/test_mosflm_matrix.py::TestMOSFLMMatrixLoading::test_invalid_format PASSED [ 77%]
tests/test_mosflm_matrix.py::TestMOSFLMMatrixLoading::test_comments_and_whitespace PASSED [ 77%]
tests/test_multi_source_integration.py::test_multi_source_intensity_normalization PASSED [ 77%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_auto_select_formula PASSED [ 78%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_different_crystal_sizes PASSED [ 78%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_explicit_oversample_overrides_auto PASSED [ 78%]
tests/test_oversample_autoselect.py::TestOversampleAutoSelect::test_different_wavelengths PASSED [ 78%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_linter_finds_repo_root PASSED [ 78%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_linter_loads_yaml PASSED [ 78%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_yaml_structure_validation PASSED [ 78%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_missing_yaml_file PASSED [ 79%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_invalid_yaml PASSED [ 79%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_real_repo_linting PASSED [ 79%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_extraction_of_spec_ats PASSED [ 79%]
tests/test_parity_coverage_lint.py::TestParityCoverageLinter::test_extraction_of_yaml_ats PASSED [ 79%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-001-detpixels-64] SKIPPED [ 79%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-001-detpixels-128] SKIPPED [ 79%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-001-detpixels-256] SKIPPED [ 80%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-001-detpixels-512] SKIPPED [ 80%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-002-pixel-0.05mm] SKIPPED [ 80%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-002-pixel-0.1mm] SKIPPED [ 80%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-002-pixel-0.2mm] SKIPPED [ 80%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-002-pixel-0.4mm] SKIPPED [ 80%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-003-beam-20-20-detpixels-256] SKIPPED [ 80%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-003-beam-30-40-detpixels-256] SKIPPED [ 81%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-003-beam-45-25-detpixels-512] SKIPPED [ 81%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-003-beam-60-60-detpixels-1024] SKIPPED [ 81%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-004-mosflm] SKIPPED [ 81%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-004-xds] SKIPPED [ 81%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-005-mosflm-xbeam-ybeam-beam-pivot] SKIPPED [ 81%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-005-xds-xbeam-ybeam-sample-pivot] SKIPPED [ 82%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-005-mosflm-close-distance-sample-pivot] SKIPPED [ 82%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-005-xds-close-distance-sample-pivot] SKIPPED [ 82%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-006-dist-50mm-lambda-1.0] SKIPPED [ 82%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-006-dist-100mm-lambda-1.5] SKIPPED [ 82%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-006-dist-200mm-lambda-2.0] SKIPPED [ 82%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-007-rot-0-0-0] SKIPPED [ 82%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-007-rot-5-3-2] SKIPPED [ 83%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-007-rot-10-5-3] SKIPPED [ 83%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-012-simple_cubic] SKIPPED [ 83%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-011-unpolarized] SKIPPED [ 83%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-011-polarized] SKIPPED [ 83%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-020-comprehensive] SKIPPED [ 83%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-021-single_step_phi] SKIPPED [ 83%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-021-multi_step_phi] SKIPPED [ 84%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-022-single_step_phi] SKIPPED [ 84%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-022-multi_step_phi] SKIPPED [ 84%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-cubic-misset-0-0-0] SKIPPED [ 84%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-cubic-misset-10p5-0-0] SKIPPED [ 84%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-cubic-misset-0-10p25-0] SKIPPED [ 84%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-cubic-misset-0-0-9p75] SKIPPED [ 84%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-cubic-misset-15-20p5-30p25] SKIPPED [ 85%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-triclinic-misset-0-0-0] SKIPPED [ 85%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-triclinic-misset-10p5-0-0] SKIPPED [ 85%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-triclinic-misset-0-10p25-0] SKIPPED [ 85%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-triclinic-misset-0-0-9p75] SKIPPED [ 85%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-023-triclinic-misset-15-20p5-30p25] SKIPPED [ 85%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-024-random-misset-seed-12345] SKIPPED [ 85%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-024-random-misset-seed-54321] SKIPPED [ 86%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-point-pixel-distance-50mm] SKIPPED [ 86%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-point-pixel-distance-100mm] SKIPPED [ 86%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-point-pixel-distance-200mm] SKIPPED [ 86%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-point-pixel-distance-400mm] SKIPPED [ 86%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-0deg] SKIPPED [ 86%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-10deg] SKIPPED [ 86%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-20deg] SKIPPED [ 87%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-010-obliquity-distance-100mm-tilt-30deg] SKIPPED [ 87%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-016-extreme-tiny] SKIPPED [ 87%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-016-extreme-large-cell] SKIPPED [ 87%]
tests/test_parity_matrix.py::test_parity_case[AT-PARALLEL-016-extreme-long-distance] SKIPPED [ 87%]
tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_basic_execution[cpu] FAILED [ 87%]
tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_basic_execution[cuda] SKIPPED [ 88%]
tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_cuda_multiple_runs SKIPPED [ 88%]
tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_gradient_flow_preserved FAILED [ 88%]
tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_cpu_cuda_correlation[cpu] FAILED [ 88%]
tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_cpu_cuda_correlation[cuda] SKIPPED [ 88%]
tests/test_perf_pytorch_006.py::test_dtype_support[dtype0] PASSED        [ 88%]
tests/test_perf_pytorch_006.py::test_dtype_support[dtype1] PASSED        [ 88%]
tests/test_perf_pytorch_006.py::test_float32_float64_correlation PASSED  [ 89%]
tests/test_physics.py::TestPhysicsFunctions::test_sincg_against_c_value PASSED [ 89%]
tests/test_physics.py::TestPhysicsFunctions::test_sincg_fractional_miller_index PASSED [ 89%]
tests/test_physics.py::TestPhysicsFunctions::test_sincg_at_zero PASSED   [ 89%]
tests/test_physics.py::TestPhysicsFunctions::test_sincg_vectorized PASSED [ 89%]
tests/test_physics.py::TestPhysicsFunctions::test_sincg_broadcast_N PASSED [ 89%]
tests/test_pivot_mode_selection.py::TestPivotModeSelection::test_twotheta_zero_uses_config_pivot PASSED [ 89%]
tests/test_pivot_mode_selection.py::TestPivotModeSelection::test_twotheta_nonzero_forces_sample_pivot PASSED [ 90%]
tests/test_pivot_mode_selection.py::TestPivotModeSelection::test_small_twotheta_values PASSED [ 90%]
tests/test_pivot_mode_selection.py::TestPivotModeSelection::test_negative_twotheta_forces_sample_pivot PASSED [ 90%]
tests/test_pivot_mode_selection.py::TestPivotModeSelection::test_pivot_fix_integration PASSED [ 90%]
tests/test_show_config.py::TestShowConfig::test_show_config_basic PASSED [ 90%]
tests/test_show_config.py::TestShowConfig::test_show_config_with_divergence PASSED [ 90%]
tests/test_show_config.py::TestShowConfig::test_show_config_with_rotations PASSED [ 90%]
tests/test_show_config.py::TestShowConfig::test_echo_config_alias PASSED [ 91%]
tests/test_suite.py::TestGeometryFunctions::test_dot_product PASSED      [ 91%]
tests/test_suite.py::TestGeometryFunctions::test_cross_product PASSED    [ 91%]
tests/test_suite.py::TestGeometryFunctions::test_magnitude PASSED        [ 91%]
tests/test_suite.py::TestGeometryFunctions::test_unitize PASSED          [ 91%]
tests/test_suite.py::TestGeometryFunctions::test_rotate_axis PASSED      [ 91%]
tests/test_suite.py::TestGeometryFunctions::test_rotate_umat PASSED      [ 91%]
tests/test_suite.py::TestCrystalModel::test_zero_rotation PASSED         [ 92%]
tests/test_suite.py::TestCrystalModel::test_phi_rotation_90_deg PASSED   [ 92%]
tests/test_suite.py::TestCrystalModel::test_rotation_gradients PASSED    [ 92%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_golden_data_exists PASSED [ 92%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_simple_cubic_reproduction XFAIL [ 92%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_cubic_tilted_detector_reproduction PASSED [ 92%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_triclinic_P1_reproduction PASSED [ 92%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_peak_position_validation PASSED [ 93%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_sensitivity_to_cell_params FAILED [ 93%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_performance_simple_cubic FAILED [ 93%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_performance_triclinic FAILED [ 93%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_memory_usage_analysis PASSED [ 93%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_extreme_cell_parameters FAILED [ 93%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_rotation_compatibility FAILED [ 94%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_simple_cubic_mosaic_reproduction PASSED [ 94%]
tests/test_suite.py::TestTier1TranslationCorrectness::test_simulator_phi_rotation PASSED [ 94%]
tests/test_suite.py::TestTier2GradientCorrectness::test_gradcheck_crystal_params PASSED [ 94%]
tests/test_suite.py::TestTier2GradientCorrectness::test_gradcheck_detector_params PASSED [ 94%]
tests/test_suite.py::TestTier2GradientCorrectness::test_gradcheck_phi_rotation SKIPPED [ 94%]
tests/test_suite.py::TestTier2GradientCorrectness::test_gradcheck_mosaic_spread SKIPPED [ 94%]
tests/test_suite.py::TestTier2GradientCorrectness::test_gradient_numerical_stability SKIPPED [ 95%]
tests/test_suite.py::TestTier3ScientificValidation::test_bragg_spot_position SKIPPED [ 95%]
tests/test_suite.py::TestTier3ScientificValidation::test_polarization_limits SKIPPED [ 95%]
tests/test_suite.py::test_import PASSED                                  [ 95%]
tests/test_trace_pixel.py::TestScalingTrace::test_scaling_trace_matches_physics[dtype0-cpu] PASSED [ 95%]
tests/test_trace_pixel.py::TestScalingTrace::test_scaling_trace_matches_physics[dtype0-cuda] SKIPPED [ 95%]
tests/test_trace_pixel.py::TestScalingTrace::test_scaling_trace_matches_physics[dtype1-cpu] PASSED [ 95%]
tests/test_trace_pixel.py::TestScalingTrace::test_scaling_trace_matches_physics[dtype1-cuda] SKIPPED [ 96%]
tests/test_trace_pixel.py::TestScalingTrace::test_scaling_trace_with_absorption[cpu] PASSED [ 96%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_vectorized_matches_scalar FAILED [ 96%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_neighborhood_gathering_internals PASSED [ 96%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_oob_warning_single_fire FAILED [ 96%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_device_neutrality[cpu] PASSED [ 96%]
tests/test_tricubic_vectorized.py::TestTricubicGather::test_device_neutrality[cuda] SKIPPED [ 96%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polint_matches_scalar_batched PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polint_gradient_flow PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin2_matches_scalar_batched PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin2_gradient_flow PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin3_matches_scalar_batched PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin3_gradient_flow PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polin3_batch_shape_preserved PASSED [ 97%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_support_float64[dtype0] PASSED [ 98%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_support_float64[dtype1] PASSED [ 98%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_device_neutral[cpu] PASSED [ 98%]
tests/test_tricubic_vectorized.py::TestTricubicPoly::test_polynomials_device_neutral[cuda] SKIPPED [ 98%]
tests/test_units.py::TestUnitConversions::test_mm_to_angstroms_scalar PASSED [ 98%]
tests/test_units.py::TestUnitConversions::test_mm_to_angstroms_tensor PASSED [ 98%]
tests/test_units.py::TestUnitConversions::test_mm_to_angstroms_gradient PASSED [ 98%]
tests/test_units.py::TestUnitConversions::test_meters_to_angstroms_scalar PASSED [ 99%]
tests/test_units.py::TestUnitConversions::test_meters_to_angstroms_tensor PASSED [ 99%]
tests/test_units.py::TestUnitConversions::test_degrees_to_radians_scalar PASSED [ 99%]
tests/test_units.py::TestUnitConversions::test_degrees_to_radians_tensor PASSED [ 99%]
tests/test_units.py::TestUnitConversions::test_degrees_to_radians_gradient PASSED [ 99%]
tests/test_units.py::TestUnitConversions::test_inverse_conversions PASSED [ 99%]
tests/test_units.py::TestUnitConversions::test_batch_tensor_conversions PASSED [100%]

=================================== FAILURES ===================================
_ TestATParallel013CrossPlatformConsistency.test_pytorch_determinism_same_seed _

self = <tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency object at 0x7ab044e3de50>

    def test_pytorch_determinism_same_seed(self):
        """Test that PyTorch produces identical results with same seed."""
        # Run simulation twice with same seed
        result1 = run_simulation_deterministic(seed=42)
        result2 = run_simulation_deterministic(seed=42)
    
        # Should be exactly identical (bit-for-bit)
        assert np.array_equal(result1, result2), (
            "PyTorch not deterministic - results differ with same seed"
        )
    
        # Also check with allclose for numerical precision
        np.testing.assert_allclose(
            result1, result2,
            rtol=1e-7,
            atol=1e-12,
            err_msg="PyTorch determinism: tolerance check failed"
        )
    
        # Correlation should be perfect (1.0)
        corr, _ = pearsonr(result1.flatten(), result2.flatten())
>       assert corr >= 0.9999999, f"Correlation {corr} < 0.9999999 for same-seed runs"
E       AssertionError: Correlation 0.9999873042106628 < 0.9999999 for same-seed runs
E       assert np.float32(0.9999873) >= 0.9999999

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_013.py:164: AssertionError
----------------------------- Captured stdout call -----------------------------
auto-selected 2-fold oversampling
auto-selected 2-fold oversampling
_ TestATParallel013CrossPlatformConsistency.test_pytorch_determinism_different_seeds _

self = <tests.test_at_parallel_013.TestATParallel013CrossPlatformConsistency object at 0x7ab044e3df90>

    def test_pytorch_determinism_different_seeds(self):
        """Test that PyTorch produces different results with different seeds."""
        # Note: This test configuration uses fixed misset angles and no mosaic/noise,
        # so different seeds won't affect the result. We expect identical results.
    
        # Run simulation with different seeds
        result1 = run_simulation_deterministic(seed=42)
        result2 = run_simulation_deterministic(seed=123)
    
        # With no random components (fixed misset, no mosaic, no noise),
        # results should be identical regardless of seed
        np.testing.assert_allclose(
            result1, result2,
            rtol=1e-7,
            atol=1e-12,
            err_msg="Results differ despite no random components"
        )
    
        # Correlation should be perfect
        corr, _ = pearsonr(result1.flatten(), result2.flatten())
>       assert corr >= 0.9999999, f"Correlation {corr} < 0.9999999 for identical physics"
E       AssertionError: Correlation 0.9999873042106628 < 0.9999999 for identical physics
E       assert np.float32(0.9999873) >= 0.9999999

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_013.py:191: AssertionError
----------------------------- Captured stdout call -----------------------------
auto-selected 2-fold oversampling
auto-selected 2-fold oversampling
__________ TestATParallel015MixedUnits.test_mixed_units_comprehensive __________

self = <tests.test_at_parallel_015.TestATParallel015MixedUnits object at 0x7ab044de3950>

    def test_mixed_units_comprehensive(self):
        """Test comprehensive mixed unit scenario."""
        # Configuration with explicit units
        crystal_config = CrystalConfig(
            cell_a=75.5,      # Angstroms
            cell_b=82.3,      # Angstroms
            cell_c=91.7,      # Angstroms
            cell_alpha=87.5,  # degrees
            cell_beta=92.3,   # degrees
            cell_gamma=95.8,  # degrees
            default_F=100.0,
            N_cells=(3, 3, 3),
            phi_start_deg=0.0,    # degrees
            osc_range_deg=1.0,    # degrees
            phi_steps=1,
        )
    
        detector_config = DetectorConfig(
            distance_mm=150.5,      # millimeters
            pixel_size_mm=0.172,    # millimeters
            spixels=128,
            fpixels=128,
            detector_convention=DetectorConvention.XDS,
            detector_rotx_deg=5.0,  # degrees
            detector_roty_deg=3.0,  # degrees
            detector_rotz_deg=2.0,  # degrees
            detector_twotheta_deg=10.0,  # degrees
        )
    
        beam_config = BeamConfig(
            wavelength_A=1.54,  # Angstroms (Cu K-alpha)
            fluence=1e23,
            polarization_factor=0.95,  # dimensionless
            dmin=2.0,          # Angstroms
        )
    
        # Create models
        det = Detector(detector_config)
        crystal = Crystal(crystal_config)
    
        # Verify unit conversions happened correctly
        # Detector distance should be in meters internally
        assert np.isclose(det.distance, 0.1505, rtol=1e-6), \
            f"Distance conversion error: {det.distance} != 0.1505"
    
        # Pixel size should be in meters internally
        assert np.isclose(det.pixel_size, 0.000172, rtol=1e-6), \
            f"Pixel size conversion error: {det.pixel_size} != 0.000172"
    
        # Rotations are converted internally but not exposed as attributes
        # We can verify they work correctly by running the simulation
    
        # Wavelength should be in meters internally (used in simulator)
        # Note: BeamConfig stores in Angstroms, conversion happens in simulator
        assert beam_config.wavelength_A == 1.54, "Wavelength storage error"
    
        # Run simulation
        sim = Simulator(detector=det, crystal=crystal, beam_config=beam_config)
        intensity = sim.run(oversample=1)
    
        # Comprehensive checks
        assert intensity.shape == (128, 128), f"Wrong output shape: {intensity.shape}"
>       assert intensity.max() > 0, "Zero maximum intensity"
E       AssertionError: Zero maximum intensity
E       assert tensor(0., dtype=torch.float32) > 0
E        +  where tensor(0., dtype=torch.float32) = <built-in method max of Tensor object at 0x7ab034cd4d20>()
E        +    where <built-in method max of Tensor object at 0x7ab034cd4d20> = tensor([[0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        ...,\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.],\n        [0., 0., 0.,  ..., 0., 0., 0.]], dtype=torch.float32).max

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_015.py:274: AssertionError
__________ TestAT_PARALLEL_024.test_mosaic_rotation_umat_determinism ___________

self = <tests.test_at_parallel_024.TestAT_PARALLEL_024 object at 0x7ab044ebe450>

    def test_mosaic_rotation_umat_determinism(self):
        """Test that mosaic_rotation_umat is deterministic with same seed."""
        seed = 12345
        mosaicity = np.pi / 2.0  # 90 degrees
    
        # Generate two matrices with same seed
        umat1 = mosaic_rotation_umat(mosaicity, seed)
        umat2 = mosaic_rotation_umat(mosaicity, seed)
    
        # They should be identical
        assert torch.allclose(umat1, umat2, rtol=1e-12, atol=1e-15), \
            "Same seed did not produce identical rotation matrices"
    
        # Check that it's unitary (rotation matrix property)
        identity = torch.matmul(umat1, umat1.T)
        expected_identity = torch.eye(3, dtype=torch.float64)
>       assert torch.allclose(identity, expected_identity, rtol=1e-10, atol=1e-12), \
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            "Generated matrix is not unitary"

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_024.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x7ab03667e150>
func = <built-in method allclose of type object at 0x7ab1c6980fc0>, types = ()
args = (tensor([[ 1.0000e+00,  1.4901e-08,  0.0000e+00],
        [ 1.4901e-08,  1.0000e+00, -2.2352e-08],
        [ 0.0000e+00, -2.2352e-08,  1.0000e+00]], dtype=torch.float32), tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]]))
kwargs = {'atol': 1e-12, 'rtol': 1e-10}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^
E       RuntimeError: Float did not match Double

/home/ollie/miniconda3/lib/python3.13/site-packages/torch/utils/_device.py:104: RuntimeError
_ TestAT_PARALLEL_026_TriclinicAbsolutePosition.test_triclinic_absolute_peak_position_vs_c _

self = <tests.test_at_parallel_026.TestAT_PARALLEL_026_TriclinicAbsolutePosition object at 0x7ab044cf8410>

    @pytest.mark.requires_c_binary
    def test_triclinic_absolute_peak_position_vs_c(self):
        """Test that PyTorch and C produce peaks at the same absolute position"""
    
        from scripts.c_reference_runner import CReferenceRunner
    
        # Setup configuration
        crystal_config, detector_config, beam_config = self.setup_triclinic_config()
    
        # Create models
        crystal = Crystal(crystal_config)
        detector = Detector(detector_config)
    
        # Create PyTorch simulator
        simulator = Simulator(crystal, detector, crystal_config, beam_config)
    
        # Run PyTorch simulation
        pytorch_image = simulator.run()
        pytorch_slow, pytorch_fast, pytorch_intensity = self.find_peak_position(pytorch_image)
    
        # Setup C runner
        runner = CReferenceRunner()
    
        # Run C simulation with same configs
        c_image = runner.run_simulation(
            detector_config,
            crystal_config,
            beam_config,
            label="Triclinic absolute position test"
        )
    
>       assert c_image is not None, "C reference run failed"
E       AssertionError: C reference run failed
E       assert None is not None

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_026.py:147: AssertionError
----------------------------- Captured stdout call -----------------------------
 nanoBragg executable not available: golden_suite_generator/nanoBragg
____ TestAT_SRC_001_SourcefileAndWeighting.test_sourcefile_with_all_columns ____

self = <tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044b73610>

        def test_sourcefile_with_all_columns(self):
            """Test reading sourcefile with all 5 columns specified."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Write test source file with two sources
                # X, Y, Z, weight, wavelength (in meters)
                content = """# Test source file
    -10.0  0.0  0.0  2.0  1.0e-10
    0.0  -10.0  0.0  3.0  1.5e-10
    """
                sourcefile.write_text(content)
    
                # Read source file
                default_wavelength_m = 6.2e-10  # 6.2 Angstroms
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=default_wavelength_m,
                    default_source_distance_m=10.0
                )
    
                # Check we got 2 sources
                assert directions.shape == (2, 3)
                assert weights.shape == (2,)
                assert wavelengths.shape == (2,)
    
                # Check directions are normalized (unit vectors)
                norms = torch.linalg.norm(directions, dim=1)
>               torch.testing.assert_close(norms, torch.ones(2, dtype=torch.float64))
E               AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:64: AssertionError
__ TestAT_SRC_001_SourcefileAndWeighting.test_sourcefile_with_missing_columns __

self = <tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044b73750>

        def test_sourcefile_with_missing_columns(self):
            """Test reading sourcefile with missing columns (using defaults)."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Write test source file with varying number of columns
                content = """# Test source file with missing columns
    # Full specification
    -10.0  0.0  0.0  2.0  1.0e-10
    # Only position
    0.0  -10.0  0.0
    # No columns (should use defaults)
    
    # Comment line
    # Only position and weight
    5.0  5.0  0.0  1.5
    """
                sourcefile.write_text(content)
    
                # Read source file
                default_wavelength_m = 6.2e-10  # 6.2 Angstroms
                default_source_distance_m = 10.0
                beam_direction = torch.tensor([0.0, 0.0, 1.0], dtype=torch.float64)
    
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=default_wavelength_m,
                    default_source_distance_m=default_source_distance_m,
                    beam_direction=beam_direction
                )
    
                # Check we got 3 sources (empty line is skipped)
                assert directions.shape == (3, 3)
                assert weights.shape == (3,)
                assert wavelengths.shape == (3,)
    
                # Check wavelengths
>               assert wavelengths[0].item() == pytest.approx(1.0e-10)  # Specified
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               assert 6.199999957878788e-10 == 1e-10  1.0e-12
E                 
E                 comparison failed
E                 Obtained: 6.199999957878788e-10
E                 Expected: 1e-10  1.0e-12

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:112: AssertionError
____ TestAT_SRC_001_SourcefileAndWeighting.test_sourcefile_default_position ____

self = <tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044c190f0>

        def test_sourcefile_default_position(self):
            """Test that missing X,Y,Z defaults to -source_distanceb position."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Write source file with partial position (X, Y only, no Z)
                # Per spec, columns are: X, Y, Z, weight, wavelength
                # If we provide X=-15, Y=0 (no Z), position should be [-15, 0, 0] -> normalized [-1, 0, 0]
                content = """# Source with only X, Y position
    -15.0  0.0
    """
                sourcefile.write_text(content)
    
                # Read with specific beam direction (not actually used when X,Y provided)
                default_wavelength_m = 6.2e-10
                default_source_distance_m = 15.0  # 15 meters
                beam_direction = torch.tensor([1.0, 0.0, 0.0], dtype=torch.float64)  # Along +X
    
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=default_wavelength_m,
                    default_source_distance_m=default_source_distance_m,
                    beam_direction=beam_direction
                )
    
                # Position [-15, 0, 0] normalized to unit vector: [-1, 0, 0]
                expected_direction = torch.tensor([[-1.0, 0.0, 0.0]], dtype=torch.float64)
>               torch.testing.assert_close(directions, expected_direction)
E               AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:148: AssertionError
__ TestAT_SRC_001_SourcefileAndWeighting.test_multiple_sources_normalization ___

self = <tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044c19220>

        def test_multiple_sources_normalization(self):
            """Test that intensity is properly normalized by number of sources."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "test_sources.txt"
    
                # Create two sources with same wavelength but different positions
                content = """# Two sources for normalization test
    -10.0  0.0  0.0  1.0  6.2e-10
    10.0  0.0  0.0  1.0  6.2e-10
    """
                sourcefile.write_text(content)
    
                # Read sources
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=6.2e-10
                )
    
                # Verify we have 2 sources
                assert len(directions) == 2
                assert len(weights) == 2
                assert len(wavelengths) == 2
    
                # Verify directions are opposite (sources on opposite sides)
                torch.testing.assert_close(directions[0], -directions[1])
    
                # Both sources have weight 1.0 specified in the file
>               torch.testing.assert_close(weights, torch.ones(2, dtype=torch.float64))
E               AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:180: AssertionError
___ TestAT_SRC_001_SourcefileAndWeighting.test_weighted_sources_integration ____

self = <tests.test_at_src_001.TestAT_SRC_001_SourcefileAndWeighting object at 0x7ab044dc2cf0>

        def test_weighted_sources_integration(self):
            """Test that sources with weights can be loaded and simulated (AT-SRC-001)."""
            with tempfile.TemporaryDirectory() as tmpdir:
                sourcefile = Path(tmpdir) / "weighted_sources.txt"
    
                # Create two sources with different weights as specified in AT-SRC-001
                # "Setup: -sourcefile with two sources having distinct weights and "
                content = """# Two sources with different weights and wavelengths
    # X Y Z weight wavelength
    0.0  0.0  -10.0  2.0  6.2e-10
    0.0  0.0  -10.0  3.0  8.0e-10
    """
                sourcefile.write_text(content)
    
                # Read sources
                directions, weights, wavelengths = read_sourcefile(
                    sourcefile,
                    default_wavelength_m=6.2e-10
                )
    
                # Verify weights are preserved per AT-SRC-001
                # "intensity contributions SHALL sum with per-source  and weight"
                assert weights[0].item() == pytest.approx(2.0)
                assert weights[1].item() == pytest.approx(3.0)
    
                # Verify wavelengths are preserved
                assert wavelengths[0].item() == pytest.approx(6.2e-10)
>               assert wavelengths[1].item() == pytest.approx(8.0e-10)
E               assert 6.199999957878788e-10 == 8e-10  1.0e-12
E                 
E                 comparison failed
E                 Obtained: 6.199999957878788e-10
E                 Expected: 8e-10  1.0e-12

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:224: AssertionError
___________________________ test_sourcefile_parsing ____________________________

    def test_sourcefile_parsing():
        """Basic test of source file parsing."""
        with tempfile.TemporaryDirectory() as tmpdir:
            sourcefile = Path(tmpdir) / "test_sources.txt"
    
            # Write test source file with two sources
            content = """# Test source file
    -10.0  0.0  0.0  2.0  1.0e-10
    0.0  -10.0  0.0  3.0  1.5e-10
    """
            sourcefile.write_text(content)
    
            # Read source file
            default_wavelength_m = 6.2e-10
            directions, weights, wavelengths = read_sourcefile(
                sourcefile,
                default_wavelength_m=default_wavelength_m
            )
    
            # Check results
            assert directions.shape == (2, 3)
            assert weights.shape == (2,)
            assert wavelengths.shape == (2,)
    
            # Check directions are normalized
            norms = torch.linalg.norm(directions, dim=1)
>           torch.testing.assert_close(norms, torch.ones(2, dtype=torch.float64))
E           AssertionError: The values for attribute 'dtype' do not match: torch.float32 != torch.float64.

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001_simple.py:41: AssertionError
___________ TestAT_STR_003_LatticeShapeModels.test_gauss_shape_model ___________

self = <tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels object at 0x7ab044c19f30>

    def test_gauss_shape_model(self):
        """Test GAUSS (Gaussian in reciprocal space) lattice shape model."""
        # Configure for GAUSS shape
        self.crystal_config.shape = CrystalShape.GAUSS
        self.crystal_config.fudge = 1.0
    
        # Create simulator to test the full implementation
>       simulator = Simulator(
            crystal=Crystal(self.crystal_config),
            detector=None,  # Not needed for this test
            crystal_config=self.crystal_config,
            beam_config=self.beam_config,
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_str_003.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.simulator.Simulator object at 0x7ab03b66f0b0>
crystal = <nanobrag_torch.models.crystal.Crystal object at 0x7ab040a76e40>
detector = None
crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=(...'gauss'>, fudge=1.0, sample_x=1.0000000000000001e-07, sample_y=1.0000000000000001e-07, sample_z=1.0000000000000001e-07)
beam_config = BeamConfig(wavelength_A=1.0, N_source_points=1, source_distance_mm=10000.0, source_size_mm=0.0, source_directions=None...=(0.0, 0.0, 1.0), flux=0.0, exposure=0.0, beamsize_mm=0.0, fluence=1.2593201528622709e+29, dmin=0.0, water_size_um=0.0)
device = None, dtype = torch.float32, debug_config = None

    def __init__(
        self,
        crystal: Crystal,
        detector: Detector,
        crystal_config: Optional[CrystalConfig] = None,
        beam_config: Optional[BeamConfig] = None,
        device=None,
        dtype=torch.float32,
        debug_config: Optional[dict] = None,
    ):
        """
        Initialize simulator with crystal, detector, and configurations.
    
        Args:
            crystal: Crystal object containing unit cell and structure factors
            detector: Detector object with geometry parameters
            crystal_config: Configuration for crystal rotation parameters (phi, mosaic)
            beam_config: Beam configuration (optional, for future use)
            device: PyTorch device (cpu/cuda)
            dtype: PyTorch data type
            debug_config: Debug configuration with printout, printout_pixel, trace_pixel options
        """
        self.crystal = crystal
        self.detector = detector
        # If crystal_config is provided, update only the rotation-related parameters
        # This preserves essential parameters like cell dimensions and default_F
        if crystal_config is not None:
            # Update only the rotation-related fields that are explicitly set
            # This preserves the crystal's essential parameters while allowing rotation updates
            if hasattr(crystal_config, 'phi_start_deg'):
                self.crystal.config.phi_start_deg = crystal_config.phi_start_deg
            if hasattr(crystal_config, 'osc_range_deg'):
                self.crystal.config.osc_range_deg = crystal_config.osc_range_deg
            if hasattr(crystal_config, 'phi_steps'):
                self.crystal.config.phi_steps = crystal_config.phi_steps
            if hasattr(crystal_config, 'mosaic_spread_deg'):
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
        else:
            self.device = torch.device("cpu")
        self.dtype = dtype
    
        # PERF-PYTORCH-004 Attempt #14: Ensure detector is on the same device/dtype as simulator
        # This prevents device mismatch errors when detector tensors (beam_vector, pixel_coords)
        # interact with simulator tensors (wavelength, incident_beam_direction) during compilation
        if self.detector is not None:
            self.detector = self.detector.to(device=self.device, dtype=self.dtype)
    
        # Store debug configuration
        self.debug_config = debug_config if debug_config is not None else {}
        self.printout = self.debug_config.get('printout', False)
        self.printout_pixel = self.debug_config.get('printout_pixel', None)  # [fast, slow]
        self.trace_pixel = self.debug_config.get('trace_pixel', None)  # [slow, fast]
    
        # Phase CLI-FLAGS-003 M0a: Enable trace instrumentation on Crystal when trace_pixel is active
        # This guards _last_tricubic_neighborhood population to prevent unconditional debug payload retention
        if self.trace_pixel is not None:
            self.crystal._enable_trace = True
    
        # Set incident beam direction from detector.beam_vector
        # This is critical for convention consistency (AT-PARALLEL-004) and CLI override support (CLI-FLAGS-003 Phase H2)
        # The detector.beam_vector property handles both convention defaults and CUSTOM overrides (e.g., -beam_vector)
        if self.detector is not None:
            # Use detector's beam_vector property which handles:
            # - CUSTOM convention with user-supplied custom_beam_vector
            # - Convention defaults (MOSFLM: [1,0,0], XDS/DIALS: [0,0,1])
            # The detector normalizes and returns the vector with correct device/dtype
            self.incident_beam_direction = self.detector.beam_vector.clone()
        else:
            # If no detector provided, default to MOSFLM beam direction
            self.incident_beam_direction = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        # PERF-PYTORCH-006: Store wavelength as tensor with correct dtype
        self.wavelength = torch.tensor(self.beam_config.wavelength_A, device=self.device, dtype=self.dtype)
    
        # Physical constants (from nanoBragg.c ~line 240)
        # PERF-PYTORCH-006: Store as tensors with correct dtype to avoid implicit float64 upcasting
        self.r_e_sqr = torch.tensor(
            7.94079248018965e-30, device=self.device, dtype=self.dtype  # classical electron radius squared (meters squared)
        )
        # Use fluence from beam config (AT-FLU-001)
        self.fluence = torch.tensor(self.beam_config.fluence, device=self.device, dtype=self.dtype)
        # Polarization setup from beam config
        # PERF-PYTORCH-006: Store as tensor with correct dtype
        kahn_value = self.beam_config.polarization_factor if not self.beam_config.nopolar else 0.0
        self.kahn_factor = torch.tensor(kahn_value, device=self.device, dtype=self.dtype)
        self.polarization_axis = torch.tensor(
            self.beam_config.polarization_axis, device=self.device, dtype=self.dtype
        )
    
        # PERF-PYTORCH-004 P1.2 + P3.0: Pre-normalize source tensors to avoid repeated .to() calls in run()
        # Move source direction/wavelength/weight tensors to correct device/dtype once during init
        # P3.0: Seed fallback tensors (equal weights, primary wavelength) when omitted before device cast
        _has_sources = (self.beam_config.source_directions is not None and
                       len(self.beam_config.source_directions) > 0)
        if _has_sources:
            self._source_directions = self.beam_config.source_directions.to(device=self.device, dtype=self.dtype)
    
            # P3.0: Default source_wavelengths to primary wavelength if not provided (AT-SRC-001)
            if self.beam_config.source_wavelengths is not None:
                self._source_wavelengths = self.beam_config.source_wavelengths.to(device=self.device, dtype=self.dtype)  # meters
            else:
                # Use primary wavelength for all sources
                primary_wavelength_m = self.beam_config.wavelength_A * 1e-10
                n_sources = len(self.beam_config.source_directions)
                self._source_wavelengths = torch.full((n_sources,), primary_wavelength_m, device=self.device, dtype=self.dtype)
    
            self._source_wavelengths_A = self._source_wavelengths * 1e10  # Convert to Angstroms once
    
            # P3.0: Default source_weights to equal weights if not provided
            if self.beam_config.source_weights is not None:
                self._source_weights = self.beam_config.source_weights.to(device=self.device, dtype=self.dtype)
            else:
                # Default to equal weights if not provided
                self._source_weights = torch.ones(len(self.beam_config.source_directions), device=self.device, dtype=self.dtype)
        else:
            self._source_directions = None
            self._source_wavelengths_A = None
            self._source_weights = None
    
        # PERF-PYTORCH-004 P3.4: Cache frequently-accessed tensors to reduce per-run allocations
        # Pre-convert pixel coordinates to correct device/dtype once
>       self._cached_pixel_coords_meters = self.detector.get_pixel_coords().to(device=self.device, dtype=self.dtype)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:569: AttributeError
________ TestAT_STR_003_LatticeShapeModels.test_shape_model_comparison _________

self = <tests.test_at_str_003.TestAT_STR_003_LatticeShapeModels object at 0x7ab044a89130>

    def test_shape_model_comparison(self):
        """Compare all four shape models at the same reflection."""
        # Test point slightly off a Bragg peak
        h_frac = 0.1  # Fractional Miller index offset
        k_frac = 0.1
        l_frac = 0.1
    
        results = {}
    
        for shape in [CrystalShape.SQUARE, CrystalShape.ROUND,
                     CrystalShape.GAUSS, CrystalShape.TOPHAT]:
            self.crystal_config.shape = shape
    
            # Create simulator with this shape
>           simulator = Simulator(
                crystal=Crystal(self.crystal_config),
                detector=None,
                crystal_config=self.crystal_config,
                beam_config=self.beam_config,
            )

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_str_003.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.simulator.Simulator object at 0x7ab0408dd490>
crystal = <nanobrag_torch.models.crystal.Crystal object at 0x7ab040f2d9a0>
detector = None
crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=(...square'>, fudge=1.0, sample_x=1.0000000000000001e-07, sample_y=1.0000000000000001e-07, sample_z=1.0000000000000001e-07)
beam_config = BeamConfig(wavelength_A=1.0, N_source_points=1, source_distance_mm=10000.0, source_size_mm=0.0, source_directions=None...=(0.0, 0.0, 1.0), flux=0.0, exposure=0.0, beamsize_mm=0.0, fluence=1.2593201528622709e+29, dmin=0.0, water_size_um=0.0)
device = None, dtype = torch.float32, debug_config = None

    def __init__(
        self,
        crystal: Crystal,
        detector: Detector,
        crystal_config: Optional[CrystalConfig] = None,
        beam_config: Optional[BeamConfig] = None,
        device=None,
        dtype=torch.float32,
        debug_config: Optional[dict] = None,
    ):
        """
        Initialize simulator with crystal, detector, and configurations.
    
        Args:
            crystal: Crystal object containing unit cell and structure factors
            detector: Detector object with geometry parameters
            crystal_config: Configuration for crystal rotation parameters (phi, mosaic)
            beam_config: Beam configuration (optional, for future use)
            device: PyTorch device (cpu/cuda)
            dtype: PyTorch data type
            debug_config: Debug configuration with printout, printout_pixel, trace_pixel options
        """
        self.crystal = crystal
        self.detector = detector
        # If crystal_config is provided, update only the rotation-related parameters
        # This preserves essential parameters like cell dimensions and default_F
        if crystal_config is not None:
            # Update only the rotation-related fields that are explicitly set
            # This preserves the crystal's essential parameters while allowing rotation updates
            if hasattr(crystal_config, 'phi_start_deg'):
                self.crystal.config.phi_start_deg = crystal_config.phi_start_deg
            if hasattr(crystal_config, 'osc_range_deg'):
                self.crystal.config.osc_range_deg = crystal_config.osc_range_deg
            if hasattr(crystal_config, 'phi_steps'):
                self.crystal.config.phi_steps = crystal_config.phi_steps
            if hasattr(crystal_config, 'mosaic_spread_deg'):
                self.crystal.config.mosaic_spread_deg = crystal_config.mosaic_spread_deg
            if hasattr(crystal_config, 'mosaic_domains'):
                self.crystal.config.mosaic_domains = crystal_config.mosaic_domains
            if hasattr(crystal_config, 'mosaic_seed'):
                self.crystal.config.mosaic_seed = crystal_config.mosaic_seed
            if hasattr(crystal_config, 'spindle_axis'):
                self.crystal.config.spindle_axis = crystal_config.spindle_axis
        # Use the provided beam_config, or Crystal's beam_config, or default
        if beam_config is not None:
            self.beam_config = beam_config
        elif hasattr(crystal, 'beam_config') and crystal.beam_config is not None:
            self.beam_config = crystal.beam_config
        else:
            self.beam_config = BeamConfig()
        # Normalize device to ensure consistency
        if device is not None:
            # Create a dummy tensor on the device to get the actual device with index
            temp = torch.zeros(1, device=device)
            self.device = temp.device
        else:
            self.device = torch.device("cpu")
        self.dtype = dtype
    
        # PERF-PYTORCH-004 Attempt #14: Ensure detector is on the same device/dtype as simulator
        # This prevents device mismatch errors when detector tensors (beam_vector, pixel_coords)
        # interact with simulator tensors (wavelength, incident_beam_direction) during compilation
        if self.detector is not None:
            self.detector = self.detector.to(device=self.device, dtype=self.dtype)
    
        # Store debug configuration
        self.debug_config = debug_config if debug_config is not None else {}
        self.printout = self.debug_config.get('printout', False)
        self.printout_pixel = self.debug_config.get('printout_pixel', None)  # [fast, slow]
        self.trace_pixel = self.debug_config.get('trace_pixel', None)  # [slow, fast]
    
        # Phase CLI-FLAGS-003 M0a: Enable trace instrumentation on Crystal when trace_pixel is active
        # This guards _last_tricubic_neighborhood population to prevent unconditional debug payload retention
        if self.trace_pixel is not None:
            self.crystal._enable_trace = True
    
        # Set incident beam direction from detector.beam_vector
        # This is critical for convention consistency (AT-PARALLEL-004) and CLI override support (CLI-FLAGS-003 Phase H2)
        # The detector.beam_vector property handles both convention defaults and CUSTOM overrides (e.g., -beam_vector)
        if self.detector is not None:
            # Use detector's beam_vector property which handles:
            # - CUSTOM convention with user-supplied custom_beam_vector
            # - Convention defaults (MOSFLM: [1,0,0], XDS/DIALS: [0,0,1])
            # The detector normalizes and returns the vector with correct device/dtype
            self.incident_beam_direction = self.detector.beam_vector.clone()
        else:
            # If no detector provided, default to MOSFLM beam direction
            self.incident_beam_direction = torch.tensor(
                [1.0, 0.0, 0.0], device=self.device, dtype=self.dtype
            )
        # PERF-PYTORCH-006: Store wavelength as tensor with correct dtype
        self.wavelength = torch.tensor(self.beam_config.wavelength_A, device=self.device, dtype=self.dtype)
    
        # Physical constants (from nanoBragg.c ~line 240)
        # PERF-PYTORCH-006: Store as tensors with correct dtype to avoid implicit float64 upcasting
        self.r_e_sqr = torch.tensor(
            7.94079248018965e-30, device=self.device, dtype=self.dtype  # classical electron radius squared (meters squared)
        )
        # Use fluence from beam config (AT-FLU-001)
        self.fluence = torch.tensor(self.beam_config.fluence, device=self.device, dtype=self.dtype)
        # Polarization setup from beam config
        # PERF-PYTORCH-006: Store as tensor with correct dtype
        kahn_value = self.beam_config.polarization_factor if not self.beam_config.nopolar else 0.0
        self.kahn_factor = torch.tensor(kahn_value, device=self.device, dtype=self.dtype)
        self.polarization_axis = torch.tensor(
            self.beam_config.polarization_axis, device=self.device, dtype=self.dtype
        )
    
        # PERF-PYTORCH-004 P1.2 + P3.0: Pre-normalize source tensors to avoid repeated .to() calls in run()
        # Move source direction/wavelength/weight tensors to correct device/dtype once during init
        # P3.0: Seed fallback tensors (equal weights, primary wavelength) when omitted before device cast
        _has_sources = (self.beam_config.source_directions is not None and
                       len(self.beam_config.source_directions) > 0)
        if _has_sources:
            self._source_directions = self.beam_config.source_directions.to(device=self.device, dtype=self.dtype)
    
            # P3.0: Default source_wavelengths to primary wavelength if not provided (AT-SRC-001)
            if self.beam_config.source_wavelengths is not None:
                self._source_wavelengths = self.beam_config.source_wavelengths.to(device=self.device, dtype=self.dtype)  # meters
            else:
                # Use primary wavelength for all sources
                primary_wavelength_m = self.beam_config.wavelength_A * 1e-10
                n_sources = len(self.beam_config.source_directions)
                self._source_wavelengths = torch.full((n_sources,), primary_wavelength_m, device=self.device, dtype=self.dtype)
    
            self._source_wavelengths_A = self._source_wavelengths * 1e10  # Convert to Angstroms once
    
            # P3.0: Default source_weights to equal weights if not provided
            if self.beam_config.source_weights is not None:
                self._source_weights = self.beam_config.source_weights.to(device=self.device, dtype=self.dtype)
            else:
                # Default to equal weights if not provided
                self._source_weights = torch.ones(len(self.beam_config.source_directions), device=self.device, dtype=self.dtype)
        else:
            self._source_directions = None
            self._source_wavelengths_A = None
            self._source_weights = None
    
        # PERF-PYTORCH-004 P3.4: Cache frequently-accessed tensors to reduce per-run allocations
        # Pre-convert pixel coordinates to correct device/dtype once
>       self._cached_pixel_coords_meters = self.detector.get_pixel_coords().to(device=self.device, dtype=self.dtype)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'get_pixel_coords'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:569: AttributeError
________ TestAT_TOOLS_001_DualRunnerComparison.test_script_integration _________

self = <tests.test_at_tools_001.TestAT_TOOLS_001_DualRunnerComparison object at 0x7ab044aa0160>

    @pytest.mark.skipif(
        not Path("./nanoBragg").exists() and not Path("./golden_suite_generator/nanoBragg").exists(),
        reason="Requires C binary for integration test"
    )
    def test_script_integration(self):
        """Test the full script execution."""
        # Run with minimal arguments
        cmd = [
            'python', 'scripts/nb_compare.py',
            '--outdir', 'test_comparison',
            '--',
            '-default_F', '100',
            '-cell', '100', '100', '100', '90', '90', '90',
            '-lambda', '1.0',
            '-distance', '100',
            '-detpixels', '64',
            '-floatfile', 'test.bin'
        ]
    
        # Run the script
        result = subprocess.run(cmd, capture_output=True, text=True)
    
        # Check that it ran without critical errors per spec
        # Exit codes: 0=success, 1=usage error, 2=runner failure, 3=correlation<threshold, 4=shape mismatch, 5=I/O error
>       assert result.returncode in [0, 3]  # 0=pass, 3=correlation below threshold
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 2 in [0, 3]
E        +  where 2 = CompletedProcess(args=['python', 'scripts/nb_compare.py', '--outdir', 'test_comparison', '--', '-default_F', '100', '-cell', '100', '100', '100', '90', '90', '90', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-floatfile', 'test.bin'], returncode=2, stdout='', stderr="python: can't open file '/tmp/pytest-of-ollie/pytest-488/test_fdump_preserves_sparse_be0/scripts/nb_compare.py': [Errno 2] No such file or directory\n").returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_at_tools_001.py:191: AssertionError
___________ TestCLIPix0Override.test_pix0_vector_mm_beam_pivot[cpu] ____________

self = <tests.test_cli_flags.TestCLIPix0Override object at 0x7ab044c1b6f0>
device = 'cpu'

    @pytest.mark.parametrize("device", ["cpu", pytest.param("cuda", marks=pytest.mark.skipif(
        not torch.cuda.is_available(), reason="CUDA not available"))])
    def test_pix0_vector_mm_beam_pivot(self, device):
        """
        Regression test for CLI-FLAGS-003 Phase H3b.
    
        CRITICAL FINDING from Phase H3b1:
        When custom detector vectors are provided, C code IGNORES -pix0_vector_mm entirely.
        The custom vectors already define the detector geometry completely.
    
        This test verifies BOTH scenarios:
        1. WITH custom vectors: pix0_override has NO EFFECT (matches C behavior)
        2. WITHOUT custom vectors: pix0_override IS applied
    
        Expected pix0 vector from C trace (phase_h) WITH custom vectors:
        -0.216336514802265, 0.215206668836451, -0.230198010448577 meters
    
        Reference: plans/active/cli-noise-pix0/plan.md Phase H3b
        Evidence: reports/2025-10-cli-flags/phase_h/implementation/pix0_mapping_analysis.md
        """
        import json
        from pathlib import Path
    
        # Load expected C pix0 vector
        expected_json_path = Path("reports/2025-10-cli-flags/phase_h/implementation/pix0_expected.json")
>       with open(expected_json_path) as f:
             ^^^^^^^^^^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'reports/2025-10-cli-flags/phase_h/implementation/pix0_expected.json'

/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:462: FileNotFoundError
_________________ TestHKLFdumpParity.test_scaled_hkl_roundtrip _________________

self = <tests.test_cli_flags.TestHKLFdumpParity object at 0x7ab044a7f250>

    def test_scaled_hkl_roundtrip(self):
        """
        Roundtrip test: HKL text  PyTorch grid  Fdump  PyTorch grid.
    
        Expected failure (before fix):
        - read_fdump will fail to match HKL grid due to padding mismatch
        - C allocates (range+1) dimensions but PyTorch currently uses range
    
        After fix:
        - Both readers should produce identical grids
        - Max |F|  1e-6 electrons (spec-a-core.md:460)
        """
        from pathlib import Path
        import tempfile
        from nanobrag_torch.io.hkl import read_hkl_file, write_fdump, read_fdump
    
        # Input files from Phase L1b analysis
        hkl_path = "scaled.hkl"
        c_fdump_path = "reports/2025-10-cli-flags/phase_l/hkl_parity/Fdump_scaled_20251006181401.bin"
    
        # Verify files exist
>       assert Path(hkl_path).exists(), f"Missing {hkl_path}"
E       AssertionError: Missing scaled.hkl
E       assert False
E        +  where False = exists()
E        +    where exists = PosixPath('scaled.hkl').exists
E        +      where PosixPath('scaled.hkl') = <class 'pathlib._local.Path'>('scaled.hkl')

/home/ollie/Documents/tmp/nanoBragg/tests/test_cli_flags.py:835: AssertionError
__________________ TestDebugTraceFeatures.test_printout_flag ___________________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044b00f50>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_printout_flag(self, minimal_args):
        """Test that -printout produces verbose debug output."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with -printout flag
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-printout'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmpxi8o4yya.bin', '-printout'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 \n  Wavelength: 1.00 \n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:50: AssertionError
_________________ TestDebugTraceFeatures.test_trace_pixel_flag _________________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044af8e90>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_trace_pixel_flag(self, minimal_args):
        """Test that -trace_pixel produces detailed trace for specific pixel."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with -trace_pixel flag for pixel (32, 32) [slow, fast]
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-trace_pixel', '32', '32'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp_7129prb.bin', '-trace_pixel', '32', '32'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 \n  Wavelength: 1.00 \n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=32, fast=32)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:121: AssertionError
_______________ TestDebugTraceFeatures.test_combined_debug_flags _______________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044af8fc0>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_combined_debug_flags(self, minimal_args):
        """Test that multiple debug flags can be used together."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with both -printout and -trace_pixel
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-printout',
                '-trace_pixel', '30', '30'
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Check that the command succeeded
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp6lthhg8g.bin', '-printout', '-trace_pixel', '30', '30'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 \n  Wavelength: 1.00 \n  Device: cpu, Dtype: torch.float32\n\nDebug output enabled for simulation\n  Tracing pixel (slow=30, fast=30)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:160: AssertionError
_______________ TestDebugTraceFeatures.test_out_of_bounds_pixel ________________

self = <tests.test_debug_trace.TestDebugTraceFeatures object at 0x7ab044b216d0>
minimal_args = ['-cell', '100', '100', '100', '90', '90', ...]

    def test_out_of_bounds_pixel(self, minimal_args):
        """Test that out-of-bounds pixel indices are handled gracefully."""
        with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as f:
            output_file = f.name
    
        try:
            # Run with out-of-bounds pixel (detector is 64x64)
            cmd = ['python', '-m', 'nanobrag_torch'] + minimal_args + [
                '-floatfile', output_file,
                '-trace_pixel', '100', '100'  # Out of bounds
            ]
    
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**os.environ, 'KMP_DUPLICATE_LIB_OK': 'TRUE'}
            )
    
            # Should still succeed (gracefully handle out of bounds)
>           assert result.returncode == 0, f"Command failed: {result.stderr}"
E           AssertionError: Command failed: Error: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             Traceback (most recent call last):
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main
E                 intensity = simulator.run()
E               File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run
E                 I_before_normalization_pre_polar  # Pre-polar accumulated intensity
E                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E             UnboundLocalError: cannot access local variable 'I_before_normalization_pre_polar' where it is not associated with a value
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['python', '-m', 'nanobrag_torch', '-cell', '100', '100', '100', '90', '90', '90', '-default_F', '100', '-lambda', '1.0', '-distance', '100', '-detpixels', '64', '-pixel', '0.1', '-floatfile', '/tmp/tmp95dnwva2.bin', '-trace_pixel', '100', '100'], returncode=1, stdout='Running simulation...\n  Detector: 64x64 pixels\n  Crystal: 100.0x100.0x100.0 \n  Wavelength: 1.00 \n  Device: cpu, Dtype: torch.float32\n  Tracing pixel (slow=100, fast=100)\nauto-selected 2-fold oversampling\n', stderr='Error: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\nTraceback (most recent call last):\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/__main__.py", line 1136, in main\n    intensity = simulator.run()\n  File "/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py", line 1254, in run\n    I_before_normalization_pre_polar  # Pre-polar accumulated intensity\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnboundLocalError: cannot access local variable \'I_before_normalization_pre_polar\' where it is not associated with a value\n').returncode

/home/ollie/Documents/tmp/nanoBragg/tests/test_debug_trace.py:198: AssertionError
____________ TestDetectorInitialization.test_default_initialization ____________

self = <tests.test_detector_config.TestDetectorInitialization object at 0x7ab044b01810>

    def test_default_initialization(self):
        """Test that Detector initializes with default config."""
        detector = Detector(dtype=torch.float64)
    
        # Check that config was created
        assert detector.config is not None
        assert isinstance(detector.config, DetectorConfig)
    
        # Check unit conversions (detector uses meters internally)
        assert detector.distance == 0.1  # 100 mm = 0.1 m
        assert detector.pixel_size == 0.0001  # 0.1 mm = 0.0001 m
    
        # Check dimensions
        assert detector.spixels == 1024
        assert detector.fpixels == 1024
    
        # Check beam center in pixels
        # MOSFLM convention: 51.25 mm / 0.1 mm per pixel + 0.5 = 513.0
>       assert detector.beam_center_s == 513.0
E       assert tensor(512.5000) == 513.0
E        +  where tensor(512.5000) = <src.nanobrag_torch.models.detector.Detector object at 0x7ab039330750>.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_config.py:142: AssertionError
_________ TestDetectorInitialization.test_custom_config_initialization _________

self = <tests.test_detector_config.TestDetectorInitialization object at 0x7ab044b01950>

    def test_custom_config_initialization(self):
        """Test that Detector initializes with custom config."""
        config = DetectorConfig(
            distance_mm=200.0,
            pixel_size_mm=0.2,
            spixels=2048,
            fpixels=2048,
            beam_center_s=204.8,  # 1024 pixels * 0.2 mm
            beam_center_f=204.8,
        )
        detector = Detector(config, dtype=torch.float64)
    
        # Check unit conversions (detector uses meters internally)
        assert detector.distance == 0.2  # 200 mm = 0.2 m
        assert detector.pixel_size == 0.0002  # 0.2 mm = 0.0002 m
    
        # Check dimensions
        assert detector.spixels == 2048
        assert detector.fpixels == 2048
    
        # Check beam center in pixels
        # Default convention is MOSFLM which adds +0.5 pixel offset
>       assert detector.beam_center_s == 1024.5  # 204.8 mm / 0.2 mm per pixel + 0.5
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert tensor(1024.) == 1024.5
E        +  where tensor(1024.) = <src.nanobrag_torch.models.detector.Detector object at 0x7ab03b95ed50>.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_config.py:171: AssertionError
____________ TestDetectorConventions.test_denzo_beam_center_mapping ____________

self = <tests.test_detector_conventions.TestDetectorConventions object at 0x7ab044af9a70>

    def test_denzo_beam_center_mapping(self):
        """Test DENZO beam center mapping differs from MOSFLM (no +0.5 pixel offset)."""
        # Use explicit beam centers to test the offset behavior
        beam_center_mm_s = 50.0  # mm
        beam_center_mm_f = 50.0  # mm
        pixel_size = 0.1  # mm
    
        config_denzo = DetectorConfig(
            detector_convention=DetectorConvention.DENZO,
            spixels=1024,
            fpixels=1024,
            pixel_size_mm=pixel_size,
            distance_mm=100.0,
            beam_center_s=beam_center_mm_s,
            beam_center_f=beam_center_mm_f
        )
    
        config_mosflm = DetectorConfig(
            detector_convention=DetectorConvention.MOSFLM,
            spixels=1024,
            fpixels=1024,
            pixel_size_mm=pixel_size,
            distance_mm=100.0,
            beam_center_s=beam_center_mm_s,
            beam_center_f=beam_center_mm_f
        )
    
        detector_denzo = Detector(config_denzo, dtype=torch.float64)
        detector_mosflm = Detector(config_mosflm, dtype=torch.float64)
    
        # Convert mm to pixels for comparison
        beam_center_pixels = beam_center_mm_s / pixel_size  # 500 pixels
    
        # DENZO should store beam center as-is in pixels
        # MOSFLM should add +0.5 pixel offset
        expected_denzo = beam_center_pixels  # 500.0
        expected_mosflm = beam_center_pixels + 0.5  # 500.5
    
        assert torch.allclose(detector_denzo.beam_center_s, torch.tensor(expected_denzo, dtype=torch.float64), atol=1e-6), \
            f"DENZO beam_center_s should be {expected_denzo}, got {detector_denzo.beam_center_s}"
        assert torch.allclose(detector_denzo.beam_center_f, torch.tensor(expected_denzo, dtype=torch.float64), atol=1e-6), \
            f"DENZO beam_center_f should be {expected_denzo}, got {detector_denzo.beam_center_f}"
>       assert torch.allclose(detector_mosflm.beam_center_s, torch.tensor(expected_mosflm, dtype=torch.float64), atol=1e-6), \
            f"MOSFLM beam_center_s should be {expected_mosflm}, got {detector_mosflm.beam_center_s}"
E       AssertionError: MOSFLM beam_center_s should be 500.5, got 500.0
E       assert False
E        +  where False = <built-in method allclose of type object at 0x7ab1c6980fc0>(tensor(500.), tensor(500.5000), atol=1e-06)
E        +    where <built-in method allclose of type object at 0x7ab1c6980fc0> = torch.allclose
E        +    and   tensor(500.) = <src.nanobrag_torch.models.detector.Detector object at 0x7ab039330a50>.beam_center_s
E        +    and   tensor(500.5000) = <built-in method tensor of type object at 0x7ab1c6980fc0>(500.5, dtype=torch.float64)
E        +      where <built-in method tensor of type object at 0x7ab1c6980fc0> = torch.tensor
E        +      and   torch.float64 = torch.float64

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_conventions.py:113: AssertionError
_______________ test_beam_pivot_keeps_beam_indices_and_alignment _______________

    def test_beam_pivot_keeps_beam_indices_and_alignment():
        cfg = DetectorConfig(
            detector_convention=DetectorConvention.MOSFLM,
            detector_pivot=DetectorPivot.BEAM,
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=1024, fpixels=1024,
            beam_center_s=51.2, beam_center_f=51.2,
            detector_twotheta_deg=0.0,
        )
        d = Detector(cfg, dtype=torch.float64)
    
        # 1) Direct beam fractional indices must be equal to beam_center_s and beam_center_f
        # (Note: MOSFLM +0.5 offset is already included in d.beam_center_s/f)
        s0, f0 = _beam_indices(d)
>       assert torch.allclose(s0, d.beam_center_s, atol=1e-12)
E       assert False
E        +  where False = <built-in method allclose of type object at 0x7ab1c6980fc0>(tensor(512.5000), tensor(512.), atol=1e-12)
E        +    where <built-in method allclose of type object at 0x7ab1c6980fc0> = torch.allclose
E        +    and   tensor(512.) = <nanobrag_torch.models.detector.Detector object at 0x7ab039330250>.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_pivots.py:43: AssertionError
______________ test_sample_pivot_moves_beam_indices_with_twotheta ______________

    def test_sample_pivot_moves_beam_indices_with_twotheta():
        cfg = DetectorConfig(
            detector_convention=DetectorConvention.MOSFLM,
            detector_pivot=DetectorPivot.SAMPLE,
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=1024, fpixels=1024,
            beam_center_s=51.2, beam_center_f=51.2,
            detector_twotheta_deg=0.0,
        )
        d = Detector(cfg, dtype=torch.float64)
    
        # At zero rotation with center-based indexing, beam indices equal beam centers
        s0, f0 = _beam_indices(d)
>       assert torch.allclose(s0, d.beam_center_s, atol=1e-12)
E       assert False
E        +  where False = <built-in method allclose of type object at 0x7ab1c6980fc0>(tensor(512.5000), tensor(512.), atol=1e-12)
E        +    where <built-in method allclose of type object at 0x7ab1c6980fc0> = torch.allclose
E        +    and   tensor(512.) = <nanobrag_torch.models.detector.Detector object at 0x7ab039330b50>.beam_center_s

/home/ollie/Documents/tmp/nanoBragg/tests/test_detector_pivots.py:75: AssertionError
_____________ TestAdvancedGradients.test_gradient_flow_simulation ______________

self = <tests.test_gradients.TestAdvancedGradients object at 0x7ab044afa9e0>

    def test_gradient_flow_simulation(self):
        """Verify end-to-end gradient flow through full simulation pipeline."""
        device = torch.device("cpu")
        dtype = torch.float64
    
        # Create differentiable cell parameters
        cell_a = torch.tensor(100.0, dtype=dtype, requires_grad=True)
        cell_b = torch.tensor(100.0, dtype=dtype, requires_grad=True)
        cell_c = torch.tensor(100.0, dtype=dtype, requires_grad=True)
        cell_alpha = torch.tensor(90.0, dtype=dtype, requires_grad=True)
        cell_beta = torch.tensor(90.0, dtype=dtype, requires_grad=True)
        cell_gamma = torch.tensor(90.0, dtype=dtype, requires_grad=True)
    
        # Create config with tensor parameters
        config = CrystalConfig(
            cell_a=cell_a,
            cell_b=cell_b,
            cell_c=cell_c,
            cell_alpha=cell_alpha,
            cell_beta=cell_beta,
            cell_gamma=cell_gamma,
            mosaic_spread_deg=0.0,
            mosaic_domains=1,
            N_cells=(5, 5, 5),
        )
    
        # Create objects
        crystal = Crystal(config=config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
    
        # Run simulation
        simulator = Simulator(
            crystal, detector, crystal_config=config, device=device, dtype=dtype
        )
        image = simulator.run()
    
        # Compute loss
        loss = image.sum()
    
        # Verify image requires grad
        assert image.requires_grad, "Output image should require gradients"
    
        # Backward pass
        loss.backward()
    
        # Verify all parameters have gradients
        assert cell_a.grad is not None, "cell_a should have gradient"
        assert cell_b.grad is not None, "cell_b should have gradient"
        assert cell_c.grad is not None, "cell_c should have gradient"
        assert cell_alpha.grad is not None, "cell_alpha should have gradient"
        assert cell_beta.grad is not None, "cell_beta should have gradient"
        assert cell_gamma.grad is not None, "cell_gamma should have gradient"
    
        # Verify gradients are non-zero (at least one should be)
        grad_magnitudes = [
            cell_a.grad.abs().item(),
            cell_b.grad.abs().item(),
            cell_c.grad.abs().item(),
            cell_alpha.grad.abs().item(),
            cell_beta.grad.abs().item(),
            cell_gamma.grad.abs().item(),
        ]
>       assert any(
            mag > 1e-10 for mag in grad_magnitudes
        ), "At least one gradient should be non-zero"
E       AssertionError: At least one gradient should be non-zero
E       assert False
E        +  where False = any(<generator object TestAdvancedGradients.test_gradient_flow_simulation.<locals>.<genexpr> at 0x7ab03935b9f0>)

/home/ollie/Documents/tmp/nanoBragg/tests/test_gradients.py:447: AssertionError
----------------------------- Captured stdout call -----------------------------
auto-selected 2-fold oversampling
____________ TestCUDAGraphsCompatibility.test_basic_execution[cpu] _____________

self = <tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility object at 0x7ab0449aa490>
device = 'cpu'

    @pytest.mark.parametrize("device", ["cpu", pytest.param("cuda", marks=pytest.mark.skipif(not torch.cuda.is_available(), reason="CUDA not available"))])
    def test_basic_execution(self, device):
        """Test that basic simulation runs on both CPU and CUDA without errors."""
        # Simple cubic crystal configuration
        crystal_config = CrystalConfig(
            cell_a=100.0, cell_b=100.0, cell_c=100.0,
            cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0,
            misset_deg=(0.0, 0.0, 0.0),
            phi_start_deg=0.0, osc_range_deg=0.0, phi_steps=1,
            spindle_axis=(0.0, 0.0, 1.0),
            mosaic_spread_deg=0.0, mosaic_domains=1,
            N_cells=(3, 3, 3),
            default_F=100.0
        )
    
        # Small detector for fast test
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=64, fpixels=64,
            beam_center_s=3.2, beam_center_f=3.2
        )
    
        beam_config = BeamConfig(
            wavelength_A=6.2
        )
    
        # Create simulator on target device (dtype defaults to float32)
>       simulator = Simulator(
            crystal_config=crystal_config,
            detector_config=detector_config,
            beam_config=beam_config,
            device=device,
            dtype=torch.float32
        )
E       TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'

/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:53: TypeError
___________ TestCUDAGraphsCompatibility.test_gradient_flow_preserved ___________

self = <tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility object at 0x7ab044a04b00>

    def test_gradient_flow_preserved(self):
        """Test that cloning incident_beam_direction preserves gradient flow."""
        # Use float64 for gradcheck precision
        distance_tensor = torch.tensor(100.0, requires_grad=True, dtype=torch.float64)
    
        crystal_config = CrystalConfig(
            cell_a=100.0, cell_b=100.0, cell_c=100.0,
            cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0,
            misset_deg=(0.0, 0.0, 0.0),
            phi_start_deg=0.0, osc_range_deg=0.0, phi_steps=1,
            spindle_axis=(0.0, 0.0, 1.0),
            mosaic_spread_deg=0.0, mosaic_domains=1,
            N_cells=(3, 3, 3),
            default_F=100.0
        )
    
        detector_config = DetectorConfig(
            distance_mm=distance_tensor,
            pixel_size_mm=0.1,
            spixels=32, fpixels=32,
            beam_center_s=1.6, beam_center_f=1.6
        )
    
        beam_config = BeamConfig(
            wavelength_A=6.2
        )
    
>       simulator = Simulator(
            crystal_config=crystal_config,
            detector_config=detector_config,
            beam_config=beam_config,
            device="cpu",
            dtype=torch.float64
        )
E       TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'

/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:142: TypeError
__________ TestCUDAGraphsCompatibility.test_cpu_cuda_correlation[cpu] __________

self = <tests.test_perf_pytorch_005_cudagraphs.TestCUDAGraphsCompatibility object at 0x7ab0448631d0>
device = 'cpu'

    @pytest.mark.parametrize("device", ["cpu", pytest.param("cuda", marks=pytest.mark.skipif(not torch.cuda.is_available(), reason="CUDA not available"))])
    def test_cpu_cuda_correlation(self, device):
        """Test that CPU and CUDA (if available) produce highly correlated results."""
        crystal_config = CrystalConfig(
            cell_a=100.0, cell_b=100.0, cell_c=100.0,
            cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0,
            misset_deg=(0.0, 0.0, 0.0),
            phi_start_deg=0.0, osc_range_deg=0.0, phi_steps=1,
            spindle_axis=(0.0, 0.0, 1.0),
            mosaic_spread_deg=0.0, mosaic_domains=1,
            N_cells=(3, 3, 3),
            default_F=100.0
        )
    
        detector_config = DetectorConfig(
            distance_mm=100.0,
            pixel_size_mm=0.1,
            spixels=64, fpixels=64,
            beam_center_s=3.2, beam_center_f=3.2
        )
    
        beam_config = BeamConfig(
            wavelength_A=6.2
        )
    
        # Run on CPU
>       simulator_cpu = Simulator(
            crystal_config=crystal_config,
            detector_config=detector_config,
            beam_config=beam_config,
            device="cpu",
            dtype=torch.float32
        )
E       TypeError: Simulator.__init__() got an unexpected keyword argument 'detector_config'

/home/ollie/Documents/tmp/nanoBragg/tests/test_perf_pytorch_005_cudagraphs.py:184: TypeError
_______ TestTier1TranslationCorrectness.test_sensitivity_to_cell_params ________

self = <tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab044a28380>

    def test_sensitivity_to_cell_params(self):
        """Test that the model behaves physically when cell parameters change."""
        import os
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        # Set up base triclinic cell
        device = torch.device("cpu")
        dtype = torch.float64
    
        base_config = CrystalConfig(
            cell_a=70.0,
            cell_b=80.0,
            cell_c=90.0,
            cell_alpha=75.0,
            cell_beta=85.0,
            cell_gamma=95.0,
            N_cells=[3, 3, 3],  # Smaller for speed
        )
    
        # Create base simulation
        crystal = Crystal(config=base_config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        detector.spixels = 256  # Smaller for speed
        detector.fpixels = 256
        detector.beam_center_f = 128.5
        detector.beam_center_s = 128.5
    
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
            phi_steps=1,  # Explicitly set phi_steps
            osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
            mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
        )
    
>       simulator = Simulator(
            crystal, detector, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:678: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.models.detector.Detector object at 0x7ab039331950>
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
>       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError
________ TestTier1TranslationCorrectness.test_performance_simple_cubic _________

self = <tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab044a28af0>

    def test_performance_simple_cubic(self):
        """Test performance of simple cubic simulation."""
        import os
        import time
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        # Create simple cubic crystal
        crystal = Crystal(device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        # Use smaller detector for consistent timing
        detector.spixels = 256
        detector.fpixels = 256
        detector.beam_center_f = 128.5
        detector.beam_center_s = 128.5
    
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
            phi_steps=1,  # Explicitly set phi_steps
            osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
            mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
        )
    
>       simulator = Simulator(
            crystal, detector, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:804: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.models.detector.Detector object at 0x7ab039331850>
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
>       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError
__________ TestTier1TranslationCorrectness.test_performance_triclinic __________

self = <tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab044a10750>

    def test_performance_triclinic(self):
        """Test performance of triclinic simulation.
    
        This test verifies that triclinic crystal simulation does not
        have excessive overhead compared to simple cubic. Due to system
        load variations, we use a median of multiple runs and a relaxed
        tolerance.
        """
        import os
        import time
        import statistics
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        # Create triclinic crystal
        triclinic_config = CrystalConfig(
            cell_a=70.0,
            cell_b=80.0,
            cell_c=90.0,
            cell_alpha=75.0,
            cell_beta=85.0,
            cell_gamma=95.0,
            N_cells=[5, 5, 5],
        )
    
        crystal = Crystal(config=triclinic_config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        # Use smaller detector for consistent timing
        detector.spixels = 256
        detector.fpixels = 256
        detector.beam_center_f = 128.5
        detector.beam_center_s = 128.5
    
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
            phi_steps=1,  # Explicitly set phi_steps
            osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
            mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
        )
    
        # Set beam config with wavelength
        from nanobrag_torch.config import BeamConfig
        beam_config = BeamConfig(wavelength_A=1.0)
    
>       simulator = Simulator(
            crystal, detector, beam_config=beam_config, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:879: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.models.detector.Detector object at 0x7ab039331b50>
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
>       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError
_________ TestTier1TranslationCorrectness.test_extreme_cell_parameters _________

self = <tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab0449b3890>

    def test_extreme_cell_parameters(self):
        """Test numerical stability for edge cases."""
        import os
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        print("\n=== Testing Extreme Cell Parameters ===")
    
        # Test cases with different extreme parameters
        test_cases = [
            # Nearly cubic cells (angles near 90)
            {
                "name": "Nearly cubic",
                "config": CrystalConfig(
                    cell_a=100.0,
                    cell_b=100.1,
                    cell_c=99.9,
                    cell_alpha=89.9,
                    cell_beta=90.1,
                    cell_gamma=90.0,
                    N_cells=[2, 2, 2],
                ),
            },
            # Moderately skewed cells (challenging but not extreme)
            {
                "name": "Moderately skewed",
                "config": CrystalConfig(
                    cell_a=50.0,
                    cell_b=60.0,
                    cell_c=70.0,
                    cell_alpha=70.0,  # Less extreme than 45
                    cell_beta=110.0,  # Less extreme than 135
                    cell_gamma=80.0,   # Less extreme than 60
                    N_cells=[2, 2, 2],
                ),
            },
            # Very small cell dimensions
            {
                "name": "Very small cells",
                "config": CrystalConfig(
                    cell_a=1.0,
                    cell_b=1.5,
                    cell_c=2.0,
                    cell_alpha=90.0,
                    cell_beta=90.0,
                    cell_gamma=90.0,
                    N_cells=[10, 10, 10],
                ),
            },
            # Very large cell dimensions
            {
                "name": "Very large cells",
                "config": CrystalConfig(
                    cell_a=1000.0,
                    cell_b=1200.0,
                    cell_c=1500.0,
                    cell_alpha=90.0,
                    cell_beta=90.0,
                    cell_gamma=90.0,
                    N_cells=[1, 1, 1],
                ),
            },
        ]
    
        for test_case in test_cases:
            print(f"\nTesting: {test_case['name']}")
    
            try:
                # Create crystal
                crystal = Crystal(
                    config=test_case["config"], device=device, dtype=dtype
                )
    
                # Check geometry calculations
                tensors = crystal.compute_cell_tensors()
    
                # Verify no NaN or Inf values
                for key, tensor in tensors.items():
                    if key == "V":  # Volume is scalar
                        assert torch.isfinite(
                            tensor
                        ), f"NaN/Inf in {key} for {test_case['name']}"
                        print(f"  Volume: {tensor.item():.3e}")
                        # Check for reasonable volume bounds
                        assert tensor.item() > 1e-12, f"Volume too small for {test_case['name']}: {tensor.item():.3e}"
                        assert tensor.item() < 1e15, f"Volume too large for {test_case['name']}: {tensor.item():.3e}"
                    else:  # Vectors
                        assert torch.all(
                            torch.isfinite(tensor)
                        ), f"NaN/Inf in {key} for {test_case['name']}"
                        magnitude = torch.norm(tensor).item()
                        print(f"  |{key}|: {magnitude:.3e}")
                        # Check for reasonable vector magnitude bounds
                        assert magnitude < 1e10, f"Vector {key} magnitude too large for {test_case['name']}: {magnitude:.3e}"
    
                # Try to run a small simulation
                detector = Detector(device=device, dtype=dtype)
                detector.spixels = 64
                detector.fpixels = 64
                detector.beam_center_f = 32.5
                detector.beam_center_s = 32.5
    
                rot_config = CrystalConfig(
                    phi_start_deg=torch.tensor(0.0, device=device, dtype=dtype),
                    osc_range_deg=torch.tensor(0.0, device=device, dtype=dtype),
                    mosaic_spread_deg=torch.tensor(0.0, device=device, dtype=dtype),
                )
    
>               simulator = Simulator(
                    crystal,
                    detector,
                    crystal_config=rot_config,
                    device=device,
                    dtype=dtype,
                )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.models.detector.Detector object at 0x7ab03b48b550>
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
>       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError
----------------------------- Captured stdout call -----------------------------

=== Testing Extreme Cell Parameters ===

Testing: Nearly cubic
  |a|: 1.000e+02
  |b|: 1.001e+02
  |c|: 9.990e+01
  |a_star|: 1.000e-02
  |b_star|: 9.990e-03
  |c_star|: 1.001e-02
  Volume: 1.000e+06
   Failed: 'float' object has no attribute 'to'
_________ TestTier1TranslationCorrectness.test_rotation_compatibility __________

self = <tests.test_suite.TestTier1TranslationCorrectness object at 0x7ab0449b3e30>

    def test_rotation_compatibility(self):
        """Test that dynamic geometry works with crystal rotations."""
        import os
    
        os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"
    
        device = torch.device("cpu")
        dtype = torch.float64
    
        print("\n=== Testing Rotation Compatibility ===")
    
        # Create triclinic crystal with proper parameters
        config = CrystalConfig(
            cell_a=70.0,
            cell_b=80.0,
            cell_c=90.0,
            cell_alpha=75.0,
            cell_beta=85.0,
            cell_gamma=95.0,
            N_cells=[3, 3, 3],
            default_F=100.0,  # Add non-zero structure factor
        )
    
        crystal = Crystal(config=config, device=device, dtype=dtype)
        detector = Detector(device=device, dtype=dtype)
        detector.spixels = 128
        detector.fpixels = 128
        detector.beam_center_f = 64.5
        detector.beam_center_s = 64.5
    
        # Test with phi rotation and mosaic spread
        rot_config = CrystalConfig(
            phi_start_deg=torch.tensor(10.0, device=device, dtype=dtype),
            osc_range_deg=torch.tensor(20.0, device=device, dtype=dtype),
            phi_steps=5,
            mosaic_spread_deg=torch.tensor(0.5, device=device, dtype=dtype),
            mosaic_domains=10,
        )
    
        # Create beam config with proper wavelength
        from nanobrag_torch.config import BeamConfig
        beam_config = BeamConfig(wavelength_A=1.0)
    
>       simulator = Simulator(
            crystal, detector, beam_config=beam_config, crystal_config=rot_config, device=device, dtype=dtype
        )

/home/ollie/Documents/tmp/nanoBragg/tests/test_suite.py:1247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/simulator.py:492: in __init__
    self.detector = self.detector.to(device=self.device, dtype=self.dtype)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <nanobrag_torch.models.detector.Detector object at 0x7ab039330950>
device = device(type='cpu'), dtype = torch.float64

    def to(self, device=None, dtype=None):
        """Move detector to specified device and/or dtype."""
        if device is not None:
            self.device = device
        if dtype is not None:
            self.dtype = dtype
    
        # Move basis vectors to new device/dtype
        self.fdet_vec = self.fdet_vec.to(device=self.device, dtype=self.dtype)
        self.sdet_vec = self.sdet_vec.to(device=self.device, dtype=self.dtype)
        self.odet_vec = self.odet_vec.to(device=self.device, dtype=self.dtype)
    
        # Move beam center tensors
>       self.beam_center_s = self.beam_center_s.to(device=self.device, dtype=self.dtype)
                             ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'float' object has no attribute 'to'

/home/ollie/Documents/tmp/nanoBragg/src/nanobrag_torch/models/detector.py:232: AttributeError
----------------------------- Captured stdout call -----------------------------

=== Testing Rotation Compatibility ===
______________ TestTricubicGather.test_vectorized_matches_scalar _______________

self = <tests.test_tricubic_vectorized.TestTricubicGather object at 0x7ab0448e0190>
crystal_with_data = <nanobrag_torch.models.crystal.Crystal object at 0x7ab0393899a0>

    def test_vectorized_matches_scalar(self, crystal_with_data):
        """
        Verify that batched gather produces correct neighborhoods.
    
        Phase C1 requirement: Build (B, 4, 4, 4) neighborhoods via advanced indexing.
        This test validates the gather mechanism by comparing:
        1. Scalar interpolation (existing path, B=1)
        2. Shape assertions on batched gather output
        3. Neighborhood contents match expected HKL data
    
        Reference: design_notes.md Section 2.2, Section 5.1
        """
        crystal = crystal_with_data
    
        # Test case 1: Single query point (scalar path, B=1)
        h_scalar = torch.tensor([1.5], dtype=torch.float32)
        k_scalar = torch.tensor([2.3], dtype=torch.float32)
        l_scalar = torch.tensor([0.5], dtype=torch.float32)
    
        # This should use the scalar path (B=1)
        F_scalar = crystal._tricubic_interpolation(h_scalar, k_scalar, l_scalar)
    
        assert F_scalar.shape == h_scalar.shape, f"Scalar output shape mismatch: {F_scalar.shape} vs {h_scalar.shape}"
        assert not torch.isnan(F_scalar).any(), "Scalar output contains NaNs"
        assert not torch.isinf(F_scalar).any(), "Scalar output contains Infs"
    
        # Test case 2: Batched query points (gather path, B>1)
        # Use a small batch to verify neighborhood gathering
        h_batch = torch.tensor([1.5, 2.3, -1.2], dtype=torch.float32)
        k_batch = torch.tensor([2.3, -0.5, 3.1], dtype=torch.float32)
        l_batch = torch.tensor([0.5, 1.8, -2.0], dtype=torch.float32)
    
        # This triggers the batched gather path (B=3)
        # Currently falls back to nearest-neighbor but builds neighborhoods internally
        F_batch = crystal._tricubic_interpolation(h_batch, k_batch, l_batch)
    
        assert F_batch.shape == h_batch.shape, f"Batch output shape mismatch: {F_batch.shape} vs {h_batch.shape}"
        assert not torch.isnan(F_batch).any(), "Batch output contains NaNs"
        assert not torch.isinf(F_batch).any(), "Batch output contains Infs"
    
        # Test case 3: Multi-dimensional batch (detector grid simulation)
        # Simulate a small detector region: (S=2, F=3)
        h_grid = torch.tensor([[1.5, 2.3, 0.8], [-1.2, 3.1, 1.9]], dtype=torch.float32)
        k_grid = torch.tensor([[2.3, -0.5, 1.2], [3.1, -2.0, 0.5]], dtype=torch.float32)
        l_grid = torch.tensor([[0.5, 1.8, -1.0], [-2.0, 0.3, 2.5]], dtype=torch.float32)
    
        # Flatten to (B=6) internally
        F_grid = crystal._tricubic_interpolation(h_grid, k_grid, l_grid)
    
        assert F_grid.shape == h_grid.shape, f"Grid output shape mismatch: {F_grid.shape} vs {h_grid.shape}"
        assert not torch.isnan(F_grid).any(), "Grid output contains NaNs"
        assert not torch.isinf(F_grid).any(), "Grid output contains Infs"
    
        # Test case 4: Verify neighborhood bounds checking still works
        # Query point near edge (h=4.5  floor=4  needs neighbors 3,4,5,6; 6>h_max=5)
        h_edge = torch.tensor([4.5], dtype=torch.float32)
        k_edge = torch.tensor([0.0], dtype=torch.float32)
        l_edge = torch.tensor([0.0], dtype=torch.float32)
    
        # Capture warning state before test
        warning_shown_before = crystal._interpolation_warning_shown
    
        # This should trigger OOB fallback and return default_F
        F_edge = crystal._tricubic_interpolation(h_edge, k_edge, l_edge)
    
        # Should fallback to default_F due to OOB
        expected_default = crystal.config.default_F
        # Allow small tolerance due to potential floating point ops
>       assert torch.allclose(F_edge, torch.tensor(expected_default), atol=1e-5), \
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            f"OOB fallback failed: expected {expected_default}, got {F_edge.item()}"

/home/ollie/Documents/tmp/nanoBragg/tests/test_tricubic_vectorized.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x7ab03667e150>
func = <built-in method allclose of type object at 0x7ab1c6980fc0>, types = ()
args = (tensor([100.], dtype=torch.float32), tensor(100.))
kwargs = {'atol': 1e-05}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^
E       RuntimeError: Float did not match Double

/home/ollie/miniconda3/lib/python3.13/site-packages/torch/utils/_device.py:104: RuntimeError
----------------------------- Captured stdout call -----------------------------
WARNING: out of range for three point interpolation
WARNING: further warnings will not be printed!
_______________ TestTricubicGather.test_oob_warning_single_fire ________________

self = <tests.test_tricubic_vectorized.TestTricubicGather object at 0x7ab044a06650>
simple_crystal_config = CrystalConfig(cell_a=100.0, cell_b=100.0, cell_c=100.0, cell_alpha=90.0, cell_beta=90.0, cell_gamma=90.0, misset_deg=[...square'>, fudge=1.0, sample_x=5.0000000000000004e-08, sample_y=5.0000000000000004e-08, sample_z=5.0000000000000004e-08)

    def test_oob_warning_single_fire(self, simple_crystal_config):
        """
        Verify that out-of-bounds warning fires exactly once and disables interpolation.
    
        Phase C2 requirement: Lock the single-warning behavior for OOB fallback.
        When tricubic interpolation encounters an out-of-bounds neighborhood query:
        1. First occurrence triggers warning message (printed once only)
        2. Interpolation is permanently disabled (self.interpolate = False)
        3. Subsequent OOB queries return default_F without additional warnings
    
        Reference: plans/active/vectorization.md Phase C2
        """
        # Create crystal with small HKL data range to easily trigger OOB
        crystal = Crystal(simple_crystal_config)
    
        h_range, k_range, l_range = 11, 11, 11  # covers h,k,l  [-5, 5]
        hkl_data = torch.ones((h_range, k_range, l_range), dtype=torch.float32) * 50.0
        crystal.hkl_data = hkl_data
        crystal.hkl_metadata = {
            'h_min': -5, 'h_max': 5,
            'k_min': -5, 'k_max': 5,
            'l_min': -5, 'l_max': 5,
            'h_range': 10, 'k_range': 10, 'l_range': 10
        }
    
        # Enable interpolation explicitly
        crystal.interpolate = True
        initial_warning_state = crystal._interpolation_warning_shown
        assert not initial_warning_state, "Warning flag should start False"
        assert crystal.interpolate, "Interpolation should start enabled"
    
        # First OOB query: h=4.8  floor=4  needs neighbors [3,4,5,6]
        # Since h_max=5, neighbor h=6 is out of range
        h_oob = torch.tensor([4.8], dtype=torch.float32)
        k_oob = torch.tensor([0.0], dtype=torch.float32)
        l_oob = torch.tensor([0.0], dtype=torch.float32)
    
        # Capture stdout to verify warning message
        import io
        import sys
        captured_output = io.StringIO()
        sys.stdout = captured_output
    
        # First call: should trigger warning
        F_first = crystal._tricubic_interpolation(h_oob, k_oob, l_oob)
    
        # Restore stdout
        sys.stdout = sys.__stdout__
        warning_text = captured_output.getvalue()
    
        # Verify warning was printed
        assert "WARNING: out of range for three point interpolation" in warning_text, \
            "First OOB call should print warning"
        assert "further warnings will not be printed" in warning_text, \
            "Warning should indicate no further warnings"
    
        # Verify state changes
        assert crystal._interpolation_warning_shown, "Warning flag should be set"
        assert not crystal.interpolate, "Interpolation should be disabled"
    
        # Verify fallback to default_F
        expected_default = crystal.config.default_F
>       assert torch.allclose(F_first, torch.tensor(expected_default), atol=1e-5), \
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            f"First OOB call should return default_F={expected_default}, got {F_first.item()}"

/home/ollie/Documents/tmp/nanoBragg/tests/test_tricubic_vectorized.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x7ab03667e150>
func = <built-in method allclose of type object at 0x7ab1c6980fc0>, types = ()
args = (tensor([100.], dtype=torch.float32), tensor(100.))
kwargs = {'atol': 1e-05}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^
E       RuntimeError: Float did not match Double

/home/ollie/miniconda3/lib/python3.13/site-packages/torch/utils/_device.py:104: RuntimeError
=============================== warnings summary ===============================
tests/test_at_parallel_026.py:23
  /home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_026.py:23: PytestUnknownMarkWarning: Unknown pytest.mark.parallel_validation - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    pytest.mark.parallel_validation

tests/test_at_parallel_026.py:116
  /home/ollie/Documents/tmp/nanoBragg/tests/test_at_parallel_026.py:116: PytestUnknownMarkWarning: Unknown pytest.mark.requires_c_binary - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.requires_c_binary

tests/test_at_crystal_absolute.py::TestATCrystalAbsolute::test_triclinic_absolute_positions
  /home/ollie/Documents/tmp/nanoBragg/tests/test_at_crystal_absolute.py:205: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)
    triclinic_error = np.sqrt(

tests/test_at_crystal_absolute.py::TestATCrystalAbsolute::test_triclinic_absolute_positions
  /home/ollie/Documents/tmp/nanoBragg/tests/test_at_crystal_absolute.py:228: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)
    cubic_dist_from_center = np.sqrt(

tests/test_at_crystal_absolute.py::TestATCrystalAbsolute::test_cubic_vs_triclinic_systematic_difference
  /home/ollie/Documents/tmp/nanoBragg/tests/test_at_crystal_absolute.py:292: DeprecationWarning: __array_wrap__ must accept context and return_scalar arguments (positionally) in the future. (Deprecated NumPy 2.0)
    position_diff = np.sqrt(

tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_sourcefile_with_all_columns
  /home/ollie/Documents/tmp/nanoBragg/tests/test_at_src_001.py:51: UserWarning: Sourcefile wavelength column differs from CLI -lambda value. Per spec-a-core.md:150-151, sourcefile wavelengths are ignored. All sources will use CLI wavelength 6.200000e-10 m.
    directions, weights, wavelengths = read_sourcefile(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
- generated xml file: /home/ollie/Documents/tmp/nanoBragg/reports/2026-01-test-suite-triage/phase_h/20251011T033418Z/artifacts/pytest_full.xml -
============================= slowest 25 durations =============================
1100.61s call     tests/test_gradients.py::TestPropertyBasedGradients::test_property_gradient_stability
144.63s call     tests/test_gradients.py::TestAdvancedGradients::test_joint_gradcheck
128.24s call     tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_b
71.38s call     tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_c
62.10s call     tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_alpha
50.67s call     tests/test_gradients.py::TestAdvancedGradients::test_gradgradcheck_cell_params
48.38s call     tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_gamma
48.25s call     tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_beta
46.46s call     tests/test_gradients.py::TestCellParameterGradients::test_gradcheck_cell_a
11.77s call     tests/test_at_perf_005.py::TestATPERF005CompilationOptimization::test_torch_compile_speedup
7.79s call     tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_float32_vs_float64_performance
7.42s call     tests/test_at_perf_005.py::TestATPERF005CompilationOptimization::test_compilation_amortization
5.41s call     tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_peak_memory_usage
3.04s call     tests/test_at_parallel_001.py::TestATParallel001::test_cli_beam_center_calculation
3.04s call     tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_overload_count_determinism
3.02s call     tests/test_at_cli_003.py::TestATCLI003::test_convention_header_keys_consistency
3.00s call     tests/test_at_perf_001.py::TestATPERF001VectorizationPerformance::test_vectorization_scaling
2.32s call     tests/test_at_parallel_012.py::TestATParallel012ReferencePatternCorrelation::test_high_resolution_variant
2.17s call     tests/test_at_perf_003.py::TestATPERF003MemoryBandwidth::test_memory_bandwidth_utilization
2.06s call     tests/test_at_perf_002.py::TestATPERF002ParallelExecution::test_cpu_thread_scaling
2.03s call     tests/test_at_cli_008.py::TestATCLI008DminFiltering::test_dmin_filtering_reduces_intensity
2.02s call     tests/test_at_cli_008.py::TestATCLI008DminFiltering::test_dmin_zero_has_no_effect
2.02s call     tests/test_at_cli_005.py::test_cli_roi_different_conventions
2.02s call     tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_different_seed_produces_different_noise
2.01s call     tests/test_at_cli_007.py::TestATCLI007NoiseDeterminism::test_negative_seed_accepted
=========================== short test summary info ============================
FAILED tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_pytorch_determinism_same_seed
FAILED tests/test_at_parallel_013.py::TestATParallel013CrossPlatformConsistency::test_pytorch_determinism_different_seeds
FAILED tests/test_at_parallel_015.py::TestATParallel015MixedUnits::test_mixed_units_comprehensive
FAILED tests/test_at_parallel_024.py::TestAT_PARALLEL_024::test_mosaic_rotation_umat_determinism
FAILED tests/test_at_parallel_026.py::TestAT_PARALLEL_026_TriclinicAbsolutePosition::test_triclinic_absolute_peak_position_vs_c
FAILED tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_sourcefile_with_all_columns
FAILED tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_sourcefile_with_missing_columns
FAILED tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_sourcefile_default_position
FAILED tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_multiple_sources_normalization
FAILED tests/test_at_src_001.py::TestAT_SRC_001_SourcefileAndWeighting::test_weighted_sources_integration
FAILED tests/test_at_src_001_simple.py::test_sourcefile_parsing - AssertionEr...
FAILED tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_gauss_shape_model
FAILED tests/test_at_str_003.py::TestAT_STR_003_LatticeShapeModels::test_shape_model_comparison
FAILED tests/test_at_tools_001.py::TestAT_TOOLS_001_DualRunnerComparison::test_script_integration
FAILED tests/test_cli_flags.py::TestCLIPix0Override::test_pix0_vector_mm_beam_pivot[cpu]
FAILED tests/test_cli_flags.py::TestHKLFdumpParity::test_scaled_hkl_roundtrip
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_printout_flag
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_trace_pixel_flag
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_combined_debug_flags
FAILED tests/test_debug_trace.py::TestDebugTraceFeatures::test_out_of_bounds_pixel
FAILED tests/test_detector_config.py::TestDetectorInitialization::test_default_initialization
FAILED tests/test_detector_config.py::TestDetectorInitialization::test_custom_config_initialization
FAILED tests/test_detector_conventions.py::TestDetectorConventions::test_denzo_beam_center_mapping
FAILED tests/test_detector_pivots.py::test_beam_pivot_keeps_beam_indices_and_alignment
FAILED tests/test_detector_pivots.py::test_sample_pivot_moves_beam_indices_with_twotheta
FAILED tests/test_gradients.py::TestAdvancedGradients::test_gradient_flow_simulation
FAILED tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_basic_execution[cpu]
FAILED tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_gradient_flow_preserved
FAILED tests/test_perf_pytorch_005_cudagraphs.py::TestCUDAGraphsCompatibility::test_cpu_cuda_correlation[cpu]
FAILED tests/test_suite.py::TestTier1TranslationCorrectness::test_sensitivity_to_cell_params
FAILED tests/test_suite.py::TestTier1TranslationCorrectness::test_performance_simple_cubic
FAILED tests/test_suite.py::TestTier1TranslationCorrectness::test_performance_triclinic
FAILED tests/test_suite.py::TestTier1TranslationCorrectness::test_extreme_cell_parameters
FAILED tests/test_suite.py::TestTier1TranslationCorrectness::test_rotation_compatibility
FAILED tests/test_tricubic_vectorized.py::TestTricubicGather::test_vectorized_matches_scalar
FAILED tests/test_tricubic_vectorized.py::TestTricubicGather::test_oob_warning_single_fire
= 36 failed, 504 passed, 143 skipped, 2 xfailed, 6 warnings in 1867.56s (0:31:07) =
