# nanoBragg PyTorch Debugging Guidelines

**Version:** 1.1  
**Date:** 2024-07-25  
**Owner:** PyTorch Development Team

## Overview

This document outlines the debugging methodology and tools for the nanoBragg PyTorch implementation. The debugging approach is built around a parallel trace comparison between the C code and the PyTorch implementation to ensure correctness and facilitate rapid issue resolution.

## Core Debugging Philosophy

### Parallel Trace Comparison Rule

**CRITICAL:** All debugging of physics discrepancies MUST begin with a parallel trace comparison. This involves:
1. Generating a detailed, step-by-step log of intermediate variables from the original C code for a specific pixel (the "Golden Trace").
2. Generating an identical log from the PyTorch implementation using `scripts/debug_pixel_trace.py`.
3. Comparing these two logs line-by-line to find the first point of divergence.

This methodology is mandatory to avoid guesswork and ensure bugs are found deterministically.

## Debugging Workflow (SOP-4.1)

Follow the specialized PyTorch physics debugging process from `processes.xml`:

1. **Identify an On-Peak Pixel:** Run the PyTorch simulation and visually inspect the output image to find the coordinates of a bright pixel on a Bragg peak.
2. **Generate Golden C Trace:** Run the instrumented C code with the `-dump_pixel` flag pointing at the on-peak pixel to generate the ground-truth C trace log.
3. **Generate PyTorch Trace:** Update `scripts/debug_pixel_trace.py` to target the same on-peak pixel and run it to generate the PyTorch trace log.
4. **Compare Traces:** Use a diff tool (`diff`, `vimdiff`, etc.) to compare the C trace and the PyTorch trace.
5. **Identify Divergence Point:** Find the first variable where the numerical values differ significantly. This is the location of the bug.
6. **Isolate and Fix:** Examine the PyTorch code responsible for calculating the divergent variable. Check for common issues:
   - Unit conversion errors (e.g., meters vs. Angstroms).
   - Incorrect physical constants.
   - Mismatched mathematical formulas or conventions.
7. **Apply Fix and Re-validate:** Apply the fix and re-run the PyTorch trace. Repeat the comparison until the logs match.

## Debug Script and Trace Management

### Active PyTorch Debug Script

**Script:** `scripts/debug_pixel_trace.py`  
**Purpose:** Generates the PyTorch side of the parallel trace comparison.

### Golden C-Code Trace

**Source:** Generated by the instrumented `nanoBragg.c` in `golden_suite_generator/`.  
**Location:** `tests/golden_data/<test_case>_C_trace.log`  
**Purpose:** Provides the "ground truth" intermediate values for the physics calculation.  
**Management:** This file should only be regenerated when the C code's physics model is intentionally changed.

## Key Variables to Compare

When comparing traces, pay close attention to:
- **Scattering Vector q (or S):** The most common source of geometry errors.
- **Fractional Miller Index h,k,l:** Should be nearly identical.
- **F_latt:** Mismatches indicate errors in the crystal shape factor (sincg).
- **omega_pixel / polar:** Mismatches indicate errors in scaling factor calculations.
- **Final Intensity:** The final check for overall correctness.

## Common Debugging Scenarios

### Physics Calculation Issues

**Symptoms:** Wrong intensity values, flat images, scale mismatches  
**First step:** Run pixel trace and compare scattering vector calculations  
**Common causes:** Missing 2π factors, unit conversion errors, coordinate transforms  

### Unit System Problems

**Symptoms:** Values off by powers of 10, dimension errors  
**First step:** Check pixel trace "Additional Debugging Information" section  
**Common causes:** Mixing Angstroms/meters, incorrect scaling factors  

### Gradient Issues

**Symptoms:** `torch.autograd.gradcheck` failures, "modified in-place" errors  
**First step:** Verify computation graph connectivity in trace  
**Common causes:** Manual tensor reassignment, detached operations

### Gradient Flow Debugging

**Symptoms:** `RuntimeError: element 0 of tensors does not require grad and does not have a grad_fn`  
**Methodology:** Use systematic isolation to find computation graph breaks:

1. **Isolate the Problem:** Create minimal test case with `requires_grad=True` input
2. **Trace Through Computation:** Check `requires_grad` at each step
3. **Identify Break Point:** Find where `requires_grad` becomes `False`
4. **Common Causes:**
   - `.item()` calls on differentiable tensors (detaches from graph)
   - `torch.linspace` with tensor endpoints (known PyTorch limitation)
   - Manual tensor overwriting instead of functional computation
   - Using `.detach()` or `.numpy()` on tensors requiring gradients

**Example Debug Pattern:**
```python
# Step 1: Isolate
phi_start = torch.tensor(10.0, requires_grad=True)
print(f"phi_start requires_grad: {phi_start.requires_grad}")

# Step 2: Trace
config = CrystalConfig(phi_start_deg=phi_start)
print(f"config.phi_start_deg requires_grad: {config.phi_start_deg.requires_grad}")

# Step 3: Identify break
if isinstance(config.phi_start_deg, float):
    print("ERROR: Gradient lost - tensor converted to float")
```

**Solutions:**
- Replace `.item()` with direct tensor passing
- Use manual tensor arithmetic instead of `torch.linspace`
- Enforce tensor inputs at architectural boundaries  

### Coordinate System Issues

**Symptoms:** 90-degree rotated images, incorrect peak positions  
**First step:** Verify pixel coordinate calculations in trace  
**Common causes:** `torch.meshgrid` indexing, axis orientation  

## Debug Output Interpretation

### Pixel Trace Log Structure

```
================================================================================
Single Pixel Trace Debugging Log
nanoBragg PyTorch Implementation
================================================================================

Target Pixel: (slow=250, fast=350)
Test Case: simple_cubic
Wavelength: 6.2 Angstroms
Precision: torch.float64

[Step-by-step calculations with 12-digit precision]

================================================================================
Additional Debugging Information
================================================================================
[Complete parameter dump]
```

### Key Variables to Monitor

- **Pixel Coordinate (Å):** Must be in Angstroms for physics calculations
- **Scattering Vector q (Å⁻¹):** Critical for Miller index calculation
- **Fractional Miller Index h,k,l:** Should show spatial variation across detector
- **F_latt:** Shape factor - should vary significantly near Bragg peaks
- **Final Intensity:** Should match golden reference order of magnitude

## Advanced Debugging

### Memory and Performance Issues

Use the existing debug scripts with smaller detector sizes:
```python
# Override detector size for debugging
detector_test.spixels = 3
detector_test.fpixels = 3
detector_test.invalidate_cache()
```

### GPU vs CPU Differences

Run identical calculations on both devices and compare intermediate values:
```python
# Compare device outputs
pytorch_image_cpu = simulator_cpu.run()
pytorch_image_gpu = simulator_gpu.run()
diff = torch.abs(pytorch_image_cpu - pytorch_image_gpu.cpu())
```

### Precision Issues

Use double precision for debugging:
```python
dtype = torch.float64  # Always use for debugging
# Check for precision loss in long calculation chains
```

## Debug Script Maintenance

### Updating the Active Script

When modifying `scripts/debug_pixel_trace.py`:
1. Maintain backward compatibility with existing golden reference
2. Add new trace variables at the end to preserve log structure
3. Update variable descriptions if calculation methods change
4. Regenerate golden reference only when absolutely necessary

### Golden Reference Management

**Current Golden Reference:** `tests/golden_data/simple_cubic_pixel_trace.log`
- Generated from: simple_cubic test case, pixel (250,350)
- Contains: Complete physics calculation trace
- Precision: torch.float64
- **Do not modify without team approval**

### Creating New Debug Scripts

If a new debug script is absolutely necessary:
1. Archive current script: `mv scripts/debug_pixel_trace.py scripts/archive/`
2. Create new script following naming convention: `scripts/debug_[purpose].py`
3. Update this document with new active script information
4. Generate new golden reference
5. Update all documentation references

## Troubleshooting

### Script Fails to Run

1. Check PYTHONPATH: `PYTHONPATH=/Users/ollie/Documents/nanoBragg/src`
2. Check OpenMP: Set `KMP_DUPLICATE_LIB_OK=TRUE`
3. Verify torch installation and device availability

### Unexpected Trace Values

1. Compare with previous known-good trace
2. Check for recent code changes in physics calculations
3. Verify input parameters match expected test case
4. Check for precision loss or numerical instability

### Performance Issues

1. Reduce detector size for debugging
2. Use CPU for initial debugging, GPU for performance testing
3. Profile memory usage during trace generation

## Integration with Testing

The debug script integrates with the three-tier testing strategy:

- **Tier 1:** Provides golden reference for translation correctness
- **Tier 2:** Validates gradient flow through computation graph
- **Tier 3:** Supplies intermediate values for scientific validation

See `Testing_Strategy.md` Section 4.3 for complete integration details.